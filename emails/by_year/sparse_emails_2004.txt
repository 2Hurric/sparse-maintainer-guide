--- Emails for Year 2004 ---

=== Thread: [No Subject] ===

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
is aimed at being a very efficient and light-weight C front-end... only!
You don't aim it to be the uber-integrated-entangled-monster that GCC has
grown into.

Couple this to an extremely efficient optimizer and code generator (LLVM)
with a huge list of features (like transparent link-time interprocedural
optimization, if you want to use it), and I think that it would be an
incredibly valuable open-source compiler.

In any case, if anyone is interested in this (perhaps the other Chris L?
:) ), I would be happy to help in a secondary role.

-Chris

-- 
http://llvm.org/
http://www.nondot.org/~sabre/Projects/



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
though.  To make the question a little more clear, here's the relevant
bit of code:

static ssize_t
scdrv_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
{
. . .
		/* (sd->sd_rb is a char*) */
		if (copy_to_user(buf, sd->sd_rb, len))
			return -EFAULT;
. . .
}


(There's a symmetrical copy_from_user() call in the corresponding
_write() function of course.)  Here's sparse's complaint:


drivers/char/snsc.c:340:7: warning: incorrect type in initializer (different address spaces)
drivers/char/snsc.c:340:7:    expected void *__cu_to
drivers/char/snsc.c:340:7:    got char [noderef] *buf<asn:1>
drivers/char/snsc.c:340:7: warning: shift too big for type (480)


I would assume that the "shift too big" is an ia64 issue with sparse,
but the other one looks like a legitimate complaint.  So I tried the
following:

. . .
		if (copy_to_user((void __user *)buf, (void *)sd->sd_rb, len))
			return -EFAULT;
. . .


This time sparse complains as follows:


drivers/char/snsc.c:340:7: warning: incorrect type in initializer (different address spaces)
drivers/char/snsc.c:340:7:    expected void *__cu_to
drivers/char/snsc.c:340:7:    got void [noderef] *<noident><asn:1>
drivers/char/snsc.c:340:7: warning: shift too big for type (480)


I'm not sure how to make this go away...  Surely this cast isn't
stripping the address space indication off of "buf"-- on the contrary,
aren't I explicitly restating it?  Is the complaint just a symptom of
sparse not entirely working on ia64?

Thanks - Greg
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
to use the LLVM backend then continue to hack on the Sparse X86 backend.
Additionally, the LLVM verifier will help catch a lot of issues.

Anyway, I'm just curious what is in store for the future of Sparse.  Is it
to become a full fledged compiler?  If not, why is the continuing
optimization/codegen work?

-Chris

-- 
http://llvm.cs.uiuc.edu/
http://www.nondot.org/~sabre/Projects/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Unknown
To: Unknown
Subject: 
Date: 
Message-ID: 
--------------------
============================================================================
Segmentation fault:

compile/20000211-1.c
compile/20010102-1.c
compile/20010404-1.c
compile/20021001-1.c
compile/20030320-1.c
compile/920415-1.c
compile/920501-10.c
compile/920501-12.c
compile/920501-23.c
compile/920808-1.c
compile/921109-1.c
compile/921206-1.c
compile/930111-1.c
compile/930529-1.c
compile/960106-1.c
compile/961126-1.c
compile/simd-2.c
compile/simd-5.c
execute/20020226-1.c
execute/20020508-1.c
execute/20020508-2.c
execute/20020508-3.c
execute/20021010-1.c
execute/920415-1.c
execute/920428-2.c
execute/920501-7.c
execute/920721-4.c
execute/920730-1.c
execute/920909-1.c
execute/930429-2.c
execute/930529-1.c
execute/960218-1.c
execute/991112-1.c
execute/ashldi-1.c
execute/ashrdi-1.c
execute/builtin-abs-1.c
execute/builtin-abs-2.c
execute/builtins/string-7.c
execute/builtins/string-asm-1-lib.c
execute/comp-goto-2.c
execute/ieee/fp-cmp-5.c
execute/ieee/fp-cmp-8.c
execute/ieee/inf-1.c
execute/ieee/mzero5.c
execute/lshrdi-1.c
execute/nestfunc-2.c
execute/nestfunc-3.c
execute/nestfunc-5.c
execute/nestfunc-6.c
unsorted/386.c
unsorted/a3.c
unsorted/aaa.c
unsorted/a.c
unsorted/ac.c
unsorted/acc.c
unsorted/add386.c
unsorted/addcc.c
unsorted/andm.c
unsorted/andn.c
unsorted/band.c
unsorted/bb0.c
unsorted/bc.c
unsorted/bfx.c
unsorted/bt386.c
unsorted/bug.c
unsorted/cmul.c
unsorted/comb.c
unsorted/const.c
unsorted/div.c
unsorted/jmp.c
unsorted/l.c
unsorted/logic.c
unsorted/m5.c
unsorted/m68.c
unsorted/mm.c
unsorted/mod.c
unsorted/modcc.c
unsorted/mu.c
unsorted/nand.c
unsorted/neg.c
unsorted/or.c
unsorted/parms.c
unsorted/pass.c
unsorted/selfrec.c
unsorted/set88.c
unsorted/sh.c
unsorted/sub32.c
unsorted/subcc.c
unsorted/test-flow.c
unsorted/tmp.c
unsorted/u.c
unsorted/uuarg.c
unsorted/xfoo.c
unsorted/xor.c
unsorted/xp.c
unsorted/xzz.c
============================================================================
compile/20001226-1.c

88 seconds to check now instead of several approximately 20 changesets earlier
(don't remember exactly).
============================================================================

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: "-o foo" and "-I foo" ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: "-o foo" and "-I foo"
Date: Wed, 28 Jul 2004 18:29:17 +0000
Message-ID: <20040728182917.9E2181422D58 () darter ! rentec ! com>
--------------------

check mishandles "-I foo" and "-o foo" which can lead it to open the wrong
file.  This will happen if the option is specified after the .c file.

Morten



===== lib.c 1.53 vs edited =====
--- 1.53/lib.c	2004-07-27 10:00:57 -04:00
+++ edited/lib.c	2004-07-28 14:23:30 -04:00
@@ -590,8 +590,14 @@
 }
 char **handle_switch_I(char *arg, char **next)
 {
-	add_pre_buffer("#add_include \"%s/\"\n", arg + 1);
-	return next;
+	// FIXME: What about "-I-"?
+	if (!strcmp (arg, "I") && *next) {
+		add_pre_buffer("#add_include \"%s/\"\n", next);
+		return next + 1; // "-I foo"
+	} else {
+		add_pre_buffer("#add_include \"%s/\"\n", arg + 1);
+		return next;    // "-Ifoo" or (bogus) terminal "-I"
+	}
 }
 
 char **handle_switch_i(char *arg, char **next)
@@ -619,6 +625,14 @@
 	return next;
 }
 
+char **handle_switch_o(char *arg, char **next)
+{
+	if (!strcmp (arg, "o") && *next)
+		return next + 1; // "-o foo"
+	else
+		return next;     // "-ofoo" or (bogus) terminal "-o"
+}
+
 char **handle_switch(char *arg, char **next)
 {
 	char **rc = next;
@@ -630,6 +644,7 @@
 	case 'I': rc = handle_switch_I(arg, next); break;
 	case 'i': rc = handle_switch_i(arg, next); break;
 	case 'm': rc = handle_switch_m(arg, next); break;
+	case 'o': rc = handle_switch_o(arg, next); break;
 	default:
 		/*
 		 * Ignore unknown command line options:
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: ";" in struct; assignment of const areas ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: ";" in struct; assignment of const areas
Date: Thu, 22 Jul 2004 19:43:05 +0000
Message-ID: <20040722194305.065D21422D58 () darter ! rentec ! com>
--------------------

1. sparse is silent about missing ";" in structures.
2. const areas are not detected.

Morten




union U { int a; int b };
struct S { int a; int b };

static void
test (const union U *u, const struct S *s)
{
  *u = *u;
  *s = *s;
}

-----------------------------------------------------------------------------

troll:/scratch/welinder/sparse> ./check foo.c
troll:/scratch/welinder/sparse> gcc-3.4 -Wall -c foo.c
foo.c:1: warning: no semicolon at end of struct or union
foo.c:2: warning: no semicolon at end of struct or union
foo.c: In function `test':
foo.c:7: error: assignment of read-only location
foo.c:8: error: assignment of read-only location
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: ";" in struct; assignment of const areas
Date: Thu, 22 Jul 2004 20:30:56 +0000
Message-ID: <Pine.LNX.4.58.0407221303570.22809 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Jul 2004, Morten Welinder wrote:
> 
> 1. sparse is silent about missing ";" in structures.

Yes. Just a missing warning - we already do test for it, it's just that
sparse silently ignores that error. I'll add it.

> 2. const areas are not detected.

Ok, that thing we just didn't even test for. Easy enough to do in 
assignment evaluation.

Both fixes pushed out.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: "char" vs "signed char" vs "unsigned char" ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: "char" vs "signed char" vs "unsigned char"
Date: Wed, 18 Aug 2004 15:50:56 +0000
Message-ID: <20040818155056.94B971422D4F () darter ! rentec ! com>
--------------------

Both Sun's C compiler and gcc (2.7.2, 2.95.2, 3.4.0) are adamant that
"char" is a different type from both "signed char" and "unsigned char".
Thus the program below produces three warnings.  (Check produces none,
but that's not the point here.)

This kind of question seems ungoogleable and I don't have a set of standards
handy.  Is this three-kinds-of-chars something that is mandated by them?
(Sun typically goes by the book, so I am expecting the answer to be "yes".)

For ints the situation seems to be different: "signed int" is "int", no
questions asked.

LINUS, what do you want to do with this?  I have code to make all the signed
ctypes different and it appears to behave well on the code I have.  (See
yesterday's post.)

Morten



-----------------------------------------------------------------------------

int
main (int argc, char **argv)
{
  char c;
  signed char sc;
  unsigned char uc;

  (void)(&c == &uc);
  (void)(&c == &sc);
  (void)(&uc == &sc);

  return 0;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: "char" vs "signed char" vs "unsigned char"
Date: Wed, 18 Aug 2004 16:58:51 +0000
Message-ID: <20040818095851.0abb84b5.rddunlap () osdl ! org>
--------------------
On Wed, 18 Aug 2004 11:50:56 -0400 (EDT) Morten Welinder wrote:

| 
| Both Sun's C compiler and gcc (2.7.2, 2.95.2, 3.4.0) are adamant that
| "char" is a different type from both "signed char" and "unsigned char".
| Thus the program below produces three warnings.  (Check produces none,
| but that's not the point here.)
| 
| This kind of question seems ungoogleable and I don't have a set of standards
| handy.  Is this three-kinds-of-chars something that is mandated by them?
| (Sun typically goes by the book, so I am expecting the answer to be "yes".)

It sorta seems to say that, but only at first (IMO):

Section 6.2.5, #15:
 The three types char, signed char, and unsigned char are collectively called
 the character types. The implementation shall define char to have the same
 range, representation, and behavior as either signed char or unsigned char.35)

Footnote 35:
 CHAR_MIN, defined in <limits.h>, will have one of the values 0 or SCHAR_MIN,
 and this can be used to distinguish the two options. Irrespective of the
 choice made, char is a separate type from the other two and is not compatible
 with either.

| For ints the situation seems to be different: "signed int" is "int", no
| questions asked.

Agreed.  Section 6.2.5, #4:

 There are five standard signed integer types, designated as signed char,
 short int, int, long int, and long long int. (These and other types may be
 designated in several additional ways, as described in 6.7.2.) There may
 also be implementation-defined extended signed integer types.28) The
 standard and extended signed integer types are collectively called
 signed integer types.29)

| LINUS, what do you want to do with this?  I have code to make all the signed
| ctypes different and it appears to behave well on the code I have.  (See
| yesterday's post.)


--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: "signed int" as separate ctype ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: "signed int" as separate ctype
Date: Tue, 17 Aug 2004 18:38:54 +0000
Message-ID: <20040817183854.C3DA41422D56 () darter ! rentec ! com>
--------------------

Having "signed int" as a ctype different from "int" ends up looking
a whole lot cleaner that I had expected.  In my code I see no misfires
from doing this.

I'd appreciate if someone cloned

    http://sparse-mw.bkbits.net:8080/sparse

(or pulled it with the intention of unpull later -- there is a lot of
solaris stuff in there you probably do not want) and give it a try on
some different codebase.

Thanks,

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: "undefined preprocessor identifier" and system headers ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: "undefined preprocessor identifier" and system headers
Date: Mon, 26 Jul 2004 17:40:33 +0000
Message-ID: <20040726174033.691141422D58 () darter ! rentec ! com>
--------------------

Currently on Solaris/Sparc I get a large number of warnings due to the
style of preprocessor tests used in system headers.  See the list for
<stdio.h> below.  Sample lines that cause these are:

#if (_XOPEN_SOURCE - 0 == 500)
#if __cplusplus >= 199711L
#if     defined(__EXTENSIONS__) || defined(_REENTRANT) || \
            (_POSIX_C_SOURCE - 0 >= 199506L)

System headers is not a place I would like to start editing.

So what are my options?

1. Ditch Solaris.  Tempting; very tempting; but not very constructive.
2. Teach the pre-processor not to warn about this in system headers.
3. Teach the pre-processor about the "FOO - 0" ideom.  (That's a partial
   solution.)
4. Teach the pre-processor not to warn like this for identifiers starting
   with an underscore.

Comments?

Side questions...

A. Why does sparse (in create_builtin_stream) pretend to be gcc 2.95 yet
   does not define __FUNCTION__ and __PRETTY_FUNCTION__?

B. Why __STDC__==1?  In the world of gcc 2.95 that means no strtoull, for
   example.

Morten



/usr/include/sys/feature_tests.h:138:6: warning: undefined preprocessor identifier '_XOPEN_SOURCE'
/usr/include/iso/stdio_iso.h:69:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:93:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:158:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:193:6: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:194:2: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:198:6: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:199:2: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:213:6: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:214:2: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:277:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:287:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:307:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:318:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/stdio.h:36:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/stdio.h:246:7: warning: undefined preprocessor identifier '_POSIX_C_SOURCE'
/usr/include/stdio.h:371:7: warning: undefined preprocessor identifier '_POSIX_C_SOURCE'
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: #include MACRO ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: #include MACRO
Date: Fri, 23 Jul 2004 17:08:54 +0000
Message-ID: <20040723170854.1E9D21422D53 () darter ! rentec ! com>
--------------------

Sparse actually goes looking for a file called "<stdio.h>", angle brackets
included.

I'm not sure including stuff this way is comme it faut, but it is what
FreeType does.  gcc-3.4 is happy with it.

Morten


sparse-2004-07-23> cat foo.c
#define OINK <stdio.h>
#include OINK
sparse-2004-07-23> ./check foo.c 
foo.c:2:10: error: unable to open '<stdio.h>'
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 17:33:18 +0000
Message-ID: <Pine.LNX.4.58.0407231026560.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Morten Welinder wrote:
>
>	#define OINK <stdio.h>
>	#include OINK
> 
> Sparse actually goes looking for a file called "<stdio.h>", angle brackets
> included.
> 
> I'm not sure including stuff this way is comme it faut, but it is what
> FreeType does.  gcc-3.4 is happy with it.

Oh wow, what a pretty (not) piece of code.

But yeah, I think it's legal C.

Easy enough to fix. 

		Linus

===== pre-process.c 1.88 vs edited =====
--- 1.88/pre-process.c	2004-06-13 09:11:42 -07:00
+++ edited/pre-process.c	2004-07-23 10:32:56 -07:00
@@ -669,6 +669,10 @@
 		expand_list(&token->next);
 		expect = 0;
 		next = token;
+		if (match_op(token->next, '<')) {
+			next = token->next;
+			expect = '>';
+		}
 	}
 	token = next->next;
 	filename = token_name_sequence(token, expect, token);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 17:57:20 +0000
Message-ID: <20040723195713.GB7017 () mars ! ravnborg ! org>
--------------------
On Fri, Jul 23, 2004 at 10:33:18AM -0700, Linus Torvalds wrote:
> 
> 
> On Fri, 23 Jul 2004, Morten Welinder wrote:
> >
> >	#define OINK <stdio.h>
> >	#include OINK
> > 
> > Sparse actually goes looking for a file called "<stdio.h>", angle brackets
> > included.
> > 
> > I'm not sure including stuff this way is comme it faut, but it is what
> > FreeType does.  gcc-3.4 is happy with it.
> 
> Oh wow, what a pretty (not) piece of code.
Agreed, but I have actually seen this trick used to avoid ifdef hell in
includes.

> ===== pre-process.c 1.88 vs edited =====
> --- 1.88/pre-process.c	2004-06-13 09:11:42 -07:00
> +++ edited/pre-process.c	2004-07-23 10:32:56 -07:00
> @@ -669,6 +669,10 @@
>  		expand_list(&token->next);
>  		expect = 0;
>  		next = token;
> +		if (match_op(token->next, '<')) {
> +			next = token->next;
> +			expect = '>';
> +		}
>  	}
>  	token = next->next;
>  	filename = token_name_sequence(token, expect, token);

Without testing this looks not to be enough.
The macro OINK can contain both types of references to files like:
<file.h>
"../include/file.h"

So at least check for both '<' and '"'.
Would it be possible to process the include after preprocessing,
this should cover any fancy token pasting (if that works).

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 18:28:16 +0000
Message-ID: <Pine.LNX.4.58.0407231118130.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Sam Ravnborg wrote:
> 
> Without testing this looks not to be enough.
> The macro OINK can contain both types of references to files like:
> <file.h>
> "../include/file.h"
> 
> So at least check for both '<' and '"'.

No, the " thing is handled correctly simply by virtue of the tokenizer 
always understanding strings.

So it's really the case that '<' is a special case that triggers special 
rules. A normal string does not. Which is why we only test for the '<' 
case there.

> Would it be possible to process the include after preprocessing,
> this should cover any fancy token pasting (if that works).

Nope. The '<' thing actually _disables_ preprocessing. In other words:

	#define stdio "math.h"
	#include <stdio.h>
	#include stdio

is actually supposed to work, exactly because the _first_ "stdio" token is 
not expanded.

Of course, the sparse preprocessor is actually a bit special here. It 
really _does_ tokenize everything, so you can actually write

	#include < stdio . h >

and it will do exactly the same as <stdio.h>, because it's just three 
(unexpanded) tokens: "stdio" "." and "h". That's arguably buggy, but the C 
standard actually says that spaces are special in filenames, so I believe 
that it's technically valid.

For much the same reason, sparse will happily also allow you to do:

	#define myheader stdio
	#include myheader.h

which will actually expand (because of lack of angle brackets) to be
equivalent to

	#include stdio.h

which sparse happily parses.

I could make it a bit more strict, but I don't really care. I personally 
like the sparse rules - they are no less sensible than the more common 
rules, and in particular they allow the stream to _always_ be tokenized 
rather than the regular very strange special cases that normal C 
preprocessors tend to have.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 18:43:06 +0000
Message-ID: <20040723184306.03C271422D53 () darter ! rentec ! com>
--------------------

Well, from the "Just Don't Do That!" department then comes...

sparse-2004-07-23> touch 'foo"bar'
sparse-2004-07-23> cat foo.c
#include <foo"bar>
sparse-2004-07-23> gcc-3.4 -I. -c -Wall foo.c 
sparse-2004-07-23> ./check -I. foo.c 
foo.c:2:0: warning: Newline in string or character constant
foo.c:2:0: warning: End of file in middle of string
foo.c:1:11: warning: expected '>' at end of filename
foo.c:1:11: error: unable to open 'foo'
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 18:50:49 +0000
Message-ID: <20040723205133.GA7760 () mars ! ravnborg ! org>
--------------------
On Fri, Jul 23, 2004 at 11:28:16AM -0700, Linus Torvalds wrote:
> 
> 
> On Fri, 23 Jul 2004, Sam Ravnborg wrote:
> > 
> > Without testing this looks not to be enough.
> > The macro OINK can contain both types of references to files like:
> > <file.h>
> > "../include/file.h"
> > 
> > So at least check for both '<' and '"'.
> 
> No, the " thing is handled correctly simply by virtue of the tokenizer 
> always understanding strings.
> 
> So it's really the case that '<' is a special case that triggers special 
> rules. A normal string does not. Which is why we only test for the '<' 
> case there.
> 
> > Would it be possible to process the include after preprocessing,
> > this should cover any fancy token pasting (if that works).
> 
> Nope. The '<' thing actually _disables_ preprocessing. In other words:
> 
> 	#define stdio "math.h"
> 	#include <stdio.h>
> 	#include stdio
> 
> is actually supposed to work, exactly because the _first_ "stdio" token is 
> not expanded.

Tried it out and you are right.
Did the following (only for testing):

foo.c:
#define stringify(a) #a
#define token_paste(a,b) a##b

#define xstr(s) str(s)
#define str(s) #s

#include xstr(token_paste(fo,o.h))

foo(void)
{
	char* s = xstr(token_paste(fo,o.h));
}
foo.h:
void foo(long);

And sparse complained as expected:

foo.c:10:1: warning: symbol 'foo' redeclared with different type (originally declared at foo.h:1) - incompatible argument 1 (different types)

Good!


But doing s/long/void/ in foo.h did not make sparse complain about the difference
in return type.
Prototype says void, implementation says (default) int.

Neither does it complain about the missing return statement??

I tried a simple file, bar.c:
int i;
int foo(void)
{
	if (i)
		return 0;
}

But with the same result.


Latest just pulled sparse.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 19:10:34 +0000
Message-ID: <Pine.LNX.4.58.0407231205100.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Morten Welinder wrote:
> 
> Well, from the "Just Don't Do That!" department then comes...

Yeah, that's a bug in your program. You can only have standard header 
names inside brackets. 

At least according to sparse. I'm not sure what C99 says, but at the same 
time I'm not in the least interested in sillyness, either.

If you want to include a filename with a quote in it or any other 
character like that, you can just do so with

	#include "silly\"name"

and if you find a system that has standard header names with strange 
characters in them, just don't run sparse on it. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 19:19:40 +0000
Message-ID: <Pine.LNX.4.58.0407231212080.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Sam Ravnborg wrote:
> 
> But doing s/long/void/ in foo.h did not make sparse complain about the difference
> in return type.
> Prototype says void, implementation says (default) int.

Sparse doesn't believe in default types.

If you don't have a typename, sparse defaults to "incomplete type". Which
in most cases means "cannot use it".

For example:

	f(int i)
	{
	        return i;
	}

will give the (very logical) warning

	test.c:3:9: warning: incorrect type in return expression (different types)
	test.c:3:9:    expected incomplete type 
	test.c:3:9:    got int i

since you're trying to return an "int" in a function that returns an 
incomplete type.

Remember: sparse is not about traditional C. Sparse is very much about 
type-checking, so in some cases sparse is much less forgiving than "real 
C". 

The canonical example of this is K&R C, or using functions without any 
declaration. In traditional C, that's fine. In sparse C, you'll get a loud 
complaint about "undefined identifier 'xxxx'" and sparse will not try to 
make up any implied types.

> Neither does it complain about the missing return statement??

Sparse doesn't complain about missing returns, that can be done only after
flow analysis, and "check" right now doesn't do linearization. For
example:

	int hello(void)
	{
		for (;;) ;
	}

should _not_ complain about a missing return, because there is no point 
where we fall through.

You could add the "missing return" warning to the linearization pass (we 
_do_ do flow analysis there), but then you'd also have to add support for 
understanding the "noreturn" attribute etc and actually add the 
"linearize_symbol()" to check.c.

Doing that might be a good idea. Right now we have never ever actually 
tested the sparse linearization code on the full kernel. I suspect we may 
have bugs there.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 19:38:33 +0000
Message-ID: <20040723213914.GA19640 () mars ! ravnborg ! org>
--------------------
On Fri, Jul 23, 2004 at 12:19:40PM -0700, Linus Torvalds wrote:
> 
> 
> On Fri, 23 Jul 2004, Sam Ravnborg wrote:
> > 
> > But doing s/long/void/ in foo.h did not make sparse complain about the difference
> > in return type.
> > Prototype says void, implementation says (default) int.
> 
> Sparse doesn't believe in default types.

Neither do I so we agree on this point.
> 
> If you don't have a typename, sparse defaults to "incomplete type". Which
> in most cases means "cannot use it".
> 
> For example:
> 
> 	f(int i)
> 	{
> 	        return i;
> 	}
> 
> will give the (very logical) warning
> 
> 	test.c:3:9: warning: incorrect type in return expression (different types)
> 	test.c:3:9:    expected incomplete type 
> 	test.c:3:9:    got int i
> 
> since you're trying to return an "int" in a function that returns an 
> incomplete type.
> 
> Remember: sparse is not about traditional C. Sparse is very much about 
> type-checking, so in some cases sparse is much less forgiving than "real 
> C". 

Yup, but things differ when void is introduced.
The following code snippet should give 4 warnings:

int f(int i);
f(int i)
{}

g(int i);
int g(int i)
{}

void h(int i);
h(int i)
{}

i(int i);
void i(int i)
{}

But result only in two:
test.c:2:1: warning: symbol 'f' redeclared with different type (originally declared at test.c:1) - different types
test.c:6:5: warning: symbol 'g' redeclared with different type (originally declared at test.c:5) - different types

At least in my interpretation "incomplete type" != void.

> > Neither does it complain about the missing return statement??
> 
> Sparse doesn't complain about missing returns, that can be done only after
> flow analysis, and "check" right now doesn't do linearization. For
> example:
> 
> 	int hello(void)
> 	{
> 		for (;;) ;
> 	}
> 
> should _not_ complain about a missing return, because there is no point 
> where we fall through.

OK - did not think of it this way.

[snip]

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 19:55:39 +0000
Message-ID: <20040723195539.8A99E1422D53 () darter ! rentec ! com>
--------------------

The only real-code situation where sparse's handling causes a problem that
I can find are with <foo//bar>.  I grepped a lot of code for this, only to
find it in Linux of all places:

./LINUX/ARCHIVES/kernel/linux-2.4.19/linux/arch/mips/galileo-boards/ev96100/pci_ops.c:#include <asm//gt64120.h>
./LINUX/ARCHIVES/kernel/linux-2.4.20/linux-2.4.20/arch/mips/galileo-boards/ev96100/pci_ops.c:#include <asm//gt64120.h>
./LINUX/ARCHIVES/kernel/linux-2.4.24/linux-2.4.24/arch/ia64/sn/io/drivers/ioconfig_bus.c:#include <asm//sn/sn_sal.h>

The conclusion is that it probably does not occur often enough to worry about.
(Things like <foo-> do not seem to occur at all.  Stuff with backslashes does
occur, but in the Windows world only.)

However, sparse also does not handle absolute includes.  (The barfage below
is due to Solaris' header files.)  I would argue that taking care of this
would be useful.

sparse-2004-07-23> cat foo.c
#include "/usr/include/stdio.h"
# No-go with path
sparse-2004-07-23> ./check ./foo.c
./foo.c:1:10: error: unable to open '/usr/include/stdio.h'
# Ok without
/sparse-2004-07-23> ./check foo.c
/usr/include/sys/feature_tests.h:70:5: warning: undefined preprocessor identifier '_LARGEFILE64_SOURCE'
/usr/include/sys/feature_tests.h:138:6: warning: undefined preprocessor identifier '_XOPEN_SOURCE'
/usr/include/iso/stdio_iso.h:69:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:93:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:158:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:193:6: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:194:2: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:198:6: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:199:2: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:213:6: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:214:2: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:277:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:287:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:307:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/iso/stdio_iso.h:318:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/stdio.h:36:5: warning: undefined preprocessor identifier '__cplusplus'
/usr/include/stdio.h:246:7: warning: undefined preprocessor identifier '_POSIX_C_SOURCE'
/usr/include/stdio.h:371:7: warning: undefined preprocessor identifier '_POSIX_C_SOURCE'
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Fri, 23 Jul 2004 23:54:15 +0000
Message-ID: <Pine.LNX.4.58.0407231647520.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Morten Welinder wrote:
> 
> The only real-code situation where sparse's handling causes a problem that
> I can find are with <foo//bar>.

Indeed. We had to fix one of those things in the 2.6.x kernel.

> The conclusion is that it probably does not occur often enough to worry about.
> (Things like <foo-> do not seem to occur at all.  Stuff with backslashes does
> occur, but in the Windows world only.)
> 
> However, sparse also does not handle absolute includes.  (The barfage below
> is due to Solaris' header files.)  I would argue that taking care of this
> would be useful.

Agreed. That's a bug. Fixed and pushed out.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Sat, 24 Jul 2004 06:42:45 +0000
Message-ID: <Pine.LNX.4.58.0407232336000.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Linus Torvalds wrote:
> 
> You could add the "missing return" warning to the linearization pass (we 
> _do_ do flow analysis there), but then you'd also have to add support for 
> understanding the "noreturn" attribute etc and actually add the 
> "linearize_symbol()" to check.c.
> 
> Doing that might be a good idea. Right now we have never ever actually 
> tested the sparse linearization code on the full kernel. I suspect we may 
> have bugs there.

Indeed. I made "check.c" (which will become "sparse" when we install it) 
do linearization, and that showed up a number of bugs. Very few of them 
were in the linearizer, though - it's just that the linearizer is unhappy 
about lost type information, and some of the earlier passes were silent 
about their unhappiness and had done things wrong.

I fixed the worst offenders, and enabled "linearize_symbol()" in sparse by 
default. End result pushed out.

At least one bug remains: it causes the new sparse to complain about
"warning: label already bound" in various places. I think it happens when
an inline function ends up re-using its builtin while/for/break/return
symbols due to some missing symbol duplication when inlining. Again, that
is unlikely to be a linearization bug per se, it's just shown by the fact
that linearization uses more of the tree than we used to.

Pushed out as-is. If somebody finds the label symbol re-use bug, please 
holler.

(And no, I didn't make linearization warn about missing return values. 
But now it should be all set for it if somebody wants to take a look at 
the linearizer..)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #include MACRO
Date: Sat, 24 Jul 2004 07:13:50 +0000
Message-ID: <Pine.LNX.4.58.0407240010540.1971 () ppc970 ! osdl ! org>
--------------------


On Fri, 23 Jul 2004, Linus Torvalds wrote:
> 
> At least one bug remains: it causes the new sparse to complain about
> "warning: label already bound" in various places. I think it happens when
> an inline function ends up re-using its builtin while/for/break/return
> symbols due to some missing symbol duplication when inlining. Again, that
> is unlikely to be a linearization bug per se, it's just shown by the fact
> that linearization uses more of the tree than we used to.

This is the minimal test-case for this bug that I've found so far.

I'm going to sleep, but maybe somebody more alert can see what's wrong in 
inlining.

	static inline int cmp(void)
	{ 
	        while (1)
	                1;
	}

	void test(void)
	{
	        int i;
	        for (i = 0;cmp(); i++)
	                ;
	}

This results in

	torvalds@ppc970:~/BK/sparse> ./check test.c 
	test.c:3:9: warning: label 'continue' already bound
	test.c:3:9: warning: label 'break' already bound

ie we've apparently gotten the loop control symbols seriously messed up.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: #line ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: #line
Date: Fri, 30 Jul 2004 14:38:48 +0000
Message-ID: <20040730143848.DDA651422D58 () darter ! rentec ! com>
--------------------

Stuff from bison contains #line directives.  This makes sparse ignore
such lines.  This helps but doesn't exactly make sparse happy over such
.c files.

(Ignoring isn't quite right because, arguably, later error messages should
refer to the file from which the c code was generated, not from the c code
itself.)


Morten




===== pre-process.c 1.91 vs edited =====
--- 1.91/pre-process.c	2004-07-26 13:21:57 -04:00
+++ edited/pre-process.c	2004-07-30 10:33:43 -04:00
@@ -1307,6 +1307,14 @@
 	return 1;
 }
 
+/*
+ * We ignore #line for now.
+ */
+static int handle_line(struct stream *stream, struct token **line, struct token *token)
+{
+	return 1;
+}
+
 static int handle_preprocessor_command(struct stream *stream, struct token **line, struct ident *ident, struct token *token)
 {
 	int i;
@@ -1326,6 +1334,7 @@
 		{ "error",	handle_error },
 		{ "include",	handle_include },
 		{ "pragma",	handle_pragma },
+		{ "line",	handle_line },
 
 		// our internal preprocessor tokens
 		{ "nostdinc",	handle_nostdinc },
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: #weak_define ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: #weak_define
Date: Fri, 05 Nov 2004 19:58:38 +0000
Message-ID: <20041105195838.079741422D4F () darter ! rentec ! com>
--------------------

Should lookup_symbol clear ->weak when it sets ->used?

It doesn't sound right to use the weak definition in one part of the file
and the regular definition later.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #weak_define
Date: Fri, 05 Nov 2004 20:33:51 +0000
Message-ID: <Pine.LNX.4.58.0411051228390.2223 () ppc970 ! osdl ! org>
--------------------


On Fri, 5 Nov 2004, Morten Welinder wrote:
> 
> Should lookup_symbol clear ->weak when it sets ->used?
> 
> It doesn't sound right to use the weak definition in one part of the file
> and the regular definition later.

I like your thinking, where usage would basically harden it.

On the other hand, I was thinking of using "weak" for non-preprocessor
symbols too, and maybe the right thing to do is to not clear weak on
usage, but just _test_ both usage and weak.

Also, lookup_symbol() is actually used in do_handle_define() to look up
the old value, so it will _always_ be used there.

So what you probably really want is a second "expanded" bit or something.

Hmm?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: #weak_define
Date: Fri, 05 Nov 2004 20:39:02 +0000
Message-ID: <20041105203902.3F57D1422D4F () darter ! rentec ! com>
--------------------

> maybe the right thing to do is to not clear weak on usage, but just
> _test_ both usage and weak.

That would work -- it's basically the same thing except for the error
text.

> So what you probably really want is a second "expanded" bit or something.

No, that won't work because "#ifdef FOO" should be considered a use.

Let me try sorting it out.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: #weak_define
Date: Fri, 05 Nov 2004 20:48:27 +0000
Message-ID: <Pine.LNX.4.58.0411051246440.2223 () ppc970 ! osdl ! org>
--------------------


On Fri, 5 Nov 2004, Morten Welinder wrote:
> 
> No, that won't work because "#ifdef FOO" should be considered a use.
> 
> Let me try sorting it out.

Sounds like the simplest thing is to just clear the "weak" bit as per your
original suggestion, but _not_ do it in lookup_symbol(). Instead only do
it in the cases that matters (ie expansion, ifdef, whatever). That way
other types of symbols (that never even get to that point) can still use
the weak bit for their stuff.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: (i ? baa : miau).moo = 1; ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: (i ? baa : miau).moo = 1;
Date: Tue, 27 Jul 2004 13:32:35 +0000
Message-ID: <20040727133235.893A91422D53 () darter ! rentec ! com>
--------------------

Check doesn't like the code below:

> ./check ~/foo.c
/home/welinder/foo.c:7:6: warning: expected lvalue for member dereference
/home/welinder/foo.c:7:19: warning: generating address of non-lvalue

-----------------------------------------------------------------------------

struct oink { int moo; };

static void
foo (int i)
{
  struct oink baa, miau;
  (i ? baa : miau).moo = 1;
}

-----------------------------------------------------------------------------

gcc 2.95 is happy with it

gcc 3.4 barfs:
> gcc-3.4 -c -Wall ~/foo.c
/home/welinder/foo.c: In function `foo':
/home/welinder/foo.c:7: error: invalid lvalue in assignment
/home/welinder/foo.c: At top level:
/home/welinder/foo.c:5: warning: 'foo' defined but not used


Now this impressive warning has me wondering.  Sun is typically a go-by-the-
book shop.

> /opt/SUNWspro/bin/cc -V -c  ~/foo.c
cc: Sun WorkShop 6 update 2 C 5.3 Patch 111679-08 2002/05/09
acomp: Sun WorkShop 6 update 2 C 5.3 Patch 111679-08 2002/05/09
"/home/welinder/foo.c", line 7: warning: left operand of "." must be lvalue in this context, program behavior is undefined
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: (i ? baa : miau).moo = 1;
Date: Tue, 27 Jul 2004 16:20:57 +0000
Message-ID: <Pine.LNX.4.58.0407270849390.2522 () ppc970 ! osdl ! org>
--------------------


On Tue, 27 Jul 2004, Morten Welinder wrote:
> 
> Check doesn't like the code below:

Yes.

This is one of the last _fundamental_ bugs in sparse. The rest is either 
just a regular bug, or my strange notion of how things should work. But 
the "structure return" thing is fundamental, and not likely to be fixed 
soon unless somebody gets really excited about it and puts in a fair 
amount of work.

The exact case you cite is I think technically not valid C, but that
doesn't matter: there are cases that _are_ valid C (function return member
dereferences) and the conditional expression thing is really exactly the
same thing. Besides, it's something I think we really want anyway.

Any kind of "expression returning struct" + "member dereference" right now
is basically broken. There aren't many ways to do it (functions and the
conditional operation being the only two I can think of, with "statement
expressions" as a C extension also having the issue), and it's rare enough
that I have to just admit that I didn't think about it from the beginning.

Although in all fairness: even if I _had_ thought about it, I'd probably
have screwed it up.

The problem is that the way sparse does member dereferences, they quite 
fundamentally are "dereference (address of structure + offset)". And only 
lvalues have addresses in sparse. So structure member dereferences end up 
requiring lvalues, so

	struct foo fn(void);
	struct foo a, b;

	fn().member				// doesn't work
	({ struct foo x; .... x; }).member	// doesn't work
	(x ? a : b).member			// doesn't work

Now, the fix for this is to internally re-write the tree as (the "const"
is because we really should warn about an assignment here if somebody 
ends up using the member in that context).

	const struct foo tmp = <expression>;
	tmp.member;				// does work

when encountering this situation, and that would indeed fix it. HOWEVER, 
one reason I haven't gotten around to it is that it's rare enough that I 
don't care terribly deeply ("I'll have to fix it eventually, but...") and 
I'm not 100% sure how I want to do it.

The thing is, I can do it two different ways:

 - structures are really always just addresses, with special cases for 
   assignment and function argument/return passing. This is the C 
   approach, and it makes the case fairly trivial and needs very little 
   sparse changes (real change: we'd basically just allow "addressof" on a
   structure even if it isn't an lvalue, and let the code generation worry 
   about it).

   This is the five-minute hack, and if somebody actually is bothered by 
   it, and writes a patch and sends it to me, I'll probably accept it as a 
   temporary thing, even though I'm not sure I actually like it.

   The real problem with this is that it will pessimize structures that 
   fit into registers, if only because it makes us _think_ of structures
   as always being memory-backed, even if they might not really be. Maybe 
   that isn't a real problem, who knows? I think it's a cop-out, though.

 - notice when the above happens, and make a special case for it. This has 
   the advantage that I could do the conditional more sanely, ie I could 
   rewrite

	(x ? a : b).member

   as

	(x ? a.member : b.member)

   which is likely what we always want to do anyway. For function calls
   and statement expressions we'd do other rewrites - witht he fallback
   being the temporary assignment. This has the advantage that for inline
   functions and statement expressions, the same kind of optimizations 
   would be very natural to do - move the member dereference into the
   return place instead, and just make the code naturally care only about
   the member being used.

   I think this is the right approach. But it's certainly more than a 
   five-minute hack (even if we start off doing _just_ the temporary 
   rewrite and get an lvalue that way).

So... Comments? 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: -Wdefault-bitfield-sign ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: -Wdefault-bitfield-sign
Date: Mon, 16 Aug 2004 21:25:15 +0000
Message-ID: <20040816212515.1D1381422D4F () darter ! rentec ! com>
--------------------

This should cut down the noise in the kernel tree.

[Damn, typo in the changesets: the option's name has hyphens like
gcc's, not underscores.]

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c |    4 +++-
 lib.c      |   35 +++++++++++++++++++++++++++++++++++
 lib.h      |    1 +
 parse.c    |   28 +++++++++++++++++++++++-----
 symbol.c   |   13 -------------
 5 files changed, 62 insertions(+), 19 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/16 1.735)
   Introduce -Wdefault_bitfield_sign and only warn when asked for.

<welinder@troll.com> (04/08/16 1.734)
   parse.c:
     Get the right signedness (which broke when the code moved here).

<welinder@troll.com> (04/08/13 1.732)
   evaluate.c:
     Ignore MOD_EXPLICITLY_SIGNED for type comparisons.

<welinder@troll.com> (04/08/13 1.731)
   Don't complain over sign problems with unnamed bitfields.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Architecture directives in sparse ===

From: John Cherry <cherry () osdl ! org>
To: linux-sparse
Subject: Architecture directives in sparse
Date: Tue, 29 Jun 2004 21:25:41 +0000
Message-ID: <1088544340.6323.86.camel () cherrybomb ! pdx ! osdl ! net>
--------------------
I have just started including sparse runs in the automated kernel
builds.  In looking at the output, the warning...

  CHECK   kernel/exec_domain.c
kernel/exec_domain.c:59:2: warning: switch with no cases

only appears if __i386__ is NOT defined.  Is it the intent of sparse to
generate the same architecture specific directives that are generated by
gcc?

cherry@cherrybomb:~> gcc -E -dM -x c /dev/null
#define __DBL_MIN_EXP__ (-1021)
#define __FLT_MIN__ 1.17549435e-38F
#define __CHAR_BIT__ 8
#define __WCHAR_MAX__ 2147483647
#define __DBL_DENORM_MIN__ 4.9406564584124654e-324
#define __FLT_EVAL_METHOD__ 2
#define __unix__ 1
#define unix 1
#define __i386__ 1
#define __SIZE_TYPE__ unsigned int
#define __ELF__ 1
#define __DBL_MIN_10_EXP__ (-307)
#define __FINITE_MATH_ONLY__ 0
#define __GNUC_PATCHLEVEL__ 1
#define __FLT_RADIX__ 2
#define __LDBL_EPSILON__ 1.08420217248550443401e-19L
#define __SHRT_MAX__ 32767
#define __LDBL_MAX__ 1.18973149535723176502e+4932L
#define __linux 1
#define __unix 1
#define __LDBL_MAX_EXP__ 16384
#define __LONG_MAX__ 2147483647L
#define __linux__ 1
#define __SCHAR_MAX__ 127
#define __DBL_DIG__ 15
#define __USER_LABEL_PREFIX__ 
#define linux 1
#define __tune_pentium__ 1
#define __STDC_HOSTED__ 1
#define __LDBL_MANT_DIG__ 64
#define __FLT_EPSILON__ 1.19209290e-7F
#define __LDBL_MIN__ 3.36210314311209350626e-4932L
#define __WCHAR_TYPE__ long int
#define __FLT_DIG__ 6
#define __FLT_MAX_10_EXP__ 38
#define __INT_MAX__ 2147483647
#define __gnu_linux__ 1
#define __FLT_MAX_EXP__ 128
#define __DECIMAL_DIG__ 21
#define __DBL_MANT_DIG__ 53
#define __WINT_TYPE__ unsigned int
#define __GNUC__ 3
#define __LDBL_MIN_EXP__ (-16381)
#define __tune_i586__ 1
#define __LDBL_MAX_10_EXP__ 4932
#define __DBL_EPSILON__ 2.2204460492503131e-16
#define __DBL_MAX__ 1.7976931348623157e+308
#define __DBL_MAX_EXP__ 1024
#define __FLT_DENORM_MIN__ 1.40129846e-45F
#define __LONG_LONG_MAX__ 9223372036854775807LL
#define __FLT_MAX__ 3.40282347e+38F
#define __GXX_ABI_VERSION 102
#define __FLT_MIN_10_EXP__ (-37)
#define __FLT_MIN_EXP__ (-125)
#define i386 1
#define __GNUC_MINOR__ 3
#define __DBL_MAX_10_EXP__ 308
#define __LDBL_DENORM_MIN__ 3.64519953188247460253e-4951L
#define __DBL_MIN__ 2.2250738585072014e-308
#define __PTRDIFF_TYPE__ int
#define __LDBL_MIN_10_EXP__ (-4931)
#define __REGISTER_PREFIX__ 
#define __LDBL_DIG__ 18
#define __NO_INLINE__ 1
#define __i386 1
#define __FLT_MANT_DIG__ 24
#define __VERSION__ "3.3.1 (SuSE Linux)"

Thanks,
John

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Architecture directives in sparse
Date: Wed, 30 Jun 2004 02:34:31 +0000
Message-ID: <Pine.LNX.4.58.0406291928380.11212 () ppc970 ! osdl ! org>
--------------------


On Tue, 29 Jun 2004, John Cherry wrote:
>
> I have just started including sparse runs in the automated kernel
> builds.  In looking at the output, the warning...
> 
>   CHECK   kernel/exec_domain.c
> kernel/exec_domain.c:59:2: warning: switch with no cases
> 
> only appears if __i386__ is NOT defined.  Is it the intent of sparse to
> generate the same architecture specific directives that are generated by
> gcc?

No. The intent is for the sparse binary to be architecture-neutral,
although that is not really strictly true right now. In particular, it 
currently picks up the search-path for the gcc header files from the build 
environment. But that's the only known deficiency (and that should really 
be handled by having some header files of our own, but glibc in particular 
seems to be very intimate with gcc header files, so..)

So you have to define all the architecture stuff on your own on the 
command line. The two common cases are

 - The "-m64" flag to tell sparse to use "LP64" mode, where ints are 
   32-bit, and long and pointers are 64-bits.
 - Various arch-specific "-Dxxxx=1" things.

The architectures specify the CHECK macro in their arch-specific Makefile, 
so ppc64 has

	CHECK := $(CHECK) -m64 -D__powerpc__=1

and i386 has

	CHECK := $(CHECK) -D__i386__=1

so other than that include file thing, sparse itself should be able to
"cross-check" without having to have any special cross-sparse environment.

In fact, on m68k, they got around the include file problem too, by having

	CHECK := $(CHECK) -D__mc68000__=1 -I$(shell $(CC) -print-file-name=include)

which means that m68k is cross-checkable by default.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: John Cherry <cherry () osdl ! org>
To: linux-sparse
Subject: Re: Architecture directives in sparse
Date: Wed, 30 Jun 2004 20:37:22 +0000
Message-ID: <1088627842.2522.43.camel () cherrybomb ! pdx ! osdl ! net>
--------------------
Thanks for the explanation Linus.  My sparse runs were overriding the
CHECK macro by specifying CHECK on the make command line to specify a
sparse path...

make CHECK=/usr/local/bin/sparse C=1 $MAKEOPT $TARGET

Seems that we had to specify the sparse path for awhile, but I can't
seem to remember why.  Anyway, it was an artifact and has been removed.

John

On Tue, 2004-06-29 at 19:34, Linus Torvalds wrote:
> On Tue, 29 Jun 2004, John Cherry wrote:
> >
> > I have just started including sparse runs in the automated kernel
> > builds.  In looking at the output, the warning...
> > 
> >   CHECK   kernel/exec_domain.c
> > kernel/exec_domain.c:59:2: warning: switch with no cases
> > 
> > only appears if __i386__ is NOT defined.  Is it the intent of sparse to
> > generate the same architecture specific directives that are generated by
> > gcc?
> 
> No. The intent is for the sparse binary to be architecture-neutral,
> although that is not really strictly true right now. In particular, it 
> currently picks up the search-path for the gcc header files from the build 
> environment. But that's the only known deficiency (and that should really 
> be handled by having some header files of our own, but glibc in particular 
> seems to be very intimate with gcc header files, so..)
> 
> So you have to define all the architecture stuff on your own on the 
> command line. The two common cases are
> 
>  - The "-m64" flag to tell sparse to use "LP64" mode, where ints are 
>    32-bit, and long and pointers are 64-bits.
>  - Various arch-specific "-Dxxxx=1" things.
> 
> The architectures specify the CHECK macro in their arch-specific Makefile, 
> so ppc64 has
> 
> 	CHECK := $(CHECK) -m64 -D__powerpc__=1
> 
> and i386 has
> 
> 	CHECK := $(CHECK) -D__i386__=1
> 
> so other than that include file thing, sparse itself should be able to
> "cross-check" without having to have any special cross-sparse environment.
> 
> In fact, on m68k, they got around the include file problem too, by having
> 
> 	CHECK := $(CHECK) -D__mc68000__=1 -I$(shell $(CC) -print-file-name=include)
> 
> which means that m68k is cross-checkable by default.
> 
> 		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Buglet in alignment of structures and unions ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Buglet in alignment of structures and unions
Date: Fri, 27 Aug 2004 14:54:39 +0000
Message-ID: <20040827145439.B6EDA1422D56 () darter ! rentec ! com>
--------------------

The i386 C ABI says that this should have alignment and thus size==1.

  union Foo {
    char c;
    int : 1;
  } foo;

Interestingly, the ABI also says that "int foo : 2" should have range 0-3.
Gcc is starting to look like the odd man out here.  (*Clickety-click*, bug
filed with gcc.)

Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 symbol.c |   19 ++++++++++++++-----
 1 files changed, 14 insertions(+), 5 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/27 1.749)
   Unnamed bitfields should not affect structure and union alignment.

diff -Nru a/symbol.c b/symbol.c
--- a/symbol.c	2004-08-27 10:36:03 -04:00
+++ b/symbol.c	2004-08-27 10:36:03 -04:00
@@ -66,15 +66,20 @@
 };
 
 /*
- * Unions are easy to lay out ;)
+ * Unions are fairly easy to lay out ;)
  */
 static void lay_out_union(struct symbol *sym, void *_info, int flags)
 {
 	struct struct_union_info *info = _info;
 
 	examine_symbol_type(sym);
-	if (sym->ctype.alignment > info->max_align)
-		info->max_align = sym->ctype.alignment;
+
+	// Unnamed bitfields do not affect alignment.
+	if (sym->ident || !is_bitfield_type(sym)) {
+		if (sym->ctype.alignment > info->max_align)
+			info->max_align = sym->ctype.alignment;
+	}
+
 	if (sym->bit_size > info->bit_size)
 		info->bit_size = sym->bit_size;
 
@@ -91,8 +96,12 @@
 	unsigned long align_bit_mask;
 
 	examine_symbol_type(sym);
-	if (sym->ctype.alignment > info->max_align)
-		info->max_align = sym->ctype.alignment;
+
+	// Unnamed bitfields do not affect alignment.
+	if (sym->ident || !is_bitfield_type(sym)) {
+		if (sym->ctype.alignment > info->max_align)
+			info->max_align = sym->ctype.alignment;
+	}
 
 	bit_size = info->bit_size;
 	base_size = sym->bit_size; 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: Buglet in alignment of structures and unions
Date: Fri, 27 Aug 2004 15:21:37 +0000
Message-ID: <20040827082137.4ad7e673.rddunlap () osdl ! org>
--------------------
On Fri, 27 Aug 2004 10:54:39 -0400 (EDT) Morten Welinder wrote:

| 
| The i386 C ABI says that this should have alignment and thus size==1.
| 
|   union Foo {
|     char c;
|     int : 1;
|   } foo;
| 
| Interestingly, the ABI also says that "int foo : 2" should have range 0-3.
| Gcc is starting to look like the odd man out here.  (*Clickety-click*, bug
| filed with gcc.)

gcc list just went thru about 100 emails (nothing compared to
reiser4 on lkml) on
Subject: Re: Help with bit-field semantics in C and C++

and ISTM that they agree with you... we'll see.

--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Buglet in alignment of structures and unions
Date: Fri, 27 Aug 2004 15:29:44 +0000
Message-ID: <20040827152944.784D91422D56 () darter ! rentec ! com>
--------------------

   gcc list just went thru about 100 emails (nothing compared to
   reiser4 on lkml) on
   Subject: Re: Help with bit-field semantics in C and C++

Not quite related, really.  Those were roughly...

* One third about C++ enum bitfields assigned random ints.
* One third "Did not!"
* One third "Did too!"

I think we (and they, for that matter) can safely ignore that
thread.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Buglet in alignment of structures and unions
Date: Fri, 27 Aug 2004 17:52:28 +0000
Message-ID: <Pine.LNX.4.58.0408271051370.14196 () ppc970 ! osdl ! org>
--------------------


On Fri, 27 Aug 2004, Morten Welinder wrote:
> 
> Interestingly, the ABI also says that "int foo : 2" should have range 0-3.

Hmm.. How do you make a signed bitfield? Does an explicit "signed" matter 
here?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Buglet in alignment of structures and unions
Date: Fri, 27 Aug 2004 18:00:44 +0000
Message-ID: <20040827180044.0FF661422D56 () darter ! rentec ! com>
--------------------

   > Interestingly, the ABI also says that "int foo : 2" should have range 0-3.

   Hmm.. How do you make a signed bitfield? Does an explicit "signed" matter 
   here?

Yes, "signed" does matter.  Now realize that gcc and the gcc people are not in
the mood to follow the ABI in this.  For what it is worth, Sun's C compiler
defaults to unsigned bitfields.  (And that was why I add the check for
explicit bitfield sign in the first place.)

Oh, and the alignment-unaffected-by-unnamed-bitfields feature of the ABI turns
out to conflict with the C99 standard...  (Section 6.2.7 specifically.)

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Buglet in alignment of structures and unions
Date: Fri, 27 Aug 2004 18:18:44 +0000
Message-ID: <Pine.LNX.4.58.0408271116230.14196 () ppc970 ! osdl ! org>
--------------------


On Fri, 27 Aug 2004, Morten Welinder wrote:
> 
> Yes, "signed" does matter.  Now realize that gcc and the gcc people are not in
> the mood to follow the ABI in this.  For what it is worth, Sun's C compiler
> defaults to unsigned bitfields.  (And that was why I add the check for
> explicit bitfield sign in the first place.)

Ok. I'm inclined to follow the ABI (and the fact that it's more
convenient) than gcc. But the warning makes sense as a portability thing, 
so as long as sparse doesn't seriously generate code, it doesn't matter 
what we decide.

> Oh, and the alignment-unaffected-by-unnamed-bitfields feature of the ABI turns
> out to conflict with the C99 standard...  (Section 6.2.7 specifically.)

Are you sure you can't just consider a

	int x:3;

to fit in a "char", and let the relaxed alignment come from there (rather
than the un-named-ness).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: CSE _and_ if-conversion ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: CSE _and_ if-conversion
Date: Wed, 24 Nov 2004 18:59:44 +0000
Message-ID: <Pine.LNX.4.58.0411241021520.20993 () ppc970 ! osdl ! org>
--------------------

Damn, I'm good.

I'm now doing a limited form of if-conversion, in that I convert 
good-looking phi-nodes into select operations. I'm not a big believer in 
general if-conversion with predicated instructions, but on the other hand 
I definitely _do_ want to get the trivial cases where we can just rewrite 
an if into a "select()". 

Iow, I believe that these test-cases should all be branch-free:

	int fn1(int argc, int a, int b)
	{
		int i;
		if (argc)
			i = a;
		else
			i = b;
		return i;
	}

	int fn2(int argc)
	{
		if (!argc)
			return -1;
		return argc;
	}

	int fn3(int argc, int a, int b)
	{
		int retval = a;
		if (argc)
			retval = b;
		return retval;
	}

since they really all boil down to the same thing: a select on a pseudo, 
with no actual real "code" in any of the cases, ie the linearization 
results in empty blocks that don't have anything but a phi-source note in 
them.

And dammit if sparse doesn't do that right now. Of course, I quite
possibly have bugs in it (I wouldn't be surprised if I can get the sense
of the "select" wrong at times), and right now it doesn't merge all the
basic blocks completely, because my bb packer still gets confused too
easily.

But the above three test-cases now linearizs to the appended
linearization. I've manually removed empty blocks, nop's and instructions
marked unused, and added notes on why something didn't merge, but I have
not actually changed anything else in any way.

Cool, no?

		Linus

----

  ep 0xf7fe200c: fn1	
	ENTRY:
	bb: 0xf7f9e00c
	   test.c:1:5
	  **to 0xf7f9e06c (test.c:8:2)**
	  **to 0xf7f9e06c (test.c:8:2)**
		setcc %arg1
		%r6 <- select  %arg2, %arg3
		br	.L0xf7f9e06c

	/* Not merged: "two parents" and "stale phi source" */
	bb: 0xf7f9e06c
	   test.c:8:2
	  **from 0xf7f9e00c (test.c:1:5)**
	  **from 0xf7f9e00c (test.c:1:5)**
	  **phi source (%r6,.L0xf7f9e06c)**
		ret %r6
	
	
  ep 0xf7fe2028: fn2	
	ENTRY:
	bb: 0xf7f9e0ac
	   test.c:11:5
	  **to 0xf7f9e10c (test.c:11:5)**
	  **to 0xf7f9e10c (test.c:11:5)**
		setcc %arg1
		%r8 <- select  %arg1, $0xffffffff
		br	.L0xf7f9e10c
	
	/* Not merged: "two parents" */
	bb: 0xf7f9e10c
	   test.c:11:5
	  **from 0xf7f9e0ac (test.c:11:5)**
	  **from 0xf7f9e0ac (test.c:11:5)**
		ret %r8
	
	
  ep 0xf7fe2044: fn3	
	ENTRY:
	bb: 0xf7f9e12c
	   test.c:18:5
	  **to 0xf7f9e16c (test.c:23:2)**
	  **to 0xf7f9e16c (test.c:23:2)**
		setcc %arg1
		%r15 <- select  %arg3, %arg2
		br	.L0xf7f9e16c
	
	/* Not merged: "two parents" and "stale phi source" */
	bb: 0xf7f9e16c
	   test.c:23:2
	  **from 0xf7f9e12c (test.c:18:5)**
	  **from 0xf7f9e12c (test.c:18:5)**
	  **phi source (%r15,.L0xf7f9e16c)**
		ret %r15
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Can this warning be improved? ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Can this warning be improved?
Date: Thu, 03 Jun 2004 18:57:59 +0000
Message-ID: <20040603185759.GA9338 () mars ! ravnborg ! org>
--------------------
The following warning looks strange:

kernel/acct.c:397:27: warning: incorrect type in argument 2 (different address spaces)
kernel/acct.c:397:27:    expected char const [noderef] *<noident><asn:1>
kernel/acct.c:397:27:    got char *<noident>


It is generated in the following code snippet:
#include/linux/syscalls.h
asmlinkage long sys_wait4(pid_t pid, unsigned int __user *stat_addr, ...)

#kernel/acct.c
struct subprocess_info {
	...
        int retval;
};

static int wait_for_helper(void *data)
{
        struct subprocess_info *sub_info = data;
	...
        sys_wait4(pid, &sub_info->retval, 0, NULL
);

If the warning looked like the following it would be
easier to follow:

kernel/acct.c:397:27: warning: incorrect type in argument 2 (different address spaces)
kernel/acct.c:397:27:    expected unsigned int __user *
kernel/acct.c:397:27:    got int *


Please notice there seems to be some errors in the generated warning:

kernel/acct.c:397:27:    expected char const [noderef] *<noident><asn:1>
kernel/acct.c:397:27:    got char *<noident>

The expected part say 'char const [noderef] *<noident><asn:1>'
I cannot see why sparse say 'char const', since this is an int.
The [noderef] I dunno what tells me.
The <noident> looks useless.
The <asn:1> looks like debug info.

The got part say 'got char *<noident>'
Again it looks like int are converted to char.


Give me a couple of days and I could fix it myself, but if this is
simple to fix for others..

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Thu, 03 Jun 2004 20:13:59 +0000
Message-ID: <Pine.LNX.4.58.0406031310540.3403 () ppc970 ! osdl ! org>
--------------------


On Thu, 3 Jun 2004, Sam Ravnborg wrote:
>
> The following warning looks strange:
> 
> kernel/acct.c:397:27: warning: incorrect type in argument 2 (different address spaces)
> kernel/acct.c:397:27:    expected char const [noderef] *<noident><asn:1>
> kernel/acct.c:397:27:    got char *<noident>
> 
> 
> It is generated in the following code snippet:

No it's not.

Line 397 of kernel/acct.c is:

	...
        file->f_op->write(file, (char *)&ac,
                               sizeof(struct acct), &file->f_pos);
	...

and it's complaining because it gets a "char *", even though the "write()" 
operation takes a "const char __user *".

The types it complains about are 100% correct.

> I cannot see why sparse say 'char const', since this is an int.

No. It's clearly a "const char *".

I don't know where you get the int from.

> The [noderef] I dunno what tells me.
> The <noident> looks useless.
> The <asn:1> looks like debug info.

The "noderef" is part of the definition of what a "user" pointer is: you 
cannot dereference it.

<noident> is there because sparse will tell you what the symbol name was, 
and in this case there was no symbol name (it's a cast).

The <asn:1> is "address space number 1", which is again because sparse 
wants a _user_ pointer to the write.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Thu, 03 Jun 2004 20:57:59 +0000
Message-ID: <20040603205759.GA31425 () mars ! ravnborg ! org>
--------------------
On Thu, Jun 03, 2004 at 01:13:59PM -0700, Linus Torvalds wrote:
> No it's not.
...

Arghh..
Copied from the wrong place, and then switched of my brain - sorry.

So to make sure I got it right I made the following sample code:


#define __user              __attribute__((noderef, address_space(1)))

long sys_wait4(int n, unsigned int __user *stat_addr);

struct subprocess_info {
        int retval;
};

static int wait_for_helper(void *data)
{
        struct subprocess_info *sub_info = data;
        sys_wait4(1, &sub_info->retval);
}

[Copied from kmod.c]

Which generates the following warning with sparse:
foo.c:12:23: warning: incorrect type in argument 2 (different address spaces)
foo.c:12:23:    expected unsigned int [noderef] *stat_addr<asn:1>
foo.c:12:23:    got int [addressable] [toplevel] *<noident>

This makes more sense now.
Also now I realise I shall read noderef: 'no dereference'.
I read it 'node reference' previously. That did not make much sense.

And 'asn' I read Abstract syntax node, which was wrong as well.

<noident> I already understood.

Thanks for the clarifications.


About the particular warning in kmod.c.
Would it be correct just to cast it to (int __user *)?

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Thu, 03 Jun 2004 21:19:43 +0000
Message-ID: <Pine.LNX.4.58.0406031407280.3403 () ppc970 ! osdl ! org>
--------------------

[ Andrew and Rusty added to discussion ]

On Thu, 3 Jun 2004, Sam Ravnborg wrote:
> 
> About the particular warning in kmod.c.
> Would it be correct just to cast it to (int __user *)?

No. It's really only correct to cast a kernel pointer to a __user pointer
if you do something that literally _makes_ kernel addresses be user 
addresses, in other words, only if you do a

	set_fs(KERNEL_DS);
	.. here kernel addresses are user addresses ..
	set_fs(USER_DS);

At other times the cast is valid because it really was a user mode pointer 
in teh first place, and we just needed to change the type (say, from a 
"void __user *" to a "unsigned int __user *").

So we should look at where the pointer comes from, and whether maybe it 
was wrong to call it a kernel pointer in the first place.

And quite frankly, in this case I believe that sparse has found a real
kernel bug, and that the warning is valid. "&retval" really _is_ in kernel
space, and passing it off to "sys_wait4()" should cause wait4() to return
-EFAULT.

Of course, we don't actually _look_ at the return value of sys_wait4(), so 
nobody ever noticed that "retval" was never updated, and the end result 
really seems to be that everybody always thinks that a blocking
"call_usermode_helper()" was always successful, regardless of what the 
user mode helper actually returned.

This is why we should _not_ just cast things to __user pointers.

Btw, this bug was introduced by:

	ChangeSet 1.1371.52.76 2003/12/30 17:00:38 akpm@osdl.org
	  [PATCH] call_usermodehelper retval fix

	  The reworked firmware loader in the DVB patches needs the fix to the
	  call_usermodehelper() return value. 
	  
	  From: Rusty Russell <rusty@rustcorp.com.au>
	....

and I bet nobody actually tested that it works. Or maybe the user of 
usermodehelper in that one case actually did a "set_fs()" somewhere.

Rusty, any comments?

		Linus


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Rusty Russell <rusty () rustcorp ! com ! au>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Fri, 04 Jun 2004 00:09:38 +0000
Message-ID: <1086307778.29381.845.camel () bach>
--------------------
On Fri, 2004-06-04 at 07:19, Linus Torvalds wrote:
> 	ChangeSet 1.1371.52.76 2003/12/30 17:00:38 akpm@osdl.org
> 	  [PATCH] call_usermodehelper retval fix
> 
> 	  The reworked firmware loader in the DVB patches needs the fix to the
> 	  call_usermodehelper() return value. 
> 	  
> 	  From: Rusty Russell <rusty@rustcorp.com.au>
> 	....
> 
> and I bet nobody actually tested that it works. Or maybe the user of 
> usermodehelper in that one case actually did a "set_fs()" somewhere.
> 
> Rusty, any comments?

Yep.  We are keventd here.  sys_wait4() works fine.

I can re-test if you want, but I specifically recall testing this
because it *has* been a PITA to get right: it used to return EFAULT, as
Linus said.

Rusty.
-- 
Anyone who quotes me in their signature is an idiot -- Rusty Russell

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Fri, 04 Jun 2004 01:22:53 +0000
Message-ID: <Pine.LNX.4.58.0406031818370.7010 () ppc970 ! osdl ! org>
--------------------


On Fri, 4 Jun 2004, Rusty Russell wrote:
> 
> Yep.  We are keventd here.  sys_wait4() works fine.

Ok. If it does, it pretty much does so by mistake. It needs a huge 
comment, methinks.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andrew Morton <akpm () osdl ! org>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Fri, 04 Jun 2004 01:34:52 +0000
Message-ID: <20040603183452.25647e82.akpm () osdl ! org>
--------------------
Linus Torvalds <torvalds@osdl.org> wrote:
>
> 
> 
> On Fri, 4 Jun 2004, Rusty Russell wrote:
> > 
> > Yep.  We are keventd here.  sys_wait4() works fine.
> 
> Ok. If it does, it pretty much does so by mistake. It needs a huge 
> comment, methinks.
> 



Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 25-akpm/kernel/kmod.c |   12 ++++++++++--
 1 files changed, 10 insertions(+), 2 deletions(-)

diff -puN kernel/kmod.c~huge-comment kernel/kmod.c
--- 25/kernel/kmod.c~huge-comment	2004-06-03 18:31:10.063810224 -0700
+++ 25-akpm/kernel/kmod.c	2004-06-03 18:33:49.065638272 -0700
@@ -192,10 +192,18 @@ static int wait_for_helper(void *data)
 	allow_signal(SIGCHLD);
 
 	pid = kernel_thread(____call_usermodehelper, sub_info, SIGCHLD);
-	if (pid < 0)
+	if (pid < 0) {
 		sub_info->retval = pid;
-	else
+	} else {
+		/*
+		 * Normally it is bogus to call wait4() from in-kernel because
+		 * wait4() wants to write the exit code to a userspace address.
+		 * But wait_for_helper() always runs as keventd, and put_user()
+		 * to a kernel address works OK for kernel threads, due to their
+		 * having an mm_segment_t which spans the entire address space.
+		 */
 		sys_wait4(pid, &sub_info->retval, 0, NULL);
+	}
 
 	complete(sub_info->complete);
 	return 0;
_

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Can this warning be improved?
Date: Fri, 04 Jun 2004 02:48:28 +0000
Message-ID: <Pine.LNX.4.58.0406031947450.7010 () ppc970 ! osdl ! org>
--------------------


On Thu, 3 Jun 2004, Andrew Morton wrote:
> +		/*
> +		 * Normally it is bogus to call wait4() from in-kernel because
> +		 * wait4() wants to write the exit code to a userspace address.
> +		 * But wait_for_helper() always runs as keventd, and put_user()
> +		 * to a kernel address works OK for kernel threads, due to their
> +		 * having an mm_segment_t which spans the entire address space.
> +		 */
>  		sys_wait4(pid, &sub_info->retval, 0, NULL);

Ok, then we might as well add the __user thing there while we're at it, to 
point out what the comment is about.

Will do.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Check in Policy? ===

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: Check in Policy?
Date: Mon, 13 Sep 2004 17:39:41 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKGEOODDAA.mshah () teja ! com>
--------------------
Hi,

How can I submit a patch for review and check in to the main repository?

Thanks,

-Mitesh


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Check in Policy?
Date: Mon, 13 Sep 2004 17:41:06 +0000
Message-ID: <Pine.LNX.4.58.0409131038400.2378 () ppc970 ! osdl ! org>
--------------------


On Mon, 13 Sep 2004, Mitesh shah wrote:
> 
> How can I submit a patch for review and check in to the main repository?

Just post it here for discussion, with explanations of what it does and 
why you want to do something.

No strict "requirements", although it would be nice to have a similar
sign-off to what we do for the kernel, I guess (ie the "I have the right
to release this"). For trivial stuff (and in sparse, most stuff _is_
pretty trivial, it's not like this is rocket science for the most part) I
don't really care, though.

Whether it gets checked in or not depends on how many people agree ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Checking signedness in sparse.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 15:18:41 +0000
Message-ID: <Pine.LNX.4.58.0409210756260.25656 () ppc970 ! osdl ! org>
--------------------

Richard pointed out that the fact that gcc didn't check for signedness in 
type equality was in fact a bug, and that gcc-4 will in fact do so, and 
that the kernel has a number of problems.

So I removed the code that masked the sign in "type_difference()", and
indeed, there's a lot of code that ends up being slightly confused about
passing in "int *" vs "unsigned int *" etc.

However, I get the feeling that checking signedness at least for "char" 
cannot be right, partly because we have a _ton_ of those warnings, and 
partly because I just don't see how to remove some of them without doing 
some totally silly contortions. We sometimes use "unsigned char *" 
explicitly, because we want to use them for hashes and/or just make sure 
that we don't consider negative values, but then we have "char *" as the 
basic interfaces, because dammit, that's standard. Having to cast between 
the two just cannot be right.

So I'm getting the feeling that strict signedness checking cannot be 
right, never mind what gcc thinks. Can people point to what standards 
require, and what other compilers do?

I'd be inclined to do either
 - ignore sign entirely for the non-explicitly-signed "char" case. This 
   would make sense, considering the historic "char *" usage, and the fact
   that "char" really is different even in the standard (and has special 
   initializers, like "string")
 - ignore signedness everywhere unless _both_ sides as explicitly signed,
   and they differ in the actual sign. This would make sense just because
   I hate special-casing "char", and it seems like a sane rule.

Hmm?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 15:34:29 +0000
Message-ID: <20040921153429.3AB4E1422D58 () darter ! rentec ! com>
--------------------

I am quite certain that any significant noise volume will come from
[plain] char only.  But I would suggest looking at some real samples
before accepting that as truth.

Assuming it holds, I would suggest special-casing plain char.

I've had to deal with a library (namely libxml) that uses a typedef of
"unsigned char" as its character type and it is PAINFUL!  Some gccs,
probably archs I don't have, will actually already complain over the
mismatch if you send a "string" argument.  Enter macros like

    #define CC2XML(s) ((const xmlChar *)(s))

just to keep the noise down (and casts out of the code proper).  I hate
having to please the compiler like that.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 15:46:33 +0000
Message-ID: <Pine.LNX.4.58.0409210841070.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Morten Welinder wrote:
> 
> I've had to deal with a library (namely libxml) that uses a typedef of
> "unsigned char" as its character type and it is PAINFUL!  Some gccs,
> probably archs I don't have, will actually already complain over the
> mismatch if you send a "string" argument. 

Richard? I really think that's a bug if gcc warns about

	signed char *s = "0123456789abcdef";
	unsigned char *u = "0123456789abcdef";

(depending on what the particular sign of char is that day), then that
should be considered a _bug_.

I definitely will make at least regular "char" not complain. If gcc 
complains about some of them, I will consider that a gcc bug, and tell 
people not to use such a broken compiler version.

The question is really how far we can take that analogy of "char". Does it 
extend to "int" too, ie should we complain about

	"unsigned int *" vs "signed int *"

(which definitely makes sense) but _not_ complain about

	"unsigned int *" vs "int *"

The reason I like the "complain on explicit sign difference" is that it 
allows the _programmer_ to decide whether he cares about sign or not. 
Extra casts are evil, and maybe there are reasons for mixing signs.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 16:09:35 +0000
Message-ID: <Pine.LNX.4.58.0409210903340.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Linus Torvalds wrote:
> 
> The question is really how far we can take that analogy of "char". Does it 
> extend to "int" too, ie should we complain about
> 
> 	"unsigned int *" vs "signed int *"
> 
> (which definitely makes sense) but _not_ complain about
> 
> 	"unsigned int *" vs "int *"

Well, I rewrote the tests slightly, so that we now trivially see which 
case was which.

A test-file like

	signed char *sc;
	unsigned char *uc = sc;
	char *c1 = sc;
	char *c2 = uc;
	signed int *si;
	unsigned int *ui = si;
	int *i1 = si;
	int *i2 = ui;

now gives the warnings:

	test.c:2:21: warning: incorrect type in initializer (different explicit signedness)
	test.c:2:21:    expected unsigned char *[addressable] [toplevel] uc
	test.c:2:21:    got signed char *[addressable] [toplevel] sc
	test.c:6:20: warning: incorrect type in initializer (different explicit signedness)
	test.c:6:20:    expected unsigned int *[addressable] [toplevel] ui
	test.c:6:20:    got signed int *[addressable] [toplevel] si
	test.c:8:11: warning: incorrect type in initializer (different signedness)
	test.c:8:11:    expected int *[addressable] [toplevel] i2
	test.c:8:11:    got unsigned int *[addressable] [toplevel] ui

ie note how it does not complain about the assignments to "char *", but it
_does_ complain when an explicitly signed char is assigned to an
explicitly unsigned char. That clearly makes sense.

I also made non-char types warn (different message - ie the "i2 = ui"  
thing on line 8 warns), at least for now. I'm not convinced it's 
necessariyl a good idea, but it's at least not _as_ obviously stupid as it 
is to warn about "char".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 16:14:12 +0000
Message-ID: <20040921161412.0B5B91422D58 () darter ! rentec ! com>
--------------------

> Extra casts are evil [...]

Speaking of casts, one of the main reason they are evil is that they specify
only the target type and thus don't break when other changes cause the
expression's type to change.  With sparse, one could have...

#define CAST(_t,_f,_e) \
  (__builtin_warning(typeof (_e) != (_f), "barf"),(_t)(_e))

I haven't actually done this in practice -- just thinking aloud -- so
I don't know how well it would work and how intrusive it would be.

I asked around, and the problems we saw with character sign were for
ppc and/or s390 if that rings a bell with someone.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 16:29:57 +0000
Message-ID: <Pine.LNX.4.58.0409210917540.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Morten Welinder wrote:
> 
> > Extra casts are evil [...]
> 
> Speaking of casts, one of the main reason they are evil is that they specify
> only the target type and thus don't break when other changes cause the
> expression's type to change.  With sparse, one could have...
> 
> #define CAST(_t,_f,_e) \
>   (__builtin_warning(typeof (_e) != (_f), "barf"),(_t)(_e))

Apart from having to use [] around the types, yes. I agree that the lack
of source type is one of the problems with casts (due to hiding outright
type confusion), but I literally think that a bigger problem is the fact 
that it makes code not as clearly readable.

Your syntax doesn't help the second problem at all (and actually just 
makes it worse).

I'd rather have a setup where casts really aren't needed in _any_ normal
code. They'd be the "we use them to explicitly break the type system"  
(which is still very important), but they should only be used when they 
really _are_ needed.

C++ is totally broken in this respect, in requiring more casts than C 
does. 

Btw, now that I can do the statistics: a regular build for me (ppc64) of
the kernel has nine (9) cases of "different explicit signedness" (all but
one of which is in the nfs4 XDR code), and 138 occurrences of just regular
"different signedness".

With the "char" cases filtered out, most of them look like reasonably sane 
warnings.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 16:49:43 +0000
Message-ID: <Pine.LNX.4.58.0409210942190.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Linus Torvalds wrote:
> 
> With the "char" cases filtered out, most of them look like reasonably sane 
> warnings.

Actually, I think I have to take that back.

_Some_ of them look reasonable. Many do not.

In fact, even the "explicit sign" differences are a bit questionable. The 
xdr4 code does something like this:

	s64	len, start, end;
	...
	p = xdr_decode_hyper(p, &start);
	p = xdr_decode_hyper(p, &len);
	..

and both of these generate warnings, because xdr_decode_hyper() looks like

	static inline u32 *
	xdr_decode_hyper(u32 *p, __u64 *valp)

but the fact is, it obviously works fine to return both u64 and s64
values, and forcing the caller to use one over the other is just not that
sensible. Similarly, adding a cast is clearly EVIL (not to mention 
stupid), and duplicating the function to do the same thing also seems 
totally idiotic.

Quite frankly, to me it looks more and more like being too careful about 
signs is just not worth it. Alternatively, we could keep the "warn about 
explicit sign differences only", and make sure that "s64" was just 
implicitly signed.

But at that point there are effectively no warnings left in the kernel, 
which implies that the check itself isn't that important in the first 
place.

Richard, are you sure that the gcc team has thought this through wrt
gcc-4.0, or is this just another total disaster like adding
"-Wsign-compare" to the default flags in gcc-3.0?

I'd love to hear what other compilers do. They must have seen exactly the 
same issues. Does the intel/sparc/xxx compiler warn about these things by 
default?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:22:48 +0000
Message-ID: <20040921172248.052D51422D58 () darter ! rentec ! com>
--------------------

[cutting rth from cc as this is irrelavant for him]

This teaches cgcc about recently-arrived sparse-only options.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 cgcc |    2 +-
 1 files changed, 1 insertion(+), 1 deletion(-)

through these ChangeSets:

<welinder@troll.com> (04/09/21 1.801)
   Teach cgcc about -Wbitwise and -Wtypesign.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-09-21 13:21:23 -04:00
+++ b/cgcc	2004-09-21 13:21:23 -04:00
@@ -24,7 +24,7 @@
 
 sub check_only_option {
     my ($arg) = @_;
-    return 1 if $arg =~ /^-W(no-?)?default-bitfield-sign$/;
+    return 1 if $arg =~ /^-W(no-?)?(default-bitfield-sig|bitwise|typesign)$/;
     return 0;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:32:09 +0000
Message-ID: <20040921173209.GA7155 () wohnheim ! fh-wedel ! de>
--------------------
On Tue, 21 September 2004 09:29:57 -0700, Linus Torvalds wrote:
> 
> I'd rather have a setup where casts really aren't needed in _any_ normal
> code. They'd be the "we use them to explicitly break the type system"  
> (which is still very important), but they should only be used when they 
> really _are_ needed.

Much agreement.  Most casts I ever see are converted to "(void*)foo".
Neither source nor target type are void*, but the pattern explicitly
sais "no matter what the source or target types are, make this pointer
the same type as the target".

Point is that 99% of all casts fall into this category.  So if I ever
see a different one, it usually is a bug.

Jrn

-- 
The wise man seeks everything in himself; the ignorant man tries to get
everything from somebody else.
-- unknown
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Richard Henderson <rth () twiddle ! net>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:41:09 +0000
Message-ID: <20040921174109.GA31771 () twiddle ! net>
--------------------
On Tue, Sep 21, 2004 at 08:18:41AM -0700, Linus Torvalds wrote:
>  - ignore sign entirely for the non-explicitly-signed "char" case. This 
>    would make sense, considering the historic "char *" usage, and the fact
>    that "char" really is different even in the standard (and has special 
>    initializers, like "string")

Perhaps you want -funsigned-char for the kernel.  Then you don't need
casts to unsigned char anywhere.  Personally, I think that's what most
people want *all* of the time; stupid ABIs.

>  - ignore signedness everywhere unless _both_ sides as explicitly signed,
>    and they differ in the actual sign. This would make sense just because
>    I hate special-casing "char", and it seems like a sane rule.

This, I think, is a mistake, because C doesn't differentiate between
"signed int" and "int".  They really are the same.  Creating an artificial
difference here makes no sense.


r~
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:46:55 +0000
Message-ID: <Pine.LNX.4.58.0409211043420.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Jrn Engel wrote:
> 
> Much agreement.  Most casts I ever see are converted to "(void*)foo".
> Neither source nor target type are void*, but the pattern explicitly
> sais "no matter what the source or target types are, make this pointer
> the same type as the target".
> 
> Point is that 99% of all casts fall into this category.  So if I ever
> see a different one, it usually is a bug.

I'd argue that "void *" casts are bugs. They shouldn't ever be needed.

Either somethign takes an untyped pointer (memset et al) or it doesn't. If 
it takes a "void *", then a cast isn't necessary. If it doesn't, then 
casting it is wrong anyway.

Sometimes there are _totally_ untyped variables, and they may be "unsigned 
long" or "void *" or something, and then you do need a cast if you need to 
cast between integers and pointers. I'd argue that that is a deficiency of 
the C language too, and that it would be fine to have a totally opaque 
sized type that silently allows automatic conversions of the right size 
even across pointers/integers.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:48:29 +0000
Message-ID: <Pine.LNX.4.58.0409211047160.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Richard Henderson wrote:
> 
> >  - ignore signedness everywhere unless _both_ sides as explicitly signed,
> >    and they differ in the actual sign. This would make sense just because
> >    I hate special-casing "char", and it seems like a sane rule.
> 
> This, I think, is a mistake, because C doesn't differentiate between
> "signed int" and "int".  They really are the same.  Creating an artificial
> difference here makes no sense.

Sparse already has the difference, to make printouts cleaner and to make 
all integer types behave the sane. It was originally needed for bitfields, 
where an explicit sign actually does mean something else.

gcc gets that wrong, btw. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:49:49 +0000
Message-ID: <Pine.LNX.4.58.0409211048370.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Richard Henderson wrote:
>
> On Tue, Sep 21, 2004 at 08:18:41AM -0700, Linus Torvalds wrote:
> >  - ignore sign entirely for the non-explicitly-signed "char" case. This 
> >    would make sense, considering the historic "char *" usage, and the fact
> >    that "char" really is different even in the standard (and has special 
> >    initializers, like "string")
> 
> Perhaps you want -funsigned-char for the kernel. 

Richard, you're ignoring the fundamental issue.

It's _wrong_ for the compiler to complain about

	unsigned char *p = "hello world".

End of story. No excuses about "use "-funsigned-char" or something like 
that.

I still haven't heard anybody say what other compilers do. I don't even 
have access to anything but sparse and gcc, so ..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:55:37 +0000
Message-ID: <20040921175537.653201422D58 () darter ! rentec ! com>
--------------------

> I'd argue that "void *" casts are bugs. They shouldn't ever be needed.

Ok, here are two bugs, then, :-)  caddr_t ends up being char pointers and
gcc/sparse are not happy.

It does, however, make sense to ensure that blob_alloc really does deliver
a generic pointer.  Nevertheless, please let me know if you reject it
and I'll just keep it in my tree.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 lib.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/21 1.802)
   Portability fix.  Good Ole K&R gave us char* for generic pointers
   and Solaris mmap seems stuck with that.

diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-09-21 13:53:24 -04:00
+++ b/lib.c	2004-09-21 13:53:24 -04:00
@@ -83,8 +83,8 @@
 };
 
 #define CHUNK 32768
-#define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-#define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
+#define blob_alloc(size) ((void *)mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0))
+#define blob_free(addr,size) munmap((void *)(addr), ((size)+4095) & ~4095)
 
 struct allocator_struct {
 	const char *name;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:58:32 +0000
Message-ID: <20040921175832.GA11366 () wohnheim ! fh-wedel ! de>
--------------------
On Tue, 21 September 2004 10:46:55 -0700, Linus Torvalds wrote:
> 
> I'd argue that "void *" casts are bugs. They shouldn't ever be needed.

You could.  In most such cases, the underlying fields should already
be void*.  Actually, the only remaining ones I could find in my
ethernet driver are this one:

        struct mii_ioctl_data   *mii = (void*)&rq->ifr_data;

And two casting from long to void*.

> Either somethign takes an untyped pointer (memset et al) or it doesn't. If 
> it takes a "void *", then a cast isn't necessary. If it doesn't, then 
> casting it is wrong anyway.

Or the interface is plain wrong.  That's not as usual, but still
happens.

> Sometimes there are _totally_ untyped variables, and they may be "unsigned 
> long" or "void *" or something, and then you do need a cast if you need to 
> cast between integers and pointers. I'd argue that that is a deficiency of 
> the C language too, and that it would be fine to have a totally opaque 
> sized type that silently allows automatic conversions of the right size 
> even across pointers/integers.

Jupp.  If C had such an opaque type, I would be down to one case.

Jrn

-- 
To announce that there must be no criticism of the President, or that we
are to stand by the President, right or wrong, is not only unpatriotic
and servile, but is morally treasonable to the American public.
-- Theodore Roosevelt, Kansas City Star, 1918
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 17:59:17 +0000
Message-ID: <20040921175917.769731422D58 () darter ! rentec ! com>
--------------------

> I still haven't heard anybody say what other compilers do. I don't even 
> have access to anything but sparse and gcc, so ..

Solaris native seems to barf, see below.

Morten



-----------------------------------------------------------------------------
int main(int argc, char **argv) {
  signed char *sc;
  unsigned char *uc = sc;
  char *c1 = sc;
  char *c2 = uc;
  signed int *si;
  unsigned int *ui = si;
  int *i1 = si;
  int *i2 = ui;
  return 0;
}
-----------------------------------------------------------------------------

troll:/scratch/welinder/janitorial> /opt/SUNWspro/bin/cc ~/foo.c
"/home/welinder/foo.c", line 3: warning: assignment type mismatch:
        pointer to unsigned char "=" pointer to signed char
"/home/welinder/foo.c", line 4: warning: assignment type mismatch:
        pointer to char "=" pointer to signed char
"/home/welinder/foo.c", line 5: warning: assignment type mismatch:
        pointer to char "=" pointer to unsigned char
"/home/welinder/foo.c", line 7: warning: assignment type mismatch:
        pointer to unsigned int "=" pointer to signed int
"/home/welinder/foo.c", line 9: warning: assignment type mismatch:
        pointer to int "=" pointer to unsigned int
troll:/scratch/welinder/janitorial> gcc-3.4 -O2 -Wall -c ~/foo.c
/home/welinder/foo.c: In function `main':
/home/welinder/foo.c:4: warning: unused variable `c1'
/home/welinder/foo.c:5: warning: unused variable `c2'
/home/welinder/foo.c:8: warning: unused variable `i1'
/home/welinder/foo.c:9: warning: unused variable `i2'
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:04:10 +0000
Message-ID: <Pine.LNX.4.58.0409211059550.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Morten Welinder wrote:
> 
> Ok, here are two bugs, then, :-)  caddr_t ends up being char pointers and
> gcc/sparse are not happy.

Btw, anybody who uses "caddr_t" in this age is a f*cking idiot, imnsho.  
Use "void *"  instead. Old-style K&R compilers just do not matter.

> It does, however, make sense to ensure that blob_alloc really does deliver
> a generic pointer.  Nevertheless, please let me know if you reject it
> and I'll just keep it in my tree.

Can't you do this as a bug against Solaris, the same way broken windows 
mmap's are fixed up?

And tell those Sun guys to exit the stone age. Do they still ship a kroken 
K&R compiler suite for bootstrapping because they are trying to screw over 
their cutomers?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:05:17 +0000
Message-ID: <Pine.LNX.4.58.0409211104300.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Linus Torvalds wrote:
> 
> Can't you do this as a bug against Solaris, the same way broken windows 
> mmap's are fixed up?

Alternatively, just do it as an inline function, and do something like

	void *addr = mmap(..)

which shows that even if Solaris is crazy, _we_ don't care about the type.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Richard Henderson <rth () twiddle ! net>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:08:48 +0000
Message-ID: <20040921180848.GB31771 () twiddle ! net>
--------------------
On Tue, Sep 21, 2004 at 09:49:43AM -0700, Linus Torvalds wrote:
> In fact, even the "explicit sign" differences are a bit questionable. The 
> xdr4 code does something like this:
> 
> 	s64	len, start, end;
> 	...
> 	p = xdr_decode_hyper(p, &start);
> 	p = xdr_decode_hyper(p, &len);
> 	..
> 
> and both of these generate warnings, because xdr_decode_hyper() looks like
> 
> 	static inline u32 *
> 	xdr_decode_hyper(u32 *p, __u64 *valp)
> 
> but the fact is, it obviously works fine to return both u64 and s64
> values, and forcing the caller to use one over the other is just not that
> sensible.

Maybe.  Or maybe it's a bug that the caller typo'd s64 instead of u64,
and (start < end) will mistakenly compare false when end gets large.

> ... and duplicating the function to do the same thing also seems 
> totally idiotic.

I don't agree.  If signed vs unsigned really isn't important, because
xdr_decode_hyper does no range checking, yadda yadda, then

	static inline u32 *
	xdr_decode_hyper_s(u32 *p, s64 *valp)
	{
	  return xdr_decode_hyper (p, (u64 *) valp));
	}

does not seem too much to ask.

> Richard, are you sure that the gcc team has thought this through wrt
> gcc-4.0, or is this just another total disaster like adding
> "-Wsign-compare" to the default flags in gcc-3.0?

I think we're on more solid ground here than -Wsign-compare, because
the types "int *" and "unsigned int *" are not compatible [c99 6.2.7].
IANAL, but we could be within our rights to reject the program entirely
[c99 6.5.16.1].

I am finding it somewhat annoying that there's no -W switch to turn it
off though, since there are three include/linux/ headers that now prevent
me from using -Werror under arch/alpha/.


r~
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Richard Henderson <rth () twiddle ! net>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:20:01 +0000
Message-ID: <20040921182001.GC31771 () twiddle ! net>
--------------------
On Tue, Sep 21, 2004 at 10:49:49AM -0700, Linus Torvalds wrote:
> Richard, you're ignoring the fundamental issue.
>
> It's _wrong_ for the compiler to complain about
> 
> 	unsigned char *p = "hello world".

Am I?

In compiling my bits I never saw that pop up, but saw lots of other
"char *" vs "unsigned char *" mismatches.  So I assumed you were
talking about basically any sort of character manipulation.  Which
more or less jived with other things you had to say downthread.

I could agree with character constants, since there's no way to declare
a string literal of type unsigned char.  Or explictly signed char for
that matter.


r~
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:20:53 +0000
Message-ID: <20040921182053.B81671422D58 () darter ! rentec ! com>
--------------------

I'm sure Sun has a million bugs filed for that already, all in
WONTFIX state.  The chances on getting it fixed in less than
five years (not counting deploying lags) are not big.  Don't
forget that you would have to deal with the equivalent of
the union of gcc and glibc developers there.

Anyway, here's a function version that would hide the problem
neatly under the carpet.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 lib.c |   16 ++++++++++++++--
 1 files changed, 14 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/21 1.802)
   Turn blob_alloc and blob_free into functions so value passing
   hides caddr_t stupidity.

diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-09-21 14:16:01 -04:00
+++ b/lib.c	2004-09-21 14:16:01 -04:00
@@ -83,8 +83,20 @@
 };
 
 #define CHUNK 32768
-#define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-#define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
+
+static inline void *
+blob_alloc (size_t size)
+{
+	size = (size + 4095) & ~4095;
+	return mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+}
+
+static inline void
+blob_free (void *addr, size_t size)
+{
+	size = (size + 4095) & ~4095;
+	munmap(addr, size);
+}
 
 struct allocator_struct {
 	const char *name;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:35:07 +0000
Message-ID: <Pine.LNX.4.58.0409211132290.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Morten Welinder wrote:
> 
> I'm sure Sun has a million bugs filed for that already, all in
> WONTFIX state.  The chances on getting it fixed in less than
> five years (not counting deploying lags) are not big.  Don't
> forget that you would have to deal with the equivalent of
> the union of gcc and glibc developers there.
> 
> Anyway, here's a function version that would hide the problem
> neatly under the carpet.

Can I change my mind? Please make it a non-inlined function, and move it 
to lib.c, and also check for errors, ie something like

	void *blob_alloc(size_t size)
	{
		void *ptr = mmap(..
		if ((int)(long)ptr == -1)
			ptr = NULL;
		return ptr;
	}

(we actually check for NULL in "allocate()", so the above makes sense, 
while the old code would just later SIGSEGV on a bad ptr access..)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:44:14 +0000
Message-ID: <20040921184414.935301422D58 () darter ! rentec ! com>
--------------------

There you go.  They already live in lib.c

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 lib.c |   18 ++++++++++++++++--
 1 files changed, 16 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/21 1.802)
   Make blob_alloc and blob_free functions in order to hide caddr_t
   issues and to get error checks.

diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-09-21 14:43:31 -04:00
+++ b/lib.c	2004-09-21 14:43:31 -04:00
@@ -83,8 +83,22 @@
 };
 
 #define CHUNK 32768
-#define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
-#define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
+
+static void *blob_alloc (size_t size)
+{
+	void *ptr;
+	size = (size + 4095) & ~4095;
+	ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	if (ptr == MAP_FAILED)
+		ptr = NULL;
+	return ptr;
+}
+
+static void blob_free (void *addr, size_t size)
+{
+	size = (size + 4095) & ~4095;
+	munmap(addr, size);
+}
 
 struct allocator_struct {
 	const char *name;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Checking signedness in sparse..
Date: Tue, 21 Sep 2004 18:57:06 +0000
Message-ID: <Pine.LNX.4.58.0409211151330.25656 () ppc970 ! osdl ! org>
--------------------


On Tue, 21 Sep 2004, Morten Welinder wrote:
> 
> There you go.  They already live in lib.c

Duh. Thanks.

Btw, I keep noticing the "4096", and I keep ignoring it. It's wrong, and 
it's kind of pointless anyway, since we always really use the CHUNK thing, 
which is a lot more correct anyway (yeah, you could have larger 
page-sizes, and no, I don't think I care at that point any more but at 
least we could then just increase the CHUNK to 64k or something).

So right now that 4096 is a no-op, but it's an _ugly_ (and incorrect)  
no-op, so I suspect we should just declare that blob_chunk() always has to
be called with CHUNK size (or maybe multiples of it)? That's why it's
called "blob", after all. We're not allocating individual bytes like we
were doing some general-purpose malloc().

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Compatibility code ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Compatibility code
Date: Thu, 30 Sep 2004 16:15:30 +0000
Message-ID: <20040930161530.13B351422D56 () darter ! rentec ! com>
--------------------

I'm not 100% happy with the way the compatibility code has ended up
so far -- it encourages code duplication.  To get a Solaris port
one would mostly copy compat-linux, for example.  I suggest...

1. Create a single file compat.c saying something like...

-----------------------------------------------------------------------------
#if defined(__linux__)
#include "compat-linux.c"
#elif defined(__sun__)
#include "compat-solaris.c"
...
#endif

#ifdef COMPAT_GENERIC_BLOB_ALLOC
void *blob_alloc(unsigned long size)
{
	// The Unix-standard way
	...
}
#endif
...
-----------------------------------------------------------------------------

2. Make compat-linux.c simple define COMPAT_GENERIC_BLOB_ALLOC and
   friends.

3. Make a compat-solaris.c that defined most of these COMPAT_FOOs
   but had its own string_to_ld.

4. Fix Makefile to reflect the above.

5. Fix compat.h to include <sys/stat.h> instead of trying to define
   it itself.  "stat" is reserved by the C library and can very well
   be #defined (for example to stat64).


Comments?

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Compatibility code
Date: Thu, 30 Sep 2004 17:40:37 +0000
Message-ID: <Pine.LNX.4.58.0409301037060.2403 () ppc970 ! osdl ! org>
--------------------


On Thu, 30 Sep 2004, Morten Welinder wrote:
> 
> I'm not 100% happy with the way the compatibility code has ended up
> so far -- it encourages code duplication.  To get a Solaris port
> one would mostly copy compat-linux, for example.  I suggest...
> 
> 1. Create a single file compat.c saying something like...

No, how about this approach instead:
 - create a "compat" subdirectory which has various helper routines.
 - make "compat-linux.c" just look like

	#include "compat/mmap-blob.c"
	#include "compat/strtold.c"
	#include "compat/posix-stat.c"

and that's basically it.

I _hate_ #ifdef's. They are evil. They make for unreadable code, and they 
are also a major impediment to good maintenance, because they force a 
certain structure on you.

In contrast, allowing free duplication is _good_. If some code doesn't fit 
some configuration, it shouldn't even be _visible_.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Constant from loop condition ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Constant from loop condition
Date: Tue, 16 Nov 2004 02:39:43 +0000
Message-ID: <200411160239.iAG2dhR09749 () troll ! rentec ! com>
--------------------

Hi all,

I want to recognize code that is morally equivalent to...

    while (l != NULL) {
        /* Something that doesn't "break".  */
    }
    f(l);

...so I can deduce that f(NULL) is being called and barf[*]  I just
found another two cases of this (with "for", not "while") so it
is something that really does happen.

To me this sounds like a job for the linerizer.  Can we do this
yet?

Morten


[*] For my use it is not relevant that f(l) might not be reached.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Constant from loop condition
Date: Tue, 16 Nov 2004 03:18:10 +0000
Message-ID: <Pine.LNX.4.58.0411151844180.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Morten Welinder wrote:
> 
> I want to recognize code that is morally equivalent to...
> 
>     while (l != NULL) {
>         /* Something that doesn't "break".  */
>     }
>     f(l);
> 
> ...so I can deduce that f(NULL) is being called and barf[*]  I just
> found another two cases of this (with "for", not "while") so it
> is something that really does happen.
> 
> To me this sounds like a job for the linerizer.  Can we do this
> yet?

It's not entirely trivial, but all the information is now there.

You have to tag "f" as wanting to be checked somehow, so that you can flag 
all calls to it. There's no good infrastructure for doing this, but at 
worst you can just walk every instruction and just look for a "OP_CALL" 
with pseudo being the "f" symbol-pseudo. 

Once you do that, you can then look at the argument pseudo for that 
OP_CALL, and look for dominating uses of that argument, and recognize that 
a pattern line

	br pseudo,true,false

means that pseudo is zero if we branch to false and nothing else gets us 
there.

So then, if the false branch is a proper dominating bb to the call, you
know that "l" was zero. Simple enough.

HOWEVER. At this point, while you _can_ do this, it's obviously not very 
practical. The information is there, but it's pretty expensive and complex 
to get at, and the fact is, value range-propagation is a generic 
optimization issue. The _proper_ way to do this may be to write a nice 
proper range-propagation pass, and pass down _all_ known values past 
conditionals. At that point, the call should have been rewritten as a 
plain "f($0)", and you would now have an absolutely _trivial_ time warning 
about it.

But value propagation isn't all that easy. It's really all the same things
I've done for symbols, except doing all that dominating graph stuff for
all pseudos. Some of it is a lot easier (no issues of overlap etc), but on
the other hand pseudos show up in many more contexts. So it's likely a lot
more expensive (usually _many_ more pseudos than symbols), and the payoff
is generally much smaller (a few clever optimizations vs major wins).

For example, in the symbol->pseudo transforms, I didn't bother _AT_ALL_ 
with the fact that my algorithm is something like O(nsym*usage*ninsn). 
It's an extremely stupid algorithm that doesn't pre-calculate _any_ 
dominance graphs or anything like that, but on the other hand it should be 
quite cache-friendly in most cases since it's just walking the same
graph over and over again. So with most functions having a reasonably 
limited number of symbols, I doubt the stupid algorithm is a problem. I 
suspect it _might_ be a serious problem if you do this for each pseudo.

To make value propagation more useful, you'd also have to not just look at
conditional branches against zero, but also follow the "def" of the
conditional pseudo, and see if it was a "setXX" instruction, in which case
you can propagate the successful value that it was testing for. 

There are likely good algorithms for doing this on SSA. Me, I'm just a
programmer. I don't read no steenking papers. Although that's mainly
because I don't know which steenking papers are worth reading. Pointers?

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Constant from loop condition
Date: Tue, 16 Nov 2004 04:25:52 +0000
Message-ID: <Pine.LNX.4.58.0411151954360.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Linus Torvalds wrote:
> 
> But value propagation isn't all that easy. It's really all the same things
> I've done for symbols, except doing all that dominating graph stuff for
> all pseudos. Some of it is a lot easier (no issues of overlap etc), but on
> the other hand pseudos show up in many more contexts. So it's likely a lot
> more expensive (usually _many_ more pseudos than symbols), and the payoff
> is generally much smaller (a few clever optimizations vs major wins).

Hmm.. Thinking about the problem, the limitations we have on pseudos would 
seem to make it a lot simpler than the symbol domination cases. In 
particular, the single-def property means that we really only need to 
track dominance on a basic-block level. So while there are lots more 
pseudos, the tracking ends up being much cheaper.

I'll think about doing something. Maybe.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Control Flow Analysis ===

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Control Flow Analysis
Date: Mon, 07 Jun 2004 00:15:18 +0000
Message-ID: <40C3B396.6020905 () numba-tu ! com>
--------------------
This is a multi-part message in MIME format.
--------------090706030809030309040202
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

When I searched for graph algorithm libraries, especially for control
flow graphs, I couldn't find much and everything I found carried a lot
of baggage.  So I decided to write my own with the goal of being
adaptable (under some assumptions though) to whatever representation
of CFGs was already chosen -- as opposed to imposing my own. That was
the birth of cfgkit.

I've adopted the bits of it that's finished to sparse and would like to 
solicitate comments.  It's a quick hack job, so please don't be alarmed.

As an appetizer, I've included the graphical representation of finding 
immediate predominators and loops (green nodes are loop headers of 
reducible loops).  I intend to continue working on control dependence, 
SSA conversion, etc.

Thanks,
Tommy


--------------090706030809030309040202
Content-Type: application/postscript;
 name="emit_atom_list.ps"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="emit_atom_list.ps"

%!PS-Adobe-2.0
%%Creator: dot version 1.9 (Tue Sep 23 20:36:36 UTC 2003)
%%For: (tommy) Tommy Thorn
%%Title: emit_atom_list
%%Pages: (atend)
%%BoundingBox: 35 35 449 737
%%EndComments
save
%%BeginProlog
/DotDict 200 dict def
DotDict begin

/setupLatin1 {
mark
/EncodingVector 256 array def
 EncodingVector 0

ISOLatin1Encoding 0 255 getinterval putinterval

EncodingVector
  dup 306 /AE
  dup 301 /Aacute
  dup 302 /Acircumflex
  dup 304 /Adieresis
  dup 300 /Agrave
  dup 305 /Aring
  dup 303 /Atilde
  dup 307 /Ccedilla
  dup 311 /Eacute
  dup 312 /Ecircumflex
  dup 313 /Edieresis
  dup 310 /Egrave
  dup 315 /Iacute
  dup 316 /Icircumflex
  dup 317 /Idieresis
  dup 314 /Igrave
  dup 334 /Udieresis
  dup 335 /Yacute
  dup 376 /thorn
  dup 337 /germandbls
  dup 341 /aacute
  dup 342 /acircumflex
  dup 344 /adieresis
  dup 346 /ae
  dup 340 /agrave
  dup 345 /aring
  dup 347 /ccedilla
  dup 351 /eacute
  dup 352 /ecircumflex
  dup 353 /edieresis
  dup 350 /egrave
  dup 355 /iacute
  dup 356 /icircumflex
  dup 357 /idieresis
  dup 354 /igrave
  dup 360 /dcroat
  dup 361 /ntilde
  dup 363 /oacute
  dup 364 /ocircumflex
  dup 366 /odieresis
  dup 362 /ograve
  dup 365 /otilde
  dup 370 /oslash
  dup 372 /uacute
  dup 373 /ucircumflex
  dup 374 /udieresis
  dup 371 /ugrave
  dup 375 /yacute
  dup 377 /ydieresis  

% Set up ISO Latin 1 character encoding
/starnetISO {
        dup dup findfont dup length dict begin
        { 1 index /FID ne { def }{ pop pop } ifelse
        } forall
        /Encoding EncodingVector def
        currentdict end definefont
} def
/Times-Roman starnetISO def
/Times-Italic starnetISO def
/Times-Bold starnetISO def
/Times-BoldItalic starnetISO def
/Helvetica starnetISO def
/Helvetica-Oblique starnetISO def
/Helvetica-Bold starnetISO def
/Helvetica-BoldOblique starnetISO def
/Courier starnetISO def
/Courier-Oblique starnetISO def
/Courier-Bold starnetISO def
/Courier-BoldOblique starnetISO def
cleartomark
} bind def

%%BeginResource: procset
/coord-font-family /Times-Roman def
/default-font-family /Times-Roman def
/coordfont coord-font-family findfont 8 scalefont def

/InvScaleFactor 1.0 def
/set_scale {
	dup 1 exch div /InvScaleFactor exch def
	dup scale
} bind def

% styles
/solid { [] 0 setdash } bind def
/dashed { [9 InvScaleFactor mul dup ] 0 setdash } bind def
/dotted { [1 InvScaleFactor mul 6 InvScaleFactor mul] 0 setdash } bind def
/invis {/fill {newpath} def /stroke {newpath} def /show {pop newpath} def} bind def
/bold { 2 setlinewidth } bind def
/filled { } bind def
/unfilled { } bind def
/rounded { } bind def
/diagonals { } bind def

% hooks for setting color 
/nodecolor { sethsbcolor } bind def
/edgecolor { sethsbcolor } bind def
/graphcolor { sethsbcolor } bind def
/nopcolor {pop pop pop} bind def

/beginpage {	% i j npages
	/npages exch def
	/j exch def
	/i exch def
	/str 10 string def
	npages 1 gt {
		gsave
			coordfont setfont
			0 0 moveto
			(\() show i str cvs show (,) show j str cvs show (\)) show
		grestore
	} if
} bind def

/set_font {
	findfont exch
	scalefont setfont
} def

% draw aligned label in bounding box aligned to current point
/alignedtext {			% width adj text
	/text exch def
	/adj exch def
	/width exch def
	gsave
		width 0 gt {
			text stringwidth pop adj mul 0 rmoveto
		} if
		[] 0 setdash
		text show
	grestore
} def

/boxprim {				% xcorner ycorner xsize ysize
		4 2 roll
		moveto
		2 copy
		exch 0 rlineto
		0 exch rlineto
		pop neg 0 rlineto
		closepath
} bind def

/ellipse_path {
	/ry exch def
	/rx exch def
	/y exch def
	/x exch def
	matrix currentmatrix
	newpath
	x y translate
	rx ry scale
	0 0 1 0 360 arc
	setmatrix
} bind def

/endpage { showpage } bind def

/layercolorseq
	[	% layer color sequence - darkest to lightest
		[0 0 0]
		[.2 .8 .8]
		[.4 .8 .8]
		[.6 .8 .8]
		[.8 .8 .8]
	]
def

/layerlen layercolorseq length def

/setlayer {/maxlayer exch def /curlayer exch def
	layercolorseq curlayer 1 sub layerlen mod get
	aload pop sethsbcolor
	/nodecolor {nopcolor} def
	/edgecolor {nopcolor} def
	/graphcolor {nopcolor} def
} bind def

/onlayer { curlayer ne {invis} if } def

/onlayers {
	/myupper exch def
	/mylower exch def
	curlayer mylower lt
	curlayer myupper gt
	or
	{invis} if
} def

/curlayer 0 def

%%EndResource
%%EndProlog
%%BeginSetup
14 default-font-family set_font
1 setmiterlimit
% /arrowlength 10 def
% /arrowwidth 5 def

% make sure pdfmark is harmless for PS-interpreters other than Distiller
/pdfmark where {pop} {userdict /pdfmark /cleartomark load put} ifelse
% make '<<' and '>>' safe on PS Level 1 devices
/languagelevel where {pop languagelevel}{1} ifelse
2 lt {
    userdict (<<) cvn ([) cvn load put
    userdict (>>) cvn ([) cvn load put
} if

%%EndSetup
%%Page: 1 1
%%PageBoundingBox: 36 36 449 737
%%PageOrientation: Portrait
gsave
35 35 414 702 boxprim clip newpath
36 36 translate
0 0 1 beginpage
0 0 translate 0 rotate
0.000 0.000 0.000 graphcolor
14.00 /Times-Roman set_font

%	0
gsave 10 dict begin
352 674 49 18 ellipse_path
stroke
gsave 10 dict begin
352 669 moveto 77 -0.5 (0 \(START\)) alignedtext
end grestore
end grestore

%	1
gsave 10 dict begin
filled
0.333 1.000 1.000 nodecolor
0.333 1.000 1.000 nodecolor
320 602 27 18 ellipse_path
fill
0.333 1.000 1.000 nodecolor
gsave 10 dict begin
0.000 0.000 0.000 nodecolor
320 597 moveto 4 -0.5 (1) alignedtext
end grestore
end grestore

%	0 -> 1
newpath 338 657 moveto
333 649 329 638 325 629 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 328 629 moveto
322 620 lineto
323 630 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	11
gsave 10 dict begin
385 26 27 18 ellipse_path
stroke
gsave 10 dict begin
385 21 moveto 9 -0.5 (11) alignedtext
end grestore
end grestore

%	0 -> 11
newpath 353 656 moveto
360 629 376 576 376 530 curveto
376 530 376 530 376 170 curveto
376 130 376 82 378 53 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 380 54 moveto
379 44 lineto
375 54 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	1 -> 0
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 347 647 moveto
343 638 338 626 333 618 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 344 647 moveto
350 656 lineto
349 646 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	2
gsave 10 dict begin
filled
0.333 1.000 1.000 nodecolor
0.333 1.000 1.000 nodecolor
217 530 27 18 ellipse_path
fill
0.333 1.000 1.000 nodecolor
gsave 10 dict begin
0.000 0.000 0.000 nodecolor
217 525 moveto 8 -0.5 (2) alignedtext
end grestore
end grestore

%	1 -> 2
newpath 299 591 moveto
281 580 257 564 239 550 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 242 549 moveto
232 545 lineto
239 553 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	10
gsave 10 dict begin
320 98 27 18 ellipse_path
stroke
gsave 10 dict begin
320 93 moveto 12 -0.5 (10) alignedtext
end grestore
end grestore

%	1 -> 10
newpath 309 586 moveto
302 559 302 504 302 458 curveto
302 458 302 458 302 242 curveto
302 201 302 152 307 123 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 309 124 moveto
309 114 lineto
304 123 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	11 -> 0
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 368 647 moveto
380 618 394 571 394 530 curveto
394 530 394 530 394 170 curveto
394 125 394 71 391 44 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 366 646 moveto
364 656 lineto
370 648 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	2 -> 1
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 297 582 moveto
280 568 256 552 238 541 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 294 583 moveto
304 587 lineto
297 579 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	3
gsave 10 dict begin
153 458 27 18 ellipse_path
stroke
gsave 10 dict begin
153 453 moveto 7 -0.5 (3) alignedtext
end grestore
end grestore

%	2 -> 3
newpath 199 516 moveto
189 506 177 494 168 482 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 171 482 moveto
163 475 lineto
167 485 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	5
gsave 10 dict begin
153 314 27 18 ellipse_path
stroke
gsave 10 dict begin
153 309 moveto 7 -0.5 (5) alignedtext
end grestore
end grestore

%	2 -> 5
newpath 211 512 moveto
206 482 200 417 180 368 curveto
176 358 170 348 165 340 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 167 339 moveto
160 332 lineto
163 342 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	10 -> 1
newpath 320 575 moveto
320 545 320 499 320 458 curveto
320 458 320 458 320 242 curveto
320 197 320 144 320 116 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 318 574 moveto
320 584 lineto
323 574 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	10 -> 1
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 333 577 moveto
338 548 338 499 338 458 curveto
338 458 338 458 338 242 curveto
338 196 338 141 331 114 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 331 576 moveto
331 586 lineto
336 577 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	10 -> 11
newpath 334 82 moveto
343 72 355 59 365 48 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 366 50 moveto
371 41 lineto
363 47 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	3 -> 2
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 202 506 moveto
193 495 181 482 171 472 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 200 507 moveto
208 513 lineto
203 504 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	3 -> 5
newpath 135 444 moveto
125 433 122 423 117 404 curveto
113 388 113 383 117 368 curveto
121 357 127 346 133 337 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 134 339 moveto
139 330 lineto
131 336 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	4
gsave 10 dict begin
153 386 27 18 ellipse_path
stroke
gsave 10 dict begin
153 381 moveto 8 -0.5 (4) alignedtext
end grestore
end grestore

%	3 -> 4
newpath 147 440 moveto
146 432 146 423 146 414 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 148 414 moveto
147 404 lineto
144 414 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	5 -> 2
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 222 502 moveto
223 469 216 412 198 368 curveto
192 353 181 338 171 327 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 220 502 moveto
222 512 lineto
225 502 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	8
gsave 10 dict begin
27 242 27 18 ellipse_path
stroke
gsave 10 dict begin
27 237 moveto 7 -0.5 (8) alignedtext
end grestore
end grestore

%	5 -> 8
newpath 130 304 moveto
108 292 76 274 53 261 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 55 259 moveto
45 256 lineto
52 263 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	7
gsave 10 dict begin
99 242 27 18 ellipse_path
stroke
gsave 10 dict begin
99 237 moveto 7 -0.5 (7) alignedtext
end grestore
end grestore

%	5 -> 7
newpath 137 299 moveto
129 290 119 278 111 267 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 113 266 moveto
106 259 lineto
109 269 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	6
gsave 10 dict begin
171 242 27 18 ellipse_path
stroke
gsave 10 dict begin
171 237 moveto 7 -0.5 (6) alignedtext
end grestore
end grestore

%	5 -> 6
newpath 152 296 moveto
153 288 155 278 158 268 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 160 269 moveto
161 259 lineto
155 268 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	4 -> 3
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 160 430 moveto
160 421 160 412 159 404 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 158 430 moveto
159 440 lineto
162 430 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	4 -> 5
newpath 153 368 moveto
153 360 153 351 153 342 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 156 342 moveto
153 332 lineto
151 342 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	8 -> 5
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 127 295 moveto
104 282 72 264 50 252 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 125 297 moveto
135 300 lineto
128 293 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	9
gsave 10 dict begin
199 170 27 18 ellipse_path
stroke
gsave 10 dict begin
199 165 moveto 7 -0.5 (9) alignedtext
end grestore
end grestore

%	8 -> 9
newpath 48 231 moveto
53 229 58 226 63 224 curveto
98 208 139 192 166 182 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 166 185 moveto
175 179 lineto
165 180 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	7 -> 5
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 141 290 moveto
134 278 124 266 116 257 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 138 290 moveto
146 297 lineto
142 287 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	7 -> 9
newpath 118 228 moveto
134 218 156 201 174 188 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 174 191 moveto
181 183 lineto
171 187 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	6 -> 5
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 166 289 moveto
169 279 171 268 172 260 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 164 287 moveto
163 297 lineto
169 289 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore

%	6 -> 9
newpath 178 225 moveto
181 216 185 206 189 196 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 191 197 moveto
192 187 lineto
186 196 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	9 -> 2
newpath 231 504 moveto
245 476 264 429 264 386 curveto
264 386 264 386 264 314 curveto
264 251 256 223 217 183 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 229 503 moveto
227 513 lineto
233 505 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	9 -> 10
newpath 219 158 moveto
240 145 270 127 292 114 curveto
stroke
gsave 10 dict begin
solid
0.000 0.000 0.000 edgecolor
newpath 292 117 moveto
300 110 lineto
290 112 lineto
closepath
fill
0.000 0.000 0.000 edgecolor
end grestore

%	9 -> 5
gsave 10 dict begin
0.000 1.000 1.000 edgecolor
newpath 179 295 moveto
190 286 201 274 207 260 curveto
216 236 211 206 205 188 curveto
stroke
gsave 10 dict begin
solid
0.000 1.000 1.000 edgecolor
newpath 178 293 moveto
172 301 lineto
181 296 lineto
closepath
fill
0.000 1.000 1.000 edgecolor
end grestore
end grestore
endpage
grestore
%%PageTrailer
%%EndPage: 1

--------------090706030809030309040202
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 8bit
Content-Disposition: inline;
 filename="patch"

diff -u --rec --new-file sparse/Makefile ../../sparse/sparse/Makefile
--- sparse/Makefile	2004-06-06 16:58:51 -07:00
+++ ../../sparse/sparse/Makefile	2004-06-06 16:11:31 -07:00
@@ -6,10 +6,12 @@
 PREFIX=$(HOME)
 PROGRAMS=test-lexing test-parsing obfuscate check compile test-linearize
 
-LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h linearize.h
+LIB_H=    token.h parse.h lib.h symbol.h scope.h expression.h target.h \
+	  linearize.h control-flow.h
 
 LIB_OBJS= target.o parse.o tokenize.o pre-process.o symbol.o lib.o scope.o \
-	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o
+	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \
+	  control-flow.o
 
 LIB_FILE= sparse.a
 LIBS=$(LIB_FILE)
diff -u --rec --new-file sparse/cfgkit/dfn.h ../../sparse/sparse/cfgkit/dfn.h
--- sparse/cfgkit/dfn.h	1969-12-31 16:00:00 -08:00
+++ ../../sparse/sparse/cfgkit/dfn.h	2004-06-06 16:57:22 -07:00
@@ -0,0 +1,137 @@
+/*
+ * Depth-first numbering template.
+ *
+ *   Copyright  2004 Tommy Thorn
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
+ *   Bostom MA 02111-1307, USA; either version 2 of the License, or
+ *   (at your option) any later version; incorporated herein by reference.
+ *
+ * Simply recursive traversals for numbering nodes in pre-order,
+ * reverse post-order, and depth-first order.  We traverse the graph
+ * twice.  Once to initialize the pre-order number to an "unvisited"
+ * marker (~1).  Second, to calculate the various orders.  After this
+ * traversal, the preorder number of all nodes reachable from the root
+ * is guarenteed to not be "unvisited".
+ *
+ * Requires: PREN(G,v) must initially be anything but ~1.
+ *
+ */
+
+static int next_preorder_n;       // Next pre-order number
+static int next_rpostorder_n;     // Next reverse post-order number
+
+#define UNVISITED (~1)
+
+/*
+ * Counts the number of nodes and initializes the prenumber to ~1
+ * (that is our "unvisited" marker in the depth-first search below).
+ */
+
+static int df_count_nodes(GRAPH_T G, NODE_T v)
+{
+	int sum = 0;
+
+	if (PREN(G,v) != UNVISITED) {
+		NODE_T m;
+		PREN(G,v) = UNVISITED;
+		sum = 1;
+		FOR_EACH_SUCCESSOR(G,v,m)
+			sum += df_count_nodes(G,m);
+		END_FOR_EACH_SUCCESSOR;
+	}
+
+	return sum;
+}
+
+static int df_count_nodes_rev(GRAPH_T G, NODE_T v)
+{
+	int sum = 0;
+
+	if (PREN(G,v) != UNVISITED) {
+		NODE_T m;
+		PREN(G,v) = UNVISITED;
+		sum = 1;
+		FOR_EACH_PREDECESSOR(G,v,m)
+			sum += df_count_nodes_rev(G,m);
+		END_FOR_EACH_PREDECESSOR;
+	}
+
+	return sum;
+}
+
+void dfs_(GRAPH_T G, NODE_T v)
+{
+	NODE_T m;
+
+        PREN(G,v) = next_preorder_n++;
+#ifdef ND
+	ND(G,v) = 1;
+#endif
+#ifdef PREORDER
+	PREORDER(G,PREN(G,v)) = v;
+#endif
+
+	FOR_EACH_SUCCESSOR(G,v,m)
+                if (PREN(G,m) == UNVISITED) {
+                        dfs_(G,m);
+#ifdef ND
+			ND(G,v) += ND(G,m);
+#endif
+                }
+	END_FOR_EACH_SUCCESSOR;
+
+	DFN(G,v) = next_rpostorder_n--;
+#ifdef DFORDER
+	DFORDER(G,DFN(G,v)) = v;
+#endif
+}
+
+void dfs_rev(GRAPH_T G, NODE_T v)
+{
+	NODE_T m;
+
+        PREN(G,v) = next_preorder_n++;
+#ifdef ND
+	ND(G,v) = 1;
+#endif
+#ifdef PREORDER
+	PREORDER(G,PREN(G,v)) = v;
+#endif
+
+	FOR_EACH_PREDECESSOR(G,v,m) {
+                if (PREN(G,m) == UNVISITED) {
+                        dfs_rev(G,m);
+#ifdef ND
+			ND(G,v) += ND(G,m);
+#endif
+                }
+	} END_FOR_EACH_PREDECESSOR;
+
+	DFN(G,v) = next_rpostorder_n--;
+#ifdef DFORDER
+	DFORDER(G,DFN(G,v)) = v;
+#endif
+}
+
+void dfn(GRAPH_T G)
+{
+	NODE_COUNT(G) = df_count_nodes(G,ROOT(G));
+
+	next_preorder_n = 0;
+	next_rpostorder_n = NODE_COUNT(G) - 1;
+	dfs_(G,ROOT(G));
+}
+
+void dfn_rev(GRAPH_T G)
+{
+	NODE_COUNT(G) = df_count_nodes_rev(G,END(G));
+
+	next_preorder_n = 0;
+	next_rpostorder_n = NODE_COUNT(G) - 1;
+	dfs_rev(G,END(G));
+}
+
+#undef UNVISITED
diff -u --rec --new-file sparse/cfgkit/havlak97-intervals.h ../../sparse/sparse/cfgkit/havlak97-intervals.h
--- sparse/cfgkit/havlak97-intervals.h	1969-12-31 16:00:00 -08:00
+++ ../../sparse/sparse/cfgkit/havlak97-intervals.h	2004-06-06 16:48:14 -07:00
@@ -0,0 +1,320 @@
+/*
+ * Finding loops.
+ *
+ * Copyright (c) 2004 Tommy Thorn
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
+ *   Bostom MA 02111-1307, USA; either version 2 of the License, or
+ *   (at your option) any later version; incorporated herein by reference.
+ *
+ * This is an implementation of Halvak's algorithm for finding loops,
+ * as described in
+ *
+ *  @article{262005,
+ *   author = {Paul Havlak},
+ *   title = {Nesting of reducible and irreducible loops},
+ *   journal = {ACM Trans. Program. Lang. Syst.},
+ *   volume = {19},
+ *   number = {4},
+ *   year = {1997},
+ *   issn = {0164-0925},
+ *   pages = {557--567},
+ *   doi = {http://doi.acm.org/10.1145/262004.262005},
+ *   publisher = {ACM Press},
+ *   }
+ *
+ * Required macros:
+ * - PREORDERN, node to pre-order number mapping.
+ *   (Must be initialized to a non ~1 value).
+ *
+ * Optionally defined
+ * - ND, node to number of descendents mapping.
+ * - DEPTH_FIRST_ORDER, a depth-first number to node mapping.
+ *
+ */
+
+#include <assert.h>
+
+#define DEBUG_HAVLAK(fmt ...) /* printf(fmt) */
+
+static inline int isdescendant(GRAPH_T G, NODE_T x, NODE_T y)
+{
+        /*
+	 * This is a basic property.  If this breaks, something bad
+	 * happened.
+	 */
+        assert((PREN(G,x) < PREN(G,y) && DFN(G,x) < DFN(G,y))
+	       ==
+               (PREN(G,x) < PREN(G,y)
+		&&
+		PREN(G,x) + ND(G,x) > PREN(G,y)));
+
+        return PREN(G,x) < PREN(G,y) && DFN(G,x) < DFN(G,y);
+}
+
+static inline int isbackedge(GRAPH_T G, NODE_T x, NODE_T y)
+{
+        return PREN(G,x) >= PREN(G,y) && DFN(G,x) >= DFN(G,y);
+}
+
+
+/*
+ * Classic FIND-UNION structure using inverse trees pointing to a
+ * canonical representative.
+ */
+
+static NODE_T find(GRAPH_T G, NODE_T u)
+{
+        NODE_T w;
+
+	DEBUG_HAVLAK(" [find(%d)->", DFN(G,u));
+
+	w = REPRESENTATIVE(G,u);
+
+	/*
+	 * This assert might fail if dead nodes (unreachable from
+	 * root) are present!  So make sure to not have any before
+	 * calling interval_analyse.
+	 */
+	assert(w != NO_NODE);
+
+        if (w != REPRESENTATIVE(G,w)) {
+                do {
+                        w = REPRESENTATIVE(G,w);
+                } while (REPRESENTATIVE(G,w) != w);
+                do {
+                        REPRESENTATIVE(G,u) = w;
+                        u = REPRESENTATIVE(G,u);
+                } while (REPRESENTATIVE(G,u) != w);
+        }
+
+	DEBUG_HAVLAK("%d]", DFN(G,w));
+        return w;
+}
+
+/*
+ * Special case version of the general UNION where we know that `v' is
+ * the representative of it's own set.
+ */
+
+static inline void merge(GRAPH_T G, NODE_T u, NODE_T v)
+{
+        NODE_T w;
+
+	assert(v != NO_NODE);
+        assert(REPRESENTATIVE(G,u) != NO_NODE);
+        assert(REPRESENTATIVE(G,v) == v);
+
+	/* Let v be the representative of the new equivalent class. */
+        REPRESENTATIVE(G,find(G,u)) = v;
+
+	/* Maintain a ring of all the elements in this class. */
+        w = ELEMENTS(G,v);
+        ELEMENTS(G,v) = ELEMENTS(G,u);
+        ELEMENTS(G,u) = w;
+}
+
+
+/*
+ * We use the constant EMPTY to terminate lists, such that the last
+ * element on a list still has a non-NO_NODE list field and we can
+ * thus tell that it's on a list.  The alternative is to use rings,
+ * but that requires more housekeeping.
+ */
+
+#define EMPTY NO_NODE_2
+
+static void collapse(GRAPH_T G,
+		     NODE_T loop_body,
+		     NODE_T loop_header,
+		     int irreducible)
+{
+	assert(loop_header != NO_NODE);
+	assert(loop_body != NO_NODE);
+
+        IRREDUCIBLE(G,loop_header) = irreducible;
+
+	do {
+                NODE_T z = loop_body;
+                loop_body = LOOP_BODY(G,loop_body);
+
+		assert(z != NO_NODE);
+                assert(REPRESENTATIVE(G,z) != NO_NODE);
+                LOOP_BODY(G,z) = NO_NODE;
+                LOOP_PARENT(G,z) = loop_header;
+
+                merge(G,z,loop_header);
+        } while (loop_body != EMPTY);
+}
+
+static void findloop(GRAPH_T G, NODE_T pHeader)
+{
+        NODE_T loop_body = EMPTY;
+        NODE_T worklist = EMPTY;
+        NODE_T y, z, r;
+        int irreducible = 0;
+
+	assert(REPRESENTATIVE(G,pHeader) != NO_NODE);
+
+	DEBUG_HAVLAK("\nfindloop(%d)", DFN(G,pHeader));
+
+        FOR_EACH_PREDECESSOR(G,pHeader,y) {
+		DEBUG_HAVLAK(" pred %d", DFN(G,y));
+                if (isbackedge(G,y,pHeader)) {
+                        r = find(G,y);
+
+			/*
+			 * If r is a new potential header add it to
+			 * the worklist (if not already on).
+			 */
+                        if (r != pHeader && WORKLIST(G,r) == NO_NODE) {
+                                DEBUG_HAVLAK("\n  adding %2d to worklist",
+					     DFN(G,r));
+                                assert(WORKLIST(G,r) == NO_NODE);
+                                WORKLIST(G,r) = worklist;
+				worklist = r;
+                        }
+                }
+	} END_FOR_EACH_PREDECESSOR;
+
+	DEBUG_HAVLAK("\n  MAINLOOP");
+
+        while (worklist != EMPTY) {
+		NODE_T y1;
+
+		/* Pop one element of the worklist... */
+                y = worklist;
+		worklist = WORKLIST(G,y);
+		WORKLIST(G,y) = NO_NODE;
+
+		/* ... and add it to the loop body. */
+                LOOP_BODY(G,y) = loop_body;
+		loop_body = y;
+
+                DEBUG_HAVLAK("\n  added %d to loop_body", DFN(G,y));
+
+		/*
+		 * Traverse each incoming edges to y.  However, if y
+		 * is the header of an irreducible loop, we have to
+		 * visit all incoming edges of all the nodes in the
+		 * loop body.
+		 */
+		y1 = y;
+		for (;;) {
+			assert(y1 != NO_NODE);
+
+                        FOR_EACH_PREDECESSOR(G,y1,z) {
+                                if (isbackedge(G,z,y1))
+                                        continue;
+
+                                if (pHeader == z || isdescendant(G,pHeader,z)){
+                                        r = find(G,z);
+
+#ifdef EXTRA_CHECKING
+	assert((PREN(G,pHeader) >= PREN(G,r) ||
+		PREN(G,pHeader) + ND(G,pHeader) <= PREN(G,r))
+	       ==
+	       (!isdescendant(G,pHeader, r)));
+
+	assert(isdescendant(G,pHeader, r) == isdescendant(G,pHeader, z));
+#endif
+                                        if (r != pHeader &&
+					    LOOP_BODY(G,r) == NO_NODE &&
+					    WORKLIST(G,r) == NO_NODE) {
+                                                WORKLIST(G,r) = worklist;
+						worklist = r;
+                                                DEBUG_HAVLAK("\n  added %d to "
+							     "worklist",
+							     DFN(G,r));
+                                        }
+                                } else {
+#ifdef EXTRA_CHECKING
+        r = find(G,z);
+
+	assert((PREN(G,pHeader) >= PREN(G,r) ||
+		PREN(G,pHeader) + ND(G,pHeader) <= PREN(G,r))
+	       ==
+	       (!isdescendant(G, pHeader, r)));
+
+	assert(isdescendant(G,pHeader, r) == isdescendant(G,pHeader, z));
+#endif
+
+                                        if (z != pHeader) {
+                                                irreducible = 1;
+                                        }
+
+                                        DEBUG_HAVLAK("\n  %d is ignored",
+						     DFN(G,z));
+                                }
+                        } END_FOR_EACH_PREDECESSOR;
+
+			/*
+			 * If y wasn't an irreducible loop header,
+			 * we're done.
+			 */
+                        if (!IRREDUCIBLE(G,y))
+                                break;
+
+			/*
+			 * ... otherwise we'll have to visit all it's
+			 * members.
+			 */
+			y1 = ELEMENTS(G,y1);
+			if (y1 == y)
+				break;
+                }
+        }
+
+        if (loop_body != EMPTY)
+                collapse(G, loop_body, pHeader, irreducible);
+}
+
+void interval_analyse(GRAPH_T G)
+{
+        int i;
+
+        dfn(G);
+
+	for (i = 0; i < NODE_COUNT(G); ++i) {
+		NODE_T n = PREORDER(G,i);
+		assert(n != NO_NODE && PREN(G,n) == i);
+
+		LOOP_PARENT(G,n) =
+		WORKLIST(G,n)    =
+		LOOP_BODY(G,n)   = NO_NODE;
+
+		ELEMENTS(G,n)    = n;
+
+		REPRESENTATIVE(G,n) = n;
+	}
+
+        for (i = NODE_COUNT(G) - 1; 0 <= i; --i)
+                findloop(G,PREORDER(G,i));
+
+	/*
+	 * LOOP_PARENT and IRREDUCIBLE only are interesting at this
+	 * point, so lets overload LOOP_BODY to be the first child of
+	 * a loop and ELEMENTS to be the list of it's elements.
+	 */
+	for (i = 0; i < NODE_COUNT(G); ++i) {
+		NODE_T v = PREORDER(G,i);
+		LOOP_BODY(G,v) = ELEMENTS(G,v) = NO_NODE;
+	}
+
+	for (i = 0; i < NODE_COUNT(G); ++i) {
+		NODE_T v = PREORDER(G,i);
+
+		if (LOOP_PARENT(G,v) != NO_NODE) {
+			NODE_T loop_parent = LOOP_PARENT(G,v);
+
+			assert(ELEMENTS(G,v) == NO_NODE);
+
+			ELEMENTS(G,v) = LOOP_BODY(G,loop_parent);
+			LOOP_BODY(G,loop_parent) = v;
+		}
+	}
+}
+
+#undef EMPTY
diff -u --rec --new-file sparse/cfgkit/tarjan79-dominators.h ../../sparse/sparse/cfgkit/tarjan79-dominators.h
--- sparse/cfgkit/tarjan79-dominators.h	1969-12-31 16:00:00 -08:00
+++ ../../sparse/sparse/cfgkit/tarjan79-dominators.h	2004-06-06 16:48:06 -07:00
@@ -0,0 +1,245 @@
+/*
+ * Find dominators.
+ *
+ *   Copyright  2004 Tommy Thorn
+ *
+ *   This program is free software; you can redistribute it and/or modify
+ *   it under the terms of the GNU General Public License as published by
+ *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
+ *   Bostom MA 02111-1307, USA; either version 2 of the License, or
+ *   (at your option) any later version; incorporated herein by reference.
+ *
+ * This is an implementation of Thomas Lengauer and Robert Endre
+ * Tarjan's algorithm for finding dominators, as described in
+ *
+ *  @article{357071,
+ *   author = {Thomas Lengauer and Robert Endre Tarjan},
+ *   title = {A fast algorithm for finding dominators in a flowgraph},
+ *   journal = {ACM Trans. Program. Lang. Syst.},
+ *   volume = {1},
+ *   number = {1},
+ *   year = {1979},
+ *   issn = {0164-0925},
+ *   pages = {121--141},
+ *   doi = {http://doi.acm.org/10.1145/357062.357071},
+ *   publisher = {ACM Press},
+ *   }
+ *
+ * This only implements the O(n log n) algorithm, though it's an easy
+ * extention to arrive at the near-linear algorithm.
+ *
+ * Required macros:
+ * - NODE_T, FOR_EACH_SUCCESSOR, MAKE_PRED
+ *
+ * - Computed:
+ *     PARENT :: NODE_T  -> NODE_T
+ *     PRED   :: NODE_T  -> Set NODE_T
+ *     SEMI   :: NODE_T  -> Integer   (Initially -1)
+ *     VERTEX :: Integer -> NODE_T
+ *     BUCKET :: NODE_T  -> Set NODE_T
+ *     DOM    :: NODE_T  -> NODE_T
+ *
+ * - Intermediate (for the path compression)
+ *     The ancestor in the forest
+ *     ANCESTOR :: NODE_T -> NODE_T  (Initially NO_NODE)
+ *     LABEL    :: NODE_T -> NODE_T  (Initially the identity mapping)
+ *
+ * Optionally defined
+ * - MODULE, a module name prefix for the externally defined symbols.
+ * XXX
+ *
+ * We keep the naming of the original naming, but we label everything
+ * starting with 0 and not 1 like in the original article.  Thus, -1
+ * and not 0 denotes the "no information" value.
+ *
+ * Requires:
+ */
+
+#define DEBUG_TARJAN(fmt ...) //printf(fmt)
+
+static int dom_n;
+
+/*
+ * General LINK and EVAL that works for both pre- and post-dominator.
+ */
+
+static void compress(GRAPH_T G, NODE_T v)
+{
+	if (ANCESTOR(G,ANCESTOR(G,v)) != NO_NODE) {
+		compress(G,ANCESTOR(G,v));
+		if (SEMI(G,LABEL(G,ANCESTOR(G,v))) < SEMI(G,LABEL(G,v)))
+			LABEL(G,v) = LABEL(G,ANCESTOR(G,v));
+		ANCESTOR(G,v) = ANCESTOR(G,ANCESTOR(G,v));
+	}
+}
+
+static NODE_T eval(GRAPH_T G, NODE_T v)
+{
+	DEBUG_TARJAN("eval %d\n", DFN(G,v));
+
+	if (ANCESTOR(G,v) == NO_NODE) {
+		DEBUG_TARJAN("  -> %d\n", DFN(G,v));
+		return v;
+	} else {
+		compress(G,v);
+		DEBUG_TARJAN("  -> %d\n", DFN(G,LABEL(G,v)));
+		return LABEL(G,v);
+	}
+}
+
+static void link(GRAPH_T G, NODE_T v, NODE_T w)
+{
+	ANCESTOR(G, w) = v;
+}
+
+/*
+ * The pre- and  post-dominator alg.
+ */
+
+static void predom_dfs(GRAPH_T G, NODE_T v)
+{
+	NODE_T w;
+
+	DEBUG_TARJAN("predom_dfs %p (semi %x)\n", v, SEMI(G,v));
+
+	SEMI(G,v) = ++dom_n;
+	VERTEX(G,dom_n) = v;
+
+	FOR_EACH_SUCCESSOR(G,v,w) {
+		if (SEMI(G,w) == ~1) {
+			PARENT(G,w) = v;
+			predom_dfs(G,w);
+		}
+	} END_FOR_EACH_SUCCESSOR;
+}
+
+void predominators(GRAPH_T G)
+{
+	int i;
+
+	dfn(G);
+
+	// Step 1
+	DEBUG_TARJAN("step1 (%d)\n", NODE_COUNT(G));
+	for (i = 0; i < NODE_COUNT(G); ++i) {
+		NODE_T v = PREORDER(G,i);
+		DEBUG_TARJAN("init %p\n", v);
+		SEMI(G,v) = ~1;
+		EMPTY_BUCKET(G,v);
+		ANCESTOR(G,v) = NO_NODE;
+		LABEL(G,v) = v;
+	}
+
+	DEBUG_TARJAN("step1 (%d nodes)\n", NODE_COUNT(G));
+
+	dom_n = -1;
+	DEBUG_TARJAN("predom_dfs\n");
+	predom_dfs(G,ROOT(G));
+	NODE_COUNT(G) = dom_n + 1;
+
+	for (i = NODE_COUNT(G) - 1; 1 <= i; --i) {
+		NODE_T v, pw, w = VERTEX(G,i);
+
+		DEBUG_TARJAN("step 2: %d\n", i);
+		// Step 2
+		FOR_EACH_PREDECESSOR(G,w,v) {
+			NODE_T u;
+			DEBUG_TARJAN("(%d,%d) in G\n", DFN(G,v), DFN(G,w));
+			u = eval(G,v);
+			if (SEMI(G,u) < SEMI(G,w))
+				SEMI(G,w) = SEMI(G,u);
+		} END_FOR_EACH_PREDECESSOR;
+
+		ADD_TO_BUCKET(G, VERTEX(G,SEMI(G,w)), w);
+		link(G, PARENT(G,w), w);
+
+		// Step 3
+		pw = PARENT(G,w);
+		FOR_EACH_BUCKET_ELEM(G,pw,v) {
+			NODE_T u = eval(G,v);
+			IPREDOM(G,v) = SEMI(G,u) < SEMI(G,v) ? u : pw;
+		} END_FOR_EACH_BUCKET_ELEM;
+		EMPTY_BUCKET(G,pw);
+	}
+	// Step 4
+	for (i = 1; i < NODE_COUNT(G); ++i) {
+		NODE_T w = VERTEX(G,i);
+		if (IPREDOM(G,w) != VERTEX(G,SEMI(G,w)))
+			IPREDOM(G,w) = IPREDOM(G,IPREDOM(G,w));
+	}
+	IPREDOM(G,ROOT(G)) = NO_NODE;
+}
+
+static void postdom_dfs(GRAPH_T G, NODE_T v)
+{
+	NODE_T w;
+
+	DEBUG_TARJAN("postdom_dfs %p (semi %x)\n", v, SEMI(G,v));
+
+	SEMI(G,v) = ++dom_n;
+	VERTEX(G,dom_n) = v;
+
+	FOR_EACH_PREDECESSOR(G,v,w) {
+		if (SEMI(G,w) == ~1) {
+			PARENT(G,w) = v;
+			postdom_dfs(G,w);
+		}
+	} END_FOR_EACH_PREDECESSOR;
+}
+
+void postdominators(GRAPH_T G)
+{
+	int i;
+
+	dfn_rev(G);
+
+	// Step 1
+	DEBUG_TARJAN("step1 (%d)\n", NODE_COUNT(G));
+	for (i = 0; i < NODE_COUNT(G); ++i) {
+		NODE_T v = PREORDER(G,i);
+		DEBUG_TARJAN("init %p\n", v);
+		SEMI(G,v) = ~1;
+		EMPTY_BUCKET(G,v);
+		ANCESTOR(G,v) = NO_NODE;
+		LABEL(G,v) = v;
+	}
+
+	DEBUG_TARJAN("step1 (%d nodes)\n", NODE_COUNT(G));
+
+	dom_n = -1;
+	DEBUG_TARJAN("postdom_dfs\n");
+	postdom_dfs(G,END(G));
+	NODE_COUNT(G) = dom_n + 1;
+
+	for (i = NODE_COUNT(G) - 1; 1 <= i; --i) {
+		NODE_T v, pw, w = VERTEX(G,i);
+
+		DEBUG_TARJAN("step 2: %d\n", i);
+		// Step 2
+		FOR_EACH_SUCCESSOR(G,w,v) {
+			NODE_T u;
+			DEBUG_TARJAN("(%d,%d) in G\n", DFN(G,v), DFN(G,w));
+			u = eval(G,v);
+			if (SEMI(G,u) < SEMI(G,w))
+				SEMI(G,w) = SEMI(G,u);
+		} END_FOR_EACH_SUCCESSOR;
+
+		ADD_TO_BUCKET(G, VERTEX(G,SEMI(G,w)), w);
+		link(G, PARENT(G,w), w);
+
+		// Step 3
+		pw = PARENT(G,w);
+		FOR_EACH_BUCKET_ELEM(G,pw,v) {
+			NODE_T u = eval(G,v);
+			IPOSTDOM(G,v) = SEMI(G,u) < SEMI(G,v) ? u : pw;
+		} END_FOR_EACH_BUCKET_ELEM;
+		EMPTY_BUCKET(G,pw);
+	}
+	// Step 4
+	for (i = 1; i < NODE_COUNT(G); ++i) {
+		NODE_T w = VERTEX(G,i);
+		if (IPOSTDOM(G,w) != VERTEX(G,SEMI(G,w)))
+			IPOSTDOM(G,w) = IPOSTDOM(G,IPOSTDOM(G,w));
+	}
+	IPOSTDOM(G,END(G)) = NO_NODE;
+}
diff -u --rec --new-file sparse/control-flow.c ../../sparse/sparse/control-flow.c
--- sparse/control-flow.c	1969-12-31 16:00:00 -08:00
+++ ../../sparse/sparse/control-flow.c	2004-06-06 16:52:37 -07:00
@@ -0,0 +1,224 @@
+/*
+ * Control Flow Analyse - find dominators and loops (and more in future).
+ *
+ * Copyright  2004 Tommy Thorn
+ *
+ * We do this by instantiating parts the cfgkit library.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include "control-flow.h"
+
+GRAPH_T NEW_GRAPH()
+{
+	return (GRAPH_T) calloc(1, sizeof (struct graph));
+}
+
+void FREE_GRAPH(GRAPH_T G)
+{
+	/*
+	  We don't attempt to free the basic blocks
+
+
+	NODE_T v, w;
+
+	for (v = g->all_nodes; v != NO_NODE; v = w) {
+		w = v->all_nodes;
+		free(v);
+	}
+	*/
+	free(G->preorder);
+	free(G->dforder);
+	free(G->vertex);
+	free(G);
+}
+
+int IS_SUCC(GRAPH_T g, NODE_T v, NODE_T w)
+{
+	NODE_T vv;
+
+	FOR_EACH_SUCCESSOR(G,v,vv)
+		if (vv == w)
+			return 1;
+	END_FOR_EACH_SUCCESSOR;
+	return 0;
+}
+
+int IS_PRED(GRAPH_T g, NODE_T w, NODE_T v)
+{
+	NODE_T ww;
+
+	FOR_EACH_SUCCESSOR(G,w,ww)
+		if (ww == v)
+			return 1;
+	END_FOR_EACH_SUCCESSOR;
+	return 0;
+}
+
+#include "cfgkit/dfn.h"
+#include "cfgkit/tarjan79-dominators.h"
+#include "cfgkit/havlak97-intervals.h"
+
+/*
+ * Prepare the basic block to be used as graph nodes.
+ */
+
+static void prepare_bb(GRAPH_T G, struct basic_block *bb)
+{
+	struct terminator_iterator term;
+	struct basic_block *next;
+
+	if (bb->aux)
+		return;
+
+	// XXX adopt sparse special allocators
+	bb->aux = calloc(1, sizeof *bb->aux);
+
+	// Translate a very inconvenient instruction iterator to node lists
+	init_terminator_iterator(last_instruction(bb->insns), &term);
+	while ((next = next_terminator_bb(&term)) != NULL) {
+		ADD_SUCC(G, bb, next);
+	}
+
+	// QQQ Apparently not all basic blocks are in the ep->bbs list
+	// below so we traverse the graph to reach everything.
+	FOR_EACH_SUCCESSOR(G,bb,next)
+		prepare_bb(G,next);
+	END_FOR_EACH_SUCCESSOR;
+}
+
+static void cluster(FILE *f, GRAPH_T G, NODE_T v)
+{
+	 NODE_T w = LOOP_BODY(G,v);
+	 fprintf(f,"subgraph cluster%d {\n",
+		 DFN(G,v));
+	 fprintf(f,"\t%d;", DFN(G,v));
+	 while (w != NO_NODE) {
+		 if (LOOP_BODY(G,w) != NO_NODE)
+		     cluster(f,G,w);
+		 fprintf(f,"%d;", DFN(G,w));
+		 w = ELEMENTS(G,w);
+	 }
+	 fprintf(f,"}\n");
+}
+
+static int verbose = 1;
+
+void control_flow(struct entrypoint *ep)
+{
+	int i, n = 0;
+	struct basic_block *bb;
+	GRAPH_T G = NEW_GRAPH();
+
+	printf("start %p\n", ep->start);
+	FOR_EACH_PTR(ep->bbs, bb) {
+		if (!ROOT(G))
+			ROOT(G) = bb;
+		printf("bb %p\n", bb);
+		prepare_bb(G, bb);
+		++n;
+	} END_FOR_EACH_PTR;
+
+	NODE_COUNT(G) = n;
+	// QQQ ROOT(G) = ep->start; WHY!!??
+
+	// XXX This isn't quite elegant
+	G->preorder = calloc(n, sizeof (NODE_T));
+	G->dforder  = calloc(n, sizeof (NODE_T));
+	G->vertex   = calloc(n, sizeof (NODE_T));
+
+	// assert(END(G) != NO_NODE);
+	dfn(G);
+	interval_analyse(G);
+	// postdominators(G); Needs END(G)
+	predominators(G);
+
+	dfn(G);
+	printf("\nGraph (size %d)", NODE_COUNT(G));
+	fflush(stdout);
+	if (verbose) {
+
+		FILE *f = fopen("/tmp/graph.dot","w");
+		fprintf(f,"digraph %s {\n", show_ident(ep->name->ident));
+		printf("\n");
+
+		for (i = 0; i < NODE_COUNT(G); ++i) {
+			NODE_T v = DFORDER(G,i);
+			NODE_T w;
+			char *name =
+				ROOT(G) == v ? "START" :
+				END(G) == v ? "END" : "";
+			assert(v != NO_NODE);
+
+			// The node
+			printf("%s%d:", name, DFN(G,v));
+
+			// Successor edges
+			if (name[0])
+				fprintf(f,"\t%d [label=\"%d (%s)\"]",
+					DFN(G,v), DFN(G,v), name);
+			else
+				fprintf(f,"\t%d", DFN(G,v));
+
+			fprintf(f," [color=%s%s];\n",
+				IRREDUCIBLE(G,v) ? "red" :
+				LOOP_BODY(G,v) != NO_NODE ? "green" :
+				"black",
+				LOOP_BODY(G,v) == NO_NODE ? "" : ",style=filled"
+				);
+			FOR_EACH_SUCCESSOR(G,v,w) {
+				fprintf(f,"\t%d -> %d;\n",
+					DFN(G,v), DFN(G,w));
+				printf(" %d", DFN(G,w));
+			} END_FOR_EACH_SUCCESSOR;
+			printf("\n");
+
+
+			// Immediate predominators
+			if (1 && IPREDOM(G,v) != NO_NODE) {
+				fprintf(f,"\t%d -> %d [color=red];\n",
+					DFN(G,v), DFN(G,IPREDOM(G,v)));
+			}
+
+			// Immediate postdominators
+			if (0 && IPOSTDOM(G,v) != NO_NODE) {
+				fprintf(f,"\t%d -> %d [color=purple];\n",
+					DFN(G,v), DFN(G,IPOSTDOM(G,v)));
+			}
+
+			// Loop headers
+			if (0 && LOOP_PARENT(G,v) != NO_NODE) {
+				fprintf(f,"\t%d -> %d [color=blue];\n",
+					DFN(G,v), DFN(G,LOOP_PARENT(G,v)));
+			}
+
+			// Loop bodies
+			if (0 && LOOP_BODY(G,v) != NO_NODE) {
+				printf("[loop body of %d = %d] ",
+				       DFN(G,v), DFN(G,LOOP_BODY(G,v)));
+				fprintf(f,"\t%d -> %d [color=green];\n",
+					DFN(G,v), DFN(G,LOOP_BODY(G,v)));
+			}
+
+			// Loop elements
+			if (0 && ELEMENTS(G,v) != NO_NODE) {
+				printf("[loop body of %d = %d] ",
+				       DFN(G,v), DFN(G,ELEMENTS(G,v)));
+				fprintf(f,"\t%d -> %d [color=pink];\n",
+					DFN(G,v), DFN(G,ELEMENTS(G,v)));
+			}
+
+			// Loops as nested subgraphs
+			if (0 && LOOP_BODY(G,v) != NO_NODE &&
+			    LOOP_PARENT(G,v) == NO_NODE) {
+				cluster(f,G,v);
+			}
+		}
+		fprintf(f,"}\n\n");
+		fclose(f);
+		system("/usr/bin/dot -Tps -o /tmp/graph.ps /tmp/graph.dot > /tmp/log 2>&1");
+		system("/usr/X11R6/bin/gv /tmp/graph.ps");
+	}
+}
diff -u --rec --new-file sparse/control-flow.h ../../sparse/sparse/control-flow.h
--- sparse/control-flow.h	1969-12-31 16:00:00 -08:00
+++ ../../sparse/sparse/control-flow.h	2004-06-06 16:47:22 -07:00
@@ -0,0 +1,149 @@
+/*
+ * Control Flow Analyse - find dominators and loops (and more in future).
+ *
+ * Copyright  2004 Tommy Thorn
+ *
+ * Licensed under the Open Software License version 1.1
+ *
+ * This defines the mapping between basicblocks and the cfgkit graphs.
+ *
+ * This is a straightforward mapping: nodes are basic blocks, structs
+ * with all the attributes for that node.  In this example we even
+ * simplify further by imposing a static limit to the fan-out and
+ * fan-in of nodes (this limitation is not resonable in practice).
+ *
+ * Please see GRAPH_IMPLEMENTATION for explanation of the macros that
+ * must be defined by a graph implementation.
+ */
+
+
+#ifndef CONTROL_FLOW_H
+#define CONTROL_FLOW_H
+
+#include <assert.h>
+#include "linearize.h"
+
+typedef struct graph *GRAPH_T;
+typedef struct basic_block *NODE_T;
+#define NO_NODE   ((NODE_T)  0)
+#define NO_NODE_2 ((NODE_T) -1)
+
+struct graph {
+	NODE_T all_nodes;
+
+	unsigned node_count;
+	NODE_T root, end;
+
+	NODE_T *preorder;
+	NODE_T *dforder;
+
+	// For dominators
+	NODE_T *vertex;
+};
+
+struct aux_info {
+	struct basic_block_list *successors;
+
+	int pren, dfn, nd;
+
+	/* Dominators */
+	NODE_T parent, ipredom, ipostdom;
+	int semi;
+	struct basic_block_list *bucket;
+
+	// For link and compress
+	NODE_T ancestor, label;
+
+	/* Dominators & Loops */
+	NODE_T representative;
+
+	/* Loops */
+	int irreducible;
+	NODE_T elements, loop_body, worklist, loop_parent;
+};
+
+/* Declarations for depth-first numbering. */
+
+#define FOR_EACH_SUCCESSOR(G,s,d)   FOR_EACH_PTR((s)->aux->successors,d)
+#define END_FOR_EACH_SUCCESSOR      END_FOR_EACH_PTR
+#define FOR_EACH_PREDECESSOR(G,s,d) FOR_EACH_PTR((s)->parents,d)
+#define END_FOR_EACH_PREDECESSOR    END_FOR_EACH_PTR
+
+extern GRAPH_T NEW_GRAPH();
+extern NODE_T  NEW_NODE(GRAPH_T g);
+
+static void inline ADD_SUCC(GRAPH_T G, NODE_T v, NODE_T w)
+{
+	add_ptr_list((struct ptr_list **)&v->aux->successors, w);
+}
+
+static void inline ADD_PRED(GRAPH_T G, NODE_T w, NODE_T v)
+{
+	assert(0);
+}
+
+/* Graph properties */
+
+#define NODE_COUNT(G) (G)->node_count
+#define ROOT(G)  (G)->root
+#define END(G)   (G)->end
+
+
+/* Not used by any algothm (yet?) */
+
+extern int IS_SUCC(GRAPH_T g, NODE_T v, NODE_T w);
+extern int IS_PRED(GRAPH_T g, NODE_T w, NODE_T v);
+
+
+/*
+ * For depth-first numbering etc.
+ */
+
+#define ND(G,v)          (v)->aux->nd
+#define DFN(G,v)         (v)->aux->dfn
+#define DFORDER(G,i)     (G)->dforder[i]
+#define PREN(G,v)        (v)->aux->pren
+#define PREORDER(G,i)    (G)->preorder[i]
+
+
+/*
+ * For dominators
+ */
+
+#define IPREDOM(G,v)        (v)->aux->ipredom
+#define IPOSTDOM(G,v)       (v)->aux->ipostdom
+
+#define PARENT(G,v)         (v)->aux->parent
+#define SEMI(G,v)           (v)->aux->semi
+#define VERTEX(G,i)         (G)->vertex[i]
+#define ANCESTOR(G,v)       (v)->aux->ancestor
+#define LABEL(G,v)          (v)->aux->label
+
+static inline void EMPTY_BUCKET(GRAPH_T G, NODE_T v)
+{
+	free_ptr_list((struct ptr_list **)&v->aux->bucket);
+}
+
+static inline void ADD_TO_BUCKET(GRAPH_T G, NODE_T v, NODE_T w)
+{
+	add_ptr_list((struct ptr_list **)&v->aux->bucket, w);
+}
+
+#define FOR_EACH_BUCKET_ELEM(G,b,v) FOR_EACH_PTR((b)->aux->bucket,v)
+#define END_FOR_EACH_BUCKET_ELEM END_FOR_EACH_PTR
+
+
+
+/*
+ * Loop finding
+ */
+
+#define LOOP_BODY(G,v)       (v)->aux->loop_body
+#define ELEMENTS(G,v)        (v)->aux->elements
+#define LOOP_PARENT(G,v)     (v)->aux->loop_parent
+#define IRREDUCIBLE(G,v)     (v)->aux->irreducible
+
+#define REPRESENTATIVE(G,v)  (v)->aux->representative
+#define WORKLIST(G,v)        (v)->aux->worklist
+
+#endif
diff -u --rec --new-file sparse/linearize.c ../../sparse/sparse/linearize.c
--- sparse/linearize.c	2004-06-06 16:58:51 -07:00
+++ ../../sparse/sparse/linearize.c	2004-06-06 16:02:14 -07:00
@@ -1052,6 +1052,9 @@
 
 			ep->name = sym;
 			bb->flags |= BB_REACHABLE;
+			ep->start = bb;
+			/* How do I get the return target? ep->end = alloc_basic_block(); */
+
 			set_activeblock(ep, bb);
 			concat_symbol_list(base_type->arguments, &ep->syms);
 			result = linearize_statement(ep, base_type->stmt);
diff -u --rec --new-file sparse/linearize.h ../../sparse/sparse/linearize.h
--- sparse/linearize.h	2004-06-06 16:58:51 -07:00
+++ ../../sparse/sparse/linearize.h	2004-06-06 15:56:54 -07:00
@@ -134,10 +134,13 @@
  */
 #define BB_REACHABLE	0x00000001
 
+struct aux_info;
+
 struct basic_block {
 	unsigned long flags;		/* BB status flags */
 	struct basic_block_list *parents; /* sources */
 	struct instruction_list *insns;	/* Linear list of instructions */
+	struct aux_info *aux;
 };
 
 static inline int is_branch_goto(struct instruction *br)
@@ -190,6 +193,7 @@
 	struct symbol_list *syms;
 	struct basic_block_list *bbs;
 	struct basic_block *active;
+	struct basic_block *start, *end;
 };
 
 struct entrypoint *linearize_symbol(struct symbol *sym);
diff -u --rec --new-file sparse/test-linearize.c ../../sparse/sparse/test-linearize.c
--- sparse/test-linearize.c	2004-06-06 16:58:51 -07:00
+++ ../../sparse/sparse/test-linearize.c	2004-06-06 15:47:08 -07:00
@@ -29,8 +29,10 @@
 	evaluate_symbol(sym);
 	expand_symbol(sym);
 	ep = linearize_symbol(sym);
-	if (ep)
+	if (ep) {
+		control_flow(ep);
 		show_entry(ep);
+	}
 }
 
 int main(int argc, char **argv)

--------------090706030809030309040202--


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Control Flow Analysis
Date: Mon, 07 Jun 2004 00:36:00 +0000
Message-ID: <Pine.LNX.4.58.0406061725570.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 6 Jun 2004, Tommy Thorn wrote:
> 
> I've adopted the bits of it that's finished to sparse and would like to 
> solicitate comments.  It's a quick hack job, so please don't be alarmed.

Your copyright lines look a bit strange:

	Copyright ) 2004 Tommy Thorn

Ehh?

Also, you use the GPL, but that doesn't actually work, since the GPL
requires that everything linking into it also be GPL'd, and sparse is OSL
for a reason.. You seem to know this, because _one_ of your files says
OSL.

Finally, you have a serious case of that rare "shouting dane disease",
which is when people of Danish descent start using ALL CAPS as a result of
sudden withdrawal symptoms of not having ready access to Aalborg Akvavit.  
Please go immediately to the nearest liquor store, take a quick sip, and
come back with the caps-lock key taped over in case of relapses.

Hint: typedefs and macros that act like functions are lower-case (and
please don't mix #ifdef's inside code).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Core dump with no argument ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Core dump with no argument
Date: Tue, 27 Jul 2004 19:20:45 +0000
Message-ID: <20040727192045.711761422D53 () darter ! rentec ! com>
--------------------

"./check" currently just core dumps.  That's not nice.

Morten



===== check.c 1.33 vs ? (writable without lock!)  =====
--- 1.33/check.c        2004-07-27 14:28:32 -04:00
+++ ?/check.c   2004-07-27 15:18:12 -04:00
@@ -68,6 +68,9 @@
                filename = arg;
        }
 
+       if (!filename)
+               die("Next time add the name of a C source file, OK?");
+
        // Initialize type system
        init_ctype();
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: DAC960: signed boolean warnings ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: DAC960: signed boolean warnings
Date: Sat, 09 Oct 2004 04:05:41 +0000
Message-ID: <20041008210541.01c4886c.rddunlap () osdl ! org>
--------------------

drivers/block/DAC960.[hc] has about 100 of these warnings:

drivers/block/DAC960.h:142:16: warning: dubious one-bit signed bitfield
drivers/block/DAC960.h:148:19: warning: dubious one-bit signed bitfield
drivers/block/DAC960.h:149:17: warning: dubious one-bit signed bitfield

based on this:

/*
  Define a Boolean data type.
*/
typedef enum { false, true } __attribute__ ((packed)) boolean;


Is there a clean way to make 'boolean' be unsigned in this case?

Thanks,
--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: DAC960: signed boolean warnings
Date: Sat, 09 Oct 2004 06:00:46 +0000
Message-ID: <Pine.LNX.4.58.0410082251430.3897 () ppc970 ! osdl ! org>
--------------------


On Fri, 8 Oct 2004, Randy.Dunlap wrote:
> 
> drivers/block/DAC960.[hc] has about 100 of these warnings:
> 
> drivers/block/DAC960.h:142:16: warning: dubious one-bit signed bitfield
> drivers/block/DAC960.h:148:19: warning: dubious one-bit signed bitfield
> drivers/block/DAC960.h:149:17: warning: dubious one-bit signed bitfield
> 
> based on this:
> 
> /*
>   Define a Boolean data type.
> */
> typedef enum { false, true } __attribute__ ((packed)) boolean;
> 
> Is there a clean way to make 'boolean' be unsigned in this case?

Heh. I think the sparse warning is true in this case (gcc _will_ make a 
one-bit bitfield signed unless you use "-funsigned-bitfields", so using 
"boolean x:1" will result in something that never actually has the "ebyn 
true" value). 

But if you define both "false" and "true" to be "unsigned" values, then
sparse should consider the "boolean" to be unsigned too, thanks to the
enum type work by Al. HOWEVER, because of how the "is_signed" test works
in sparse, that will still complain. That looks like a sparse bug.

Al? Why does this complain:

	typedef enum {
		false = 0U,
		true = 1U
	} boolean;

	struct hello {
		boolean x:1;
	};

I'll take a look at it tomorrow unless Al immediately sees what's wrong.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: DAC960: signed boolean warnings
Date: Sat, 09 Oct 2004 17:00:44 +0000
Message-ID: <Pine.LNX.4.58.0410090955120.3897 () ppc970 ! osdl ! org>
--------------------


On Fri, 8 Oct 2004, Linus Torvalds wrote:
> 
> Al? Why does this complain:
> 
> 	typedef enum {
> 		false = 0U,
> 		true = 1U
> 	} boolean;
> 
> 	struct hello {
> 		boolean x:1;
> 	};
> 
> I'll take a look at it tomorrow unless Al immediately sees what's wrong.

Ok, I made sparse do the right thing for the above. Since all the types of 
the actual values agree (they are all "unsigned int"), the type of 
"boolean" ends up being "unsigned int" too. So now the above doesn't 
complain any more, but that's really a very sparse-specific (and 
apparently Plan9 C-compiler-specific) extension.

A regular enum will still complain, I'm afraid. If you write

	typedef enum {
		false, true
	} boolean;

then "boolean" will be a regular "int" type, and thus

	boolean x:1

will complain about being potentially signed..

Of course, sparse itself will actually consider the above to be an 
unsigned bitfield, so the warning is really about "gcc will consider this 
signed, which is silly".

Btw, gcc has an option called "-funsigned-bitfields", which makes gcc do 
the right thing. We might shut up about the signed bitfields if we see 
that option, since that means that the user is doing the right thing 
anyway. 

I think that should be the default for gcc, but the gcc people are being 
silly as usual.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Delivery failed ===

From: robert () deccanetworld ! com
To: linux-sparse
Subject: Delivery failed
Date: Tue, 13 Apr 2004 13:36:30 +0000
Message-ID: <200504121351.j3CDpRD14620 () mail ! deccanetworld ! com>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_0005_7599257C.67F0F5A3
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

------------------  Virus Warning Message (on gatekeeper)

Found virus WORM_MYDOOM.BC in file message.scr
The uncleanable file message.scr is moved to /tmp/virCvkBVS.

---------------------------------------------------------

------=_NextPart_000_0005_7599257C.67F0F5A3
Content-Type: text/plain;
	charset=us-ascii
Content-Transfer-Encoding: 7bit




------=_NextPart_000_0005_7599257C.67F0F5A3
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit


------------------  Virus Warning Message (on gatekeeper)

message.scr is removed from here because it contains a virus.

---------------------------------------------------------
------=_NextPart_000_0005_7599257C.67F0F5A3--


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Does Sparse find out duplicate definitions? ===

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: Does Sparse find out duplicate definitions?
Date: Thu, 09 Sep 2004 17:57:57 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKKENLDDAA.mshah () teja ! com>
--------------------
Sparse did not throw an error for duplicate definitions of the variable.
Also, it seems that it overwrites the definition with the latest one.
Does it suppose to find out?

-------------------------
Example program:

void main() {
  int i, i;
  int i[10];
  int *i;
}
----------------------
-Mitesh


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Does Sparse find out duplicate definitions?
Date: Thu, 09 Sep 2004 18:12:52 +0000
Message-ID: <Pine.LNX.4.58.0409091104220.5912 () ppc970 ! osdl ! org>
--------------------


On Thu, 9 Sep 2004, Mitesh shah wrote:
>
> Sparse did not throw an error for duplicate definitions of the variable.
> Also, it seems that it overwrites the definition with the latest one.

Yes. Sparse isn't really very careful about things that the normal 
compiler finds, since I've mainly used it to check sources that compile 
with find with normal gcc. So most of the warnings sparse does is for the 
sparse extensions, or for cases where sparse simply has real problems 
understanding the file. Things like duplicate symbols sparse doesn't much 
care about ;)

It should not be hard to add support for it, though. Sparse _does_ keep 
track of all symbol definitions for a particular identifier, and some of 
the logic you want already exists in "check_duplicates". That one is 
designed just for top-level symbols, though, so it doesn't care about 
things like scoping.

Anyway, you can create a small copy of "check_duplicates()" that ignores
symbols that aren't in the same scope, something like

	if (sym->scope != next->scope)
		continue;

or similar. Add code in "evaluate_statement()" to do this for each 
symbol in a STMT_COMPOUND, and you should be all set (you can't do it in 
evaluate_symbol(), that would cause recursions).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Does the Sparse work under cygwin? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Does the Sparse work under cygwin?
Date: Wed, 08 Sep 2004 19:15:04 +0000
Message-ID: <20040908191504.GA22881 () 64m ! dyndns ! org>
--------------------
I used to run sparse in cygwin from time to time.
I eventually lost interest in using sparse under cygwin.

There is another pit fall to watch out is that, in cygwin
mmap anonymous page is broken. It did not reset page to zero.

For the strtold, you are right cygwin doesn't have that.
I guess you have to use sscanf instead.

Chris

On Wed, Sep 08, 2004 at 03:24:09PM -0700, Mitesh shah wrote:
> Hi,
> 
> I tried to compile sparse under cygwin and got an undefined symbol for
> strtold function call. Looks like strtold in not there in cygwin gcc. Is
> there a plan to support sparse under cygwin?
> 
> error message:
> -------------------------
> 
> sparse.a(expression.o)(.text+0x546): In function `get_number_value':
> /c/projects/sparse-bk/expression.c:207: undefined reference to
> `_strtold'
> collect2: ld returned 1 exit status
> make: *** [test-lexing] Error 1
> 
> --------------------------
> 
> Thanks,
> 
> Mitesh
> 
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: Does the Sparse work under cygwin?
Date: Wed, 08 Sep 2004 22:24:09 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKKENGDDAA.mshah () teja ! com>
--------------------
Hi,

I tried to compile sparse under cygwin and got an undefined symbol for
strtold function call. Looks like strtold in not there in cygwin gcc. Is
there a plan to support sparse under cygwin?

error message:
-------------------------

sparse.a(expression.o)(.text+0x546): In function `get_number_value':
/c/projects/sparse-bk/expression.c:207: undefined reference to
`_strtold'
collect2: ld returned 1 exit status
make: *** [test-lexing] Error 1

--------------------------

Thanks,

Mitesh


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Does the Sparse work under cygwin?
Date: Wed, 08 Sep 2004 22:28:21 +0000
Message-ID: <Pine.LNX.4.58.0409081523410.5912 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Sep 2004, Mitesh shah wrote:
> 
> I tried to compile sparse under cygwin and got an undefined symbol for
> strtold function call. Looks like strtold in not there in cygwin gcc. Is
> there a plan to support sparse under cygwin?

You probably need to do the same thing that Morten did for his Sun patch,
which was to implement a "strtold()" helper function.

The trivial one is to just wrap "strtod()" and call it strtold(). A
regular strtod() is old-ANSI and should exist pretty much anywhere
(strtold() is C99). And it's certainly "good enough" in practice.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Does the Sparse work under cygwin?
Date: Wed, 08 Sep 2004 22:42:26 +0000
Message-ID: <Pine.LNX.4.58.0409081541140.5912 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Sep 2004, Christopher Li wrote:
> 
> For the strtold, you are right cygwin doesn't have that.
> I guess you have to use sscanf instead.

If it doesn't have strtold, it probably doesn't support "%Lf" either (but
that generally won't show up at compile-time, and will just show as a
runtime bug).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: Does the Sparse work under cygwin?
Date: Thu, 09 Sep 2004 17:47:22 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKAENLDDAA.mshah () teja ! com>
--------------------
> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Christopher Li
> Sent: Wednesday, September 08, 2004 12:15 PM
> To: Mitesh shah
> Cc: Linux-Sparse
> Subject: Re: Does the Sparse work under cygwin?
>
>
> I used to run sparse in cygwin from time to time.
> I eventually lost interest in using sparse under cygwin.
>
> There is another pit fall to watch out is that, in cygwin
> mmap anonymous page is broken. It did not reset page to zero.


I am hitting segmentation fault in struct_declaration_list for somewhat
larger files. I tried to debug it but looks like there is a memory
corruption for the symbol list. I am trying to find out if it is related
to this mmap issue. Did you solve the mmap issue on cygwin? I replaced
the allocate with malloc and it seems to work.

Thanks,

-Mitesh



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Doing CSE in sparse.. ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 19:20:43 +0000
Message-ID: <20041123192043.GA23123 () 64m ! dyndns ! org>
--------------------
I happen to reading the same paper and looking at the same file.
Well, I got the stuff from Tommy.

My feeling is that sparse need to have the dominator for basic
blocks.

Right now after the memory to pseudo promotion. The phi node
place at the place where the store instruction used to be.

It still need to find the right place to insert the phi node
to get optimal number of phi nodes. It needs dominator and its
friends to find the right place.

BTW, the tarjan79-dominators.h is not enough. It reference other
parts your GSA.

Chris

On Tue, Nov 23, 2004 at 02:38:52PM -0800, Tommy Thorn wrote:
> Sigh, I can't write to an osdl address and having an attachment apparently got
> me blocked.  Life used to be simple.  Anyway, the file mentioned below can be
> gotten at http://not.meko.dk/tarjan79-dominators.h
> 
> Grief.
> Tommy
> 
> 
> Linus Torvalds said:
> >
> > Ok, I committed my first version of CSE in sparse earlier today. It kind of
> works.
> >
> > By "kind of works" I mean that it does seem to properly find common
> sub-expressions, but it doesn't actually replace them very often. Right now
> I only replace them when they are in the same basic-block, which is one
> particular special case that isn't actually very interesting.
> >
> > The "different basic blocks" case shouldn't be that hard, but it requires
> checking that one instruction is a proper dominator of another _or_ it
> requires finding some least-common-dominator thing. I dunno. Again, this is
> probably something that has been researched to death, and I just can't be
> bothered to read papers about it, since it seems to be easier to "Just do
> it" rather than trying to be fancy about it.
> 
> Well, the classic implementation (nearly linear) is due to Lengauer and
> Tarjan, the proper "academic" citation is:
> 
>  *  @article{357071,
>  *   author = {Thomas Lengauer and Robert Endre Tarjan},
>  *   title = {A fast algorithm for finding dominators in a flowgraph}, *  
> journal = {ACM Trans. Program. Lang. Syst.},
>  *   volume = {1},
>  *   number = {1},
>  *   year = {1979},
>  *   issn = {0164-0925},
>  *   pages = {121--141},
>  *   doi = {http://doi.acm.org/10.1145/357062.357071},
>  *   publisher = {ACM Press},
>  *   }
>  *
> 
> I already sent you an implementation of the O(n ln n) version that's even well
> tested.  If you can look beyond some trivial issues you might even be able to
> use it.  The file is part of the much larger GSA effort which has stalled
> (again) due to lack of time.  You need to instantiate some macros or rewrite
> to fit the assumptions, but it should be fairly easy to do.
> 
> I hope you can use it and I'm sorry I can't spare more time on sparse these days.
> 
> Cheers,
> Tommy
> 
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 21:29:07 +0000
Message-ID: <Pine.LNX.4.58.0411231322020.20993 () ppc970 ! osdl ! org>
--------------------

Ok, I committed my first version of CSE in sparse earlier today. It kind 
of works.

By "kind of works" I mean that it does seem to properly find common 
sub-expressions, but it doesn't actually replace them very often. Right 
now I only replace them when they are in the same basic-block, which is 
one particular special case that isn't actually very interesting.

The "different basic blocks" case shouldn't be that hard, but it requires 
checking that one instruction is a proper dominator of another _or_ it 
requires finding some least-common-dominator thing. I dunno. Again, this 
is probably something that has been researched to death, and I just can't 
be bothered to read papers about it, since it seems to be easier to "Just 
do it" rather than trying to be fancy about it.

When I find a CSE thing, I don't try to be fancy and follow the 
instructions that the CSE may have modified. I just end up re-hashing the 
whole damn thing, and see if I can find some other CSE based on the first 
one. This is called "being stupid in the extreme", but dammit, it's just 
too hard to fix up the hash lists dynamically.

Again, I'm sure there are more intelligent ways of doing this. What I do 
is pretty much obvious to a five-year-old, which makes the code pretty 
easy to read.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 22:05:54 +0000
Message-ID: <19494.65.113.40.130.1101247554.squirrel () numba-tu ! com>
--------------------
------=_20041123140554_96700
Content-Type: text/plain; charset="iso-8859-1"
Content-Transfer-Encoding: 8bit

Linus Torvalds said:
>
> Ok, I committed my first version of CSE in sparse earlier today. It kind
> of works.
>
> By "kind of works" I mean that it does seem to properly find common
> sub-expressions, but it doesn't actually replace them very often. Right
> now I only replace them when they are in the same basic-block, which is
> one particular special case that isn't actually very interesting.
>
> The "different basic blocks" case shouldn't be that hard, but it requires
> checking that one instruction is a proper dominator of another _or_ it
> requires finding some least-common-dominator thing. I dunno. Again, this
> is probably something that has been researched to death, and I just can't
> be bothered to read papers about it, since it seems to be easier to "Just
> do it" rather than trying to be fancy about it.

Well, the classic implementation (nearly linear) is due to Lengauer and
Tarjan, the proper "academic" citation is:

 *  @article{357071,
 *   author = {Thomas Lengauer and Robert Endre Tarjan},
 *   title = {A fast algorithm for finding dominators in a flowgraph},
 *   journal = {ACM Trans. Program. Lang. Syst.},
 *   volume = {1},
 *   number = {1},
 *   year = {1979},
 *   issn = {0164-0925},
 *   pages = {121--141},
 *   doi = {http://doi.acm.org/10.1145/357062.357071},
 *   publisher = {ACM Press},
 *   }
 *

I already sent you an implementation of the O(n ln n) version that's even well
tested.  If you can look beyond some trivial issues you might even be able to
use it.  The file is part of the much larger GSA effort which has stalled
(again) due to lack of time.  You need to instantiate some macros or rewrite
to fit the assumptions, but it should be fairly easy to do.

I hope you can use it and I'm sorry I can't spare more time on sparse these days.

Cheers,
Tommy

------=_20041123140554_96700
Content-Type: text/plain; name="tarjan79-dominators.h"
Content-Transfer-Encoding: 8bit
Content-Disposition: attachment; filename="tarjan79-dominators.h"

/*
 * Find dominators.
 *
 *   Copyright  2004 Tommy Thorn
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, Inc., 53 Temple Place Ste 330,
 *   Bostom MA 02111-1307, USA; either version 2 of the License, or
 *   (at your option) any later version; incorporated herein by reference.
 *
 * This is an implementation of Thomas Lengauer and Robert Endre
 * Tarjan's algorithm for finding dominators, as described in
 *
 *  @article{357071,
 *   author = {Thomas Lengauer and Robert Endre Tarjan},
 *   title = {A fast algorithm for finding dominators in a flowgraph},
 *   journal = {ACM Trans. Program. Lang. Syst.},
 *   volume = {1},
 *   number = {1},
 *   year = {1979},
 *   issn = {0164-0925},
 *   pages = {121--141},
 *   doi = {http://doi.acm.org/10.1145/357062.357071},
 *   publisher = {ACM Press},
 *   }
 *
 * This only implements the O(n log n) algorithm, though it's an easy
 * extention to arrive at the near-linear algorithm.
 *
 * Required macros:
 * - node_t, FOR_EACH_SUCCESSOR, MAKE_PRED
 *
 * - Computed:
 *     parent :: node_t  -> node_t
 *     PRED   :: node_t  -> Set node_t
 *     SEMI   :: node_t  -> Integer   (Initially -1)
 *     VERTEX :: Integer -> node_t
 *     BUCKET :: node_t  -> Set node_t
 *     DOM    :: node_t  -> node_t
 *
 * - Intermediate (for the path compression)
 *     The ancestor in the forest
 *     ANCESTOR :: node_t -> node_t  (Initially NO_NODE)
 *     LABEL    :: node_t -> node_t  (Initially the identity mapping)
 *
 * Optionally defined
 * - MODULE, a module name prefix for the externally defined symbols.
 * XXX
 *
 * We keep the naming of the original naming, but we label everything
 * starting with 0 and not 1 like in the original article.  Thus, -1
 * and not 0 denotes the "no information" value.
 *
 * Requires:
 */

#define DEBUG_TARJAN(fmt ...) //printf(fmt)

static int dom_n;

/*
 * General LINK and EVAL that works for both pre- and post-dominator.
 */

static void compress(graph_t g, node_t v)
{
	if (ancestor(g,ancestor(g,v)) != NO_NODE) {
		compress(g,ancestor(g,v));
		if (semi(g,label(g,ancestor(g,v))) < semi(g,label(g,v)))
			label(g,v) = label(g,ancestor(g,v));
		ancestor(g,v) = ancestor(g,ancestor(g,v));
	}
}

static node_t eval(graph_t g, node_t v)
{
	DEBUG_TARJAN("eval %d\n", dfn(g,v));

	if (ancestor(g,v) == NO_NODE) {
		DEBUG_TARJAN("  -> %d\n", dfn(g,v));
		return v;
	} else {
		compress(g,v);
		DEBUG_TARJAN("  -> %d\n", dfn(g,label(g,v)));
		return label(g,v);
	}
}

static void link(graph_t g, node_t v, node_t w)
{
	ancestor(g, w) = v;
}

/*
 * The pre- and  post-dominator alg.
 */

static void predom_dfs(graph_t g, node_t v)
{
	node_t w;

	DEBUG_TARJAN("predom_dfs %p (semi %x)\n", v, semi(g,v));

	semi(g,v) = ++dom_n;
	vertex(g,dom_n) = v;

	FOR_EACH_SUCCESSOR(g,v,w) {
		if (semi(g,w) == ~1) {
			parent(g,w) = v;
			predom_dfs(g,w);
		}
	} END_FOR_EACH_SUCCESSOR;
}

void predominators(graph_t g)
{
	int i;

	compute_dfn(g);

	// Step 1
	DEBUG_TARJAN("step1 (%d)\n", node_count(g));
	for (i = 0; i < node_count(g); ++i) {
		node_t v = preorder(g,i);
		DEBUG_TARJAN("init %p\n", v);
		semi(g,v) = ~1;
		empty_bucket(g,v);
		ancestor(g,v) = NO_NODE;
		label(g,v) = v;
	}

	DEBUG_TARJAN("step1 (%d nodes)\n", node_count(g));

	dom_n = -1;
	DEBUG_TARJAN("predom_dfs\n");
	predom_dfs(g,root(g));
	node_count(g) = dom_n + 1;

	for (i = node_count(g) - 1; 1 <= i; --i) {
		node_t v, pw, w = vertex(g,i);

		DEBUG_TARJAN("step 2: %d\n", i);
		// Step 2
		FOR_EACH_PREDECESSOR(g,w,v) {
			node_t u;
			DEBUG_TARJAN("(%d,%d) in g\n", dfn(g,v), dfn(g,w));
			u = eval(g,v);
			if (semi(g,u) < semi(g,w))
				semi(g,w) = semi(g,u);
		} END_FOR_EACH_PREDECESSOR;

		add_to_bucket(g, vertex(g,semi(g,w)), w);
		link(g, parent(g,w), w);

		// Step 3
		pw = parent(g,w);
		FOR_EACH_BUCKET_ELEM(g,pw,v) {
			node_t u = eval(g,v);
			ipredom(g,v) = semi(g,u) < semi(g,v) ? u : pw;
		} END_FOR_EACH_BUCKET_ELEM;
		empty_bucket(g,pw);
	}
	// Step 4
	for (i = 1; i < node_count(g); ++i) {
		node_t w = vertex(g,i);
		if (ipredom(g,w) != vertex(g,semi(g,w)))
			ipredom(g,w) = ipredom(g,ipredom(g,w));
	}
	ipredom(g,root(g)) = NO_NODE;
}

static void postdom_dfs(graph_t g, node_t v)
{
	node_t w;

	DEBUG_TARJAN("postdom_dfs %p (semi %x)\n", v, semi(g,v));

	semi(g,v) = ++dom_n;
	vertex(g,dom_n) = v;

	FOR_EACH_PREDECESSOR(g,v,w) {
		if (semi(g,w) == ~1) {
			parent(g,w) = v;
			postdom_dfs(g,w);
		}
	} END_FOR_EACH_PREDECESSOR;
}

void postdominators(graph_t g)
{
	int i;

	compute_dfn_rev(g);

	// Step 1
	DEBUG_TARJAN("step1 (%d)\n", node_count(g));
	for (i = 0; i < node_count(g); ++i) {
		node_t v = preorder(g,i);
		DEBUG_TARJAN("init %p\n", v);
		semi(g,v) = ~1;
		empty_bucket(g,v);
		ancestor(g,v) = NO_NODE;
		label(g,v) = v;
	}

	DEBUG_TARJAN("step1 (%d nodes)\n", node_count(g));

	dom_n = -1;
	DEBUG_TARJAN("postdom_dfs\n");
	postdom_dfs(g,end(g));
	node_count(g) = dom_n + 1;

	for (i = node_count(g) - 1; 1 <= i; --i) {
		node_t v, pw, w = vertex(g,i);

		DEBUG_TARJAN("step 2: %d\n", i);
		// Step 2
		FOR_EACH_SUCCESSOR(g,w,v) {
			node_t u;
			DEBUG_TARJAN("(%d,%d) in G\n", dfn(g,v), dfn(g,w));
			u = eval(g,v);
			if (semi(g,u) < semi(g,w))
				semi(g,w) = semi(g,u);
		} END_FOR_EACH_SUCCESSOR;

		add_to_bucket(g, vertex(g,semi(g,w)), w);
		link(g, parent(g,w), w);

		// Step 3
		pw = parent(g,w);
		FOR_EACH_BUCKET_ELEM(g,pw,v) {
			node_t u = eval(g,v);
			ipostdom(g,v) = semi(g,u) < semi(g,v) ? u : pw;
		} END_FOR_EACH_BUCKET_ELEM;
		empty_bucket(g,pw);
	}
	// Step 4
	for (i = 1; i < node_count(g); ++i) {
		node_t w = vertex(g,i);
		if (ipostdom(g,w) != vertex(g,semi(g,w)))
			ipostdom(g,w) = ipostdom(g,ipostdom(g,w));
	}
	ipostdom(g,end(g)) = NO_NODE;
}
------=_20041123140554_96700--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 22:38:52 +0000
Message-ID: <11322.65.113.40.130.1101249532.squirrel () numba-tu ! com>
--------------------
Sigh, I can't write to an osdl address and having an attachment apparently got
me blocked.  Life used to be simple.  Anyway, the file mentioned below can be
gotten at http://not.meko.dk/tarjan79-dominators.h

Grief.
Tommy


Linus Torvalds said:
>
> Ok, I committed my first version of CSE in sparse earlier today. It kind of
works.
>
> By "kind of works" I mean that it does seem to properly find common
sub-expressions, but it doesn't actually replace them very often. Right now
I only replace them when they are in the same basic-block, which is one
particular special case that isn't actually very interesting.
>
> The "different basic blocks" case shouldn't be that hard, but it requires
checking that one instruction is a proper dominator of another _or_ it
requires finding some least-common-dominator thing. I dunno. Again, this is
probably something that has been researched to death, and I just can't be
bothered to read papers about it, since it seems to be easier to "Just do
it" rather than trying to be fancy about it.

Well, the classic implementation (nearly linear) is due to Lengauer and
Tarjan, the proper "academic" citation is:

 *  @article{357071,
 *   author = {Thomas Lengauer and Robert Endre Tarjan},
 *   title = {A fast algorithm for finding dominators in a flowgraph}, *  
journal = {ACM Trans. Program. Lang. Syst.},
 *   volume = {1},
 *   number = {1},
 *   year = {1979},
 *   issn = {0164-0925},
 *   pages = {121--141},
 *   doi = {http://doi.acm.org/10.1145/357062.357071},
 *   publisher = {ACM Press},
 *   }
 *

I already sent you an implementation of the O(n ln n) version that's even well
tested.  If you can look beyond some trivial issues you might even be able to
use it.  The file is part of the much larger GSA effort which has stalled
(again) due to lack of time.  You need to instantiate some macros or rewrite
to fit the assumptions, but it should be fairly easy to do.

I hope you can use it and I'm sorry I can't spare more time on sparse these days.

Cheers,
Tommy


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 22:47:33 +0000
Message-ID: <27241.65.113.40.130.1101250053.squirrel () numba-tu ! com>
--------------------
Tommy Thorn said:
> Sigh, I can't write to an osdl address and having an attachment apparently got
> me blocked.  Life used to be simple.  Anyway, the file mentioned below can be
> gotten at http://not.meko.dk/tarjan79-dominators.h

This one made it though, but I realized that you probably need at least one
more file, so replace the above with

http://not.meko.dk/cfgkit-2004-11-05/dfn.h
http://not.meko.dk/cfgkit-2004-11-05/tarjan79-dominators.h

(Or http://not.meko.dk/cfgkit-2004-11-05.tar.gz for the whole shebang).

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 23:15:22 +0000
Message-ID: <Pine.LNX.4.58.0411231508130.20993 () ppc970 ! osdl ! org>
--------------------


On Tue, 23 Nov 2004, Christopher Li wrote:
>
> I happen to reading the same paper and looking at the same file.
> Well, I got the stuff from Tommy.
> 
> My feeling is that sparse need to have the dominator for basic
> blocks.

Well, I actually did write a simple dominator, but I guess it counts as a 
"fast O(mn)" rather than anything really good. 

It seems to work, and makes us CSE a lot better.

However, the "fun" CSE part is when you do actual code movement etc, and I 
don't do that yet. I have this suspicion (which may or may not be true) 
that for expressions that don't actually dominate each other we know that 
we want to limit the code movement so much that we might be ok _just_ 
checking direct parents for commonality, but I haven't thought about it 
much.

Ie for non-dominating instructions, I'd just move the instruction up to 
the parent _iff_ there is (a) just a single parent (b) none of the pseudos 
it uses are defined in the same block and (c) if doing so for both 
instructions means that we can merge them. That should be purely linear, 
since we'd never even bother to look at the complex case with multiple 
parents.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing CSE in sparse..
Date: Tue, 23 Nov 2004 23:22:03 +0000
Message-ID: <Pine.LNX.4.58.0411231516190.20993 () ppc970 ! osdl ! org>
--------------------


On Tue, 23 Nov 2004, Linus Torvalds wrote:
> 
> Well, I actually did write a simple dominator, but I guess it counts as a 
> "fast O(mn)" rather than anything really good. 
> 
> It seems to work, and makes us CSE a lot better.

Btw, even with the "pure dominance" thing (assuming I got it right, of 
course), it takes CSE from finding just a couple of entries in parse.c to 
finding 70 instructions to be CSE'd.

Of course, by now it's actually pretty hard to see when I do something 
wrong, since any interesting cases end up being pretty big. But the way I 
re-write the instructions when cse'ing, you can at least see very clearly 
what I do in the "test-linearize" output (ie the same way loads and stores 
have been changed to special no-ops that show what they used to be, the 
CSE thing changes the instruction into a special cse no-op that shows what 
the source of the CSE was).

Any CSE that does code movement is likely to be better still, but 
obviously at that point there is always the worry that you might move 
something unimportant in an error path into a hot path, so code movement 
might sometimes deprove things. I think.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Doing real symbol->pseudo conversion. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Doing real symbol->pseudo conversion.
Date: Thu, 11 Nov 2004 08:11:15 +0000
Message-ID: <Pine.LNX.4.58.0411102354160.2301 () ppc970 ! osdl ! org>
--------------------

Ok, this does it all. I checked in something that actually seems to work 
for some simple cases, and seems to do a half-way decent thing even on 
more complex stuff. Whatever.

As a test-case, here's a stupid one:

	int test(int a)
	{
	        if (a < 10)
	                a = a + 10;
	        a = a + 20;
	        return a;
	}

and it linearizes into 

	ENTRY:
	bb: 0xf7fa600c
	   test.c:1:5
	        %r2 <- setlt  %arg1, $10
	        %r9 <- %arg1
	        br      %r2, .L0xf7fa6028, .L0xf7fa6060

	bb: 0xf7fa6028
	   test.c:3:2
	  **from 0xf7fa600c (test.c:1:5)**
	        %r4 <- add  %arg1, $10
	        %r9 <- %r4
	        br      .L0xf7fa6060

	bb: 0xf7fa6060
	   test.c:1:5
	  **from 0xf7fa600c (test.c:1:5)**
	  **from 0xf7fa6028 (test.c:3:2)**
	        %r9 <- phi (%arg1, .L0xf7fa600c), (%r4, .L0xf7fa6028)
	        %r6 <- add  %r9, $20
	        ret %r6

(this is with the nops edited out to make it more readable).

NOTE! This is also with my old phi-node duplication, so if you wonder why
%r9 is assigned three times, then no, the original SSA format just has the
one phi-node for %r9, and I do a final pass to move the phi-nodes into the
sources of the phi-nodes. The idea is that if you ignore the phi-node, it
actually looks like real assembly (alternatively, if you like phi-nodes
and don't like the thing, igore the two "extra" assignments of %r9).

Anyway, what I wanted to point out was that I did a real replacement of 
the symbols. They're all gone. 

And I don't have any special loop knowledge or anything like that. I 
continue to maintain that any algorithm that needs to find loops is 
broken. But hey, maybe it is _my_ algorithm that is broken.

Here's a more complex version:

	int test(int a, int b)
	{
		if (a > 10)
			goto inside;
	repeat:
		a += 1;
	r2:
		a += b;
	inside:
		if (a < b)
			goto repeat;
		if (a < 100)
			goto r2;
		return a + b;
	}

becomes the following (this is actually without the phi-duplication, just
to avoid the bloating of the code by the addition of lots of extra
register copies):

	ENTRY:
	bb: 0xf7fa600c
	   test.c:1:5
	        %r2 <- setgt  %arg1, $10
	        br      %r2, .L0xf7fa6060, .L0xf7fa607c

	bb: 0xf7fa607c
	   test.c:5:1
	        %r17 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
	        %r4 <- add  %r17, $1
	        br      .L0xf7fa6098

	bb: 0xf7fa6098
	   test.c:7:1
	        %r18 <- phi (%r4, .L0xf7fa607c), (%arg1, .L0xf7fa600c)
	        %r7 <- add  %r18, %arg2
	        br      .L0xf7fa6060

	bb: 0xf7fa6060
	   test.c:4:8
	        %r19 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
	        %r10 <- setlt  %r19, %arg2
	        br      %r10, .L0xf7fa607c, .L0xf7fa60d0

	bb: 0xf7fa60d0
	   test.c:10:2
	        %r20 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
	        %r12 <- setlt  %r20, $100
	        br      %r12, .L0xf7fa6098, .L0xf7fa6124

	bb: 0xf7fa6124
	   test.c:1:5
	        %r21 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
	        %r15 <- add  %r21, %arg2
	        ret %r15

and as far as I can tell, it's all correct. 

Anyway, my current code tries to actually do the right thing for
structures and unions too, although FP unions will confuse it (it doesn't
understand that you can't just shift bits there). And any slightly more
complex cases will mean that it isn't able to remove all the loads and
stores, but it should degrade fairly gracefully.

Maybe.

Tommy, I dare you to look at my code.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Thu, 11 Nov 2004 08:37:06 +0000
Message-ID: <Pine.LNX.4.44.0411110236150.2338-100000 () nondot ! org>
--------------------
On Thu, 11 Nov 2004, Linus Torvalds wrote:
> Ok, this does it all. I checked in something that actually seems to work
> for some simple cases, and seems to do a half-way decent thing even on
> more complex stuff. Whatever.

How well do you handle the loop in this testcase?

#include <stdio.h>

typedef struct List {
  struct List *Next;
  int Data;
} List;

List Node0 = {0, 5};
List Node1 = {&Node0, 4};
List Node2 = {&Node1, 3};
List Node3 = {&Node2, 2};
List Node4 = {&Node3, 1};
List Node5 = {&Node4, 0};

void main() {
    List *PrevL, *CurL;
    for (PrevL = 0, CurL = &Node5; CurL; PrevL = CurL, CurL = CurL->Next)
        printf("%d %d\n", CurL->Data, PrevL ? PrevL->Data : -1);
}

-Chris


> As a test-case, here's a stupid one:
>
> 	int test(int a)
> 	{
> 	        if (a < 10)
> 	                a = a + 10;
> 	        a = a + 20;
> 	        return a;
> 	}
>
> and it linearizes into
>
> 	ENTRY:
> 	bb: 0xf7fa600c
> 	   test.c:1:5
> 	        %r2 <- setlt  %arg1, $10
> 	        %r9 <- %arg1
> 	        br      %r2, .L0xf7fa6028, .L0xf7fa6060
>
> 	bb: 0xf7fa6028
> 	   test.c:3:2
> 	  **from 0xf7fa600c (test.c:1:5)**
> 	        %r4 <- add  %arg1, $10
> 	        %r9 <- %r4
> 	        br      .L0xf7fa6060
>
> 	bb: 0xf7fa6060
> 	   test.c:1:5
> 	  **from 0xf7fa600c (test.c:1:5)**
> 	  **from 0xf7fa6028 (test.c:3:2)**
> 	        %r9 <- phi (%arg1, .L0xf7fa600c), (%r4, .L0xf7fa6028)
> 	        %r6 <- add  %r9, $20
> 	        ret %r6
>
> (this is with the nops edited out to make it more readable).
>
> NOTE! This is also with my old phi-node duplication, so if you wonder why
> %r9 is assigned three times, then no, the original SSA format just has the
> one phi-node for %r9, and I do a final pass to move the phi-nodes into the
> sources of the phi-nodes. The idea is that if you ignore the phi-node, it
> actually looks like real assembly (alternatively, if you like phi-nodes
> and don't like the thing, igore the two "extra" assignments of %r9).
>
> Anyway, what I wanted to point out was that I did a real replacement of
> the symbols. They're all gone.
>
> And I don't have any special loop knowledge or anything like that. I
> continue to maintain that any algorithm that needs to find loops is
> broken. But hey, maybe it is _my_ algorithm that is broken.
>
> Here's a more complex version:
>
> 	int test(int a, int b)
> 	{
> 		if (a > 10)
> 			goto inside;
> 	repeat:
> 		a += 1;
> 	r2:
> 		a += b;
> 	inside:
> 		if (a < b)
> 			goto repeat;
> 		if (a < 100)
> 			goto r2;
> 		return a + b;
> 	}
>
> becomes the following (this is actually without the phi-duplication, just
> to avoid the bloating of the code by the addition of lots of extra
> register copies):
>
> 	ENTRY:
> 	bb: 0xf7fa600c
> 	   test.c:1:5
> 	        %r2 <- setgt  %arg1, $10
> 	        br      %r2, .L0xf7fa6060, .L0xf7fa607c
>
> 	bb: 0xf7fa607c
> 	   test.c:5:1
> 	        %r17 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
> 	        %r4 <- add  %r17, $1
> 	        br      .L0xf7fa6098
>
> 	bb: 0xf7fa6098
> 	   test.c:7:1
> 	        %r18 <- phi (%r4, .L0xf7fa607c), (%arg1, .L0xf7fa600c)
> 	        %r7 <- add  %r18, %arg2
> 	        br      .L0xf7fa6060
>
> 	bb: 0xf7fa6060
> 	   test.c:4:8
> 	        %r19 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
> 	        %r10 <- setlt  %r19, %arg2
> 	        br      %r10, .L0xf7fa607c, .L0xf7fa60d0
>
> 	bb: 0xf7fa60d0
> 	   test.c:10:2
> 	        %r20 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
> 	        %r12 <- setlt  %r20, $100
> 	        br      %r12, .L0xf7fa6098, .L0xf7fa6124
>
> 	bb: 0xf7fa6124
> 	   test.c:1:5
> 	        %r21 <- phi (%arg1, .L0xf7fa600c), (%r7, .L0xf7fa6098)
> 	        %r15 <- add  %r21, %arg2
> 	        ret %r15
>
> and as far as I can tell, it's all correct.
>
> Anyway, my current code tries to actually do the right thing for
> structures and unions too, although FP unions will confuse it (it doesn't
> understand that you can't just shift bits there). And any slightly more
> complex cases will mean that it isn't able to remove all the loads and
> stores, but it should degrade fairly gracefully.
>
> Maybe.
>
> Tommy, I dare you to look at my code.
>
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>

-Chris

-- 
http://llvm.org/
http://nondot.org/sabre/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Thu, 11 Nov 2004 16:49:34 +0000
Message-ID: <Pine.LNX.4.58.0411110836450.2301 () ppc970 ! osdl ! org>
--------------------


On Thu, 11 Nov 2004, Chris Lattner wrote:
> 
> How well do you handle the loop in this testcase?

Note that I only (for now) do local symbols that don't have their address
taken, so no ambiguation or anything like that. Your test-case is pretty 
easy (famous last words - my linearization _looks_ correct, but I didn't 
walk through it 100%), though:

> #include <stdio.h>
> 
> typedef struct List {
>   struct List *Next;
>   int Data;
> } List;
> 
> List Node0 = {0, 5};
> List Node1 = {&Node0, 4};
> List Node2 = {&Node1, 3};
> List Node3 = {&Node2, 2};
> List Node4 = {&Node3, 1};
> List Node5 = {&Node4, 0};
> 
> void main() {
>     List *PrevL, *CurL;
>     for (PrevL = 0, CurL = &Node5; CurL; PrevL = CurL, CurL = CurL->Next)
>         printf("%d %d\n", CurL->Data, PrevL ? PrevL->Data : -1);
> }

becomes:

	ENTRY:
	bb: 0xf7fb600c
	   test.c:15:6
	        %r1 <- Node5
	        br      .L0xf7fb6028

	bb: 0xf7fb607c
	   test.c:17:10
	        %r16 <- phi (%r1, .L0xf7fb600c), (%r13, .L0xf7fb6044)
	        br      %r16, .L0xf7fb6028, .L0xf7fb60ec

	bb: 0xf7fb6028
	   test.c:17:10
	        %r3 <- "%d %d\n"
	        %r17 <- phi (%r1, .L0xf7fb600c), (%r13, .L0xf7fb6044)
	        load %r5 <- 4.0.32[%r17]
	        %r14 <- phi ($0, .L0xf7fb600c), (%r11, .L0xf7fb6044)
	        br      %r14, .L0xf7fb6098, .L0xf7fb6044

	bb: 0xf7fb6098
	   test.c:18:61
	        %r15 <- phi ($0, .L0xf7fb600c), (%r11, .L0xf7fb6044)
	        load %r8 <- 4.0.32[%r15]
	        br      .L0xf7fb6044

	bb: 0xf7fb6044
	   test.c:17:10
	        %r9 <- phi (%r8, .L0xf7fb6098), ($4294967295, .L0xf7fb60b4)
	        %r10 <- CALL printf:0xf7f66f10, %r3, %r5, %r9
	        load %r13 <- 0.0.32[%r1]
	        br      .L0xf7fb607c

	bb: 0xf7fb60ec
	   test.c:15:6
	        ret

was that what you expected?

(A load like "4.0.32[%r15]" just means that it's a 32-bit load at offset
4. Obviously, passing in "-m64" would do the right thing for a 64-bit
architecture. I'm going to simplify the load printout once I'm convinced I
do the right thing, right now it's printing out bit offsets and sizes just
to verify that it converted bitfield accesses into aligned ops right.  
The numbers should always be proper accesses with zero bit-offsets etc, so
the middle number _should_ always be zero, but right now it prints it out
for debugging, making the thing a bit less readable).

I have to admit that I'm actually impressed by how it noticed that %r1 
starts out non-NULL. It's doing a real optimization for the loop entry 
case. I knew it had the code in it, but it's kind of fun to see in real 
life.

Btw, this is obviously again with phi-expansion disabled: I disabled it
because it makes the result less readable, and my old expansion code only 
handled the case of phi-nodes at the start of a block anyway (which was 
what we used to generate until I did symbol conversion).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Thu, 11 Nov 2004 21:17:25 +0000
Message-ID: <Pine.LNX.4.58.0411111306490.2301 () ppc970 ! osdl ! org>
--------------------


On Thu, 11 Nov 2004, Linus Torvalds wrote:
>
> 	        %r14 <- phi ($0, .L0xf7fb600c), (%r11, .L0xf7fb6044)

This was bogus, because %r11 wasn't only written by a load that was 
removed by a later thing. There was a bug where the dominance-generated 
PHI nodes just didn't get the usage notes set right.

There was _another_ bug where I stopped checking for dominance too early,
which caused a load that was dominated by a later store in the same basic
block to not notice the dominance. Duh. I had it right earlier during
development, and then broke it by stupidity.

Anyway, the thing is slight more accurate now. I still don't claim it is 
_right_, but it definitely picked up a missing phi-node in the thing I 
posted earlier.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Sat, 13 Nov 2004 02:17:13 +0000
Message-ID: <Pine.LNX.4.58.0411121804400.4100 () ppc970 ! osdl ! org>
--------------------


Ok, I think I've fixed most bugs, and perhaps more interestingly, I 
slightly improved the dominance analysis so that I can track loads of 
globals and entries we take an address of too..

A silly example:

	extern int token;
        int i, j, k, l;
        i = token;
        l = 0;
        j = token;
        *p = 0;
        k = token;
        return i + j + k;

results in

        load %r1 <- 0.0.32[token:0xf7fd15f8]
        store $0 -> 0.0.32[%arg1]
        load %r4 <- 0.0.32[token:0xf7fd15f8]
        %r7 <- add  %r1, %r1
        %r9 <- add  %r7, %r4
	ret %r9

because it realizes that the assignment of "l" cannot alias "token", but
"*p" _can_. So it notices that the load of token into j is dominated by
the load of token into i, and just replaces j by i rather than loading it
anew.

The "alias" analysis isn't really any analysis at all, it really just
decides that "l" and "token" are different symbol accesses, while "*p"  
is a computed access. So any computed access will alias any symbol with
external visibility.

Right now I'm only looking at loads that are dominated by other loads or 
stores, so it only removes unnecessary memory reads, but maybe I'll make 
it kill dead writes too at some point.

				Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Mon, 15 Nov 2004 07:39:57 +0000
Message-ID: <20041115073957.GA957 () 64m ! dyndns ! org>
--------------------
That is really great progress.

I notices that it promote structure members as well even if the
structure address has been used.

struct abc {
	int a;
	int b;
};

void foo(struct abc *d)
{
	struct abc c;
	c.a = 1;
	c.b = 0;
	foo(&c);
}

will result in:

bb: 0x4005400c
   t/alias.c:6:6
        nop (%arg1 -> 0.0.32[d:0x4002f93c])
        nop ($1 -> 0.0.32[c:0x4002faa4])
        nop ($0 -> 4.0.32[c:0x4002faa4])
        %r1 <- c
        VOID <- CALL foo:0x4002f7d4, %r1
        ret
 
Chris


On Fri, Nov 12, 2004 at 06:17:13PM -0800, Linus Torvalds wrote:
> 
> 
> Ok, I think I've fixed most bugs, and perhaps more interestingly, I 
> slightly improved the dominance analysis so that I can track loads of 
> globals and entries we take an address of too..
> 
> A silly example:
> 
> 	extern int token;
>         int i, j, k, l;
>         i = token;
>         l = 0;
>         j = token;
>         *p = 0;
>         k = token;
>         return i + j + k;
> 
> results in
> 
>         load %r1 <- 0.0.32[token:0xf7fd15f8]
>         store $0 -> 0.0.32[%arg1]
>         load %r4 <- 0.0.32[token:0xf7fd15f8]
>         %r7 <- add  %r1, %r1
>         %r9 <- add  %r7, %r4
> 	ret %r9
> 
> because it realizes that the assignment of "l" cannot alias "token", but
> "*p" _can_. So it notices that the load of token into j is dominated by
> the load of token into i, and just replaces j by i rather than loading it
> anew.
> 
> The "alias" analysis isn't really any analysis at all, it really just
> decides that "l" and "token" are different symbol accesses, while "*p"  
> is a computed access. So any computed access will alias any symbol with
> external visibility.
> 
> Right now I'm only looking at loads that are dominated by other loads or 
> stores, so it only removes unnecessary memory reads, but maybe I'll make 
> it kill dead writes too at some point.
> 
> 				Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Mon, 15 Nov 2004 15:24:03 +0000
Message-ID: <20041115152403.GB957 () 64m ! dyndns ! org>
--------------------
On Mon, Nov 15, 2004 at 07:31:38AM -0800, Linus Torvalds wrote:
> 
> Fixed and checked in.
>

Yes, it works for my test case. But it still can't work on
stream_pos() in tokenize.c. Just run test-linearize tokenize.c
and look for the first function output.

There is no store. And I notice that stream_pos return a structure.

Chris 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Mon, 15 Nov 2004 15:31:38 +0000
Message-ID: <Pine.LNX.4.58.0411150719470.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Christopher Li wrote:
> 
> I notices that it promote structure members as well even if the
> structure address has been used.

Oh, fudge.

It has nothing to do with structure members (they've long since been
converted to a load off the "real" symbol). The same thing happens with a
perfectly simple scalar symbol.

It's the silly "kill local symbols" code that doesn't check for function
calls. Everybody else uses a fancy "does this instruction dominate that
instruction" function that does that correctly (famous last words), but
the exit case doesn't have an instruction to test, it just kills the
symbol, and I hadn't properly fixed that case.

So it completely overlooked the function call, and decided that the stores 
were dead.

Fixed and checked in.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Mon, 15 Nov 2004 19:18:08 +0000
Message-ID: <Pine.LNX.4.58.0411151110570.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Christopher Li wrote:
> 
> Yes, it works for my test case. But it still can't work on
> stream_pos() in tokenize.c. Just run test-linearize tokenize.c
> and look for the first function output.
> 
> There is no store.

Ahh. Different issue. It has (incorrectly) decided that the final load of
"pos" has no dominators, so it has replaced it with a undefined value (and 
the constant zero just happens to be the preferred "undefined value" 
because it's the easiest to generate ;)

Once that final load has been optimized away, the stores really _are_ 
dead. See the:

        nop (%r42 <- 0.0.64[pos:0xf7e82048])

which is the load for the return value.

So this is a different bug, not in store killing, but in the load for some 
reason not seeing its dominators. It is true that the load isn't dominated 
by any list of single stores, but the code should handle that, and realize 
that it has _partial_ dominance and cannot be optimized away (that's the 
"-1" case in the dominance analysis).

I'll see where that goes wrong.

> And I notice that stream_pos return a structure.

That's correct. A pseudo can contain a whole structure or a whole array. 
It is up to the code generator to determine how different types get 
returned. For example, small structures are often returned in registers, 
so we should _not_ assume that we should have a memory op in there.

In this case there should be a series of loads and stores, but that's just 
because of the _partial_ overlap. The logic for that obviously broken, 
right now.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Mon, 15 Nov 2004 19:41:20 +0000
Message-ID: <Pine.LNX.4.58.0411151133310.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Linus Torvalds wrote:
> 
> Ahh. Different issue. It has (incorrectly) decided that the final load of
> "pos" has no dominators, so it has replaced it with a undefined value (and 
> the constant zero just happens to be the preferred "undefined value" 
> because it's the easiest to generate ;)

Duh. Another totally idiotic case where I handed partial dominance in
another case, but _not_ in the case of the dominance being in the same
basic block (there I just said "set dominance to zero, and continue to
look for more dominating stores").

> Once that final load has been optimized away, the stores really _are_ 
> dead.

Fixing the load does indeed fix the stores too. Here's what linearize does 
to "stream_pos()" now:

	ENTRY:
	bb: 0xf7f8600c
	   tokenize.c:40:17
	  **phi source %r42**
	        %r2 <- and  $0, $0xffffffc0
	        %r3 <- or  $0, %r2
	        load %r5 <- 20.0.32[%arg1]
	        %r6 <- CAST(32->10) %r5
	        %r7 <- shl  %r6, $6
	        %r9 <- and  %r3, $0xffff003f
	        %r10 <- or  %r3, %r9
	        load %r12 <- 24.0.32[%arg1]
	        %r13 <- CAST(32->1) %r12
	        %r14 <- shl  %r13, $16
	        %r16 <- and  %r10, $0xfffeffff
	        %r17 <- or  %r10, %r16
	        load %r19 <- 28.0.32[%arg1]
	        %r20 <- CAST(32->1) %r19
	        %r21 <- shl  %r20, $17
	        %r23 <- and  %r17, $0xfffdffff
	        %r24 <- or  %r17, %r23
	        load %r26 <- 12.0.32[%arg1]
	        %r27 <- CAST(32->14) %r26
	        %r28 <- shl  %r27, $18
	        %r30 <- and  %r24, $0x3ffff
	        %r31 <- or  %r24, %r30
	        store %r31 -> 0.0.32[pos:0xf7e82048]
	        load %r33 <- 16.0.32[%arg1]
	        %r34 <- CAST(32->31) %r33
		%r36 <- and  $0, $0x80000000
	        %r37 <- or  $0, %r36
	        %r38 <- shl  $0, $31
	        %r40 <- and  %r37, $0x7fffffff
	        %r41 <- or  %r37, %r40
	        store %r41 -> 4.0.32[pos:0xf7e82048]
	        load %r42 <- 0.0.64[pos:0xf7e82048]
	        ret %r42


Note the perfect pattern of loads and stores: we literally do just _two_
32-bit stores to generate the 64-bit structure, even though there are
_seven_ assignments to bitfields in the source. The rest have been all
optimized away as being overlapping. The only ones that couldn't be
removed are the partially overlapping cases (ie the sub-words of the
word).
	
		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 07:49:44 +0000
Message-ID: <20041116074944.GB16642 () 64m ! dyndns ! org>
--------------------
Nice, this is getting better and better.

#include <stdio.h>

int main(void)
{
	int i;
	for (i=0; i< 3; i++)
		printf("%d\n", i);
}

I do a simple loop as input file.
test-linearize output: (I delete the non instruction output)
bb: 0x4004400c
        nop ($0 -> 0.0.32[i:0x4009f48c])
        br      .L0x4004408c
 
bb: 0x4004408c
        %r8 <- phi ($0, .L0x4004400c), (%r7, .L0x4004404c)
        %r2 <- setlt  %r8, $3
        br      %r2, .L0x4004402c, .L0x4004406c
 
bb: 0x4004402c
        %r3 <- "%d\n"
        %r9 <- phi ($0, .L0x4004400c), (%r7, .L0x4004404c)
        %r5 <- CALL printf:0x4009478c, %r3, %r9
        br      .L0x4004404c
 
bb: 0x4004404c
        %r10 <- phi ($0, .L0x4004400c), (%r7, .L0x4004404c)
        %r7 <- add  %r10, $1
        nop (%r7 -> 0.0.32[i:0x4009f48c])
        br      .L0x4004408c
 
bb: 0x4004406c
        ret VOID

Notice that the %r9 and %r10 phi node should get replaced by
the %r8. Because only the block contain %r8 can be reached
by the block in phi list(4004400c and 400ff04c). That is not
the case for %r9 and %r10.

And %r9 and %r10 is dominate by %r8. Replace them to %r8 get
a very good results.

Chris

On Mon, Nov 15, 2004 at 11:41:20AM -0800, Linus Torvalds wrote:
> 
> Note the perfect pattern of loads and stores: we literally do just _two_
> 32-bit stores to generate the 64-bit structure, even though there are
> _seven_ assignments to bitfields in the source. The rest have been all
> optimized away as being overlapping. The only ones that couldn't be
> removed are the partially overlapping cases (ie the sub-words of the
> word).
> 	
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 14:16:53 +0000
Message-ID: <20041116141653.GC16642 () 64m ! dyndns ! org>
--------------------
I consider symbol to pseudo conversion is a different task than
CSE. You shouldn't need CSE in the conversion.
It is just a SSA from conversion algorithm.

I think what we need is that find out all the blocks that
define the value(store). Then find out the Dominance Frontier
of those blocks. Insert phi node there.

Then all the load should use its dominator pseudo which is
a store or a phi node.

I am sure I omit the detail like unreachable blocks and
undefined values. You get the idea.

Chris

On Tue, Nov 16, 2004 at 07:41:46AM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 16 Nov 2004, Christopher Li wrote:
> > 
> > Notice that the %r9 and %r10 phi node should get replaced by
> > the %r8.
> 
> Yes. However, you can do this two ways:
> 
>  - by noticing that loads dominate the loads. I actually _do_ this 
>    already, but by the time we get to the second load, I've converted the 
>    first load into a phi-node, so the second load doesn't actually _see_ 
>    the first load that dominates it, so it has to search upwards for the
>    same stores that dominated the first one.
> 
>    Even if we do this, we'll have other cases where we miss things. I 
>    tried converting the loads in reverse order, that changed some things
>    but really not anything interesting. So that looks like a dead end.
> 
>  - Do CSE. We do need to do CSE anyway, and it would find this, among 
>    other things, automatically. CSE is reasonably easy on SSA output, you 
>    just compare for instruction equality (and you can do it reasonably 
>    efficiently by hashing them), and then verify reachability (and avoid
>    instructions with side effects, ie non-const calls and stores).
> 
> Anybody?
> 
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 14:26:43 +0000
Message-ID: <20041116142643.GD16642 () 64m ! dyndns ! org>
--------------------
We need to treat load and store dominance differently.
The load dominance you describe is indeed dominance by
the phi node.

In this case, we don't need a phi node at all so the
load dominance doesn't apply.

So this is trivial for the algorithm I describe. 
The second store dominance all the block follows it.
And there is no more new store. So no dominance frontier.
end of story.

Chris
 

On Tue, Nov 16, 2004 at 08:32:57AM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 16 Nov 2004, Linus Torvalds wrote:
> > 
> > I guess doing load dominance checking in reverse order from how we
> > linearized them is more _likely_ to find these cases in general, and it
> > doesn't really matter from any other standpoint, so I'll just check it in.
> 
> Something just struck me. The load dominance helps a lot for a (fairly 
> common) case where the loads dominate completely. But if we have an 
> incomplete dominance, ie
> 
> 	i = 0;
> 	i = 8;
> 	if (xxx)
> 		fn(i);
> 	fn2(i);
> 
> then we now have the sad case that we'll see the second load of "i" (in
> the fn2() argument) dominated by both the first load of "i" in the first
> fn() argument) _and_ the store of "i" (it needs two assignments, because 
> otherwise the optimization with a single assignment kicks in and does the 
> right thing automatically ;).
> 
> The code is not clever enough to realize that sometimes load dominance
> checking is a bad thing if it's partial. That may be why my earlier tests
> showed that it wasn't worth doing in reverse - I didn't look closer at
> _why_ I got lots of phi-nodes.
> 
> I don't know how others do this: one option is to allow dominating loads
> only for the trivial "single parent" case, another option is to just sort
> it out later by trivially expanding the phi recursively and noticing that
> it all boils down to one thing.
> 
> Comments?
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 15:23:22 +0000
Message-ID: <20041116152322.GE16642 () 64m ! dyndns ! org>
--------------------
On Tue, Nov 16, 2004 at 10:03:07AM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 16 Nov 2004, Christopher Li wrote:
> >
> > I consider symbol to pseudo conversion is a different task than
> > CSE. You shouldn't need CSE in the conversion.
> > It is just a SSA from conversion algorithm.
> 
> No, no, I'm not suggesting doing CSE in the conversion. I'm suggesting 
> _not_ doing anything special in the conversion, and just depending on CSE 
> to fix it up.

It is still tempting to do it right here to make it friendly to emit asm
code. CSE is a big and complicate thing. I prefer baby steps.

> 
> > I think what we need is that find out all the blocks that
> > define the value(store). Then find out the Dominance Frontier
> > of those blocks. Insert phi node there.
> 
> I'm not a huge fan of that approach. We do want to do CSE _anyway_, and 
> I find my current dominance analysis very simple and readable. Stupid, 
> yes, but stupid is _good_.

What you have is already very close. We don't need to rewrite the
whole thing. Back up to the before REVERSE code ( I haven't follow your
reverse check in this morning). We just need to find out which phi node
is dominance frontier. Then convert the rest of the phi node using
dominance. I think we only need to look for phi node dominator.

> 
> So "stupid + CSE" gives us everything that "smart" would have given us, 
> and since "smart" needs CSE anyway for other things, I don't see the 
> advantage of trying to be smart. I've looked at some of the papers, and 
> quite frankly, they make my brain hurt.

Well, it is more friendly to emit back end code.
And Yes, that is what paper is designed for, maximum brain damage :-)

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 15:41:46 +0000
Message-ID: <Pine.LNX.4.58.0411160732050.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Christopher Li wrote:
> 
> Notice that the %r9 and %r10 phi node should get replaced by
> the %r8.

Yes. However, you can do this two ways:

 - by noticing that loads dominate the loads. I actually _do_ this 
   already, but by the time we get to the second load, I've converted the 
   first load into a phi-node, so the second load doesn't actually _see_ 
   the first load that dominates it, so it has to search upwards for the
   same stores that dominated the first one.

   Even if we do this, we'll have other cases where we miss things. I 
   tried converting the loads in reverse order, that changed some things
   but really not anything interesting. So that looks like a dead end.

 - Do CSE. We do need to do CSE anyway, and it would find this, among 
   other things, automatically. CSE is reasonably easy on SSA output, you 
   just compare for instruction equality (and you can do it reasonably 
   efficiently by hashing them), and then verify reachability (and avoid
   instructions with side effects, ie non-const calls and stores).

Anybody?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 16:11:14 +0000
Message-ID: <Pine.LNX.4.58.0411160805061.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Linus Torvalds wrote:
> 
>  - by noticing that loads dominate the loads. I actually _do_ this 
>    already, but by the time we get to the second load, I've converted the 
>    first load into a phi-node, so the second load doesn't actually _see_ 
>    the first load that dominates it, so it has to search upwards for the
>    same stores that dominated the first one.
> 
>    Even if we do this, we'll have other cases where we miss things. I 
>    tried converting the loads in reverse order, that changed some things
>    but really not anything interesting. So that looks like a dead end.

Note that for your particular example, just doing the load testing in the
reverse order _does_ actually find this load-load dominance, and just
making the loop that does "find_dominating_stores()" use the _REVERSE
version generates:

        ENTRY:
        bb: 0xf7fb600c
          **phi source $0**
                br      .L0xf7fb608c

        bb: 0xf7fb608c
          **phi source %r8**
                %r8 <- phi ($0, .L0xf7fb600c), (%r7, .L0xf7fb604c)
                %r2 <- setlt  %r8, $3
                br      %r2, .L0xf7fb602c, .L0xf7fb606c

        bb: 0xf7fb602c
          **phi source %r8**
                %r3 <- "%d\n"
                %r5 <- CALL printf:0xf7f66f10, %r3, %r8
                br      .L0xf7fb604c

        bb: 0xf7fb604c
          **phi source %r7**
                %r7 <- add  %r8, $1
                br      .L0xf7fb608c

        bb: 0xf7fb606c
                ret VOID

ie there is only one phi-node, and the other uses noticed the dominance of 
the original load and just used that value instead.

I guess doing load dominance checking in reverse order from how we
linearized them is more _likely_ to find these cases in general, and it
doesn't really matter from any other standpoint, so I'll just check it in.

But be aware that while it happens to catch things on your trivial
test-case, there are other cases where it won't work as well, and doing
proper CSE is still called for.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 16:32:57 +0000
Message-ID: <Pine.LNX.4.58.0411160816070.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Linus Torvalds wrote:
> 
> I guess doing load dominance checking in reverse order from how we
> linearized them is more _likely_ to find these cases in general, and it
> doesn't really matter from any other standpoint, so I'll just check it in.

Something just struck me. The load dominance helps a lot for a (fairly 
common) case where the loads dominate completely. But if we have an 
incomplete dominance, ie

	i = 0;
	i = 8;
	if (xxx)
		fn(i);
	fn2(i);

then we now have the sad case that we'll see the second load of "i" (in
the fn2() argument) dominated by both the first load of "i" in the first
fn() argument) _and_ the store of "i" (it needs two assignments, because 
otherwise the optimization with a single assignment kicks in and does the 
right thing automatically ;).

The code is not clever enough to realize that sometimes load dominance
checking is a bad thing if it's partial. That may be why my earlier tests
showed that it wasn't worth doing in reverse - I didn't look closer at
_why_ I got lots of phi-nodes.

I don't know how others do this: one option is to allow dominating loads
only for the trivial "single parent" case, another option is to just sort
it out later by trivially expanding the phi recursively and noticing that
it all boils down to one thing.

Comments?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 18:03:07 +0000
Message-ID: <Pine.LNX.4.58.0411160959330.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Christopher Li wrote:
>
> I consider symbol to pseudo conversion is a different task than
> CSE. You shouldn't need CSE in the conversion.
> It is just a SSA from conversion algorithm.

No, no, I'm not suggesting doing CSE in the conversion. I'm suggesting 
_not_ doing anything special in the conversion, and just depending on CSE 
to fix it up.

> I think what we need is that find out all the blocks that
> define the value(store). Then find out the Dominance Frontier
> of those blocks. Insert phi node there.

I'm not a huge fan of that approach. We do want to do CSE _anyway_, and 
I find my current dominance analysis very simple and readable. Stupid, 
yes, but stupid is _good_.

So "stupid + CSE" gives us everything that "smart" would have given us, 
and since "smart" needs CSE anyway for other things, I don't see the 
advantage of trying to be smart. I've looked at some of the papers, and 
quite frankly, they make my brain hurt.

It looks like an academic wrote them, not a programmer. Why am I not
horribly surprised?

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Tue, 16 Nov 2004 19:53:06 +0000
Message-ID: <Pine.LNX.4.58.0411161151100.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Christopher Li wrote:
> 
> What you have is already very close. We don't need to rewrite the
> whole thing. Back up to the before REVERSE code ( I haven't follow your
> reverse check in this morning).

The reverse thing literally didn't change any code at all, it just changes 
the order that we do the dominance finding in (ie we start with the _last_ 
load we linearized, instead of with the first one).

I've done a few cleanups since, like noticing when we find the same store
as the dominant store along all the different paths we took, and
simplifying that case (no need to do a phi-node, just use the value
directly). But the algorithm hasn't changed.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Wed, 17 Nov 2004 15:51:34 +0000
Message-ID: <20041117155134.GC15093 () 64m ! dyndns ! org>
--------------------
What is the new test case to break it?

Your previous partial domination example seems works correctly
for me.

Chris

On Tue, Nov 16, 2004 at 11:53:06AM -0800, Linus Torvalds wrote:
> 
> The reverse thing literally didn't change any code at all, it just changes 
> the order that we do the dominance finding in (ie we start with the _last_ 
> load we linearized, instead of with the first one).
> 
> I've done a few cleanups since, like noticing when we find the same store
> as the dominant store along all the different paths we took, and
> simplifying that case (no need to do a phi-node, just use the value
> directly). But the algorithm hasn't changed.
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Doing real symbol->pseudo conversion.
Date: Wed, 17 Nov 2004 21:41:21 +0000
Message-ID: <Pine.LNX.4.58.0411171322140.2222 () ppc970 ! osdl ! org>
--------------------


On Wed, 17 Nov 2004, Christopher Li wrote:
>
> What is the new test case to break it?
> 
> Your previous partial domination example seems works correctly
> for me.

Oh, it seems to be pretty correct (I'm not going to say bug-free, I've 
just had too many total brainos over the last few days ;), but it's 
certainly very easy to make it generate lots of unnecessary phi-nodes with 
the right patterns.

Not _wrong_ phi-nodes, mind you, just unnecessary ones due to not noticing 
that they are the same because the loads got coverted into phi-nodes in 
a less than optimal order.

The most trivial example is a totally made-up-one:


	void fn(int);

	int main(int argc)
	{
		/*
		 * This just makes us have two assignments to argc,
		 * to kick in the "complex" case. Assignment #1 is
		 * the implicit argument value assignment, of course.
		 */
		if (!argc)
			argc++;
		goto end;
	back:
		return argc;
	end:
		fn(argc);
		goto back;
	}

and notice how when we linearize this, we won't notice that the read of 
"argc" in the function call dominates the read of "argc" in the return 
statement (because we convert the function call argument _first_), so we 
will generate two phi-nodes that look exactly the same.

Again, my argument is that CSE takes care of it, and since _usually_ a
load is dominated by a load that was linearized previously, and we get
that case right anyway, my stupid brute-force algorithm is fine. It's
certainly a lot simpler than trying to figure out dominance frontiers and
trying to always put the phi-nodes at the "optimal" point.

At least it's simpler on my poor brain. My phi-replacement really _is_
very simple, since they are always replaced 1:1 with the loads that caused
them (and obviously quite often, I can just nop out the load entirely and
just do a pseudo replacement instead).

The thing that struck me is how often we seem to have the _really_ simple 
case with just a single assignment to a symbol. There's a lot of code like 
that, and then the dominance algorithm doesn't ever even trigger for that 
symbol. I was hitting my head against the wall trying to figure out why I 
couldn't make a bug that I knew about happen, until I noticed that all the 
test-cases I had written to try to catch it all had just a single 
assignment in it, and thus the bug would never trigger ;)

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: FW: [PATCH] Altix system controller communication driver ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: FW: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 06:12:29 +0000
Message-ID: <Pine.LNX.4.58.0407292306170.9073 () ppc970 ! osdl ! org>
--------------------


On Fri, 30 Jul 2004, Sam Ravnborg wrote:
>
> Any of you sparsers that can help Greg?

Hmm.. I don't understand the problem?

From: Greg Howard <ghoward@sgi.com>
> 
> FWIW I looked through a couple of other drivers (and ran them through
> sparse to see what would happen), and I discovered that I seem to be
> in good company as far as this is concerned...  Are there any examples
> of a use of copy_{to,from}_user() that use char* parameters (perhaps
> cast to something else), but don't cause sparse to complain?

By definition, you can't use "copy_to/from_user()" with a char * 
parameter, since that is a kernel pointer. So I don't understand the 
question/issue.

There are certainly drivers that still have tons of missing annotations, 
although they are getting cut down by Al at a fairly rapid pace.

What is it you want to do? The _right_ thing to do is to just annotate
user pointers (through the whole chain of command) properly, and sparse
will definitely stop complaining.

If you have good reason, you can cast pointers, but they had better be 
properly cast. There's some examples in the form of

	void __user * ptr;

	set_fs(KERNEL_DS);
	/* The __user pointer cast is valid because of set_fs() */
	ptr = (void __user *) data;
	do_something(ptr);
	set_fs(USER_DS);

but quite frankly, that should be minimized. Passing kernel pointers as 
user pointers is generally a bad idea.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: FW: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 06:22:52 +0000
Message-ID: <Pine.LNX.4.58.0407292314070.9073 () ppc970 ! osdl ! org>
--------------------


On Thu, 29 Jul 2004, Linus Torvalds wrote:
> 
> Hmm.. I don't understand the problem?

Oh, I note that ia64 doesn't seem to support __user things at _all_ right 
now, is that right? Is Greg trying to make sparse usable on ia64? If so, 
it just needs having the put_user/get_user macros have the same user 
pointer checks, and all the function declarations need to be fixed too.

For these kinds of things where the code really knows about user pointers 
and does the right thing, there is also a few special things that sparse 
does to help an architecture implement the "copy_to_user()" stuff. For 
example, you can make sparse drop the address space information without 
complaining, by using the "force" attribute when casting. So

	void *ptr;
	void __user *uptr;

	...
	ptr = (__force void *) uptr;

will not cause a warning, exactly because you are telling sparse that this 
code knows what it is doing, and that a cast that removes address space 
info is actually ok in this situation.

The "__force" thing should not normally be used anywhere else, though. It
really totally disables any type casting warnings that sparse might
otherwise come up with, and thus totally kills type safety. So it is valid
only in situations where you know that the function is able to handle
_both_ user and kernel pointers, and it's thus valid to remove the address
space. 

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: sam () ravnborg ! org
To: linux-sparse
Subject: Re: FW: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 07:31:31 +0000
Message-ID: <20040730073131.8E80915C24 () post1 ! dk>
--------------------
Date: Tor, 29 Jul 2004 23:22:52 -0700 (PDT) skrev Linus Torvalds <torvalds@osdl.org> : 

>
>
>On Thu, 29 Jul 2004, Linus Torvalds wrote:
>> 
>> Hmm.. I don't understand the problem?
>
>Oh, I note that ia64 doesn't seem to support __user things at _all_
>right now, is that right? Is Greg trying to make sparse usable on ia64?

My bad. I requested Greg to run sparse on a newly submitted driver without realising ia64 dot yet have the stuff in place to do so.

Sorry for the confusion.

     Sam [via webmail]
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: sam () ravnborg ! org
To: linux-sparse
Subject: Re: FW: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 07:32:09 +0000
Message-ID: <20040730073209.DD19715C28 () post1 ! dk>
--------------------
Date: Tor, 29 Jul 2004 23:22:52 -0700 (PDT) skrev Linus Torvalds <torvalds@osdl.org> : 

>
>
>On Thu, 29 Jul 2004, Linus Torvalds wrote:
>> 
>> Hmm.. I don't understand the problem?
>
>Oh, I note that ia64 doesn't seem to support __user things at _all_
>right now, is that right? Is Greg trying to make sparse usable on ia64?

My bad. I requested Greg to run sparse on a newly submitted driver without realising ia64 dot yet have the stuff in place to do so.

Sorry for the confusion.

     Sam [via webmail]
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Greg Howard <ghoward () sgi ! com>
To: linux-sparse
Subject: Re: FW: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 15:16:39 +0000
Message-ID: <Pine.SGI.4.58.0407300947480.4233 () gallifrey ! americas ! sgi ! com>
--------------------
On Fri, 30 Jul 2004 sam@ravnborg.org wrote:

> >On Thu, 29 Jul 2004, Linus Torvalds wrote:
> >>
> >> Hmm.. I don't understand the problem?
> >
> >Oh, I note that ia64 doesn't seem to support __user things at _all_
> >right now, is that right? Is Greg trying to make sparse usable on ia64?
>
> My bad. I requested Greg to run sparse on a newly submitted driver without realising ia64 dot yet have the stuff in place to do so.
>
> Sorry for the confusion.
>
>      Sam [via webmail]
>

Thanks Sam.


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: FW: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 16:44:43 +0000
Message-ID: <Pine.LNX.4.58.0407300932140.9073 () ppc970 ! osdl ! org>
--------------------


On Fri, 30 Jul 2004, Greg Howard wrote:
> 
> From what Linus said, I'm still not sure I got everything just right,
> though.  To make the question a little more clear, here's the relevant
> bit of code:
> 
> static ssize_t
> scdrv_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
> {
> . . .
> 		/* (sd->sd_rb is a char*) */
> 		if (copy_to_user(buf, sd->sd_rb, len))
> 			return -EFAULT;

This is correct, and everything looks fine. I bet you do _not_ get any 
warnings for it on any of the architectures where sparse has been already 
set up. "buf" is a user pointer, and "sd->sd_rb" is a kernel pointer, and 
everything looks ok.

> (There's a symmetrical copy_from_user() call in the corresponding
> _write() function of course.)  Here's sparse's complaint:
> 
> 
> drivers/char/snsc.c:340:7: warning: incorrect type in initializer (different address spaces)
> drivers/char/snsc.c:340:7:    expected void *__cu_to
> drivers/char/snsc.c:340:7:    got char [noderef] *buf<asn:1>
> drivers/char/snsc.c:340:7: warning: shift too big for type (480)

This is because the ia64 <asm/uaccess.h> file defines copy_to_user() as:

	#define copy_to_user(to, from, n)       __copy_tofrom_user((to), (from), (n), 1)

and then does

	#define __copy_tofrom_user(to, from, n, check_to)                                       \
	({                                                                                      \
	        void *__cu_to = (to);                                                           \
	        const void *__cu_from = (from);                                                 \
	        long __cu_len = (n);                                                            \
		.....

so the warning comes when the macro is expanded, and the code sees:

	void *__cu_to = (buf);

and sparse is unhappy that it is trying to assign a user pointer to a
regular pointer variable.

The fix is to make copy_to_user() look something like this:

	static inline unsigned long copy_to_user(
			void __user *to,
			const void *from,
			unsigned long n)
	{
		return __copy_tofrom_user((__force void *) to, from, n, 1);
	}

instead. Same goes for copy_from_user (different argument that needs to be 
cast, of course), etc. It's not a huge amount of work, but you need to be 
careful. 

You can also use macro's instead of inline functions, but then (because 
macros have no type checking and we _want_ to see errors if somebody 
passes a kernel pointer instead of a user-pointer) you should use the 
__chk_user_ptr() macro that does the warning for you.

Oh, and one more thing: since ia64 is a 64-bit architecture, you need to
tell sparse about that too, using the "-m64" switch, and you need to
pre-define whatever ia64 architecture defines. That's most easily done by
having

	CHECK := $(CHECK) -m64 -D__IA64__

(or whatever the defines are) in the arch/ia64/Makefile.

If you are a BK user, you could look at what the other architectures have 
done. For example, just do

	bk revtool include/asm-ppc64/uaccess.h

and look over the last five changes to that file, which are all about 
adding the proper __user annotations (and then cleaning them up and making 
the code catch more of the type errors).

> I would assume that the "shift too big" is an ia64 issue with sparse,

That's because sparse defaults to a 32/32/32 setup, and thus thinks that 
your "unsigned long" is 32-bit, and warns when the shift overflows.

The "-m64" flag will fix that. See above.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: First Class Types in C ===

From: tommy () numba-tu ! com
To: linux-sparse
Subject: First Class Types in C
Date: Thu, 25 Mar 2004 22:42:26 +0000
Message-ID: <6573.65.113.40.130.1080254546.squirrel () numba-tu ! com>
--------------------
> In other words, I wanted to be able to do something like this
>
> 	#define format(x) 				\
> 		(typeof(x) == int ? "%d" :		\
> 		 typeof(x) == long ? "%ld" : "%x")
>
> 	#define print(x) printf(format(x),x)
>
> and it should just work (and work even if "int" and "long" happen to be
> the same size).
>
> Now, the above doesn't actually work right now, for a silly reason: the
> "(typeof(x)" thing is parsed as a cast, and then the code is unhappy about
> not getting the ending ")". In other cases the "typeof" is expected to be
> the start of a variable declaration, not an expression. But both those
> cases can be worked around with a strange syntactic trick:
>
> 	#define format(x)				\
> 		(0, typeof(x) == int ? "%d" :		\

I wouldn't call it silly.  The syntax of C was never designed for this
abuse, witness the similar trouble that sizeof (type) faces vs. sizeof
var.  I think you might end up confusing the user, compiler, and parse
error messages.  Wouldn't keeping the types inside parens make everything
fit much
better with the syntax (as we already do this for casts and sizeof (type))?

First class types are great (and you're only licking the surface here). 
This could really be a killer feature.


> I really want to work is something like
>
> 	static inline max(a,b)
> 	{
> 		if (typeof(a) != typeof(b))
> 			__compile_time_warning();
> 		return a > b ? a : b;
> 	}

Pray do this the correct way and not some hack.  What you're asking for is
automatically inferred polymorphic types.  I'm a great fan of polymorphic
type systems (and all kinds of higher-order type systems), but I'm not
sure I'd recommending it as it generally gets really tricky to retrofit to
a language like C.  (And I do have experience implementing such type
inference).

Generic types(*) is an alternative approach here that might be easier to
realize and fit better with your 1st class types.  Here's one idea:
introduce type parameters, either via new syntax or overloading the
existing.  For example,

 	static inline t max(type t, t a, t b)
 	{
 		return a > b ? a : b;
 	}

or you could use C++ template style syntax.

> where all argument types are inherited from the context of the calling
> process (I may have problems with the return type, sadly).
>
> Cool, or crazy.. You decide.

IMO, very cool, but I'd be sad to see a hacking limited implementation.

All just IMO,

  Tommy
(*): C++ templates is a very limited (and IMNSHO ugly) version of generic
types.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: tommy () numba-tu ! com
To: linux-sparse
Subject: Re: First Class Types in C
Date: Thu, 25 Mar 2004 23:05:19 +0000
Message-ID: <20048.65.113.40.130.1080255919.squirrel () numba-tu ! com>
--------------------
Let me follow up to my own mail so I can pretends my ideas are great (not).

> Here's one idea: introduce type parameters, either via new syntax or
> overloading the existing.  For example,
>
>  	static inline t max(type t, t a, t b)
>  	{
>  		return a > b ? a : b;
>  	}

D'oh!  That would be even harder to parse.  It would probably be better to
introduce new syntax.

/Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: First Class Types in C
Date: Fri, 26 Mar 2004 05:49:07 +0000
Message-ID: <Pine.LNX.4.58.0403251454080.1106 () ppc970 ! osdl ! org>
--------------------


On Thu, 25 Mar 2004 tommy@numba-tu.com wrote:
>
> Wouldn't keeping the types inside parens make everything fit much
> better with the syntax (as we already do this for casts and sizeof (type))?

No, that wouldn't really help. In fact, it's unparseable that way, ie

	(type)+val

could be either a cast of a prefix expression or a strange binary plus
expression. And I am _not_ a believer in adding magic parse rules to avoid
that kind of ambiguity.

I know the syntax stinks, and I haven't decided on what to do yet about
specifying a type expression. What would be simple and fairly readable
would be to have type expressions always be inside brackets, that has no
ambiguities (since an array dereference is always a postfix expression).  
So such a syntax might look like

	if ([typeof(a)] != [int])
		...

> Pray do this the correct way and not some hack.  What you're asking for is
> automatically inferred polymorphic types.  I'm a great fan of polymorphic
> type systems (and all kinds of higher-order type systems), but I'm not
> sure I'd recommending it as it generally gets really tricky to retrofit to
> a language like C.  (And I do have experience implementing such type
> inference).

I don't think I agree. I actually already had a version of sparse that I 
never committed that allowed "type variables", ie you could at least 
syntactically do

	__type__ a = int;

and it would parse correctly (well, with the bracket format it would have 
to be "__type__ a = [int];"). However, it would be crazy to try to make 
this a dynamic type system, so it literally would have to be a case where 
the only assignment that is acceptable is as an initializer, and quite 
frankly, if you do that, then it's really nothing else than syntactic 
sugar for "typedef" (ie in my tree it ended up being _exactly_ the same as 
just saying

	typedef int a;

and thus pointless).

And I don't want truly dynamic types - I want stuff that is obviously 
statically deterministic at all times.

> IMO, very cool, but I'd be sad to see a hacking limited implementation.

Well, I like the "limited" part. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: First Class Types in C
Date: Fri, 26 Mar 2004 08:38:27 +0000
Message-ID: <4063EC03.7090700 () numba-tu ! com>
--------------------

>So such a syntax might look like
>
>	if ([typeof(a)] != [int])
>		...
>  
>
That would work. And it's obvious that something out of the ordinary is 
going on.

>And I don't want truly dynamic types - I want stuff that is obviously 
>statically deterministic at all times.
>  
>
Heh, if it had dynamic types then it would hardly be C anymore :-)

Tommy



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: hpa () zytor ! com (H !  Peter Anvin)
To: linux-sparse
Subject: Re: First Class Types in C
Date: Wed, 07 Apr 2004 06:56:35 +0000
Message-ID: <c508n3$5kr$1 () terminus ! zytor ! com>
--------------------
Followup to:  <20048.65.113.40.130.1080255919.squirrel@numba-tu.com>
By author:    tommy@numba-tu.com
In newsgroup: linux.dev.sparse
>
> Let me follow up to my own mail so I can pretends my ideas are great (not).
> 
> > Here's one idea: introduce type parameters, either via new syntax or
> > overloading the existing.  For example,
> >
> >  	static inline t max(type t, t a, t b)
> >  	{
> >  		return a > b ? a : b;
> >  	}
> 
> D'oh!  That would be even harder to parse.  It would probably be better to
> introduce new syntax.
> 

How about:

template <class T> static inline T max(T a, T b)
{
	return a > b ? a : b;
}

..<ducks>...

	-hpa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: hpa () zytor ! com (H !  Peter Anvin)
To: linux-sparse
Subject: Re: First Class Types in C
Date: Wed, 07 Apr 2004 06:56:35 +0000
Message-ID: <c508n3$5kr$1 () terminus ! zytor ! com>
--------------------
Followup to:  <20048.65.113.40.130.1080255919.squirrel@numba-tu.com>
By author:    tommy@numba-tu.com
In newsgroup: linux.dev.sparse
>
> Let me follow up to my own mail so I can pretends my ideas are great (not).
> 
> > Here's one idea: introduce type parameters, either via new syntax or
> > overloading the existing.  For example,
> >
> >  	static inline t max(type t, t a, t b)
> >  	{
> >  		return a > b ? a : b;
> >  	}
> 
> D'oh!  That would be even harder to parse.  It would probably be better to
> introduce new syntax.
> 

How about:

template <class T> static inline T max(T a, T b)
{
	return a > b ? a : b;
}

..<ducks>...

	-hpa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: Fix error() argument ===

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Fix error() argument
Date: Mon, 01 Nov 2004 15:39:59 +0000
Message-ID: <20041101153959.GA28876 () iam ! uni-bonn ! de>
--------------------
Cast pointer difference to int for vararg function.

diff -u sparse-bk/tokenize.c new/tokenize.c
--- sparse-bk/tokenize.c	2004-11-01 16:34:42.000000000 +0100
+++ new/tokenize.c	2004-11-01 16:35:20.000000000 +0100
@@ -419,7 +419,7 @@
 
 	if (p == buffer_end) {
 		error(stream->pos, "number token exceeds %d characters",
-		      buffer_end - buffer);
+		      (int)(buffer_end - buffer));
 		// Pretend we saw just "1".
 		buffer[0] = '1';
 		p = buffer + 1;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Fix error() argument
Date: Mon, 01 Nov 2004 18:00:04 +0000
Message-ID: <Pine.LNX.4.58.0411010951290.28839 () ppc970 ! osdl ! org>
--------------------


On Mon, 1 Nov 2004, Ralf Wildenhues wrote:
>
> Cast pointer difference to int for vararg function.

I'd prefer to just fix the printf instead. Pointer differences are 
ptrdiff_t, and I think the right modifier combination is "%td".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Floating point constants with multiple dots ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Floating point constants with multiple dots
Date: Thu, 15 Jul 2004 20:26:24 +0000
Message-ID: <20040715202624.B25E01422D53 () darter ! rentec ! com>
--------------------

Currently sparse allows the concatenation of "." with a number starting
with a digit.  [The test for digitness is wrong, see my previous patches,
but that is not important right now.]

    "." ## "2.123" --> ".2.123"

whatever that means.  Who should catch that kind of nonsense?

Morten



> cat foo.c
#define CONCAT(x,y) x##y
double x = CONCAT(.,2.123);
> ./check foo.c
foo.c:2:12: warning: FP values not yet implemented
> gcc -c -O2 -Wall foo.c
foo.c:2: malformed floating constant
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Floating point constants with multiple dots
Date: Thu, 15 Jul 2004 20:50:18 +0000
Message-ID: <Pine.LNX.4.58.0407151346180.20824 () ppc970 ! osdl ! org>
--------------------


On Thu, 15 Jul 2004, Morten Welinder wrote:
> 
> Currently sparse allows the concatenation of "." with a number starting
> with a digit.  [The test for digitness is wrong, see my previous patches,
> but that is not important right now.]
> 
>     "." ## "2.123" --> ".2.123"
> 
> whatever that means.  Who should catch that kind of nonsense?

Eventually it will get caught when we actually try to parse the constant, 
but the fact is, as a token ".2.123" is a perfectly fine token by C 
tokenization rules.

So concatenation of "." and "2.123" is correct.

Once we actually parse the FP constants (I think Al had preliminary
patches to do that), we will obviously give an error at that point (gcc
says "too many decimal points in floating constant", which seems to be a
fine error message).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Function pointer assignment ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Function pointer assignment
Date: Wed, 28 Jul 2004 17:09:29 +0000
Message-ID: <20040728170929.E06871422D58 () darter ! rentec ! com>
--------------------

This one looks like gcc's problem, but I am just bringing it up here to
be sure.

Morten

Code:
-----------------------------------------------------------------------------
enum Moo { Baa, Oink };
static unsigned int quack (void) { return 0; }
enum Moo (*Miau) (void) = quack;
-----------------------------------------------------------------------------

> gcc-2.95.2 -Wall -c ~/foo.c
> gcc-3.4 -Wall -c ~/foo.c
> /opt/SUNWspro/bin/cc -V -c  ~/foo.c
cc: Sun WorkShop 6 update 2 C 5.3 Patch 111679-08 2002/05/09
acomp: Sun WorkShop 6 update 2 C 5.3 Patch 111679-08 2002/05/09
"/home/welinder/foo.c", line 3: warning: initialization type mismatch
> ./check ~/foo.c
/home/welinder/foo.c:3:27: warning: incorrect type in initializer (different base types)
/home/welinder/foo.c:3:27:    expected enum Moo ( *[addressable] [toplevel] Miau )( ... )
/home/welinder/foo.c:3:27:    got unsigned int ( static [addressable] [toplevel] *<noident> )( ... )
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Function pointer assignment
Date: Wed, 28 Jul 2004 17:33:47 +0000
Message-ID: <Pine.LNX.4.58.0407281025110.2522 () ppc970 ! osdl ! org>
--------------------


On Wed, 28 Jul 2004, Morten Welinder wrote:
> 
> This one looks like gcc's problem, but I am just bringing it up here to
> be sure.

Yes. The standard way is to make enum's equivalent to "int", while gcc
makes the type of enum be the type that fits the values it sees. I think
the sun compiler warning may go away if you change the type of "quack"
from "unsigned int" to "int".

Sparse is more anal, and makes each "enum" a real separate type, so you'll
always see the warning, unless you use the proper enum.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Getting rid of NS_ENUM ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Getting rid of NS_ENUM
Date: Wed, 25 Aug 2004 17:15:50 +0000
Message-ID: <20040825171550.494811422D56 () darter ! rentec ! com>
--------------------

Gcc insists that this is invalid code:

enum Foo { FOO };
struct Foo x;

> gcc-3.4 -Wall ~/foo.c
/home/welinder/foo.c:2: error: `Foo' defined as wrong kind of tag
/home/welinder/foo.c:2: error: storage size of `x' isn't known

but sparse puts the two Foo identifiers into separate namespaces: NS_ENUM
and NS_STRUCT.  Why?

It looks to me that I should...

1. Eliminate NS_ENUM.

2. Eliminate the ns parameter to struct_union_enum_specifier and just use
   NS_STRUCT in there.

3. Add these lines in struct_union_enum_specifier:
+               if (sym->type != type)
+                       error (sym->pos, "invalid tag applied to %s", show_typename (sym));

Comments?

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Getting rid of NS_ENUM
Date: Wed, 25 Aug 2004 17:34:38 +0000
Message-ID: <Pine.LNX.4.58.0408251029290.17766 () ppc970 ! osdl ! org>
--------------------


On Wed, 25 Aug 2004, Morten Welinder wrote:
> 
> Gcc insists that this is invalid code:
> 
> enum Foo { FOO };
> struct Foo x;

Damn silly C standards.

Me, I think enums and structs are obviously different. I didn't bother 
with reading a standard or anything like that.

> but sparse puts the two Foo identifiers into separate namespaces: NS_ENUM
> and NS_STRUCT.  Why?

I just think sparse makes more sense. They clearly _can_ be separate 
address spaces because the "enum" vs "struct" is always there to keep 
them separate.

And the sparse behaviour allows all strictly conforming apps, so it's not 
like it breaks anything. Think of it as a sane extension.

> It looks to me that I should...
> 
> 1. Eliminate NS_ENUM.
> 
> 2. Eliminate the ns parameter to struct_union_enum_specifier and just use
>    NS_STRUCT in there.
> 
> 3. Add these lines in struct_union_enum_specifier:
> +               if (sym->type != type)
> +                       error (sym->pos, "invalid tag applied to %s", show_typename (sym));
> 
> Comments?

Yeah, yeah. I guess we could just do that. But dammit, sparse has such
beautiful support for lots of address spaces that it just made sense to do
it.

(Right now, a sparse "namespace" is limited to just 8 bits of enums, but 
that's a small implementation detail, and the code should easily allow 
extending that to something more complicated. Including C++ namespaces 
with some work. But I guess NS_ENUM isn't really here nor there..)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Getting rid of NS_ENUM
Date: Wed, 25 Aug 2004 18:18:44 +0000
Message-ID: <20040825181844.968321422D56 () darter ! rentec ! com>
--------------------

Ouch.

I fixed and pushed that, but the box said Pandora on the outside.
(And not-fixing that namespace issue doesn't help either.)  Consider:

-----------------------------------------------------------------------------
union Foo { };

int main (int argc, char **argv)
{
  // struct Foo x;         // <-- invalid
  struct Foo;              // <-- valid [declaration]
  struct Foo { int bar; }; // <-- valid [definition]
  return 0;
}
-----------------------------------------------------------------------------

We somehow need to distinguish whether we are re-using the outer Foo or
declaring a new one.  The fact that the error() in the patch below triggers
shows that we are in fact always reusing the outer Foo.  Not good.

I would guess that we can just look for ';' or '{' as a marker than tells
us to always declare a new one *except* when we have seen declarations
in the current scope.

That's hairy.

Morten







Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 parse.c  |   10 ++++++----
 symbol.h |    9 ++++-----
 2 files changed, 10 insertions(+), 9 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/25 1.745)
   Put enums in the same namespace as unions and structs.
   Check tags when naming tagged types.
   
   This catches things like...
   
   enum Foo { FOO };
   struct Foo x;

diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-25 13:53:19 -04:00
+++ b/parse.c	2004-08-25 13:53:19 -04:00
@@ -98,7 +98,7 @@
 	return lookup_or_create_symbol(NS_LABEL, SYM_LABEL, token);
 }
 
-struct token *struct_union_enum_specifier(enum namespace ns, enum type type,
+struct token *struct_union_enum_specifier(enum type type,
 	struct token *token, struct ctype *ctype,
 	struct token *(*parse)(struct token *, struct symbol *))
 {
@@ -106,7 +106,9 @@
 
 	ctype->modifiers = 0;
 	if (token_type(token) == TOKEN_IDENT) {
-		sym = lookup_or_create_symbol(ns, type, token);
+		sym = lookup_or_create_symbol(NS_STRUCT, type, token);
+		if (sym->type != type)
+			error (sym->pos, "invalid tag applied to %s", show_typename (sym));
 		token = token->next;
 		ctype->base_type = sym;
 		if (match_op(token, '{')) {
@@ -136,7 +138,7 @@
 
 struct token *struct_or_union_specifier(enum type type, struct token *token, struct ctype *ctype)
 {
-	return struct_union_enum_specifier(NS_STRUCT, type, token, ctype, parse_struct_declaration);
+	return struct_union_enum_specifier(type, token, ctype, parse_struct_declaration);
 }
 
 static struct token *parse_enum_declaration(struct token *token, struct symbol *parent)
@@ -169,7 +171,7 @@
 
 struct token *enum_specifier(struct token *token, struct ctype *ctype)
 {
-	return struct_union_enum_specifier(NS_ENUM, SYM_ENUM, token, ctype, parse_enum_declaration);
+	return struct_union_enum_specifier(SYM_ENUM, token, ctype, parse_enum_declaration);
 }
 
 struct token *typeof_specifier(struct token *token, struct ctype *ctype)
diff -Nru a/symbol.h b/symbol.h
--- a/symbol.h	2004-08-25 13:53:19 -04:00
+++ b/symbol.h	2004-08-25 13:53:19 -04:00
@@ -27,11 +27,10 @@
 	NS_NONE = 0,
 	NS_PREPROCESSOR = 1,
 	NS_TYPEDEF = 2,
-	NS_STRUCT = 4,
-	NS_ENUM = 8,
-	NS_LABEL = 16,
-	NS_SYMBOL = 32,
-	NS_ITERATOR = 64,
+	NS_STRUCT = 4,  // Also used for unions and enums.
+	NS_LABEL = 8,
+	NS_SYMBOL = 16,
+	NS_ITERATOR = 32,
 };
 
 enum type {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Hah! First (broken) code-generation.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Hah! First (broken) code-generation..
Date: Thu, 09 Dec 2004 03:30:47 +0000
Message-ID: <Pine.LNX.4.58.0412081916090.31040 () ppc970 ! osdl ! org>
--------------------

Well, not really, since Jeff's original "compile-i386" was there much 
earlier, and quite frankly, still likely does a lot better job.

But I now do some simple ops (load/store/binop/branch), to the point where 
it's actually possible to see some kind of sense in the end result. I do 
_not_ handle OP_CALL yet, which means it really only makes sense for some 
trivial cases, but as an example, here's the current output of my 
"example" binary for the old test-case of Chris Lattner:

	#include <stdio.h>

	typedef struct List {
		struct List *Next;
		int Data;
	} List;

	List Node0 = { 0, 5 };
	List Node1 = { &Node0, 4 };
	List Node2 = { &Node1, 3 };
	List Node3 = { &Node2, 2 };
	List Node4 = { &Node3, 1 };
	List Node5 = { &Node4, 0 };

	void main()
	{
		List *PrevL, *CurL;
		for (PrevL = 0, CurL = &Node5; CurL;
		     PrevL = CurL, CurL = CurL->Next)
			printf("%d %d\n", CurL->Data, PrevL ? PrevL->Data : -1);
	}

and it becomes

	.globl main
	main:
		movl $0,eax
		movl $<Node5>,edx
		jmp .L0xf7fb60ac

	.L0xf7fb6034:
		mov.32 4(eax),edx
		testl ecx,ecx
		je .L0xf7fb60fc
		jmp .L0xf7fb60d4

	.L0xf7fb60fc:
		movl $4294967295,eax
		jmp .L0xf7fb6124

	.L0xf7fb60d4:
		mov.32 4(ecx),eax
		jmp .L0xf7fb6124

	.L0xf7fb6124:
		call.32    %r10 <- printf, "%d %d\n", %r5, %r9
		mov.32 edx,eax
		mov.32 0(eax),edx
		jmp .L0xf7fb60ac

	.L0xf7fb60ac:
		testl edx,edx
		movl eax,0(SP)
		movl 0(SP),ecx
		movl edx,eax
		je .L0xf7fb6084
		jmp .L0xf7fb6034

	.L0xf7fb6084:
		ret


which looks almost readable (yeah, yeah, instruction sizes are
inconsistent and wrong, sue me). You can tell that the "printf" call isn't
handled by the fact that it just uses the pseudo names, and if you use the 
result (this example obviously doesn't) you'd confuse the code generation.

It only uses eax/edx/ecx right now, and since it doesn't handle function 
calls at all, it doesn't notice that the function call really clobbers 
them all, but it's getting there.

(Yeah, don't try any other test programs. You'll see a lot of "undef"  
things, because I really mess up the storage for some rather simple cases.  
I do believe my phi-source combining thing is just horribly wrong, but 
it seemed sensible at the time - it's only now that I can see what it 
results in that it becomes obviously problematic)

			Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Hah! First (broken) code-generation..
Date: Sat, 11 Dec 2004 05:33:03 +0000
Message-ID: <Pine.LNX.4.58.0412102047160.31040 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Dec 2004, Linus Torvalds wrote:
> 
> But I now do some simple ops (load/store/binop/branch), to the point where 
> it's actually possible to see some kind of sense in the end result.

Much better.

It's incredible how obvious some bugs become when the output is real code 
that I'm used to reading, as opposed to a fairly high-level 
pseudo-register abstract code.

The "register allocator" is something pretty simple, since I'm aiming for 
doing purely local register allocation decisions at all times. That said, 
it actually works reasonably well, although my storage allocator sometimes 
screws up and allocates the same register as input for two different 
pseudos. Oops ;)

Actually, it's rare enough that I had to write some automation to just try
to get a test-case, so you can in fact get reasonable output for it for
many snippets of code. The output is x86-like code, with the caveat that I
don't do FP or "long long", and conditionals are still very stupid indeed.  
But I verified that an iterative "fibonacci" actually _worked_ after just
trivial syntax fixes.

The biggest problem (apart from stupid branch handling) right now is 
actually that I don't go back and fix up frame pointer offsets - I should 
save callee-saved registers, but since I just write out the result instad 
of saving it in some nice fixer-uppable-format, I can't do that yet.

Tons of broken details - instruction sizes, casts (they don't do
sign-extension, nor do they shift down bitfield offsets), and right now
the calling convention defaults to "-mregparm=3" on input, but on stack
passing on actual calls (ie sparse even disagrees with _itself_), because
that was the easiest way to verify that my storage handlign Does The Right
Thing wrt arguments, both in register and on the stack.

But the code it outputs actually makes a fair amount of sense, and the
local register allocator does surprisingly well for simple stuff, probably
because I tried pretty hard to keep register usage down. It obviously bogs
down on more complex cases, and moves things between stack slots and
registers.

To get an idea of how stupid this thing is (while also showing how it does 
reasonably well _despite_ being stupid ;), look here:

	int test1(int a, int b, int c, int d, int e)
	{
		return a+b+c+d+e;
	}

	int test2(int a, int b, int c, int d, int e)
	{
		return e+d+c+b+a;
	}

remember: incoming arguments are in the first three registers, ie %eax, 
%edx, %ecx. The code generated is:

	.globl test1
	test1:
		add.32 %edx,%eax
		add.32 %ecx,%eax
		add.32 0(FP),%eax
		add.32 4(FP),%eax
		ret


	.globl test2
	test2:
		mov.32 4(FP),%ebx
		movl %ebx,%esi
		add.32 0(FP),%esi
		add.32 %ecx,%esi
		add.32 %edx,%esi
		add.32 %eax,%esi
		movl %esi,%eax
		ret

ie though the routines really do the same thing, one of them ends up 
generating a lot better code ;)

(This also shows the lack of callee-saved registers: the first one is 
ok, the second one uses %ebx/%esi without saving them).

The second example also shows another problem I have: the silly move from
%ebx to %esi is unnecessary, but it's there because I marked %arg5 dead
_before_ I had actually loaded it into %ebx, and as a result the stupid
thing never realizes that %ebx is dead, and tries to keep it around in the
register. So it uses one register too much.

(And the final "movl" is because it doesn't realize that "add" is
associative, and we could add directly into the right register. Oh, 
well. Small problems compared to any more complex case that _really_ 
shows them ;).

Anyway, I implement most ops now (albeit _incorrectly_ in many cases), so 
you can try running "example" on real programs, and see the mess it makes 
of them. Use the "-v" flag to see it mumble to itself about where it finds 
pseudos etc ;)

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: How to extract the type identifiers? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: How to extract the type identifiers?
Date: Wed, 20 Oct 2004 17:34:00 +0000
Message-ID: <20041020173400.GA4563 () 64m ! dyndns ! org>
--------------------
On Wed, Oct 20, 2004 at 11:55:49AM -0700, Mitesh shah wrote:
> 
> Hi,
> 
> I see that all the basic types and typedefs are added as symbols and
> when a variable is declared of one of these types (basic or typedefs),
> declaration_specifiers() get the type symbol using lookup_symbol() but
> only the ctype.basic_type is associated with the variable. I need to
> extract the declared type of the variable. Reverse lookup based on the
> ctype.basic_type is also not helpful, because there may be multiple of
> typedefs pointing to the same basic_type. Is there any way to extract
> the declared type of the variables from the parsed tree?
> 
> For example,
> 
> typedef struct {
>     int i;
> } mystruct;
> 
> mystruct s;
> 
> The ctype.base_type of symbol s points to the struct of size 32 with
> member i but there is no information about "mystruct". Also there is no

It is the same type, you want them to point to the same symbol.

> information about "int" in the symbol for i.

"i" is in the symbol_list of the structure symbol.

> 
> One solution would be to store the declared type along with the variable
> symbols but that's unnecessary for backends that do not require them.
> Any other idea?

But why does back end care about that?

Regards

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: How to extract the type identifiers?
Date: Wed, 20 Oct 2004 18:55:49 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKMEIFDEAA.mshah () teja ! com>
--------------------

Hi,

I see that all the basic types and typedefs are added as symbols and
when a variable is declared of one of these types (basic or typedefs),
declaration_specifiers() get the type symbol using lookup_symbol() but
only the ctype.basic_type is associated with the variable. I need to
extract the declared type of the variable. Reverse lookup based on the
ctype.basic_type is also not helpful, because there may be multiple of
typedefs pointing to the same basic_type. Is there any way to extract
the declared type of the variables from the parsed tree?

For example,

typedef struct {
    int i;
} mystruct;

mystruct s;

The ctype.base_type of symbol s points to the struct of size 32 with
member i but there is no information about "mystruct". Also there is no
information about "int" in the symbol for i.

One solution would be to store the declared type along with the variable
symbols but that's unnecessary for backends that do not require them.
Any other idea?

Thanks,

-Mitesh


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: How to extract the type identifiers?
Date: Wed, 20 Oct 2004 19:12:10 +0000
Message-ID: <20041020191210.GA5031 () 64m ! dyndns ! org>
--------------------
On Wed, Oct 20, 2004 at 02:42:11PM -0700, Mitesh shah wrote:
> 
> I am trying to write a back end that generates C code so I want to
> preserve the user's type declaration.

I see. You want to use sparse to do source level manipulation.
The current sparse is not aim at doing that. You will going to
have similar problem on the macro that get expanded.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: How to extract the type identifiers?
Date: Wed, 20 Oct 2004 21:42:11 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKKEIGDEAA.mshah () teja ! com>
--------------------


>
> It is the same type, you want them to point to the same symbol.
>
> > information about "int" in the symbol for i.
>
> "i" is in the symbol_list of the structure symbol.
>

I agree, they are the same types so they should point to the same symbol
but I want to differentiate between their declaration because one is
declared as one typedef and other may be using another typedef or basic
C data types.


> >
> > One solution would be to store the declared type along with
> the variable
> > symbols but that's unnecessary for backends that do not
> require them.
> > Any other idea?
>
> But why does back end care about that?


I am trying to write a back end that generates C code so I want to
preserve the user's type declaration.

-Mitesh


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: RE: How to extract the type identifiers?
Date: Wed, 20 Oct 2004 23:53:27 +0000
Message-ID: <Pine.LNX.4.58.0410201643210.2317 () ppc970 ! osdl ! org>
--------------------


On Wed, 20 Oct 2004, Mitesh shah wrote:
> 
> I am trying to write a back end that generates C code so I want to
> preserve the user's type declaration.

It really is fundamentally hard.

Think about this:

	typedef int int32_t;
	typedef int32_t *my_ptr_type;

	my_type *i;

what do you suggest the type would be?

What we could do in sparse is to simply never peel off any typedef types, 
and then we'd have the ctype.base_type chain look like

	SYM_NODE i -> SYM_PTR -> SYM_NODE my_type -> SYM_PTR -> int32_t -> int

when right now we just collapse the chain, and we have just

	SYM_NODE i -> SYM_PTR -> SYM_PTR -> int

So if we did this, then it would require that sparse follow the SYM_NODE
information (possibly quite long chains) not just at the head of a type
(where currently we can have _one_ SYM_NODE), but at _any_ point in a
type.

Not impossible per se, but it does add complexity. For very little gain.

I'm not religiously against it, and if you can do a clean implementation 
that follows all the SYM_NODE chains and picks up modifiers and address 
space info etc along the chain (instead of collapsing it when it sees the 
typedef), I might accept it. But I suspect the implementation wouldn't be 
that clean..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: INCLUDEPATHS ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: INCLUDEPATHS
Date: Thu, 08 Jul 2004 14:53:33 +0000
Message-ID: <20040708145333.ACD121422D58 () darter ! rentec ! com>
--------------------

Can I have a few more include paths available, please?  (Using auto* tools
tend to produce quite a lot.)

As a bonus, this patch fixes two invalid uses of isdigit.

Morten





diff -u sparse-2004-07-07/pre-process.c sparse/pre-process.c
--- sparse-2004-07-07/pre-process.c     Mon Jun 14 19:00:29 2004
+++ sparse/pre-process.c        Tue Jun 15 16:14:27 2004
@@ -36,7 +36,7 @@
 static char elif_ignore[MAX_NEST];
 #define if_nesting (true_nesting + false_nesting)
 
-#define INCLUDEPATHS 32
+#define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
        NULL
 };
@@ -368,7 +368,7 @@
                return TOKEN_NUMBER;
        }
 
-       if (p[0] == '.' && isdigit(p[1]))
+       if (p[0] == '.' && isdigit((unsigned char)p[1]))
                return TOKEN_NUMBER;
 
        return TOKEN_SPECIAL;


diff -u sparse-2004-07-07/lib.c sparse/lib.c
--- sparse-2004-07-07/lib.c     Tue Jul  6 19:00:20 2004
+++ sparse/lib.c        Wed Jul  7 15:42:58 2004
@@ -562,7 +568,7 @@
        const char *name = arg + 1;
        const char *value = "1";
        for (;;) {
-               char c;
+               unsigned char c;
                c = *++arg;
                if (!c)
                        break;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Incorrect parsing inside #if 0 ... #endif ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Incorrect parsing inside #if 0 ... #endif
Date: Wed, 28 Jul 2004 19:04:48 +0000
Message-ID: <20040728190448.905771422D58 () darter ! rentec ! com>
--------------------

Me again -- getting tired of me?  :-)

C relaxes the parsing inside false pre-processor sections.  Thus the code
below is fine.  For what it is worth, this was discovered in real code.

Sparse's raison d'etre is, of course, to tell people "Don't do that!" so
this may or may not need fixing.  It is a bizarre error message for this
problem in any case.

Morten


> gcc-3.4 -Wall -c ~/foo.c
> ./check ~/foo.c
/home/welinder/foo.c:2:3: warning: Bad character constant
/home/welinder/foo.c:3:1: warning: Newline in string or character constant
/home/welinder/foo.c:3:1: warning: Bad character constant

#if 0
'XXX'
#endif
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Incorrect parsing inside #if 0 ... #endif
Date: Thu, 29 Jul 2004 06:07:40 +0000
Message-ID: <Pine.LNX.4.58.0407282301300.2522 () ppc970 ! osdl ! org>
--------------------


On Wed, 28 Jul 2004, Morten Welinder wrote:
> 
> Me again -- getting tired of me?  :-)

Just noting that you seem to have a lot of crap sources lying around...

> C relaxes the parsing inside false pre-processor sections.  Thus the code
> below is fine.  For what it is worth, this was discovered in real code.

Actually, C doesn't relax any parsing at all inside false pre-processor 
sections. It's just that C tokenization in general is very very lax 
indeed, and that a lot of the checking is normally done much later after 
the tokenization phase. Sparse does some checks a bit too early.

> #if 0
> 'XXX'
> #endif

I think sparse should handle this, because it might be a multi-byte 
character (which sparse doesn't support) protected by a #define exactly 
because sparse doesn't support it.

I'll think about how to handle it cleanly (without making the token cost 
for a _regular_ character token any higher - I'd hate to have to make it a 
full string thing). Maybe having a TOKEN_MULTIBYTE thing for this.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Incorrect parsing inside #if 0 ... #endif
Date: Thu, 29 Jul 2004 14:13:10 +0000
Message-ID: <20040729141310.754321422D53 () darter ! rentec ! com>
--------------------

> Just noting that you seem to have a lot of crap sources lying around...

Most is derived from Gnumeric (the Gnome spreadsheet) with Solaris/Sparc
headers.  Gnumeric is big (434381 lines of .c and .h) and very different
from the Linux kernel in terms of style, so it certainly pokes at different
parts of sparse.

> Actually, C doesn't relax any parsing at all inside false pre-processor 
> sections.

I disagree.  Section 6.10, para 4 of ISO C99 says:

 4 When in a group that is skipped (6.10.1), the directive syntax is
   relaxed to allow any sequence of preprocessing tokens to occur
   between the directive name and the following new-line character.

In particular, this contrieved example is valid:

#if 0
#define
#endif

> gcc-3.4 -Wall -c ~/foo.c
> ./check ~/foo.c
/home/welinder/foo.c:2:2: warning: expected identifier to 'define'
/home/welinder/foo.c:2:2: warning: unrecognized preprocessor line 'define'

This actually has practical consequences as seen in
http://bugzilla.gnome.org/show_bug.cgi?id=70024

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Integer promotions. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Integer promotions.
Date: Mon, 16 Aug 2004 16:10:00 +0000
Message-ID: <20040816161000.1E3FA1422D4F () darter ! rentec ! com>
--------------------

A quick look at integer_promotion suggests a problem:

1. "signed long long foo : 33" promotes to "signed int".
2. "unsigned long long foo : 33" promotes to "signed int".

While "enum Foo" and "enum Foo : 32" take different paths, they both end
up with "signed int".  That looks more like an accident.

Morten




-----------------------------------------------------------------------------

static inline struct symbol *integer_promotion(struct symbol *type)
{
	unsigned long mod =  type->ctype.modifiers;
	int width;

	if (type->type == SYM_ENUM)
		return &int_ctype;
	else if (type->type == SYM_BITFIELD) {
		mod = type->ctype.base_type->ctype.modifiers;
		width = type->fieldwidth;
	} else if (mod & (MOD_CHAR | MOD_SHORT))
		width = type->bit_size;
	else
		return type;
	if (mod & MOD_UNSIGNED && width == bits_in_int)
		return &uint_ctype;
	return &int_ctype;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Integer promotions.
Date: Sun, 22 Aug 2004 22:37:26 +0000
Message-ID: <Pine.LNX.4.58.0408221533470.17766 () ppc970 ! osdl ! org>
--------------------


On Mon, 16 Aug 2004, Morten Welinder wrote:
> 
> A quick look at integer_promotion suggests a problem:
> 
> 1. "signed long long foo : 33" promotes to "signed int".
>
> 2. "unsigned long long foo : 33" promotes to "signed int".

Yeah, that's crap.

Both should promote to "signed long" or "signed long long" depending on 
the first one to fit that number of bits.

> While "enum Foo" and "enum Foo : 32" take different paths, they both end
> up with "signed int".  That looks more like an accident.

enum's really do have to fit in "int". That's not what gcc does, but Al
pointed out tons of strange cases if you don't think of enums as integers,
and the "enum fits in int" is really the only thing the standard really
supports, I think - anything else is implementation-defined or even
undefined behaviour.

And yes, the kenrel misbehaves there, and has a few cases where it puts 
longs into enum's.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Lazy type evaluation breaks assembler code generation. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: Lazy type evaluation breaks assembler code generation.
Date: Tue, 27 Jul 2004 17:22:40 +0000
Message-ID: <E1BpVey-000Bt4-00.adobriyan-mail-ru () f13 ! mail ! ru>
--------------------
ChangeSet 1.540 aka "explicit lazy type evaluation of symbol expression"
breaks assembler code generator with the following input:

=======================================
int main(void)
{
	int a;

	a = 1;
	return 0;
}
=======================================
$ ./compile ../test.c
        .file   "test.c"
        no type at ../test.c:5:2
Segmentation fault
=======================================

When calculating address of 'a' in compile-i386.c:x86_address_gen(),
addr is set to NULL because unop->ctype is set to NULL (starting from
1.540). addr propagates back to x86_assignment() and passed to
emit_move(). emit_move() then dereferences NULL pointer.

Reverting two chunks where ctype is explicitly set to NULL makes the
problem go away.

If somebody knows the right way to fix the segfault, please, send
patch to Linus.

Alexey
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Lazy type evaluation breaks assembler code generation.
Date: Tue, 27 Jul 2004 18:45:05 +0000
Message-ID: <Pine.LNX.4.58.0407271143210.2522 () ppc970 ! osdl ! org>
--------------------


On Tue, 27 Jul 2004, Alexey Dobriyan wrote:
>
> ChangeSet 1.540 aka "explicit lazy type evaluation of symbol expression"
> breaks assembler code generator with the following input:

Hmm.. One option is to just make the code generator not care. The 
expression is always a pointer, so it _shouldn't_ care.

On the other hand, maybe the right thing to do is to use another value for 
"lazy evaluate". Most likely just "&ptr_ctype". That way the code 
generator doesn't need to care.

I'll think about it.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Lazy type evaluation breaks assembler code generation.
Date: Tue, 27 Jul 2004 21:51:02 +0000
Message-ID: <Pine.LNX.4.58.0407271449250.2522 () ppc970 ! osdl ! org>
--------------------


On Tue, 27 Jul 2004, Linus Torvalds wrote:
> 
> On the other hand, maybe the right thing to do is to use another value for 
> "lazy evaluate". Most likely just "&ptr_ctype". That way the code 
> generator doesn't need to care.

Done. I made lazy evaluation very explicit by having a special kind of 
"void *" type that is used as the lazy marker, but also ends up being
perfectly usable as just a valid pointer type, so even if we never
actually evaluate it, nobody will end up caring.

"compile" is happy again.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Linearizer problem ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Linearizer problem
Date: Mon, 16 Aug 2004 15:11:40 +0000
Message-ID: <20040816151140.7F6C51422D4F () darter ! rentec ! com>
--------------------

The assignment generates the following code for me:

        %r1 <- 2
        %r2 <- foo
        %r3 <- 0
        %r4 <- add  %r2, %r3
        load %r5 <- [%r4]
        %r6 <- -4
        %r7 <- and  %r5, %r6
        %r8 <- 3
        %r9 <- or  %r5, %r8
        store %r9 -> [%r4]

Note, that the value to be assigned, %r1, is never used.

Morten



-----------------------------------------------------------------------------
#include <stdio.h>

enum Foo { FOO, BAR, BAZ, BOOZE };

int
main (int argc, char **argv)
{
  struct {
    enum Foo foo : 2;
  } foo;
  foo.foo = BAZ;

  if (foo.foo == BAZ)
    printf ("Equal\n");

  return 0;
}
-----------------------------------------------------------------------------
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: Linearizer problem
Date: Mon, 16 Aug 2004 15:20:29 +0000
Message-ID: <4120D0BD.5030808 () pobox ! com>
--------------------
Morten Welinder wrote:
> The assignment generates the following code for me:
> 
>         %r1 <- 2
>         %r2 <- foo
>         %r3 <- 0
>         %r4 <- add  %r2, %r3
>         load %r5 <- [%r4]
>         %r6 <- -4
>         %r7 <- and  %r5, %r6
>         %r8 <- 3
>         %r9 <- or  %r5, %r8
>         store %r9 -> [%r4]
> 
> Note, that the value to be assigned, %r1, is never used.


Well that part is right...  it _shouldn't_ be used :)

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: Linearizer problem
Date: Mon, 16 Aug 2004 15:33:07 +0000
Message-ID: <20040816153307.44D311422D4F () darter ! rentec ! com>
--------------------

I hope you just mean that it should have been optimized away.  My reason
for testing this was to figure out what sign foo.foo really has.  IMHO,
it should unsigned because otherwise you put BAZ in and get -BAZ out.

Over in compile-i386.c, we have...

static int type_is_signed(struct symbol *sym)
{
	if (sym->type == SYM_NODE)
		sym = sym->ctype.base_type;
	if (sym->type == SYM_PTR)
		return 0;
	return !(sym->ctype.modifiers & MOD_UNSIGNED);
}

...which will claim an enum to be signed.  My plan was to globalize it
and make it return FALSE for enums.

Comments?

M.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizer problem
Date: Sun, 22 Aug 2004 22:33:30 +0000
Message-ID: <Pine.LNX.4.58.0408221527530.17766 () ppc970 ! osdl ! org>
--------------------


On Mon, 16 Aug 2004, Morten Welinder wrote:
> 
> Over in compile-i386.c, we have...
> 
> static int type_is_signed(struct symbol *sym)
> {
> 	if (sym->type == SYM_NODE)
> 		sym = sym->ctype.base_type;
> 	if (sym->type == SYM_PTR)
> 		return 0;
> 	return !(sym->ctype.modifiers & MOD_UNSIGNED);
> }
> 
> ...which will claim an enum to be signed.  My plan was to globalize it
> and make it return FALSE for enums.
> 
> Comments?

What part of the code ends up caring? We should always have cast the value 
of an enum to the proper integer type (which can be signed or unsigned 
depending on the size and the base type), and it sounds like somebody is 
looking at the sign of an expression that hasn't been fully evaluated yet, 
or that we're missing a cast or bitfield extract thing.

These bitfields end up being signed in expressions:

	int i:1;
	signed int i:1;
	unsigned int i:1;	// Yes really: it just gets _extracted_ unsigned
	signed int i:32;

while this one ends up being unsigned

	unsigned int i:32;
	unsigned long i:<sizeof long in bits>;

and if sparse gets confused, we should fix it.

In other words, there are two totally different "sign" issues with 
bitfields: the "extraction" time sign (which comes from the base type of 
the field) and the "expression evaluation" time sign (which is signed if 
the bitfield fits in a signed). 

At least that's what I remember. Bitfields are complex, and I might be 
totally full of sh*t.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Linearizing memory accesses.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Linearizing memory accesses..
Date: Sun, 07 Nov 2004 21:36:11 +0000
Message-ID: <Pine.LNX.4.58.0411071314060.24286 () ppc970 ! osdl ! org>
--------------------

Ok, I've worked for the last few days to clean up the way we linearize 
various things, and in particular, moving some of the simple cases away 
from the evaluator and into the linearizer. There are many things that are 
just so much _easier_ to do in a linear format than in a tree format, that 
trying to do the transformations early is just too painful.

In particular, Al had removed a number of special cases at evaluation
time, because we used to get them wrong: for things like "a += b" we used
to evaluate "a" twice etc. So the evaluate phase would actually change
that to "(tmp = &a, *tmp = *tmp + b)", which is certainly correct from an
evaluation standpoint, but is just fundamentally harder to generate good
code for, since we introduced a new symbol and made addressing explicit.  
Especially the fact that we made addressign specific is bad, since the
original code may not even have had an address (ie purely local variable).

So instead, I fixed the evaluator to just _leave_ these things as the
"complex" operators they were, and made the linearizer be a lot more
intelligent about memory accesses. And "intelligent" in this case also
happens to mean "much simpler and more straightforward".

In particular, I wanted to make sure that 
 - bitfields were considered just another "update" operation, and that 
   nested updates worked sanely (ie "bitfield += bitfield" should
   linearize to something readable, not an ungodly mess.
 - expressions that don't need an address (ie local symbols) never have 
   their address taken, even if they are bitfields or otherwise complex 
   things (structures with offsets).

I think I succeeded. The OP_LOAD/OP_STORE thing are slightly more
semantically rich - instead of just taking a pseudo, they now take a local
symbol _or_ pseudo, and they allow byte offsets. But more importantly, the
linearizer now carries along this "struct access_data" structure that
contains all the information about the access, which allows us to generate
a single load/store for the complex cases, and the linearized information 
looks sane.

I probably broke something in the process (I'm almost certain that 
initializers, that use the same "access_data" several times get things 
wrong), but I think the basic infrastructure is correct. And even complex 
cases seem to be ok, ie:

	struct hello {
	        int a;
	        int b:6;
	        int c:2;
	};

	struct hello *fn(void);

	int main(char c)
	{
	        fn()->b += c;
	}


generates

        load %r1 <- 0[c]
        %r2 <- CAST(8->6) %r1
        deathnote %r1
        %r3 <- fn
        %r4 <- CALL %r3
        deathnote %r3
        load %r5 <- 4[%r4]
        %r6 <- add  %r5, %r2
        deathnote %r5
        deathnote %r2
        %r7 <- 63
        %r8 <- and  %r6, %r7
        deathnote %r7
        %r9 <- or  %r5, %r8
        deathnote %r5
        deathnote %r8
        store %r9 -> 4[%r4]
        deathnote %r9
        deathnote %r4
        ret %r6

while something that has a local symbol:

	struct hello {
	        int a;
	        int b:6;
	        int c:2;
	};

	int main(char c)
	{
	        struct hello a;
	        a.b += c;
	}

generates the much simpler:

        load %r1 <- 0[c]
        %r2 <- CAST(8->6) %r1
        deathnote %r1
        load %r3 <- 4[a]
        %r4 <- add  %r3, %r2
        deathnote %r3
        deathnote %r2
        %r5 <- 63
        %r6 <- and  %r4, %r5
        deathnote %r5
        %r7 <- or  %r3, %r6
        deathnote %r3
        deathnote %r6
        store %r7 -> 4[a]
        deathnote %r7
        ret %r4

(ie note how we never need to take the address of "a", we just access it
directly at the proper offset).

And yeah, I bet the masking etc is way off, and I notice that I have the 
cast in the wrong place, but it's still cool ;)

		Linus


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Al Viro <viro () parcelfarce ! linux ! theplanet ! co ! uk>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 10:04:07 +0000
Message-ID: <20041108100407.GZ24336 () parcelfarce ! linux ! theplanet ! co ! uk>
--------------------
On Sun, Nov 07, 2004 at 01:36:11PM -0800, Linus Torvalds wrote:
> 
> Ok, I've worked for the last few days to clean up the way we linearize 
> various things, and in particular, moving some of the simple cases away 
> from the evaluator and into the linearizer. There are many things that are 
> just so much _easier_ to do in a linear format than in a tree format, that 
> trying to do the transformations early is just too painful.
> 
> In particular, Al had removed a number of special cases at evaluation
> time, because we used to get them wrong: for things like "a += b" we used
> to evaluate "a" twice etc. So the evaluate phase would actually change
> that to "(tmp = &a, *tmp = *tmp + b)", which is certainly correct from an
> evaluation standpoint, but is just fundamentally harder to generate good
> code for, since we introduced a new symbol and made addressing explicit.  
> Especially the fact that we made addressign specific is bad, since the
> original code may not even have had an address (ie purely local variable).
> 
> So instead, I fixed the evaluator to just _leave_ these things as the
> "complex" operators they were, and made the linearizer be a lot more
> intelligent about memory accesses. And "intelligent" in this case also
> happens to mean "much simpler and more straightforward".

Hrm...  Another fun places where we do such rewriting:
	a) x ? : y => tmp = x, tmp ? tmp : y
	b) degeneration of non-lvalue arrays.  In some cases it could be
avoided, but in general it's impossible to get rid of - C99 requires
an addressable object there and sometimes it can't be optimized away.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 15:30:25 +0000
Message-ID: <Pine.LNX.4.58.0411080722100.24286 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Al Viro wrote:
> 
> Hrm...  Another fun places where we do such rewriting:
> 	a) x ? : y => tmp = x, tmp ? tmp : y

I fixed that one up earlier ;)

> 	b) degeneration of non-lvalue arrays.  In some cases it could be
> avoided, but in general it's impossible to get rid of - C99 requires
> an addressable object there and sometimes it can't be optimized away.

That's fine. We _are_ allowed to change the expression tree, it's just 
that we have to be very very careful to make sure that it's not shared in 
awkward places. 

But the expression tree sharing is very limited: it really only happens 
for a few cases, namely
 - iterators that have the same init/exit conditions
 - the short conditionals
 - inlining

and in all of these cases it's actually ok to do certain changes. In 
particular, degeneration is fine, because even when the expression is 
shared for any of the above reasons, _all_ the sharing entities want the 
degeneration.

Similarly, in the short conditional, it was not ok to change the 
conditional from 'x' to 'x != 0.0' (because that would be wrong for the 
missing middle part), but it -is- ok to degenerate it (both parts would 
want that anyway) and it -is- ok to apply a widening cast to it to make it 
type-compatible with the false expression.

(It would _not_ be ok to apply a shrinking cast to it, though: the 
widening cast is only ok because the truth-value doesn't change).

And in inlining, the expression is obviously always used in the same
situation, so it's ok to do (the exception is when the inlining can
simplify the expressions because some argument was constant, but in that
case we will have copied the expression _anyway_, so we should be all
good).

I was thinking of adding some fancy "EXPR_COPY" expression, which would 
make sure that we do "copy-on-write" to the thing, but I decided that I 
didn't want the complexity, and am trying the "ok to change, but be very 
very careful" approach.

Let's see if we end up having tons of bugs due to this, and maybe I'll 
have to reconsider. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 15:57:14 +0000
Message-ID: <20041108155714.GA1128 () 64m ! dyndns ! org>
--------------------
On Sun, Nov 07, 2004 at 01:36:11PM -0800, Linus Torvalds wrote:
> 
> Ok, I've worked for the last few days to clean up the way we linearize 
> various things, and in particular, moving some of the simple cases away 
> from the evaluator and into the linearizer. There are many things that are 
> just so much _easier_ to do in a linear format than in a tree format, that 
> trying to do the transformations early is just too painful.
> 

Oh, no. I would rather not pick a fight Linus, and I am not a very good
fighter. But damn it, I can't stand it any more. I think that is wrong.

You DO need to have later process to transform them. Try to do the
transformations earlier by complicating the MIR is not necessary
and not worth while. I think on objective for the MIR (the op code
after linearizion) is to keep it simple and do not lose any information.
All this x86lism should really belong to a x86 specify LIR and do it
there. If you really have to do it, can you make it separator pass?

I would like to keep the ability to access the untainted MIR.


> In particular, Al had removed a number of special cases at evaluation
> time, because we used to get them wrong: for things like "a += b" we used
> to evaluate "a" twice etc. So the evaluate phase would actually change
> that to "(tmp = &a, *tmp = *tmp + b)", which is certainly correct from an
> evaluation standpoint, but is just fundamentally harder to generate good
> code for, since we introduced a new symbol and made addressing explicit.  
> Especially the fact that we made addressign specific is bad, since the
> original code may not even have had an address (ie purely local variable).

How about a = a + b; vs a += b? If the compiler generate better code in
the later, I would say it is not an very intelligent. This thing can be
done correctly in the memory to scaler promotion. And the tmp will be
promote first. The then tmp will be come an alias register to address of
a. And then a will be promote also. I can show you the step by step detail.

> 
> So instead, I fixed the evaluator to just _leave_ these things as the
> "complex" operators they were, and made the linearizer be a lot more
> intelligent about memory accesses. And "intelligent" in this case also
> happens to mean "much simpler and more straightforward".

Complicate the MIR is not necessary and IMHO is bad. I am adding the
users chain for the the memory to scaler promotion at the weekend.
The way to promote it is , you look at the symbol address register.
(before that we need to bind an address register to the symbol and
keep using that register instead of using "setval" every time)
If all it's user instruction is "load" and "store", then this memory
can be promote to register. You have to do some dance about the SSA
form and convert the load/store to reference/assign.

Allow operator has more address mode make other analyze complicate.
You have to handle the add in the address mode in the same way.


> 
> In particular, I wanted to make sure that 
>  - bitfields were considered just another "update" operation, and that 
>    nested updates worked sanely (ie "bitfield += bitfield" should
>    linearize to something readable, not an ungodly mess.
>  - expressions that don't need an address (ie local symbols) never have 
>    their address taken, even if they are bitfields or otherwise complex 
>    things (structures with offsets).


> 
> I think I succeeded. The OP_LOAD/OP_STORE thing are slightly more
> semantically rich - instead of just taking a pseudo, they now take a local
> symbol _or_ pseudo, and they allow byte offsets. But more importantly, the
> linearizer now carries along this "struct access_data" structure that
> contains all the information about the access, which allows us to generate
> a single load/store for the complex cases, and the linearized information 
> looks sane.

What we have is the very first raw information. The MIR should aim for make
later transform easy rather than easy to read. And you get all the easy to
read part when the optimization kicks in.
You jump to the optimization process too earlier. I would rather do it
right in the optimization step.

There is old Chinese saying "hurry then no reach".

If you still want to do it. May I request it to be a separate step or
layer? So I can still access to the simpler MIR.

I am sorry I have to go, it is Monday.

And I am sure you disagree, more comment later.

Best regards,

Chris



> 
> I probably broke something in the process (I'm almost certain that 
> initializers, that use the same "access_data" several times get things 
> wrong), but I think the basic infrastructure is correct. And even complex 
> cases seem to be ok, ie:
> 
> 	struct hello {
> 	        int a;
> 	        int b:6;
> 	        int c:2;
> 	};
> 
> 	struct hello *fn(void);
> 
> 	int main(char c)
> 	{
> 	        fn()->b += c;
> 	}
> 
> 
> generates
> 
>         load %r1 <- 0[c]
>         %r2 <- CAST(8->6) %r1
>         deathnote %r1
>         %r3 <- fn
>         %r4 <- CALL %r3
>         deathnote %r3
>         load %r5 <- 4[%r4]
>         %r6 <- add  %r5, %r2
>         deathnote %r5
>         deathnote %r2
>         %r7 <- 63
>         %r8 <- and  %r6, %r7
>         deathnote %r7
>         %r9 <- or  %r5, %r8
>         deathnote %r5
>         deathnote %r8
>         store %r9 -> 4[%r4]
>         deathnote %r9
>         deathnote %r4
>         ret %r6
> 
> while something that has a local symbol:
> 
> 	struct hello {
> 	        int a;
> 	        int b:6;
> 	        int c:2;
> 	};
> 
> 	int main(char c)
> 	{
> 	        struct hello a;
> 	        a.b += c;
> 	}
> 
> generates the much simpler:
> 
>         load %r1 <- 0[c]
>         %r2 <- CAST(8->6) %r1
>         deathnote %r1
>         load %r3 <- 4[a]
>         %r4 <- add  %r3, %r2
>         deathnote %r3
>         deathnote %r2
>         %r5 <- 63
>         %r6 <- and  %r4, %r5
>         deathnote %r5
>         %r7 <- or  %r3, %r6
>         deathnote %r3
>         deathnote %r6
>         store %r7 -> 4[a]
>         deathnote %r7
>         ret %r4
> 
> (ie note how we never need to take the address of "a", we just access it
> directly at the proper offset).
> 
> And yeah, I bet the masking etc is way off, and I notice that I have the 
> cast in the wrong place, but it's still cool ;)
> 
> 		Linus
> 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 17:18:16 +0000
Message-ID: <20041108171816.GA3990 () 64m ! dyndns ! org>
--------------------
On Mon, Nov 08, 2004 at 11:56:45AM -0800, Linus Torvalds wrote:
> 
> 
> On Mon, 8 Nov 2004, Christopher Li wrote:
> > 
> The MIR is _less_ tainted now. Think about it: 'a += b' _used to generate 
> this:
> 
> 	# tmp = &a
> 	r1 <- 'a'
> 	load r2 <- [r1]
> 	r3 <- tmp
> 	store r2 -> [r3]
> 
> 	# *tmp = *tmp + b
> 	r4 <- tmp
> 	load r5 <- [r4]
> 	load r6 <- [r5]
> 	r7 <- 'b'
> 	load r8 <- [r7]
> 	add r9,r6,r7
> 	r10 <- tmp
> 	load r11 <- [r10]
> 	store r9 -> [r11]
> 
> which is just horrid.
> 
> Now we generate something that is much closer to the original:
> 
> 	load r1 <- ['a']
> 	load r2 <- ['b']
> 	add r3,r1,r2
> 	store r3 -> ['a']
> 
> because we

I think I misread your the nature of your change.
I just try it. I totally agree that the current way to doing
"a += b" is much better than the old code.

I should have read the code first.

> 
> > How about a = a + b; vs a += b? If the compiler generate better code in
> > the later, I would say it is not an very intelligent. 
> 
> Indeed. And I fixed it. It now generates _exactly_ the same MIR.
> 
> But with my load-store cleanups, I _also_ generate the proper code for
> 
> 	*fn() += a
> 
> which is _not_ the same thing as
> 
> 	*fn() = *fn()+a;
> 
> > This thing can be done correctly in the memory to scaler promotion. And
> > the tmp will be promote first. The then tmp will be come an alias
> > register to address of a. And then a will be promote also. I can show
> > you the step by step detail.
> 
> Trust me. I do it correctly _now_. 
> 
> > Complicate the MIR is not necessary and IMHO is bad.
> 
> The MIR is not any more complex. Quite the reverse. It's _simpler_.
> 
> > You jump to the optimization process too earlier. I would rather do it
> > right in the optimization step.
> 
> No. Read the code. See how it works. Instead of generating a really 
> complex MIR that is complex because we did things wrong, we now generate a 
> much simpler MIR.
> 
> It just introduces two concepts: pseudo's can be constant values, and
> memory acceses are off the type "offset + (symbol|pseudo)". That's not a
> complication, it's a simplification.

OK, I am convinced. I am thinking some thing like "r1 = add 4[e], 2". Which
is not true. After I read more about it, I have no complain really.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 17:31:42 +0000
Message-ID: <20041108173142.GB3990 () 64m ! dyndns ! org>
--------------------
Yes it did get through.

about %r1 vs #foo. It doesn't matter too much to me.
But consider later it will generate asm code using %eax etc. Might
be natural just keep the %r1.

Chris 

On Mon, Nov 08, 2004 at 12:50:33PM -0800, Tommy Thorn wrote:
> [Did this get through?  Apparently osdl's MTA doesn't like me not having an
> ident service, sigh.]
> 
> > 1: Register names are frequent, constants rarer, thus we should escape the
> > latter, not the former, eg: r1 and #foobar instead of %r1 and foobar
> 
> Clarification: I meant _symbolic_ constants, not _all_ constants.
> 
> Tommy
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 19:56:45 +0000
Message-ID: <Pine.LNX.4.58.0411081141300.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Christopher Li wrote:
> 
> You DO need to have later process to transform them. Try to do the
> transformations earlier by complicating the MIR is not necessary
> and not worth while. I think on objective for the MIR (the op code
> after linearizion) is to keep it simple and do not lose any information.

We haven't lost any information. It's all there. It's just there in a more 
compact and readable format.

> All this x86lism should really belong to a x86 specify LIR and do it
> there. If you really have to do it, can you make it separator pass?

There is no x86-specific issues.  There are only generic C issues.

The fact is, 'a += b' must evaluate 'a' only once. I'm _not_ talking about
trying to keep it in some memory-to-memory architecture format like x86, 
but talking about making sure that C _requirement_ happens.

If you do it on a higher level (which we used to), you have to make the 
transformation that Al originally did, and turn 'a += b' into the much 
more complex 'tmp = &a, *tmp = *tmp + b'.

And THAT loses the original tree information.

In contrast, my changes keep the original tree information _longer_.

> I would like to keep the ability to access the untainted MIR.

The MIR is _less_ tainted now. Think about it: 'a += b' _used to generate 
this:

	# tmp = &a
	r1 <- 'a'
	load r2 <- [r1]
	r3 <- tmp
	store r2 -> [r3]

	# *tmp = *tmp + b
	r4 <- tmp
	load r5 <- [r4]
	load r6 <- [r5]
	r7 <- 'b'
	load r8 <- [r7]
	add r9,r6,r7
	r10 <- tmp
	load r11 <- [r10]
	store r9 -> [r11]

which is just horrid.

Now we generate something that is much closer to the original:

	load r1 <- ['a']
	load r2 <- ['b']
	add r3,r1,r2
	store r3 -> ['a']

because we

> How about a = a + b; vs a += b? If the compiler generate better code in
> the later, I would say it is not an very intelligent. 

Indeed. And I fixed it. It now generates _exactly_ the same MIR.

But with my load-store cleanups, I _also_ generate the proper code for

	*fn() += a

which is _not_ the same thing as

	*fn() = *fn()+a;

> This thing can be done correctly in the memory to scaler promotion. And
> the tmp will be promote first. The then tmp will be come an alias
> register to address of a. And then a will be promote also. I can show
> you the step by step detail.

Trust me. I do it correctly _now_. 

> Complicate the MIR is not necessary and IMHO is bad.

The MIR is not any more complex. Quite the reverse. It's _simpler_.

> You jump to the optimization process too earlier. I would rather do it
> right in the optimization step.

No. Read the code. See how it works. Instead of generating a really 
complex MIR that is complex because we did things wrong, we now generate a 
much simpler MIR.

It just introduces two concepts: pseudo's can be constant values, and
memory acceses are off the type "offset + (symbol|pseudo)". That's not a
complication, it's a simplification.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 20:08:42 +0000
Message-ID: <Pine.LNX.4.58.0411081204020.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Linus Torvalds wrote:
> 
> The MIR is _less_ tainted now. Think about it: 'a += b' _used to generate 
> this:
> 
> 	# tmp = &a
> 	r1 <- 'a'
> 	load r2 <- [r1]
> 	r3 <- tmp
> 	store r2 -> [r3]
> 
> 	# *tmp = *tmp + b
> 	r4 <- tmp
> 	load r5 <- [r4]
> 	load r6 <- [r5]
> 	r7 <- 'b'
> 	load r8 <- [r7]
> 	add r9,r6,r7
> 	r10 <- tmp
> 	load r11 <- [r10]
> 	store r9 -> [r11]
> 
> which is just horrid.
> 
> Now we generate something that is much closer to the original:
> 
> 	load r1 <- ['a']
> 	load r2 <- ['b']
> 	add r3,r1,r2
> 	store r3 -> ['a']

Side note: the new format has two major advantages. Not only is it more 
readable (and thus more likely correct), but my next phase is to try to 
turn local symbols into pseudo's, and then the old format was just painful 
as hell, since it took the _address_ of a symbol. Which is just 
unacceptable, since it entirely invalidates the whole MIR.

If you want to do CSE on address calculations, you can trivially do it by 
expanding the MIR later, ie change

	load r1 <- off['a']

into

	rN <- a
	rM <- off
	add rO, rN, rM
	load r1 <- [rO]

and do CSE on that format, but I'm claiming that it's _way_ too early to 
do that kind of thing at the point we used to do it. 

So I'm turning your own argument against you: we should keep the
high-level information in the MIR as long as possible, rather than throw
it away and making later optimizations much harder. The address CSE is 
_trivial_ to get later, but trying to do it early is a disaster.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 20:46:40 +0000
Message-ID: <8392.65.113.40.130.1099946800.squirrel () numba-tu ! com>
--------------------
Ok, I wasn't going to speak up, but let me just add my bit.

I really like the change.  It probably obvious to everyone, but the new "way"
makes it very easy to defer the decision of where to pass arguments.  That is,

  r2 <- load 4[#c]  (*)

can be interpreted as, fx.

  r2 <- rA2, where rA2 is some register specified by the ABI

or

  r2 <- load <someoffset>[rSP]


(*) Small suggestions for notation change

1: Register names are frequent, constants rarer, thus we should escape the
latter, not the former, eg: r1 and #foobar instead of %r1 and foobar

2: (Probably more controversial) The vast majority of instructions generate a
result, so factor out that commonality and use r2 <- add r3, r4 rather than
add r2 <- r3, r4.

Tommy


Linus Torvalds said:
>
>
> On Mon, 8 Nov 2004, Linus Torvalds wrote:
>>
>> The MIR is _less_ tainted now. Think about it: 'a += b' _used to generate
>> this:
>>
>> 	# tmp = &a
>> 	r1 <- 'a'
>> 	load r2 <- [r1]
>> 	r3 <- tmp
>> 	store r2 -> [r3]
>>
>> 	# *tmp = *tmp + b
>> 	r4 <- tmp
>> 	load r5 <- [r4]
>> 	load r6 <- [r5]
>> 	r7 <- 'b'
>> 	load r8 <- [r7]
>> 	add r9,r6,r7
>> 	r10 <- tmp
>> 	load r11 <- [r10]
>> 	store r9 -> [r11]
>>
>> which is just horrid.
>>
>> Now we generate something that is much closer to the original:
>>
>> 	load r1 <- ['a']
>> 	load r2 <- ['b']
>> 	add r3,r1,r2
>> 	store r3 -> ['a']
>
> Side note: the new format has two major advantages. Not only is it more
> readable (and thus more likely correct), but my next phase is to try to
> turn local symbols into pseudo's, and then the old format was just painful
> as hell, since it took the _address_ of a symbol. Which is just
> unacceptable, since it entirely invalidates the whole MIR.
>
> If you want to do CSE on address calculations, you can trivially do it by
> expanding the MIR later, ie change
>
> 	load r1 <- off['a']
>
> into
>
> 	rN <- a
> 	rM <- off
> 	add rO, rN, rM
> 	load r1 <- [rO]
>
> and do CSE on that format, but I'm claiming that it's _way_ too early to
> do that kind of thing at the point we used to do it.
>
> So I'm turning your own argument against you: we should keep the
> high-level information in the MIR as long as possible, rather than throw
> it away and making later optimizations much harder. The address CSE is
> _trivial_ to get later, but trying to do it early is a disaster.
>
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 20:50:33 +0000
Message-ID: <12427.65.113.40.130.1099947033.squirrel () numba-tu ! com>
--------------------
[Did this get through?  Apparently osdl's MTA doesn't like me not having an
ident service, sigh.]

> 1: Register names are frequent, constants rarer, thus we should escape the
> latter, not the former, eg: r1 and #foobar instead of %r1 and foobar

Clarification: I meant _symbolic_ constants, not _all_ constants.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 21:03:11 +0000
Message-ID: <26486.65.113.40.130.1099947791.squirrel () numba-tu ! com>
--------------------
Christopher Li said:
> about %r1 vs #foo. It doesn't matter too much to me.
> But consider later it will generate asm code using %eax etc. Might
> be natural just keep the %r1.

There is more in the world than x86 and not all use the %r1 notation.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizing memory accesses..
Date: Mon, 08 Nov 2004 21:22:49 +0000
Message-ID: <Pine.LNX.4.58.0411081317380.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Tommy Thorn wrote:
>
> [Did this get through?  Apparently osdl's MTA doesn't like me not having an
> ident service, sigh.]

The OSDL spam avoidance is pretty extreme. It's also extremely good, so 
I'm not complaining.

I saw the email from the sparse mailing list (vger.kernel.org is a proper 
mail host), but not your direct reply.

The fix is often to use your ISP's mailer to send out your emails, and not
try to do direct SMTP connections. Direct SMTP connections these days are
mostly a sign of automatically generated spam from 0wned machines.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Linearizing the kernel sources (was Re: #include MACRO) ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Linearizing the kernel sources (was Re: #include MACRO)
Date: Sat, 24 Jul 2004 16:40:18 +0000
Message-ID: <20040724164018.GA5122 () 64m ! dyndns ! org>
--------------------
On Sat, Jul 24, 2004 at 09:52:43AM -0700, Linus Torvalds wrote:
> 
> 
> On Sat, 24 Jul 2004, Linus Torvalds wrote:
> > 
> > This is the minimal test-case for this bug that I've found so far.
> 
> I can make it smaller still. It's not about inlining:
> 
> I think it might be a linearizer bug after all.
> 
> Chris?
>

Yes, I saw you fix it already. I will check out the next one.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Linearizing the kernel sources (was Re: #include MACRO)
Date: Sat, 24 Jul 2004 16:52:43 +0000
Message-ID: <Pine.LNX.4.58.0407240945040.1971 () ppc970 ! osdl ! org>
--------------------


On Sat, 24 Jul 2004, Linus Torvalds wrote:
> 
> This is the minimal test-case for this bug that I've found so far.

I can make it smaller still. It's not about inlining:

	void test(int i)
	{
		for ( ; ({ while (1) 1; }) ; i ) ;
	}

that "i" is actually important - it won't trigger without a post_statement 
in the iterator:

	test.c:3:13: warning: label 'continue' already bound
	test.c:3:13: warning: label 'break' already bound

(the error is at the "while" statement).

I think it might be a linearizer bug after all.

Chris?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizing the kernel sources (was Re: #include MACRO)
Date: Sat, 24 Jul 2004 17:39:50 +0000
Message-ID: <Pine.LNX.4.58.0407240959330.1971 () ppc970 ! osdl ! org>
--------------------


On Sat, 24 Jul 2004, Linus Torvalds wrote:
> 
> I can make it smaller still. It's not about inlining:
> 
> 	void test(int i)
> 	{
> 		for ( ; ({ while (1) 1; }) ; i ) ;
> 	}
> 
> I think it might be a linearizer bug after all.

Yes.

The problem is that the linearizer would linearize the for(..) loop as

	if (precond) {
		do {
			..
		} while (postcond);
	}

which doesn't work if precond == postcond since then you linearize the 
same statement twice, and try to re-use the labels etc, which is not going 
to work. The linearizer already knew about this special case, but only did 
it right if it looked like a pure while-loop (no post-statement).

Fixed and checked in. We can now run sparse on the kernel with the
linearizer pass turned on with only a few new warnings (at least on my 
config).

The new warnings seem to be due to sparse not being able to do the type of 
all expressions reliably. In fact, I see only one:

	drivers/md/dm-ioctl.c:1023:2: warning: call with no type!

which is the list_for_each() in:

	/*
	 * Count the devices.
	 */
	list_for_each (tmp, dm_table_get_devices(table))
		count++;

which in turn seems to be due to us not handling comma-expressions quite
right (but the DM code is really not supposed to pass a "head" that is a
complex expression, so that should probably get fixed too).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Linearizing the kernel sources (was Re: #include MACRO)
Date: Sat, 24 Jul 2004 22:01:06 +0000
Message-ID: <20040724220106.GA14390 () 64m ! dyndns ! org>
--------------------
On Sat, Jul 24, 2004 at 10:39:50AM -0700, Linus Torvalds wrote:
> 	/*
> 	 * Count the devices.
> 	 */
> 	list_for_each (tmp, dm_table_get_devices(table))
> 		count++;
> 
> which in turn seems to be due to us not handling comma-expressions quite
> right (but the DM code is really not supposed to pass a "head" that is a
> complex expression, so that should probably get fixed too).

The simple way to trigger that is:

struct list_head {
        struct list_head *next, *prev;
};

struct list_head *dm_table_get_devices(void);

void foo(void) {
        (dm_table_get_devices())->next;
}

Which seems to relate to dereference the member of a struct,  we convert
the expression to (void*) + offset. In the case of offset is zero, the
whole "+ offset" node is skipped.

If reference ->prev there, the warning does not show up.

Need to go, take another look tonight.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Linearizing the kernel sources (was Re: #include MACRO)
Date: Sun, 25 Jul 2004 01:40:58 +0000
Message-ID: <Pine.LNX.4.58.0407241826500.2522 () ppc970 ! osdl ! org>
--------------------


On Sat, 24 Jul 2004, Christopher Li wrote:
> 
> The simple way to trigger that is:

Thanks, that clarifies the issue.

> Which seems to relate to dereference the member of a struct,  we convert
> the expression to (void*) + offset. In the case of offset is zero, the
> whole "+ offset" node is skipped.

Good find.

Damn, that "don't add zero" optimization has bitten us before. The problem
is that while it obviously makes sense to avoid an add, avoiding the add
means that we end up re-using the original node, and we have to overwrite
the type information when we do that.

Which _most_ of the time is fine, but yes, anything that needs the type of
the inner node will be unhappy. Normally the checking pass doesn't care,
but now that we linearize the tree, it is understandably unhappy over
having had the type information overwritten (usually by a NULL too, but
not always - if we peel off the dereference by doing an addressof
operator, we will then re-write it with the _member_ pointer type, not the
structure pointer type that the inner node originally had).

I'll just disable that bogus optimization. We can always remove the "add
zero" at a later stage, I've grown tired of trying to fix up the type
problems that it causes to try to play games here..

I've actually been bitten by this before, but I never looked into it to
really understand why, so I blamed it on something else (and it went away
when I cleaned up the address-of stuff). Now that I look at it again, it 
was obviously always a bogus optimization.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Locking context checking and other cool stuff. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 00:48:26 +0000
Message-ID: <Pine.LNX.4.58.0410221733200.2101 () ppc970 ! osdl ! org>
--------------------

Ok,
 I've told people I wanted to do linearization because I wanted to check
locking etc, but I never actually _did_ any of this.

I now do. With the latest check-in, sparse now supports a new (incredibly 
ugly) syntax for updating an integer "context" thing at compile-time, and 
checking that the entry context matches the exit context (and that all 
internal contexts are consistent).

This is meant to be hidden inside the macros/inline functions that 
implement spinlocks, semaphores and other things, and it works roughly 
like this:

	#define spin_lock(x)	__context__ 1
	#define spin_unlock(x)	__context__ -1

	#define down(x)		__context__ 128
	#define up(x)		__context__ -128

	int main(int argc)
	{
		down(semaphore);
		if (argc) {
			argc = 5;
	#ifdef WORKS
			spin_lock(lock);
	#endif
		} else {
			spin_lock(lock);
			argc = 3;
		}
		spin_unlock(lock);
		up(semaphore);
	}

and you get:

	torvalds@ppc970:~/BK/sparse> ./check -DWORKS test.c 
	torvalds@ppc970:~/BK/sparse> ./check test.c 
	test.c:7:5: warning: context imbalance in 'main'
	torvalds@ppc970:~/BK/sparse> 

ie it will notice that something went wrong.

There's one problem with this: it really is very static. So if you do

	int main(int argc)
	{
		if (argc)
			spin_lock(lock);
		if (argc)
			spin_unlock(lock);
	}

it will complain, because it doesn't actually understand about the
locks/unlocks matching due to data control dependencies. It really just 
checks the flow graph, with _no_ understanding of what the graph actually 
means.

I don't have any way of turning the warning off yet (marking functions as 
being ok with some attribute), and I also want to expand this to:
 - have a way to verify the context (ie "the context count at this point
   must be X")
 - give initial values to functions ("this function gets called with a
   spinlock held")

but I thought I'd see what peoples reactions are.

You can use it for pretty much any "these things must balance out" kind of 
thing. Because of the lack of data following, it really doesn't work too 
well with "trylock()" etc, even though _conceptually_ it should be 
possible to do

	static inline int trylock(lock)
	{
		if (test_and_set(lock) {
			__context__ 1;
			return 1;
		}
		return 0;
	}

together with some trivial branch following (which we obviously don't do
yet). 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 01:34:39 +0000
Message-ID: <4270.192.168.1.101.1098495279.squirrel () www ! numba-tu ! com>
--------------------
Linus Torvalds said:
> I now do. With the latest check-in, sparse now supports a new (incredibly
> ugly) syntax for updating an integer "context" thing at compile-time, and
> checking that the entry context matches the exit context (and that all
> internal contexts are consistent).
...
> There's one problem with this: it really is very static. So if you do
>
> 	int main(int argc)
> 	{
> 		if (argc)
> 			spin_lock(lock);
> 		if (argc)
> 			spin_unlock(lock);
> 	}
>
> it will complain, because it doesn't actually understand about the
> locks/unlocks matching due to data control dependencies. It really just
> checks the flow graph, with _no_ understanding of what the graph actually
> means.

Knowledge of program dependence could tighten the analysis.  The case above
would trivial be handled as would cases where the condition are equal after
CSE and constant folding etc.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 01:41:20 +0000
Message-ID: <Pine.LNX.4.58.0410221839150.2101 () ppc970 ! osdl ! org>
--------------------


On Fri, 22 Oct 2004, Tommy Thorn wrote:
> 
> Knowledge of program dependence could tighten the analysis.  The case above
> would trivial be handled as would cases where the condition are equal after
> CSE and constant folding etc.

Oh yes. No question. I'm not just up for it.

A linearizer is just about as close as I want to get to a back-end. I'd 
love to see CSE being done, but quite frankly, I'd do it wrong. 

It should all be simple with the SSA layout, but ...

Hint hint.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 02:42:34 +0000
Message-ID: <20041023024234.GB13841 () wotan ! suse ! de>
--------------------
> Knowledge of program dependence could tighten the analysis.  The case above
> would trivial be handled as would cases where the condition are equal after
> CSE and constant folding etc.

This case could be perhaps handled, but in general it cannot be done because
it would be equivalent to solving the halting problem. But it would be nice
if the checker could figure out that it cannot handle it and in that case
just don't warn.

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 03:11:03 +0000
Message-ID: <4179CBC7.9020002 () numba-tu ! com>
--------------------
Andi Kleen wrote:

>>Knowledge of program dependence could tighten the analysis.  The case above
>>would trivial be handled as would cases where the condition are equal after
>>CSE and constant folding etc.
>>    
>>
>
>This case could be perhaps handled, but in general it cannot be done because
>it would be equivalent to solving the halting problem. But it would be nice
>if the checker could figure out that it cannot handle it and in that case
>just don't warn.
>  
>
Not to spawn a long and boring thread about this, but the program 
dependence [1] I'm talking about is well defined and (obviously) a 
subset of the true (uncomputable) dynamic dependence.  There will always 
be false negatives.

I'm not sure not warning on the cases it can't resolve is so desirable.  
The situation is very much the same with unintialized variables where 
gcc today will (rightfully) complain when it cannot statically determine 
that a variable is defined before a use.


My efforts on the GSA form kind of stalled in July, but I do have a few 
point (mostly) working:
- Deriving the Data Dependency Graph from the Gated Single Assignment 
(the PDG = DDG + GSA)
- Sequentializing the PDG back into a CFG
- Assembler generation from the CFG (just a toy effort)

The major part missing is still hooking it up to sparse, that is, 
generating the GSA from the sparse internal representation. I really 
should pick up the ball again.

Tommy
[1] The Program Dependence Graph and Its Use in Optimization, Jeanne 
Ferrante et al, TOPLAS 1987,
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 03:15:47 +0000
Message-ID: <Pine.LNX.4.58.0410222004560.2101 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Andi Kleen wrote:
> > Knowledge of program dependence could tighten the analysis.  The case above
> > would trivial be handled as would cases where the condition are equal after
> > CSE and constant folding etc.
> 
> This case could be perhaps handled, but in general it cannot be done because
> it would be equivalent to solving the halting problem.

I don't think we need to handle the general case.

It's quite ok to say: "you have to have clean locking". And quite frankly, 
conditional locking is _never_ clean. The only case I personally want to 
handle is really the

	if (spin_trylock(xx)) {
		..do something..
		spin_unlock(xx);
	}

case, and that one literally should be just a matter of doing some very
simple branch back-folding over the inline function return.  No CSE even
needed for that one, although I'd love to have it for slightly harder
cases.

Basically, the above just becomes:

	bb: 0xf7fa605c
	  **from 0xf7fa600c**
	        context 1
	        %r3 <- 1
	        br      .L0xf7fa604c

	bb: 0xf7fa606c
	  **from 0xf7fa600c**
	        %r5 <- 0
	        br      .L0xf7fa604c

	bb: 0xf7fa604c
	  **from 0xf7fa605c**
	  **from 0xf7fa606c**
	        %r4 <- phi (%r3, .L0xf7fa605c), (%r5, .L0xf7fa606c)
	        br      %r4, .L0xf7fa602c, .L0xf7fa603c

	bb: 0xf7fa602c
	  **from 0xf7fa604c**
	        context -1
	        br      .L0xf7fa603c

	bb: 0xf7fa603c
	  **from 0xf7fa604c**
	  **from 0xf7fa602c**
	        ret %r0


and notice that the _only_ thing we would need to fix up is to move that

	%r4 <- phi (%r3, .L0xf7fa605c), (%r5, .L0xf7fa606c)
	br      %r4, .L0xf7fa602c, .L0xf7fa603c

bb into the parents, and suddenly it would all be totally statically
determined, and sparse could tell that the trylock+unlock was perfectly ok
locking-wise.

Not any complicated stuff really needed, and the above really is the only
case that matters. Anybody who does conditional locking on real data
should (a) be shot and (b) can mark their damn functions as uncheckable
with a big comment saying "I have verified this by hand a million times".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 03:35:17 +0000
Message-ID: <20041023033517.GC13841 () wotan ! suse ! de>
--------------------
> It's quite ok to say: "you have to have clean locking". And quite frankly, 
> conditional locking is _never_ clean. The only case I personally want to 
> handle is really the
> 
> 	if (spin_trylock(xx)) {
> 		..do something..
> 		spin_unlock(xx);
> 	}
> 
> case, and that one literally should be just a matter of doing some very
> simple branch back-folding over the inline function return.  No CSE even
> needed for that one, although I'd love to have it for slightly harder
> cases.

How about the case where the lock is released in a different function? 


> Not any complicated stuff really needed, and the above really is the only
> case that matters. Anybody who does conditional locking on real data
> should (a) be shot and (b) can mark their damn functions as uncheckable
> with a big comment saying "I have verified this by hand a million times".

Ok. I suspect you'll need to mark a lot of functions in the Kernel like that
though (particularly in fs/* and drivers/*) 

-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 03:59:32 +0000
Message-ID: <Pine.LNX.4.58.0410222042380.2101 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Andi Kleen wrote:
> 
> How about the case where the lock is released in a different function? 

That's rare, and then we should just document that in thr source (we 
usually do), and we should mark the function as being nonbalanced, so that 
sparse won't complain.

I think one of the best parts of C is that you can do bad things. Sparse
allows that too - in the typechecking it's the "force" attribute, which
basically says "dammit, I know what I'm doing". Same should go for the
lock testing. We should not even _try_ to make the lock testing be
"perfect". I'm aiming for "let's get the common case right, and give the
user a way out for when we don't get it right".

That should be a hard rule in _any_ language: if you can't break the
rules, the language is useless for real work. (And the corollary to that
is that if you have to break the rules all the time, the language also
sucks).

And let's face it, 99% of all locking is very simple indeed, and the
context thing should catch that very well. The 1% is usually stuff where
an explicit annotation and a comment is a good idea _anyway_ (ie an
explicit note to sparse that "hey, we break the common rules here" is
actually a good thing for the user to see too, so having a sparse
annotation for that is _good_).

My main gripe with the stanford checker was that it wasn't freely 
available, _and_ that it tried to get all the information from the source 
code. The first problem just made it hard to use, but the second problem i 
smore fundamental: it means that the checker has to be "perfect". And 
nothing ever is. 

> Ok. I suspect you'll need to mark a lot of functions in the Kernel like that
> though (particularly in fs/* and drivers/*) 

I don't think so. We really don't tend to unlock in another function. In 
fact, it used to be illegal on sparc with the "flags" variants.

There are some special cases, dentry_iput() being one of them. But it 
really does have a comment about it, exactly because it's unusual:

 * Called with dcache_lock and per dentry lock held, drops both.

and in this case it actually happens to be an inline function, so sparse 
would not even complain about it. But if it wasn't an inline function, 
we'd have to annotate it.

In fact, I just tested this on fs/dcache.c, and I got _one_ warning when 
I did

	#define spin_lock(x) __context__ 1
	#define spin_unlock(x) __context__ -1

namely:

fs/dcache.c:147:6: warning: context imbalance in 'dput', and that one 
seems to be due to the "atomic_dec_and_lock()" (which is exactly the same 
issue as spin_trylock()).

So it actually does seem to work.

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 04:19:56 +0000
Message-ID: <Pine.LNX.4.58.0410222108170.2101 () ppc970 ! osdl ! org>
--------------------


On Fri, 22 Oct 2004, Linus Torvalds wrote:
> 
> and notice that the _only_ thing we would need to fix up is to move that
> 
> 	%r4 <- phi (%r3, .L0xf7fa605c), (%r5, .L0xf7fa606c)
> 	br      %r4, .L0xf7fa602c, .L0xf7fa603c
> 
> bb into the parents, and suddenly it would all be totally statically
> determined

Btw, the above is a _trivial_ pattern to test for (and should be pretty
common - having an inline function that returns true/false along two
different branches is a common idiom in the kernel), and it would be very
easy to add a simple collapser for basic blocks of this nature, where we
do:

 - if a basic block is just a phi instruction + a branch on the result, go 
   through each of the phi source cases and see if they are constant. 
   Rewrite the source bb to directly jump to the proper target if so.

So getting the flow control and branch collaps looks easy. The only
problem would seem to be maintaining SSA form for %r4 for the the
rewritten case.

Damn. So close, yet so far. I assume there are tons of papers on these SSA 
transforms, and this just has to be one of the more trivial cases, so I'm 
hoping Chris Li or somebody says "oh, that's easy" and just does it.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "David S. Miller" <davem () davemloft ! net>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 05:32:22 +0000
Message-ID: <20041022223222.0e7facb2.davem () davemloft ! net>
--------------------

The next thing I guess is to be able to mark data structures
in some way like:

	struct buffer {
		spinlock_t	lock;
		unsigned int	offset __protected_by__((buffer.lock));

you get the idea.  At that point we'd have the equivalent of
a tool Sun used internally for Solaris which "verified" the
SMP locking using source annotations.

Anyways, I like the context feature.  Some compiler geek can
work on better flow analysis or CSE if they want.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 06:38:13 +0000
Message-ID: <20041023063813.GC5743 () 64m ! dyndns ! org>
--------------------
On Fri, Oct 22, 2004 at 09:19:56PM -0700, Linus Torvalds wrote:
> 
> 
> On Fri, 22 Oct 2004, Linus Torvalds wrote:
> > 
> > 	%r4 <- phi (%r3, .L0xf7fa605c), (%r5, .L0xf7fa606c)
> > 	br      %r4, .L0xf7fa602c, .L0xf7fa603c
> > 
> Damn. So close, yet so far. I assume there are tons of papers on these SSA 
> transforms, and this just has to be one of the more trivial cases, so I'm 
> hoping Chris Li or somebody says "oh, that's easy" and just does it.

I am hearing. I think for that we can try to do the checking without
the SSA form. Doing the full SSA for addressable memory variable is very
complicate. We are not building a compiler here so we don't need to prove
the locking is 100% correct. We just need to pick out the possible one that
can lead to incorrect.

For.
if(try_lock(x)) {
	...;
	unlock(x);
}, 

We can build a state machine. In here the we only need to try two stat:
X is locked and X is unlocked. Then we can interpret the flow base on the
two possible stat. Both two case will work fine.

If there is feed back, it is more complicated but still doable.

Those simple unmatched one can be easily pick out in this way even
there is some degree of data flow dependency. Of course this is not
perfect, but it should be much easier to do.

Chris
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 16:47:48 +0000
Message-ID: <Pine.LNX.4.58.0410230928560.2101 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Christopher Li wrote:
> 
> I am hearing. I think for that we can try to do the checking without
> the SSA form.

Well, the thing is, I do want to keep the dang data flow in a valid
format, because otherwise there's no telling what happens when we do two
of these things, and we've modified the flow on the first one and 
invalidated the SSA information, and then the second one just does 
something wrong..

The problem I have with the SSA form is really that the location of the 
phi nodes doesn't make any sense in standard SSA. I doubt I'm the only one 
who thinks rewriting SSA because you need to move the phi node is a pain 
in the *ss.

And the fact is, the phi-node _really_ doesn't even go with the target. 
Conceptually, the phi-node doesn't _have_ a location, it's just a set of 
mapping of edges to assignments.

So my suggestion to solving this problem is to just make the phi-nodes 
totally independent of the tree. They have nothing to do with any 
location: they just really end up being a mapping of "which basic block 
and which register in that bb does this value come from".

It's still single-assignment, it's just that we make it clear that the 
location where the assignment happens is _not_ the target of the branch, 
and the phi-node is just a concept without any real location (after all, 
in actually generating the code, the actual assignment ends up being in 
the _source_ of the branch, not the target, so saying that it doesn't have 
a location is actually sane).

And once you take the phi nodes out of the flow graph in to a separate
independent "set of phi nodes associated with this entrypoint", the
rewrite is trivial. You don't even need to touch the phi node at all at
that point - it remains valid even if you change the target of one of the
branches (only if you change the _source_ of a branch due to merging a bb
or something like that do you need to rewrite the phi node to update the
source of the register).

I assume some compiler must have used phi-nodes this way already, it 
really doesn't sound that strange to me, and it should simplify a _lot_ of 
SSA flow rewriting.

(Or maybe, because it sounds so obvious, there is some obvious reason why 
people do _not_ do it. Oh, well).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 18:18:30 +0000
Message-ID: <417AA076.70902 () numba-tu ! com>
--------------------
Linus Torvalds wrote:

>The problem I have with the SSA form is really that the location of the 
>phi nodes doesn't make any sense in standard SSA. I doubt I'm the only one 
>who thinks rewriting SSA because you need to move the phi node is a pain 
>in the *ss.
>  
>
Amen. One of the more common variations on the SSA representation is to 
put the assignments at the branches, but keeping an empty phi node at 
the target, something like

    %r4 = eta(%r2)
    goto L2

L2: %r4 = phi()

which mostly helps making adding and deleting branches manageable.

>And the fact is, the phi-node _really_ doesn't even go with the target. 
>Conceptually, the phi-node doesn't _have_ a location, it's just a set of 
>mapping of edges to assignments.
>  
>
The are lots of problems phi nodes. They do not have local operational 
semantics, that is, you can't interpret a program in SSA form without 
keep track of where you came from for each goto.  They violate 
referential transparency, that is two phi nodes with the same arguments 
aren't necessarily the same value.

>So my suggestion to solving this problem is to just make the phi-nodes 
>totally independent of the tree. They have nothing to do with any 
>location: they just really end up being a mapping of "which basic block 
>and which register in that bb does this value come from".
>
>It's still single-assignment, it's just that we make it clear that the 
>location where the assignment happens is _not_ the target of the branch, 
>and the phi-node is just a concept without any real location (after all, 
>in actually generating the code, the actual assignment ends up being in 
>the _source_ of the branch, not the target, so saying that it doesn't have 
>a location is actually sane).
>
>And once you take the phi nodes out of the flow graph in to a separate
>independent "set of phi nodes associated with this entrypoint", the
>rewrite is trivial. You don't even need to touch the phi node at all at
>that point - it remains valid even if you change the target of one of the
>branches (only if you change the _source_ of a branch due to merging a bb
>or something like that do you need to rewrite the phi node to update the
>source of the register).
>  
>
Yeay, you've moving in the direction of a graphs :-)  Next logical step 
is to realize that keeping names around is silly, we should just point 
directly to the definitions of the variable (then where you choose to 
keep your phi assignments becomes irrelevant).

The basic problem didn't really change though. You still have to merge 
%r2 and %r3 somewhere and finding out where and how is the problem as it 
depends on the control flow, but it can be done with a simple little 
fixpoint algorithm where you keep pushing definitions forward until they 
meet (it's an inefficient way though).

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 18:45:31 +0000
Message-ID: <Pine.LNX.4.58.0410231132250.2101 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Tommy Thorn wrote:
>
> Amen. One of the more common variations on the SSA representation is to
> put the assignments at the branches, but keeping an empty phi node at
> the target, something like
> 
>     %r4 = eta(%r2)
>     goto L2
> 
> L2: %r4 = phi()
> 
> which mostly helps making adding and deleting branches manageable.

I ended up doing something slightly different. It works for what I wanted
to do, and it's checked in. It may not be 100% wonderful, but I think it's
actually acceptable even for a real code generator, and dammit, it was
simple.

What I do is to just say "location of phi-node doesn't matter". So I'm 
even lazier than what I outlined originally - I don't put the phi-nodes on 
any separate list or anything like that, I just say that their location 
isn't relevant. They affect the _whole_ tree, and if you need to find the 
definition of a variable "r" that is a phi-node, you need to just search 
the whole tree.

Of course, the obvious thing to do is to make the "pseudo" just have a 
pointer to its definition, which means that you don't "search" anything, 
you just look up the instruction that was the phi-node for that pseudo (if 
it was a pseudo). That's really what you want to have anyway.

So let's take my trivial test program, and see what I do to it:

	#define spin_lock(x)    __context__ 1
	#define spin_unlock(x)  __context__ -1

	#define down(x)         __context__ 128
	#define up(x)           __context__ -128

	static inline int trylock(int argc)
	{
		if (argc) {
			spin_lock(x);
			return 1;
		}
		return 0;
	}

	int main(int argc)
	{
		if (trylock(argc)) {
			spin_unlock(x);
		}                                                                                
	}

the original linearizer resulted in:

	ep 0xf7fe200c: main
	   sym: 0xf7fd1760 argc
	   sym: 0xf7fd18c8 argc

	ENTRY:
	bb: 0xf7fa600c
		%r1 <- argc
		load %r2 <- [%r1]
		br	%r2, .L0xf7fa6084, .L0xf7fa609c

	bb: 0xf7fa6084
	  **from 0xf7fa600c**
		context 1
		%r3 <- 1
		br	.L0xf7fa606c

	bb: 0xf7fa609c
	  **from 0xf7fa600c**
		%r5 <- 0
		br	.L0xf7fa606c

	bb: 0xf7fa606c
	  **from 0xf7fa6084**
	  **from 0xf7fa609c**
		%r4 <- phi (%r3, .L0xf7fa6084), (%r5, .L0xf7fa609c)
		br	%r4, .L0xf7fa603c, .L0xf7fa6054

	bb: 0xf7fa603c
	  **from 0xf7fa606c**
		context -1
		br	.L0xf7fa6054

	bb: 0xf7fa6054
	  **from 0xf7fa606c**
	  **from 0xf7fa603c**
		ret %r0


and what I do to it can actually be best expressed by the diff between the 
old one and the stuff I do in the new one:

	--- orig	2004-10-23 11:37:27.000000000 -0700
	+++ new	2004-10-23 11:37:38.000000000 -0700
	@@ -12,12 +12,12 @@
	   **from 0xf7fa600c**
	 	context 1
	 	%r3 <- 1
	-	br	.L0xf7fa606c
	+	br	.L0xf7fa603c
	 
	 bb: 0xf7fa609c
	   **from 0xf7fa600c**
	 	%r5 <- 0
	-	br	.L0xf7fa606c
	+	br	.L0xf7fa6054
	 
	 bb: 0xf7fa606c
	   **from 0xf7fa6084**
	@@ -27,12 +27,14 @@
	 
	 bb: 0xf7fa603c
	   **from 0xf7fa606c**
	+  **from 0xf7fa6084**
	 	context -1
	 	br	.L0xf7fa6054
 
	 bb: 0xf7fa6054
	   **from 0xf7fa606c**
	   **from 0xf7fa603c**
	+  **from 0xf7fa609c**
	 	ret %r0
	 
	 

Ie I _leave_ the phi-node in its original location (because location
doesn't matter), and I have just rewritted the branches. I did that by
just going through the flow graph looking for the <phi+br> pattern, and
then iterating over each <phi> entry to see what the definition for that
pseudo was (dammit, that's where I wanted to have a pointer from the
pseudo to the definition of that pseudo - instead I just ended up
searching the immediate parent block for an OP_SETVAL, which can miss the
real value if it was set somewhere else..).

And then I add the new parent info for the branches I rewrote (I do not 
remove the old parent info - partly because I'm lazy, but partly because I 
suspected that if we want to find the definitions from the <phi> node, we 
actually _want_ the bb's that are no longer really parents).

Very simple. And it makes "trylock()" work, so "sparse" no longer 
complains about the test-case.

> Yeay, you've moving in the direction of a graphs :-)  Next logical step 
> is to realize that keeping names around is silly, we should just point 
> directly to the definitions of the variable (then where you choose to 
> keep your phi assignments becomes irrelevant).

That _is_ my next step. I should probably have done it first, because it 
would have made finding the "what is the value of this phi definition" a 
lot more proper, and it means that you don't have to search for phi nodes. 
But since nothing currently really cares where the phi-node is anyway, the 
latter wasn't an issue, and the former was trivially done with a linear 
search of the parent, which catches the cases I wanted to catch..

> The basic problem didn't really change though. You still have to merge 
> %r2 and %r3 somewhere

Sure. But the information is still there, and it's no worse than it was 
before..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sat, 23 Oct 2004 18:58:50 +0000
Message-ID: <Pine.LNX.4.58.0410231156490.2101 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Linus Torvalds wrote:
> 
> > Yeay, you've moving in the direction of a graphs :-)  Next logical step 
> > is to realize that keeping names around is silly, we should just point 
> > directly to the definitions of the variable (then where you choose to 
> > keep your phi assignments becomes irrelevant).
> 
> That _is_ my next step. I should probably have done it first, because it 
> would have made finding the "what is the value of this phi definition" a 
> lot more proper, and it means that you don't have to search for phi nodes. 

Done. Trivial, really. And yes, that allowed me to get rid of the loop 
which looks for the instruction that sets the pseudo. 

Btw, the branch rewriting really does happen in real life. A normal kernel 
compile with my standard pp64 config triggers 1343 branch rewrites.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sun, 24 Oct 2004 03:57:19 +0000
Message-ID: <Pine.LNX.4.58.0410232041090.13209 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Linus Torvalds wrote:
> 
> Done. Trivial, really. And yes, that allowed me to get rid of the loop 
> which looks for the instruction that sets the pseudo. 

Btw, after fixing a stupid (and quite hard-to-find) bug with inlining of 
case statements, this now all actually works pretty well.

Together with some silly patches to the kernel like

	+# define __context_change(in,out) __attribute__((context(in,out)))
	+# define context_update(x)     __context__(x)

	...
	-void __lockfunc _spin_lock(spinlock_t *lock);
	-void __lockfunc _write_lock(rwlock_t *lock);
	-void __lockfunc _spin_lock(spinlock_t *lock);
	-void __lockfunc _read_lock(rwlock_t *lock);
	-void __lockfunc _spin_unlock(spinlock_t *lock);
	-void __lockfunc _write_unlock(rwlock_t *lock);
	-void __lockfunc _read_unlock(rwlock_t *lock);
	+void __lockfunc __context_change(0,1)  _spin_lock(spinlock_t *lock);
	+void __lockfunc __context_change(0,4)  _read_lock(rwlock_t *lock);
	+void __lockfunc __context_change(0,16) _write_lock(rwlock_t *lock);
	+void __lockfunc __context_change(1,0)  _spin_unlock(spinlock_t *lock);
	+void __lockfunc __context_change(4,0)  _read_unlock(rwlock_t *lock);
	+void __lockfunc __context_change(16,0) _write_unlock(rwlock_t *lock);

and some creative insanity:

	+#if defined(CONFIG_SMP) && defined(__CHECKER__)
	+
	+#define _spin_trylock(lock)    (_spin_trylock(lock) ? ({ context_update(+1); 1; }) : 0)
	+#define _write_trylock(lock)   (_write_trylock(lock) ? ({ context_update(+16); 1; }) : 0)
	+#define atomic_dec_and_lock(atomic,lock) \
	+       (atomic_dec_and_lock(atomic, lock) ? ({ context_update(+1); 1; }) : 0)
	+

I can actually compile the kernel with this, and I've got something like
350 context imbalance warnings.

And most of those _by_far_ seem to be due to "lock_kernel()", which is
inlined, and which has that conditional spinlock. Making it a
lock-function (the same way we uninlined regular spinlocks) would be a
very good thing.

Also, most functions that change the context (ie they return with a lock
held or similar) can be similarly annotated quite well:

	  * rq_lock - lock a given runqueue and disable interrupts.
	  */
	-static runqueue_t *this_rq_lock(void)
	+static runqueue_t *this_rq_lock(void) __context_change(0,1)
	 {
	        runqueue_t *rq;

and sparse ends up understanding that and doing the right context updates
in the callers whenever such a function is called.

Andi was definitely correct in that there are a few bad lock users - the 
vm layer tends to do some locking depending on whether there is a backing 
filestore or not. But as mentioned, most of it does seem to be lock_kernel 
etc, which should be easily handled.

I'm doing a build with the lock_kernel problem hacked out, just to verify 
my "manual eyeballing" of the original build. 

Interestingly, it already foung a "bug": it complained about

	kernel/intermodule.c:56:2: warning: context imbalance in 'inter_module_register' (saw 0, expected 1)

which is because the list_for_each() in that function _does_ actually drop 
a lock without re-taking it. Of course, it isn't a real bug, because that 
path contains a BUG() in it, so the problem that sparse found was due to 
sparse not understanding that the BUG() stops execution cold.. But it's 
kind of nice to see a report like that...

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sun, 24 Oct 2004 04:17:37 +0000
Message-ID: <Pine.LNX.4.58.0410232103010.13209 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Linus Torvalds wrote:
>
> And most of those _by_far_ seem to be due to "lock_kernel()"

Well, "by far" seems to be overdoing it. Almost half of them were due to 
lock_kernel(), but there are 207 warnings with that fixed.

Exmple:

net/unix/af_unix.c:921:40: warning: context imbalance in 'unix_wait_for_peer' (saw -4, expected 0)
net/unix/af_unix.c:950:8: warning: context imbalance in 'unix_stream_connect' (saw 4, expected 0)
net/unix/af_unix.c:1305:8: warning: context imbalance in 'unix_dgram_sendmsg' (saw 4, expected 0)
net/unix/af_unix.c:1896:13: warning: context imbalance in 'unix_seq_start' (saw 4, expected 0)
net/unix/af_unix.c:1911:13: warning: context imbalance in 'unix_seq_stop' (saw -4, expected 0)

which seems to be due to 
 - unix_wait_for_peer() being called with a read lock held, and returns
   without it. No comments about that. Tssk, tssk.
 - unix_stream_connect() doing a conditional unlock based on whether it 
   has "other".
 - 'unix_dgram_sendmsg' was due to 'unix_wait_for_peer()' not being 
   annotated, so it warned because it didn't know about it dropping the 
   lock. Annotating that fixes it.
 - unix_seq_start/stop needing to be annotated that they take/release a 
   lock. Annotating them fixes it.

So that's an example of five warnings where one ended up being hard to 
handle because locking in it literally is data-flow-dependent.

There's a magic annotation of "__context_change(-1,0)" which can be used 
to shut sparse up about things like unix_stream_connect(), which are 
data-dependent. It's just a way of shutting sparse up, and I'd hope we 
don't need to do things like that much. If this is indicative of how 
things look in general, we might need a few of them.

Can somebody come up with a nicer syntax for the annotations? My current 
macro names they do sucketh.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sun, 24 Oct 2004 16:00:49 +0000
Message-ID: <20041024160049.GB10483 () 64m ! dyndns ! org>
--------------------
On Sat, Oct 23, 2004 at 11:45:31AM -0700, Linus Torvalds wrote:
> 
> 
> On Sat, 23 Oct 2004, Tommy Thorn wrote:
> >
> Of course, the obvious thing to do is to make the "pseudo" just have a 
> pointer to its definition, which means that you don't "search" anything, 
> you just look up the instruction that was the phi-node for that pseudo (if 
> it was a pseudo). That's really what you want to have anyway.

Yes, I agree. That is why I want the pseudo_t to be a pointer of struct.
I want to have to a list of the pseudo user so you don't have to search
who use it.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Locking context checking and other cool stuff.
Date: Sun, 24 Oct 2004 20:47:12 +0000
Message-ID: <Pine.LNX.4.58.0410241335440.13209 () ppc970 ! osdl ! org>
--------------------


On Sat, 23 Oct 2004, Linus Torvalds wrote:
> 
> Can somebody come up with a nicer syntax for the annotations? My current 
> macro names they do sucketh.

I didn't get any suggestions, so I just made up my own and checked them 
in.

The new syntax for marking a function as getting or releasing a spinlock 
is to add a __acquires(lockname/locktype) or __releases(lockname/locktype) 
after the function declaration.

For example, the properly annotated _spin_[un]lock() declaration looks
like

	void __lockfunc _spin_lock(spinlock_t *lock)    __acquires(spinlock_t);
	void __lockfunc _spin_unlock(spinlock_t *lock)  __releases(spinlock_t);

which looks fairly readable to me. Eventually I might make the context
count depend on the type of lock acquired, but right now they all count as
"1".

Context checking is off by default in sparse (well, to be precise, the 
_checking_ is on, but the warning isn't printed), so nobody should notice 
anything. But as of today, you can now do

	make C=2 fs/dcache.o

and if you've changed CHECKFLAGS to include -Wcontext, it will print out

	fs/dcache.c:154:2: warning: context imbalance in 'dput' (saw -1, expected 0)

because the current kernel tree does not have the trylock annotations 
yet.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Lots of sparse bugfixes lately.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Lots of sparse bugfixes lately..
Date: Sat, 29 May 2004 05:29:19 +0000
Message-ID: <Pine.LNX.4.58.0405282219220.1648 () ppc970 ! osdl ! org>
--------------------

Al Viro has been playing with sparse on the kernel tree, and was goot at
generating these small snippets of code to show particular bugs. Which got
me a lot more motivated, so in the last few days I've been fixing a _ton_
of type and expression tree problems, and sparse really does a lot better
at things that it totally fell down on before (even when it got the type
right, it often didn't actually get the expression tree right).

As one particular example, multi-dimensional arrays actually work now,
with

	int arr[2][3][4];

	int n(int a, int b, int c)
	{
	        return arr[a][b][c];
	}

actually generating not just the correct type, but the correct expression 
tree and thus linearization

	ep 0x4002600c: n
	   sym: 0x4003b3ac a
	   sym: 0x4003b49c b
	   sym: 0x4003b58c c

	bb: 0x40069018
	        %r1 <- arr
	        %r2 <- a
	        load %r3 <- [%r2]
	        %r4 <- 48
	        %r5 <- mul  %r3, %r4
	        %r6 <- add  %r1, %r5
	        %r7 <- b
	        load %r8 <- [%r7]
	        %r9 <- 16
	        %r10 <- mul  %r8, %r9
	        %r11 <- add  %r6, %r10
	        %r12 <- c
	        load %r13 <- [%r12]
	        %r14 <- 4
	        %r15 <- mul  %r13, %r14
	        %r16 <- add  %r11, %r15
	        load %r17 <- [%r16]
	        ret %r17

which is a lot better than what it did just a few days ago.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: More debug information? ===

From: Victor Boivie <vboivie () gmail ! com>
To: linux-sparse
Subject: More debug information?
Date: Mon, 27 Sep 2004 17:18:39 +0000
Message-ID: <b1f10fbd04092710183641ef5 () mail ! gmail ! com>
--------------------
Hello everybody,

I just stumbled upon sparse and I think it's interesting for studying
compiler construction. But one thing that I would want to see is more
debug information together with the "parse tree". Something like "gcc
-S -g" would suffice since it shows the line numbers of the
corresponding c-source and then I can see what's really happening.

Maybe this is possible already, but I have failed to see how?

Thanks in advance,
Victor
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Victor Boivie <vboivie () gmail ! com>
To: linux-sparse
Subject: More debug information?
Date: Mon, 27 Sep 2004 17:18:39 +0000
Message-ID: <b1f10fbd04092710183641ef5 () mail ! gmail ! com>
--------------------
Hello everybody,

I just stumbled upon sparse and I think it's interesting for studying
compiler construction. But one thing that I would want to see is more
debug information together with the "parse tree". Something like "gcc
-S -g" would suffice since it shows the line numbers of the
corresponding c-source and then I can see what's really happening.

Maybe this is possible already, but I have failed to see how?

Thanks in advance,
Victor
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Victor Boivie <vboivie () gmail ! com>
To: linux-sparse
Subject: More debug information?
Date: Mon, 27 Sep 2004 17:18:39 +0000
Message-ID: <b1f10fbd04092710183641ef5 () mail ! gmail ! com>
--------------------
Hello everybody,

I just stumbled upon sparse and I think it's interesting for studying
compiler construction. But one thing that I would want to see is more
debug information together with the "parse tree". Something like "gcc
-S -g" would suffice since it shows the line numbers of the
corresponding c-source and then I can see what's really happening.

Maybe this is possible already, but I have failed to see how?

Thanks in advance,
Victor
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Victor Boivie <vboivie () gmail ! com>
To: linux-sparse
Subject: More debug information?
Date: Mon, 27 Sep 2004 17:27:23 +0000
Message-ID: <b1f10fbd0409271027779c3477 () mail ! gmail ! com>
--------------------
Hello everybody,

I just stumbled upon sparse and I think it's interesting for studying
compiler construction. But one thing that I would want to see is more
debug information together with the "parse tree". Something like "gcc
-S -g" would suffice since it shows the line numbers of the
corresponding c-source and then I can see what's really happening.

Maybe this is possible already, but I have failed to see how?

Thanks in advance,
Victor
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: My TODO list... ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: My TODO list...
Date: Sat, 14 Aug 2004 17:01:42 +0000
Message-ID: <200408141701.i7EH1gP08192 () troll ! rentec ! com>
--------------------

Somewhere between FYI and RFC:

* An "attribute terminating_arg (const-expr)" to handle vararg functions
  that require a terminator.  We saw missing NULLs the other day, but
  other functions seen require a 0 or a -1.  This is really a place
  where 0 is not NULL.

* Magic to detect if isdigit and friends are called on an argument of
  type char.  (A bit tricky without source code changes since isdigit
  is a macro.)

* Magic to type-check MIN and MAX.  I think sparse can do better than
  C level macros because it can inspect constants.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: My TODO list...
Date: Sun, 22 Aug 2004 19:26:56 +0000
Message-ID: <Pine.LNX.4.58.0408221205580.17766 () ppc970 ! osdl ! org>
--------------------


On Sat, 14 Aug 2004, Morten Welinder wrote:
> 
> Somewhere between FYI and RFC:
> 
> * An "attribute terminating_arg (const-expr)" to handle vararg functions
>   that require a terminator.  We saw missing NULLs the other day, but
>   other functions seen require a 0 or a -1.  This is really a place
>   where 0 is not NULL.

You really want to check both _types_ and values. Sparse does have types
as a somewhat more "real" citizen than regular C, and it wouldn't be
impossible to have both the expression and the type be forced by the
thing.

That said, I have other issues with varargs. It's not just terminating 
entries, it's the fact that they have no type safety at all. I really 
don't like using them, and you'll find that the kernel almost never does. 
I think varargs are a "good enough" hack for printf(), but should 
otherwise be avoided.

So I'd much much rather have something that isn't a special case for 
terminators in vararg lists, but a more general thing. I'd love to have 
some better checking "language" than just random attributes that would 
allow more of an annotation of what is ok for arguments.

For example, even for fixed-type things, we often want to make sure the 
input arguments are "sane" some way. You bring up another example:

> * Magic to detect if isdigit and friends are called on an argument of
>   type char.  (A bit tricky without source code changes since isdigit
>   is a macro.)

This is a classic example of something where what you really want is an 
inline function with an "int" argument, but with extra rules about what 
the permissible type conversions are - ie not just silently always do the 
normal C integer promotions.

I had planned on using the "attribute((nocast))" for this, which totally 
disables integer promotions, and would basically say: this value cannot be 
cast to any other type (except if you use the "force" thing, of course). 

But it's really not very useful for anything but user-defined types, ie my 
plan was to use it for something like

	typedef enum {
		GFP_ATOMIC = (__GFP_HIGH),
		GFP_NOIO = (__GFP_WAIT),
		GFP_NOFS = (__GFP_WAIT | __GFP_IO),
		...
	} gfp_mask_t __attribute__((nocast));

and then make the VM functions that take a GFP mask argument always use
"gfp_mask_t" - as a way to tighten up the type checking (since we've had
several cases of people using "kmalloc()" with the arguments in the wrong
order, where the compiler never noticed, since they are both integer
types).

So what I'd suggest you do is something like

	int isdigit(int arg __attribute__((nocast)))
	{
		...
	}

and then make the function argument code honour the attribute (actually,
just the "compatible_integer_types()", I guess). Would that do what you 
want?


> * Magic to type-check MIN and MAX.  I think sparse can do better than
>   C level macros because it can inspect constants.

Well, the kernel macros are doing pretty well, I have to say. They may be 
ugly, but they sure work:

	#define min(x,y) ({ \
		typeof(x) _x = (x);	\
		typeof(y) _y = (y);	\
		(void) (&_x == &_y);	\
		_x < _y ? _x : _y; })

It doesn't handle the constant case any differently, admittedly. Sparse 
could do that by having some kind of "__builtin_same_type()" macro, that 
special cases constants.

Sparse does actually have some magic type handling already, ie you can do

	if ([typeof x] == [typeof y])
			..

and it will actually do something half-way sane. Untested, of course.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Python any one? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Python any one?
Date: Wed, 14 Apr 2004 16:13:52 +0000
Message-ID: <20040414161352.GD10565 () 64m ! dyndns ! org>
--------------------
I just think of another thing, I have the sparse module for python for some
time now. I am not pushing it. I haven't use it for some time now. Just
in case any one interested in it to give me enough motivation to release it.

This module is a C source file, compile as a python module. It allow accessing
the sparse function and data structure from python. It was generate from
some python script that parse the sparse source code, using the very
same module.

I think it will be handy for people try out sparse in python. Other possible
usage is that I can let vim run python code to parse the current C code in
the buffer, do the right syntax highlighting and search for usage define
etc. BTW, that is Tommy's idea, in a emacs version. I just use it to write
the C to python module converter.


Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: Question for you all.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Question for you all..
Date: Fri, 26 Nov 2004 04:00:24 +0000
Message-ID: <Pine.LNX.4.58.0411251944480.4250 () ppc970 ! osdl ! org>
--------------------

Ok, I'm playing around with just _how_ good I can make this thing, and one 
of my test-cases is

	static inline void swap(int *a, int *b)
	{
		int tmp = *a;
		*a = *b;
		*b = tmp;
	}

	int test(int x, int y)
	{
		swap(&x,&y);
		return x;
	}

which obviously should just return "y".

Now, the funny thing is, I actually _do_ linearize to exactly that in my
current sandbox tree (not checked in yet, I need to work on some of the
fall-out):

	ep 0xf7fe200c: test

	ENTRY:
	bb: 0xf7f9e00c
	   test.c:8:5
	  **from 0x1008d8a0 (builtin:0:0)**
	        ret %arg2

(that funny "from" is just a dummy bb I set up for "outside").

But the only way I actually end up able to do that is to first run CSE,
then do my symbol simplification, then run CSE _again_, and finally do
symbol simplification a second time. I need to do that because the CSE
notices that the actual pointers end up being dead, but I need to do it
twice just so that each phase can feed on the previous phase.

Now, I can make it do this repeat thing fairly well (ie I can make it
repeat only if it thinks the symbol usage might actually have changed, and
I know when things that trigger it happen - the common case would be that
you only need to run the phases once), but on the whole I wonder how
realistic this kind of thing is.

It's a cute test-case, f'sure, but does it actually make sense? If you
have lots of levels of inlining, I might be doing CSE and symbol
simplification for quite a while (I'm not sure - I may actually always get
it after the second full iterator, but it's still going to be pretty
expensive).

What do real compilers do? Do they iterate as long as they notice that 
they've been able to simplify things? Or do they just say "screw it" and 
leave idiotic code like the above alone?

I can currently check the whole kernel tree with full CSE etc in about a 
minute-and-a-half, so it's not like this thing is a slouch, but at some 
point I wonder how much sense it all makes..

But it's pretty impressive nonetheless.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Question for you all..
Date: Fri, 26 Nov 2004 05:59:53 +0000
Message-ID: <Pine.LNX.4.58.0411252135130.4250 () ppc970 ! osdl ! org>
--------------------


On Thu, 25 Nov 2004, Linus Torvalds wrote:
> 
> But the only way I actually end up able to do that is to first run CSE,
> then do my symbol simplification, then run CSE _again_, and finally do
> symbol simplification a second time. I need to do that because the CSE
> notices that the actual pointers end up being dead, but I need to do it
> twice just so that each phase can feed on the previous phase.

Ok, I do this properly now, and only re-run a phase when it might be 
needed. It actually made a full kernel check go two seconds faster, 
probably because I needed to be more careful with the pseudo use lists, 
and removing stale entries means that we don't do unnecessary checks.

Or something. Might be just in the noise too. 

I check 874 source-files in 93 seconds: 9 of those seconds are just "make"  
doing whatever it is make does, so even if I would assume that "make"  
has zero additional overhead for running the checker, that means sparse
can do about 10 kernel .c-files per second. Still very reasonable.

Anyway, doing a "before-and-after" check actually shows that re-running
symbol analysis after CSE has done something "interesting" with symbol
pointers, actually makes a slight difference on the kernel. That is kind
of refreshing. The difference was a bit subtle (unlike my test-case):  
the case I noticed was in sleep_on() (and friends) where we use an inline
function like this:

	wait_queue_t wait;

	spin_lock_irqsave(&q->lock,flags);
	__add_wait_queue(q, &wait);
	spin_unlock(&q->lock);

it turns out that initial symbol simplification didn't dare simplify
accesses to "wait" directly, because it had its address taken, and when
the accesses to "wait" itself couldn't be simplified (and looked like an
access through a pointer), it resulted in the flow thinking that the
(indirect) stores to "wait" might alias with some other accesses, so it
pessimized the magic code that looks up "flags" on ppc64.

Re-doing symbol simplification after all the accesses to "wait" had been 
made direct rather than through a pointer resolved that alias, and removed 
a load. Very cool.

So code after:

	ep 0xf7e4e48c: interruptible_sleep_on

	ENTRY:
	bb: 0xf7e4c784
	   kernel/sched.c:2887:23
	  **from 0x1008d920 (builtin:0:0)**
	        load %r3440 <- 0.0.64[local_paca:0xf7babbf0]	/* CPU-local magic symbol */
	        load %r3441 <- 352.0.64[%r3440]			/* use "paca" */
	        store $0 -> 0.0.32[wait:0xf779d5b8]
	        store %r3441 -> 8.0.64[wait:0xf779d5b8]
	        %r3445 <- default_wake_function
	        store %r3445 -> 16.0.64[wait:0xf779d5b8]
	        load %r3448 <- 352.0.64[%r3440]			/* re-use "paca" because no alias! */
	        store $1 -> 0.0.64[%r3448]
		....

ie the fact that we had done simplification on the instructions and 
made it obvious that the stores to "&wait" were all purely local, we could 
realize that the stores didn't alias the load. This is what it looked like 
before:

	ENTRY:
	bb: 0xf7e4c784
	   kernel/sched.c:2887:23
	  **from 0x1008d968 (builtin:0:0)**
	        %r3439 <- wait					/* pointless address gen */
	        load %r3440 <- 0.0.64[local_paca:0xf7babbf0]
	        load %r3441 <- 352.0.64[%r3440]
	        store $0 -> 0.0.32[wait:0xf779d5b8]
	        store %r3441 -> 8.0.64[wait:0xf779d5b8]
	        %r3445 <- default_wake_function
	        store %r3445 -> 16.0.64[wait:0xf779d5b8]
	        load %r3447 <- 0.0.64[local_paca:0xf7babbf0]	/* re-load "paca" ;(*/
	        load %r3448 <- 352.0.64[%r3447]	
	        store $1 -> 0.0.64[%r3448]
		....


So that improvement is from just noticing that we can re-do the symbol 
access simplification after we've cleaned up address usage.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: Question for you all..
Date: Mon, 29 Nov 2004 02:44:49 +0000
Message-ID: <62011.12.111.112.6.1101696289.squirrel () numba-tu ! com>
--------------------
Linus Torvalds said:
> What do real compilers do? Do they iterate as long as they notice that
> they've been able to simplify things? Or do they just say "screw it" and
> leave idiotic code like the above alone?

At least in the literature, most iterate over some heurestic selection of
phases.  My vapour-ware GSA compiler does it incrementally -- it's part of the
representation.  All graph constructors keeps the graph in a normal form, that
is, performs constant folding, minimal strength reduction, and full GCSE
transparently as part of the construction.  Of course, that means that at
times you'd want to reintroduce redundant computation when it's cheaper than
increasing the register pressure.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Question for you all..
Date: Mon, 29 Nov 2004 07:50:42 +0000
Message-ID: <Pine.LNX.4.58.0411282324510.22796 () ppc970 ! osdl ! org>
--------------------


On Sun, 28 Nov 2004, Tommy Thorn wrote:

> Linus Torvalds said:
> > What do real compilers do? Do they iterate as long as they notice that
> > they've been able to simplify things? Or do they just say "screw it" and
> > leave idiotic code like the above alone?
> 
> At least in the literature, most iterate over some heurestic selection of
> phases.

I only have three phases right now - cse, memop and flow simplification. 
They all nest for me. I now do liveness analysis, and that doesn't nest 
any more - it doesn't change anything that CSE might care about, and more 
importantly, once I start looking at which pseudos are used, I don't see 
how you could allow CSE to change it any more. That's just crazy talk, and 
sounds unstable.

Anyway, try the current "test-linearize" on some half-way real test cases, 
and see how it also tracks liveness between blocks (you have to enable 
"verbose" with -v to make it show what pseudos are in use between blocks).

Seems to all work fine, although right now I have small problem that seems
to hit every once in a while, which seems to be due to the fact that I
don't keep the phi-nodes in any "canonical" format, so I'm not able to CSE
the dang things, and when I have phi-nodes that have other phi-nodes as
their sources, I don't expand them, which causes hickups for the liveness
analysis (I think that a reg is live too far because it doesn't see the
def that is behind a second level of phi-nodes).

But the hickups happen seldom enough even on big things like the kernel 
that I've not seen it on any trivial testcase. So give it a whirl.

For example, Chris Lattner had this test-case:

	#include <stdio.h>

	typedef struct List {
		struct List *Next;
		int Data;
	} List;

	List Node0 = { 0, 5 };
	List Node1 = { &Node0, 4 };
	List Node2 = { &Node1, 3 };
	List Node3 = { &Node2, 2 };
	List Node4 = { &Node3, 1 };
	List Node5 = { &Node4, 0 };

	void main()
	{
		List *PrevL, *CurL;
		for (PrevL = 0, CurL = &Node5; CurL;
		     PrevL = CurL, CurL = CurL->Next)
			printf("%d %d\n", CurL->Data, PrevL ? PrevL->Data : -1);
	}

and I now generate the following for it, where the "**uses xxxx **" lines 
tell you what "external" registers are live coming into a block. Maybe 
"uses" is not the right thing to say, since quite often that bb itself 
does not actually use it, but it's live because the reg is needed by a 
subsequent block (for example, bb .L0xf7fb60ac below is marked as "using" 
both %r2 and %r6, but it only actually uses %r2 itself, and %r6 is just 
passed right on to bb .L0xf7fb6034):

	main:
	ep 0xf7fe200c: main
	
	ENTRY:
	.L0xf7fb600c:
	test.c:18
	  **to 0xf7fb60ac (test.c:18:2)**
		set.32     %r1 <- Node5
		phisrc.32  %phi4 <- $0
		phisrc.32  %phi6 <- %r1
		br         .L0xf7fb60ac
	
	.L0xf7fb60ac:
	test.c:18
	  **uses %r2 (from (%phi6:.L0xf7fb600c), (%phi7:.L0xf7fb6124))**
	  **uses %r6 (from (%phi4:.L0xf7fb600c), (%phi5:.L0xf7fb6124))**
	  **from 0xf7fb600c (test.c:18:16)**
	  **from 0xf7fb6124 (test.c:20:39)**
	  **to 0xf7fb6034 (test.c:20:3)**
	  **to 0xf7fb6084 (test.c:18:2)**
		phi.32     %r2 <- %phi6, %phi7
		br         %r2, .L0xf7fb6034, .L0xf7fb6084
	
	.L0xf7fb6034:
	test.c:20
	  **uses %r2 (from (%phi6:.L0xf7fb600c), (%phi7:.L0xf7fb6124))**
	  **uses %r6 (from (%phi4:.L0xf7fb600c), (%phi5:.L0xf7fb6124))**
	  **from 0xf7fb60ac (test.c:18:2)**
	  **to 0xf7fb60d4 (test.c:20:46)**
	  **to 0xf7fb60fc (test.c:20:55)**
		set.32     %r3 <- "%d %d\n"
		load.32    %r5 <- 4[%r2]
		phi.32     %r6 <- %phi4, %phi5
		br         %r6, .L0xf7fb60d4, .L0xf7fb60fc
	
	.L0xf7fb60d4:
	test.c:20
	  **uses %r6 (from (%phi4:.L0xf7fb600c), (%phi5:.L0xf7fb6124))**
	  **uses %r3 (from .L0xf7fb6034)**
	  **uses %r5 (from .L0xf7fb6034)**
	  **from 0xf7fb6034 (test.c:20:3)**
	  **to 0xf7fb6124 (test.c:20:39)**
		load.32    %r8 <- 4[%r6]
		phisrc.32  %phi1 <- %r8
		br         .L0xf7fb6124
	
	.L0xf7fb60fc:
	test.c:20
	  **uses %r3 (from .L0xf7fb6034)**
	  **uses %r5 (from .L0xf7fb6034)**
	  **from 0xf7fb6034 (test.c:20:3)**
	  **to 0xf7fb6124 (test.c:20:39)**
		phisrc.32  %phi2 <- $0xffffffff
		br         .L0xf7fb6124
	
	.L0xf7fb6124:
	test.c:20
	  **uses %r3 (from .L0xf7fb6034)**
	  **uses %r5 (from .L0xf7fb6034)**
	  **uses %r9 (from (%phi1:.L0xf7fb60d4), (%phi2:.L0xf7fb60fc))**
	  **from 0xf7fb60d4 (test.c:20:46)**
	  **from 0xf7fb60fc (test.c:20:55)**
	  **to 0xf7fb60ac (test.c:18:2)**
		phi.32     %r9 <- %phi1, %phi2
		call.32    %r10 <- printf, %r3, %r5, %r9
		load.32    %r13 <- 0[%r2]
		phisrc.32  %phi5 <- %r2
		phisrc.32  %phi7 <- %r13
		br         .L0xf7fb60ac
	
	.L0xf7fb6084:
	test.c:18
	  **from 0xf7fb60ac (test.c:18:2)**
		ret


Anyway, it all looks sane, and I'm ready to start doing register
allocation next, since I have all the information now.

(Yeah, the above really is pretty unreadable, so who knows how right it 
is.. Which is why I need that register allocator ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: RE: warning ===

From: "h.varney" <h.varney () talk21 ! com>
To: debian-user
Subject: Re: RE: warning
Date: Thu, 25 Mar 2004 15:41:41 +0000
Message-ID: <000001c41312$77d05ea0$5f0801d5 () w4g4p2>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_000C_01C4127F.AB46B1A0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

What does this mean?
------=_NextPart_000_000C_01C4127F.AB46B1A0
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1106" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>What does this =
mean?</FONT></DIV></BODY></HTML>

------=_NextPart_000_000C_01C4127F.AB46B1A0--


-- 
To UNSUBSCRIBE, email to debian-user-request@lists.debian.org 
with a subject of "unsubscribe". Trouble? Contact listmaster@lists.debian.org

================================================================================

From: "h.varney" <h.varney () talk21 ! com>
To: debian-user
Subject: Re: RE: warning
Date: Thu, 25 Mar 2004 15:44:36 +0000
Message-ID: <000101c41312$7be8a600$5f0801d5 () w4g4p2>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_000F_01C41280.1336F860
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable


------=_NextPart_000_000F_01C41280.1336F860
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1106" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV>&nbsp;</DIV></BODY></HTML>

------=_NextPart_000_000F_01C41280.1336F860--


-- 
To UNSUBSCRIBE, email to debian-user-request@lists.debian.org 
with a subject of "unsubscribe". Trouble? Contact listmaster@lists.debian.org

================================================================================


################################################################################

=== Thread: SYM_NODE in C type of expression ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: SYM_NODE in C type of expression
Date: Fri, 27 Aug 2004 21:54:32 +0000
Message-ID: <20040827215432.GA28865 () 64m ! dyndns ! org>
--------------------
I notice that after evaluation, a lot of the C type for the expression carry
the SYM_NODE. From a pure C type point of view, it is not required.
It could directly point the base type of the SYM_NODE.

I am wondering what is the reason for the SYM_NODE. One guess is that it need some
place holder to to put the polluted version of the name space and attribute etc.
Do I miss some interesting reason?

Thanks

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: SYM_NODE in C type of expression
Date: Fri, 27 Aug 2004 23:14:54 +0000
Message-ID: <20040827231454.GB28865 () 64m ! dyndns ! org>
--------------------


On Fri, Aug 27, 2004 at 06:21:36PM -0700, Linus Torvalds wrote:
> 
> 
> On Fri, 27 Aug 2004, Christopher Li wrote:
> >
> > I notice that after evaluation, a lot of the C type for the expression carry
> > the SYM_NODE. From a pure C type point of view, it is not required.
> > It could directly point the base type of the SYM_NODE.
> 
> Nope. The base type of
> 
> 	const int hello;
> 
> is "int".
> 
> The node contains the "const" part.

In that case, yet. When I first saw SYM_NODE on ctype without spacial modifier
makes me wonder. Now it make sense. It seems more complicate to decide a
SYM_NODE is really needed or not.

Thanks.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: SYM_NODE in C type of expression
Date: Sat, 28 Aug 2004 01:21:36 +0000
Message-ID: <Pine.LNX.4.58.0408271820510.14196 () ppc970 ! osdl ! org>
--------------------


On Fri, 27 Aug 2004, Christopher Li wrote:
>
> I notice that after evaluation, a lot of the C type for the expression carry
> the SYM_NODE. From a pure C type point of view, it is not required.
> It could directly point the base type of the SYM_NODE.

Nope. The base type of

	const int hello;

is "int".

The node contains the "const" part.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Simple Question ===

From: Jean Safar <jean () datasynapse ! com>
To: axis-c-user
Subject: Simple Question
Date: Mon, 26 Jan 2004 12:04:40 +0000
Message-ID: <B53E2D51E6503E42B84AACC1BD83E5CE0177367E () exchange2 ! penthouse ! datasynapse ! com>
--------------------
This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C3E404.93819110
Content-Type: text/plain

Hi, 
 
Apologies if this was discussed alraedy. Is anyType supported in the 1.0
version of axis++? I can't compile stuff using it... 

Regards,

Jean Safar

Manager, Professional Services, Southern Europe
DataSynapse France
10-12, Ave de l'arche
92419 Courbevoie CEDEX

Work 33 1 46 91 15 74
Mob  33 6 11 50 76 64
Fax   33 1 46 91 88 00 


 

View the DataSynapse email disclaimer here: <
<http://www.datasynapse.com/legal/emailprivacy.jsp>
http://www.datasynapse.com/legal/emailprivacy.jsp>

 

------_=_NextPart_001_01C3E404.93819110
Content-Type: text/html

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=US-ASCII">
<TITLE>Message</TITLE>

<META content="MSHTML 6.00.2800.1276" name=GENERATOR></HEAD>
<BODY>
<DIV><SPAN class=039140312-26012004><FONT face=Arial size=2>Hi, 
</FONT></SPAN></DIV>
<DIV><SPAN class=039140312-26012004><FONT face=Arial 
size=2></FONT></SPAN>&nbsp;</DIV>
<DIV><SPAN class=039140312-26012004><FONT face=Arial size=2>Apologies if this 
was discussed alraedy. </FONT></SPAN><SPAN class=039140312-26012004><FONT 
face=Arial size=2>Is anyType supported in the 1.0 version of axis++? I can't 
compile stuff using it... </FONT></SPAN></DIV>
<DIV><SPAN class=039140312-26012004><FONT face=Arial 
size=2><BR>Regards,</FONT></SPAN></DIV>
<DIV align=left>
<P align=left><FONT face=Arial size=2><STRONG>Jean Safar</STRONG></FONT></P>
<P><FONT face=Arial size=2>Manager, Professional Services, Southern 
Europe<BR>DataSynapse France<BR>10-12, Ave de l'arche<BR>92419 Courbevoie 
CEDEX</FONT></P>
<P><FONT face=Arial size=2><FONT color=#008000>Work&nbsp;33 1 46 91 15 
74<BR>Mob&nbsp; 33 6 11 50 76 64<BR>Fax&nbsp;&nbsp; 33 1 46 91 88 00</FONT> 
</FONT></P>
<P><FONT size=2><BR><FONT face=Arial></FONT></FONT>&nbsp;</P>
<P><FONT face=Arial size=2>View the DataSynapse email disclaimer here: 
&lt;</FONT><A href="http://www.datasynapse.com/legal/emailprivacy.jsp"><U><FONT 
color=#0000ff><FONT face=Arial 
size=2>http://www.datasynapse.com/legal/emailprivacy.jsp</FONT></U></FONT></A><FONT 
face=Arial size=2>&gt;</FONT></P></DIV>
<DIV>&nbsp;</DIV></BODY></HTML>

------_=_NextPart_001_01C3E404.93819110--
================================================================================

From: <damitha () opensource ! lk>
To: axis-c-user
Subject: Re: Simple Question
Date: Mon, 26 Jan 2004 12:55:28 +0000
Message-ID: <32826.220.247.243.139.1075121728.squirrel () webmail ! pair ! com>
--------------------
Hi Jean,

Axis C++ currently don't support anyType

damitha
> Hi,
>
> Apologies if this was discussed alraedy. Is anyType supported in the 1.0
> version of axis++? I can't compile stuff using it...
>
> Regards,
>
> Jean Safar
>
> Manager, Professional Services, Southern Europe
> DataSynapse France
> 10-12, Ave de l'arche
> 92419 Courbevoie CEDEX
>
> Work 33 1 46 91 15 74
> Mob  33 6 11 50 76 64
> Fax   33 1 46 91 88 00
>
>
>
>
> View the DataSynapse email disclaimer here: <
> <http://www.datasynapse.com/legal/emailprivacy.jsp>
> http://www.datasynapse.com/legal/emailprivacy.jsp>
>
>



================================================================================

From: Jean Safar <jean () datasynapse ! com>
To: axis-c-user
Subject: RE: Simple Question
Date: Mon, 26 Jan 2004 13:01:16 +0000
Message-ID: <B53E2D51E6503E42B84AACC1BD83E5CE01773683 () exchange2 ! penthouse ! datasynapse ! com>
--------------------
Arr... :-) 

Is there a date set for such a support? 

Jean Safar

Manager, Professional Services, Southern Europe
DataSynapse France
10-12, Ave de l'arche
92419 Courbevoie CEDEX

Work 33 1 46 91 15 74
Mob  33 6 11 50 76 64
Fax   33 1 46 91 88 00 


 

View the DataSynapse email disclaimer here:
<http://www.datasynapse.com/legal/emailprivacy.jsp>



-----Original Message-----
From: damitha@opensource.lk [mailto:damitha@opensource.lk] 
Sent: lundi 26 janvier 2004 13:55
To: axis-c-user@ws.apache.org
Subject: Re: Simple Question


Hi Jean,

Axis C++ currently don't support anyType

damitha
> Hi,
>
> Apologies if this was discussed alraedy. Is anyType supported in the 
> 1.0 version of axis++? I can't compile stuff using it...
>
> Regards,
>
> Jean Safar
>
> Manager, Professional Services, Southern Europe
> DataSynapse France
> 10-12, Ave de l'arche
> 92419 Courbevoie CEDEX
>
> Work 33 1 46 91 15 74
> Mob  33 6 11 50 76 64
> Fax   33 1 46 91 88 00
>
>
>
>
> View the DataSynapse email disclaimer here: < 
> <http://www.datasynapse.com/legal/emailprivacy.jsp>
> http://www.datasynapse.com/legal/emailprivacy.jsp>
>
>


================================================================================

From: TKostadinov () t-online ! de
To: gtk-app-devel
Subject: Simple Question
Date: Thu, 29 Jan 2004 21:35:19 +0000
Message-ID: <1AmJol-0zDa4G0 () cmpmail10 ! bbul ! t-online ! de>
--------------------

Would somebody be so kind to tell me how to exit this mailing list?

Thank you in advance.



_______________________________________________
gtk-app-devel-list mailing list
gtk-app-devel-list@gnome.org
http://mail.gnome.org/mailman/listinfo/gtk-app-devel-list
================================================================================

From: Tristan Van Berkom <vantr () touchtunes ! com>
To: gtk-app-devel
Subject: Re: Simple Question
Date: Thu, 29 Jan 2004 21:46:56 +0000
Message-ID: <40197F50.5090709 () touchtunes ! com>
--------------------
TKostadinov@t-online.de wrote:
> Would somebody be so kind to tell me how to exit this mailing list?

send the subject "unsubscribe" to gtk-app-devel-list-request@gnome.org
(from your subscribed mail address).

Cheers,
               -Tristan


_______________________________________________
gtk-app-devel-list mailing list
gtk-app-devel-list@gnome.org
http://mail.gnome.org/mailman/listinfo/gtk-app-devel-list
================================================================================

From: Seth Kurtzberg <seth () cql ! com>
To: djbdns
Subject: Simple Question
Date: Mon, 08 Mar 2004 01:03:55 +0000
Message-ID: <404BC67B.1020306 () cql ! com>
--------------------
This is a multi-part message in MIME format.
--------------080303040207000800020400
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit

Hello, all

Apologies in advance if I missed this in the docs.  I have dnscache set 
up, and for my local network I have a file in /etc/dnscache/root/servers 
called "cql.com" to point dns requests to the tinydns instance inside 
the network that services local requests with local (192.168.1.x) 
addresses.  I have set up a secondary tinydns instance on another 
machine.  Do I list these IPs one per line in 
/etc/dnscache/root/servers/cql.com?

Thanks,

-- 
Seth Kurtzberg
MIS Corp
seth@cql.com


--------------080303040207000800020400
Content-Type: text/x-vcard; charset=utf8;
 name="seth.vcf"
Content-Transfer-Encoding: 7bit
Content-Disposition: attachment;
 filename="seth.vcf"

begin:vcard
fn:Seth Kurtzberg
n:Kurtzberg;Seth
email;internet:seth@cql.com
tel;work:480-661-1849
x-mozilla-html:TRUE
version:2.1
end:vcard


--------------080303040207000800020400--
================================================================================

From: prj () po ! cwru ! edu (Paul Jarc)
To: djbdns
Subject: Re: Simple Question
Date: Mon, 08 Mar 2004 01:46:54 +0000
Message-ID: <m3oer8cdp7.fsf () multivac ! cwru ! edu>
--------------------
Seth Kurtzberg <seth@cql.com> wrote:
> Apologies in advance if I missed this in the docs.

<URL:http://cr.yp.to/djbdns/dot-local.html>

> Do I list these IPs one per line in
> /etc/dnscache/root/servers/cql.com?

Yep.


paul
================================================================================


################################################################################

=== Thread: Simple question ===

From: Balbir Singh <balbir_soni () yahoo ! com>
To: linux-sparse
Subject: Simple question
Date: Sat, 14 Aug 2004 07:55:44 +0000
Message-ID: <20040814075544.50904.qmail () web13606 ! mail ! yahoo ! com>
--------------------
Hello, All,

Is there a snapshot of sparse available somewhere? I was able to find
only a BK repository. I do not have BK, but I would not mind using it
as a last resort.

Balbir


		
__________________________________
Do you Yahoo!?
New and Improved Yahoo! Mail - Send 10MB messages!
http://promotions.yahoo.com/new_mail 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: sam () ravnborg ! org
To: linux-sparse
Subject: Re: Simple question
Date: Sat, 14 Aug 2004 09:10:40 +0000
Message-ID: <56008.194.237.142.7.1092474640.squirrel () 194 ! 237 ! 142 ! 7>
--------------------
> Hello, All,
>
> Is there a snapshot of sparse available somewhere? I was able to find
> only a BK repository. I do not have BK, but I would not mind using it
> as a last resort.

Should be up and running at:
http://www.codemonkey.org.uk/projects/bitkeeper/sparse

   Sam


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sorting... ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Sorting...
Date: Sun, 26 Sep 2004 18:26:39 +0000
Message-ID: <200409261826.i8QIQdC11502 () troll ! rentec ! com>
--------------------

Yes, the exixting sorter is O(exp n) or even O(exp exp exp exp n).
That's a consequence of the possibility of having empty fragments.

Anyway, here is a remarkably complex merge sort that in the absense
of too many empty fragments should be O(n*log n).  The thing that
makes is complicated is that I didn't want to simply allocate an
extra copy of all data.

Note, that the list's fragments may change order -- can you say
pointer gymnastics? -- and as a consequence the list head may
change.

Turn on the PARANOIA define to check what it is doing.  Turn on
COVERAGE to make sure off the weird spots have been tested.

Morten


Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/sort

This will update the following files:


through these ChangeSets:

<welinder@anemone.rentec.com> (04/09/26 1.826)
   Ignore test-sort binary.

<welinder@anemone.rentec.com> (04/09/26 1.825)
   New BitKeeper file ``test-sort.c''

<welinder@anemone.rentec.com> (04/09/26 1.824)
   Make sure sort does not degenerate.

<welinder@anemone.rentec.com> (04/09/26 1.823)
   This file uses NULL, so include stdlib.h

diff -Nru a/Makefile b/Makefile
--- a/Makefile	2004-09-26 14:15:08 -04:00
+++ b/Makefile	2004-09-26 14:15:08 -04:00
@@ -37,6 +37,9 @@
 test-linearize: test-linearize.o $(LIB_FILE)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+test-sort: test-sort.o $(LIB_FILE)
+	gcc $(LDFLAGS) -o $@ $< $(LIBS)
+
 compile: compile.o compile-i386.o $(LIB_FILE)
 	$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
 
diff -Nru a/test-sort.c b/test-sort.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/test-sort.c	2004-09-26 14:15:08 -04:00
@@ -0,0 +1,45 @@
+#include "lib.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+static int
+int_cmp (const void *_a, const void *_b)
+{
+  const int *a = _a;
+  const int *b = _b;
+  return *a - *b;
+}
+
+#define MIN(_x,_y) ((_x) < (_y) ? (_x) : (_y))
+
+int
+main (int argc, char **argv)
+{
+  struct ptr_list *l = NULL, *l2;
+  int i, *e;
+  const int N = argv[1] ? atoi (argv[1]) : 10000;
+
+  srand (N);
+  for (i = 0; i < 1000; i++)
+    (void)rand ();
+
+  for (i = 0; i < N; i++) {
+    e = (int *)malloc (sizeof (int));
+    *e = rand ();
+    add_ptr_list (&l, e);
+  }
+  sort_list (&l, int_cmp);
+  // Sort already sorted stuff.
+  sort_list (&l, int_cmp);
+
+  l2 = l;
+  do {
+    l2->nr = MIN (l2->nr, rand () % 3);
+    for (i = 0; i < l2->nr; i++)
+      *((int*)(l2->list[i])) = rand();
+    l2 = l2->next;
+  } while (l2 != l);
+  sort_list (&l, int_cmp);
+
+  return 0;
+}
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-09-26 14:15:08 -04:00
+++ b/expand.c	2004-09-26 14:15:08 -04:00
@@ -758,23 +758,23 @@
 {
 	const struct expression *a = _a;
 	const struct expression *b = _b;
+	int r;
+
+	r = (b->type != EXPR_POS) - (a->type != EXPR_POS);
+	if (r) return r;
 
-	if (a->type != EXPR_POS)
-		return 1;
-	if (b->type != EXPR_POS)
-		return -1;
 	if (a->init_offset < b->init_offset)
-		return 1;
-	if (a->init_offset > b->init_offset)
 		return -1;
+	if (a->init_offset > b->init_offset)
+		return +1;
 	/* Check bitfield offset.. */
 	a = a->init_expr;
 	b = b->init_expr;
 	if (a && b) {
 		if (a->ctype && b->ctype) {
 			if (a->ctype->bit_offset < b->ctype->bit_offset)
-				return 1;
-			return -1;
+				return -1;
+			return +1;
 		}
 	}
 	return 0;
diff -Nru a/sort.c b/sort.c
--- a/sort.c	2004-09-26 14:15:08 -04:00
+++ b/sort.c	2004-09-26 14:15:08 -04:00
@@ -1,101 +1,289 @@
 /*
- * This is a horribly stupid list sort. We
- * use it to sort C initializers into ascending
- * order.
+ * sort_list: a stable sort for lists.
  *
- * These things tend to be sorted already, so we
- * should optimize for that case and not really
- * care about the other ones.
+ * Time complexity: O(n*log n)
+ *   [assuming limited zero-element fragments]
+ *
+ * Space complexity: O(1).
+ *
+ * Stable: yes.
  */
-#include <stdio.h>
+
 #include "lib.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#undef PARANOIA
+#undef COVERAGE
 
+#ifdef PARANOIA
+#include <assert.h>
+#else
+#define assert(x)
+#endif
+
+#ifdef COVERAGE
+static unsigned char been_there[256];
+#define BEEN_THERE(_c)					\
+  do {							\
+	if (!been_there[_c]) {				\
+		been_there[_c] = 1;			\
+		printf ("Been there: %c\n", _c);	\
+	}						\
+  } while (0)
+#else
+#define BEEN_THERE(_c) do { } while (0)
+#endif
+
+// Sort one fragment.  LIST_NODE_NR (==29) is a bit too high for my
+// taste for something this simple.  But, hey, it's O(1).
+//
+// I would use libc qsort for this, but its comparison function
+// gets a pointer indirection extra.
 static void array_sort(void **ptr, int nr, int (*cmp)(const void *, const void *))
 {
 	int i;
 	for (i = 1; i < nr; i++) {
 		void *p = ptr[i];
-		if (cmp(ptr[i-1],p) < 0) {
+		if (cmp(ptr[i-1],p) > 0) {
 			int j = i;
 			do {
 				ptr[j] = ptr[j-1];
 				if (!--j)
 					break;
-			} while (cmp(ptr[j-1], p) < 0);
+			} while (cmp(ptr[j-1], p) > 0);
 			ptr[j] = p;
 		}
 	}
 }
 
-static int merge_array(void **arr1, int nr1, void **arr2, int nr2, int (*cmp)(const void *, const void *))
+#ifdef PARANOIA
+static void verify_seq_sorted (struct ptr_list *l, int n,
+			       int (*cmp)(const void *, const void *))
 {
-	int i, j;
-	void *a, *b;
+	int i = 0;
+	const void *a;
+	struct ptr_list *head = l;
+
+	while (l->nr == 0) {
+		l = l->next;
+		if (--n == 0)
+			return;
+		assert (l != head);
+	}
 
-	if (!nr1 || !nr2)
-		return 0;
+	a = l->list[0];
+	while (n > 0) {
+		const void *b;
+		if (++i >= l->nr) {
+			i = 0;
+			l = l->next;
+			n--;
+			assert (l != head || n == 0);
+			continue;
+		}
+		b = l->list[i];
+		assert (cmp (a, b) <= 0);
+		a = b;
+	}
+}
+#endif
 
-	i = nr1-1;
-	j = 0;
-	a = arr1[i];	/* last entry of first array */
-	b = arr2[j];	/* first entry of last array */
-
-	/* If they are already sorted, don't do anything else */
-	if (cmp(a, b) >= 0)
-		return 0;
-
-	/*
-	 * Remember: we don't care. The above was
-	 * the speedpath. This is a joke. Although
-	 * it happens to be a joke that gets the
-	 * reverse sorted case right, I think.
-	 *
-	 * Damn, it's been _ages_ since I did sort
-	 * routines. I feel like a first-year CS
-	 * student again.
-	 */
-	do {
-		arr2[j] = a;
-		arr1[i] = b;
-		if (--i < 0)
-			break;
-		if (++j == nr2)
-			break;
-		a = arr1[i];
-		b = arr2[j];
-	} while (cmp(a, b) < 0);
 
-	array_sort(arr1, nr1, cmp);
-	array_sort(arr2, nr2, cmp);
+#define FLUSH_TO(b)						\
+  do {								\
+	int nr = (b)->nr;					\
+	assert (nbuf >= nr);					\
+	memcpy ((b)->list, buffer, nr * sizeof (void *));	\
+	nbuf -= nr;						\
+	memcpy (buffer, buffer + nr, nbuf * sizeof (void *));	\
+  } while (0)
+
+#define DUMP_TO(b)						\
+  do {								\
+        assert (nbuf <= (b)->nr);				\
+	memcpy ((b)->list, buffer, nbuf * sizeof (void *));	\
+  } while (0)
+
+
+// Merge two already-sorted sequences of blocks:
+//   (b1_1, ..., b1_n)  and  (b2_1, ..., b2_m)
+// Since we may be moving blocks around, we return the new head
+// of the merged list.
+static struct ptr_list *
+merge_block_seqs (struct ptr_list *b1, int n,
+		  struct ptr_list *b2, int m,
+		  int (*cmp)(const void *, const void *))
+{
+	int i1 = 0, i2 = 0;
+	const void *buffer[2 * LIST_NODE_NR];
+	int nbuf = 0;
+	struct ptr_list *newhead = b1;
+
+	// printf ("Merging %d blocks at %p with %d blocks at %p\n", n, b1, m, b2);
+
+	// Skip empty blocks in b2.
+	while (b2->nr == 0) {
+		BEEN_THERE('F');
+		b2 = b2->next;
+		if (--m == 0) {
+			BEEN_THERE('G');
+			return newhead;
+		}
+	}
+
+	// Do a quick skip in case entire blocks from b1 are
+	// already less than smallest element in b2.
+	while (b1->nr == 0 ||
+	       cmp (b1->list[b1->nr - 1], b2->list[0]) < 0) {
+		// printf ("Skipping whole block.\n");
+		BEEN_THERE('H');
+		b1 = b1->next;
+		if (--n == 0) {
+			BEEN_THERE('I');
+			return newhead;	
+		}
+	}
 
-	return 1;
+	while (1) {
+		const void *d1 = b1->list[i1];
+		const void *d2 = b2->list[i2];
+
+		assert (i1 >= 0 && i1 < b1->nr);
+		assert (i2 >= 0 && i2 < b2->nr);
+		assert (b1 != b2);
+		assert (n > 0);
+		assert (m > 0);
+
+		if (cmp (d1, d2) <= 0) {
+			BEEN_THERE('J');
+			buffer[nbuf++] = d1;
+			// Element from b1 is smaller
+			if (++i1 >= b1->nr) {
+				BEEN_THERE('L');
+				FLUSH_TO(b1);
+				do {
+					b1 = b1->next;
+					if (--n == 0) {
+						BEEN_THERE('O');
+						while (b1 != b2) {
+							BEEN_THERE('P');
+							FLUSH_TO(b1);
+							b1 = b1->next;
+						}
+						assert (nbuf == i2);
+						DUMP_TO(b2);
+						return newhead;
+					}
+				} while (b1->nr == 0);
+				i1 = 0;
+			}
+		} else {
+			BEEN_THERE('K');
+			// Element from b2 is smaller
+			buffer[nbuf++] = d2;
+			if (++i2 >= b2->nr) {
+				BEEN_THERE('M');
+				// Ok, we finished with b2.  Pull it out
+				// and plug it in before b1.
+				struct ptr_list *l = b2;
+
+				b2 = b2->next;
+				b2->prev = l->prev;
+				b2->prev->next = b2;
+				l->next = b1;
+				l->prev = b1->prev;
+				l->next->prev = l;
+				l->prev->next = l;
+
+				if (b1 == newhead) {
+					BEEN_THERE('N');
+					newhead = l;
+				}
+
+				FLUSH_TO(l);
+				b2 = b2->prev;
+				do {
+					b2 = b2->next;
+					if (--m == 0) {
+						BEEN_THERE('Q');
+						assert (nbuf == i1);
+						DUMP_TO(b1);
+						return newhead;
+					}
+				} while (b2->nr == 0);
+				i2 = 0;
+			}
+		}
+	}
 }
 
-void sort_list(struct ptr_list **list, int (*cmp)(const void *, const void *))
+
+void sort_list(struct ptr_list **plist, int (*cmp)(const void *, const void *))
 {
-	struct ptr_list *head = *list;
+	struct ptr_list *head = *plist;
+	int blocks = 1;
 
-	if (head) {
-		int repeat;
+	if (!head)
+		return;
 
-		/* Sort all the sub-lists */
-		struct ptr_list *list = head, *next;
-		do {
-			array_sort(list->list, list->nr, cmp);
-			list = list->next;
-		} while (list != head);
+	// Sort all the sub-lists
+	struct ptr_list *list = head;
+	do {
+		array_sort(list->list, list->nr, cmp);
+#ifdef PARANOIA
+		verify_seq_sorted (list, 1, cmp);
+#endif
+		list = list->next;
+	} while (list != head);
+
+	// Merge the damn things together
+	while (1) {
+		struct ptr_list *block1 = head;
 
-		/* Merge the damn things together .. */
 		do {
-			repeat = 0;
+			struct ptr_list *block2 = block1;
+			struct ptr_list *next, *newhead;
+			int i;
+
+			for (i = 0; i < blocks; i++) {
+				block2 = block2->next;
+				if (block2 == head) {
+					if (block1 == head) {
+						BEEN_THERE('A');
+						*plist = head;
+						return;
+					}
+					BEEN_THERE('B');
+					goto next_pass;
+				}						
+			}
 
-			list = head;
-			next = list->next;
-			while (next != head) {
-				repeat |= merge_array(list->list, list->nr, next->list, next->nr, cmp);
-				list = next;
+			next = block2;
+			for (i = 0; i < blocks; ) {
 				next = next->next;
+				i++;
+				if (next == head) {
+					BEEN_THERE('C');
+					break;
+				}
+				BEEN_THERE('D');
+			}
+
+			newhead = merge_block_seqs (block1, blocks,
+						    block2, i,
+						    cmp);
+#ifdef PARANOIA
+			verify_seq_sorted (newhead, blocks + i, cmp);
+#endif
+			if (block1 == head) {
+				BEEN_THERE('E');
+				head = newhead;
 			}
-		} while (repeat);
+			block1 = next;
+		} while (block1 != head);
+	next_pass:
+		blocks <<= 1;
 	}
 }
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-09-26 14:15:08 -04:00
+++ b/lib.h	2004-09-26 14:15:08 -04:00
@@ -1,5 +1,8 @@
 #ifndef LIB_H
 #define LIB_H
+
+#include <stdlib.h>
+
 /*
  * Basic helper routine descriptions for 'sparse'.
  *
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse initializer handing (in ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Sparse initializer handing (in
Date: Fri, 11 Jun 2004 20:06:57 +0000
Message-ID: <20040611130657.0c3fc8e4.rddunlap () osdl ! org>
--------------------


Sparse (2004-06-10 snapshot:)

=======
  CHECK   drivers/isdn/hardware/eicon/message.c
drivers/isdn/hardware/eicon/message.c:3438:26: warning: unexpected
compound initializer
  CC [M]  drivers/isdn/hardware/eicon/message.o

   static byte null_msg = {0};


(gcc does not complain, but then neither does it find several
of the real problems that sparse does find.)

This is valid C, so small sparse bug...


6.7.8 Initialization:

11 The initializer for a scalar shall be a single expression, optionally enclosed in braces.

--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Sparse? ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Sparse?
Date: Fri, 16 Apr 2004 05:16:50 +0000
Message-ID: <Pine.LNX.4.58.0404152210350.3947 () ppc970 ! osdl ! org>
--------------------


On Thu, 15 Apr 2004, Linus Torvalds wrote:
> 
> Looks like a sparse bug.  It shouldn't give that warning except for
> dereferencing something that has been marked "__attribute__((noderef))",
> and even then I thought that code wasn't even supposed to work.

Ok, I fixed that problem, so now it properly warns about dereferencing a 
noderef expression, ie

	#define __user __attribute__((noderef, address_space(1)))

	int test(int __user * a)
	{
	        return *a;
	}

will now get a warning that you cannot dereference the pointer directly, 
since it's a user pointer. So far so good - this should cause a nice big 
warning about people dereferencing user pointers directly.

Now, that in turn showed up another bug, so now it complains about

	#define __user __attribute__((noderef, address_space(1)))

	int __user *test(int __user * a)
	{
	        return &a[0];
	}

which it should _not_ warn about (no real derefence is taking place), but 
I have something wrong in the code that optimizes away the "+0", and it 
messes up (the expression "&a[1]" does not generate the warning ;)

So now there's a few bogus new warnings about code like that in the kernel
(usually it's of the form "&ptr->firstmember" which has the same
zero-offset thing), but I'll try to chase _that_ bug down later (and it's 
apparently been there forever, it's just that it's only noticeable now 
that I complain about the dereference thing properly).

Whack-a-mole with bugs.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: String concatenation ===

From: =?iso-8859-15?Q?Pierre-Fr=E9d=E9ric_Caillaud?= <peufeu () free ! fr>
To: python-list
Subject: Re: String concatenation
Date: Wed, 23 Jun 2004 14:21:17 +0000
Message-ID: <opr91wtrdl1v4ijd () musicbox>
--------------------

	Let's try this :

def test_concat():
	s = ''
	for i in xrange( test_len ):
		s += str( i )
	return s

def test_join():
	s = []
	for i in xrange( test_len ):
		s.append( str( i ))
	return ''.join(s)

def test_join2():
	return ''.join( map( str, range( test_len ) ))

	Results, with and without psyco :


test_len =  1000
String concatenation (normal)   4.85290050507 ms.
[] append + join (normal)       4.27646517754 ms.
map + join (normal)     2.37970948219 ms.

String concatenation (psyco)    2.0838675499 ms.
[] append + join (psyco)        2.29129695892 ms.
map + join (psyco)      2.21130692959 ms.

test_len =  5000
String concatenation (normal)   40.3251230717 ms.
[] append + join (normal)       23.3911275864 ms.
map + join (normal)     13.844203949 ms.

String concatenation (psyco)    9.65108215809 ms.
[] append + join (psyco)        13.0564379692 ms.
map + join (psyco)      13.342962265 ms.

test_len =  10000
String concatenation (normal)   163.02690506 ms.
[] append + join (normal)       47.6168513298 ms.
map + join (normal)     28.5276055336 ms.

String concatenation (psyco)    19.6494650841 ms.
[] append + join (psyco)        26.637775898 ms.
map + join (psyco)      26.7823898792 ms.

test_len =  20000
String concatenation (normal)   4556.57429695 ms.
[] append + join (normal)       92.0199871063 ms.
map + join (normal)     56.7145824432 ms.

String concatenation (psyco)    42.247030735 ms.
[] append + join (psyco)        58.3201909065 ms.
map + join (psyco)      53.8239884377 ms.


	Conclusion :

	- join is faster but worth the annoyance only if you join 1000s of strings
	- map is useful
	- psyco makes join useless if you can use it (depends on which web  
framework you use)
	- python is really pretty fast even without psyco (it runs about one mips  
!)

	Note :

	Did I mention psyco has a special optimization for string concatenation ?




-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Steve Holden <sholden () holdenweb ! com>
To: python-list
Subject: Re: String concatenation
Date: Fri, 25 Jun 2004 12:35:16 +0000
Message-ID: <40DC1C04.6060408 () holdenweb ! com>
--------------------
Duncan Booth wrote:

[...]
> Finally, a method call on a bare string (''.join, or '\n'.join) looks 
> sufficiently bad that if, for some reason, you don't want to give it a name 
> as above, I would suggest using the alternative form for calling it:
> 
>    str.join('\n', aList)
> 
> rather than:
> 
>    '\n'.join(aList)

This is, of course, pure prejudice. Not that there's anything wrong with 
that ...

regards
  Steve
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: String concatenation
Date: Fri, 09 Jul 2004 17:49:50 +0000
Message-ID: <20040709174950.DBE261422D53 () darter ! rentec ! com>
--------------------

Concatenating strings to form large strings does not work because the
chunking allocator cannot handle it.  With this patch, things work by
making the allocator create an extra-large blob when needed.

(This patch fixes the allocator in general, but strings are the most
obvious dynamic-size objects.)

The tokenizer still will not accept really long strings.  That's a separate
problem, if indeed it is a problem.

Morten


--- sparse-2004-07-07/lib.c	Tue Jul  6 19:00:20 2004
+++ sparse/lib.c	Wed Jul  7 15:42:58 2004
@@ -105,7 +105,8 @@
 	desc->useful_bytes = 0;
 	while (blob) {
 		struct allocation_blob *next = blob->next;
-		blob_free(blob, desc->chunking);
+		unsigned int chunking = blob->left + blob->offset + offsetof(struct allocation_blob, data);
+		blob_free(blob, chunking);
 		blob = next;
 	}
 }
@@ -120,16 +121,21 @@
 	desc->useful_bytes += size;
 	size = (size + alignment - 1) & ~(alignment-1);
 	if (!blob || blob->left < size) {
-		unsigned int offset, chunking = desc->chunking;
-		struct allocation_blob *newblob = blob_alloc(chunking);
+		unsigned int offset = offsetof(struct allocation_blob, data);
+		unsigned int chunking = desc->chunking;
+		struct allocation_blob *newblob;
+
+		offset = (offset + alignment - 1) & ~(alignment-1);
+		if (size + offset > chunking)
+		  chunking = size + offset;
+
+		newblob = blob_alloc(chunking);
 		if (!newblob)
 			die("out of memory");
 		desc->total_bytes += chunking;
 		newblob->next = blob;
 		blob = newblob;
 		desc->blobs = newblob;
-		offset = offsetof(struct allocation_blob, data);
-		offset = (offset + alignment - 1) & ~(alignment-1);
 		blob->left = chunking - offset;
 		blob->offset = offset - offsetof(struct allocation_blob, data);
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: String concatenation
Date: Thu, 22 Jul 2004 18:00:45 +0000
Message-ID: <20040722180045.9EAE61422D58 () darter ! rentec ! com>
--------------------

I didn't get any feedback on

    http://marc.theaimsgroup.com/?l=linux-sparse&m=108939539520796&w=2

and it didn't go in, so either The Powers That Be are busy, unhappy, or else
I need to explain myself better.  Consider...

static void
test (void)
{
  const char *s =
    "01234567890123456789012345678901234567890123456789"
    "01234567890123456789012345678901234567890123456789"
    "01234567890123456789012345678901234567890123456789"
    "01234567890123456789012345678901234567890123456789"
[snip 1000 lines of that]
    "01234567890123456789012345678901234567890123456789";
}

sparse-2004-07-18> ./check ../sparse/foo.c
Segmentation Fault (core dumped)

This kind of code occurs, for example, when strings are being used to
internalize image data.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: String concatenation
Date: Thu, 22 Jul 2004 18:53:03 +0000
Message-ID: <Pine.LNX.4.58.0407221141040.22809 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Jul 2004, Morten Welinder wrote:
> 
> I didn't get any feedback on
> 
>     http://marc.theaimsgroup.com/?l=linux-sparse&m=108939539520796&w=2
> 
> and it didn't go in, so either The Powers That Be are busy, unhappy, or else
> I need to explain myself better.  Consider...

Sorry, just busy.

I'd actually _much_ prefer to just limit the size of strings. I don't
remember what the ISO C maximum guaranteed string length was, but it was
just a few hundred bytes.  Considering that the chunk size is 32kB, and
that we already warn (and refuse to process) a _single_ string being more
than 2048 bytes, I'd suggest just movign that MAX value to a header file, 
and doing the check at concatenation time too.

It makes no sense to allow longer concatenated strings than we allow
individual strings.

Suggested patch pushed out.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: String concatenation
Date: Thu, 22 Jul 2004 18:56:58 +0000
Message-ID: <20040722115658.70065205.rddunlap () osdl ! org>
--------------------
On Thu, 22 Jul 2004 11:53:03 -0700 (PDT) Linus Torvalds wrote:

| 
| 
| On Thu, 22 Jul 2004, Morten Welinder wrote:
| > 
| > I didn't get any feedback on
| > 
| >     http://marc.theaimsgroup.com/?l=linux-sparse&m=108939539520796&w=2
| > 
| > and it didn't go in, so either The Powers That Be are busy, unhappy, or else
| > I need to explain myself better.  Consider...
| 
| Sorry, just busy.
| 
| I'd actually _much_ prefer to just limit the size of strings. I don't
| remember what the ISO C maximum guaranteed string length was, but it was
| just a few hundred bytes.  Considering that the chunk size is 32kB, and
| that we already warn (and refuse to process) a _single_ string being more
| than 2048 bytes, I'd suggest just movign that MAX value to a header file, 
| and doing the check at concatenation time too.
| 
| It makes no sense to allow longer concatenated strings than we allow
| individual strings.
| 
| Suggested patch pushed out.

5.2.4.1 Translation limits:
(at least)
- 4095 characters in a character string literal or wide string literal
  (after concatenation)

I don't see a maximum string length limit.

--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: String concatenation
Date: Thu, 22 Jul 2004 19:43:55 +0000
Message-ID: <Pine.LNX.4.58.0407221227360.22809 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Jul 2004, Randy.Dunlap wrote:
> 
> 5.2.4.1 Translation limits:
> (at least)
> - 4095 characters in a character string literal or wide string literal
>   (after concatenation)

Hmm.. This must be new. I see

	Table A-9 Defined translation limits

	 -------------------------------------------------------------
	 Item                               Actual       Minimum
	                                                 Acceptable
	 -------------------------------------------------------------

	 characters in a character string   >=4096       509
	 literal or wide string literal
	 (after concatenation)

ie the suggestion that the actual limit be over 4kB (easy enough, I'll
happily change the define), but that the guaranteed limit is 509 bytes.

But this may well be a C89 vs C99 limit thing. I wouldn't be surprised if 
C99 has raised the limits.

> I don't see a maximum string length limit.

An implementation is certainly _allowed_ to accept much longer strings. 
That doesn't mean that a user should be able to depend on it.

Ahh.. Google is your friend:

	"Most of the translation limits (5.2.4.1) have been increased,
	 most notably, the implementation must support:

	    * 63 significant initial characters in an internal identifier
	      or macro name (universal or extended characters count as
	      one),
	    * 31 significant initial characters in an external identifier
	      (counting "short" UCNs as 6 and "long" UCNs as 10, and
	      counting extended characters like the corresponding UCN),
	and
	    * 4095 characters in a logical source line. 

	These values were 31, 6, and 509, respectively, in C89. Note that
	all identifiers are case sensitive now, even external ones. (In
	C89, an implementation was allowed to ignore case for external
	identifiers.)"

(The "509" character limit was both a source line limit and a string size 
limit in C89, I assume the same is true in C99).

It _looks_ like ISO C++ makes the "recommended minima" limit be 65536, but 
hey, C++ people are crazy anyway.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: String concatenation
Date: Thu, 22 Jul 2004 19:46:28 +0000
Message-ID: <20040722124628.639ad13b.rddunlap () osdl ! org>
--------------------
On Thu, 22 Jul 2004 12:43:55 -0700 (PDT) Linus Torvalds wrote:

| 
| 
| On Thu, 22 Jul 2004, Randy.Dunlap wrote:
| > 
| > 5.2.4.1 Translation limits:
| > (at least)
| > - 4095 characters in a character string literal or wide string literal
| >   (after concatenation)
| 
| Hmm.. This must be new. I see

ISO/IEC 9899 second edition 1999-12-01 does not have a Table A-9...


| 	Table A-9 Defined translation limits
| 
| 	 -------------------------------------------------------------
| 	 Item                               Actual       Minimum
| 	                                                 Acceptable
| 	 -------------------------------------------------------------
| 
| 	 characters in a character string   >=4096       509
| 	 literal or wide string literal
| 	 (after concatenation)
| 
| ie the suggestion that the actual limit be over 4kB (easy enough, I'll
| happily change the define), but that the guaranteed limit is 509 bytes.
| 
| But this may well be a C89 vs C99 limit thing. I wouldn't be surprised if 
| C99 has raised the limits.
| 
| > I don't see a maximum string length limit.
| 
| An implementation is certainly _allowed_ to accept much longer strings. 
| That doesn't mean that a user should be able to depend on it.
| 
| Ahh.. Google is your friend:
| 
| 	"Most of the translation limits (5.2.4.1) have been increased,
| 	 most notably, the implementation must support:
| 
| 	    * 63 significant initial characters in an internal identifier
| 	      or macro name (universal or extended characters count as
| 	      one),
| 	    * 31 significant initial characters in an external identifier
| 	      (counting "short" UCNs as 6 and "long" UCNs as 10, and
| 	      counting extended characters like the corresponding UCN),
| 	and
| 	    * 4095 characters in a logical source line. 
| 
| 	These values were 31, 6, and 509, respectively, in C89. Note that
| 	all identifiers are case sensitive now, even external ones. (In
| 	C89, an implementation was allowed to ignore case for external
| 	identifiers.)"
| 
| (The "509" character limit was both a source line limit and a string size 
| limit in C89, I assume the same is true in C99).

- 4095 characters in a logical source line
- 4095 characters in a character string literal or wide string literal
  (after concatenation)

Do you need/want the entire Translation Limits section?

| It _looks_ like ISO C++ makes the "recommended minima" limit be 65536, but 
| hey, C++ people are crazy anyway.


--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: String concatenation
Date: Thu, 22 Jul 2004 20:02:40 +0000
Message-ID: <Pine.LNX.4.58.0407221300430.22809 () ppc970 ! osdl ! org>
--------------------


Ok, I pushed out a patch that increases MAX_STRING to 4095 as per C99, and 
also should be more careful about the exact size. There were some problems 
with off-by-one cases and with the final NUL at the end in the case of
oversized concatenation. I didn't test all that extensively, but it passed 
some of the trivial tests I did, and reported the right warnings.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Steven D'Aprano <steve () pearwood ! info>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 02:32:22 +0000
Message-ID: <57314838$0$1586$c3e8da3$5496439d () news ! astraweb ! com>
--------------------
T24gVHVlLCAxMCBNYXkgMjAxNiAwNzoyMSBhbSwgVGhvbWFzICdQb2ludGVkRWFycycgTGFobiB3
cm90ZToKCj4gQ2hyaXMgQW5nZWxpY28gd3JvdGU6Cj4gCj4+IE9uIE1vbiwgTWF5IDksIDIwMTYg
YXQgMTA6NDQgQU0sIFRob21hcyAnUG9pbnRlZEVhcnMnIExhaG4KPj4gPFBvaW50ZWRFYXJzQHdl
Yi5kZT4gd3JvdGU6Cj4+PiBXaXRoIHRoZSDigJwl4oCdIHN0cmluZyBvcGVyYXRvciAoZGVwcmVj
YXRlZCksIHN0ci5mb3JtYXQoKSwgYW5kCj4+PiBzdHIuVGVtcGxhdGUsIHlvdSBjYW4gdXNlIG90
aGVyIHZhbHVlcyBpbiBzdHJpbmcgdmFsdWVzIGV2ZW4gd2l0aG91dAo+Pj4gY29uY2F0ZW5hdGlv
bi4KPj4gCj4+IE5vdCBkZXByZWNhdGVkLiBEb24ndCBzcHJlYWQgRlVELgo+IAo+IElmIG9ubHkg
eW91IGNhcmVkIHRvIHJlYWQgd2hhdCBJIHJlZmVycmVkIHRvOgo+Cj4gLC08aHR0cHM6Ly9kb2Nz
LnB5dGhvbi5vcmcvMy9saWJyYXJ5L3N0ZHR5cGVzLmh0bWwjb2xkLXN0cmluZy1mb3JtYXR0aW5n
PgoKVGhhdCBpcyBleGNlbGxlbnQgYWR2aWNlIFRob21hcyEKCklmIG9ubHkgeW91IGhhZCBmb2xs
b3dlZCBpdCB5b3Vyc2VsZiwgaW5zdGVhZCBvZiBibGluZGx5IGFuZCBtZWNoYW5pY2FsbHkKY29w
eWluZyBhbmQgcGFzdGluZy4gSWYgeW91IGhhZCBib3RoZXJlZCB0byBhY3R1YWxseSByZWFkIGl0
LCB5b3Ugd291bGQKaGF2ZSBzZWVuIHRoYXQgKm5vd2hlcmUqIGRvZXMgaXQgc2F5IHRoYXQgdGhl
ICUgc3RyaW5nIG9wZXJhdG9yIGlzCmRlcHJlY2F0ZWQuCgpEZXByZWNhdGlvbiBoYXMgYSBzcGVj
aWZpYyBtZWFuaW5nIGludm9sdmluZyBhIGZvcm1hbCBwcm9jZXNzIG9mIHJlbW92aW5nIGEKZmVh
dHVyZSBmcm9tIHRoZSBsYW5ndWFnZS4gSXQgZG9lc24ndCBtZXJlbHkgbWVhbiAidGhpcyBvbGQg
ZmVhdHVyZSBoYXMKcXVpcmtzIGFuZCB3ZSB0aGluayB5b3Ugc2hvdWxkIHVzZSB0aGlzIG5ldyBm
ZWF0dXJlIGluc3RlYWQiLiBTb21lIG9mIHRoZQpjb3JlIGRldmVsb3BlcnMgbGlrZSBgZm9ybWF0
YCBiZXR0ZXIgYW5kIHRoaW5rIHRoYXQgcGVvcGxlIHNob3VsZCB1c2UgaXQgaW4KcHJlZmVyZW5j
ZSB0byB0aGUgJSBzdHJpbmcgb3BlcmF0b3IuIFRoYXQgbXVjaCBpcyB0cnVlLiBCdXQgdGhhdCBp
cyBmYXIKZnJvbSBiZWluZyBkZXByZWNhdGVkLgoKCj4gTm90ZSB0aGUga2V5IHdvcmRzOiDigJxv
bGTigJ0sIOKAnHF1aXJrc+KAnSwg4oCcZXJyb3Jz4oCdLgoKSXJyZWxldmFudCB0byB0aGUgcXVl
c3Rpb24gb2YgZGVwcmVjYXRpb24uCgpGbG9hdHMgYXJlIG9sZCAodGhleSBnbyBiYWNrIHRvIHRo
ZSBmaXJzdCByZWxlYXNlIG9mIFB5dGhvbiksIHRoZXkgaGF2ZSBtYW55CnF1aXJrcyAoeCArIHkg
LSB4IGlzIG5vdCBuZWNlc3NhcmlseSBlcXVhbCB0byB5KSwgYW5kIHBlb3BsZSBtYWtlIG1hbnkK
ZXJyb3JzIHdpdGggZmxvYXRzLiBEb2VzIHRoaXMgbWVhbiB0aGV5IGFyZSBkZXByZWNhdGVkPyBP
ZiBjb3Vyc2Ugbm90LgoKCi0tIApTdGV2ZW4KCi0tIApodHRwczovL21haWwucHl0aG9uLm9yZy9t
YWlsbWFuL2xpc3RpbmZvL3B5dGhvbi1saXN0Cg==
================================================================================

From: Chris Angelico <rosuav () gmail ! com>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 02:42:36 +0000
Message-ID: <CAPTjJmqN+G8n2zxbLsU_eocP1XXfSjchmst_f77Lho1a3xy8mg () mail ! gmail ! com>
--------------------
On Tue, May 10, 2016 at 12:32 PM, Steven D'Aprano <steve@pearwood.info> wrote:
> Floats are old (they go back to the first release of Python), they have many
> quirks (x + y - x is not necessarily equal to y), and people make many
> errors with floats. Does this mean they are deprecated? Of course not.

Careful there Steven - now that cdecimal is in core, people might
start saying that. Particularly if (as is periodically requested, and
which I think would be a good idea) Decimal literals become a thing.
And the removal of core types HAS happened. Correct me if I'm wrong,
but didn't the first release of Python have only the short integer
type, and then a completely new 'long' type was added? Automatic
promotion blurred the distinction, and then Python 3.0 removed the
'int' type and renamed 'long'. So it's theoretically possible for
Decimal to replace float...

... except that that would actually be a bad idea, which a lot of
people don't realize.

ChrisA
-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Rustom Mody <rustompmody () gmail ! com>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 03:45:56 +0000
Message-ID: <a52b14bd-6dc9-4d93-8d32-0abebdb8ec1a () googlegroups ! com>
--------------------
On Tuesday, May 10, 2016 at 2:52:13 AM UTC+5:30, Thomas 'PointedEars' Lahn wrote:
> Chris Angelico wrote:
> 
> > On Mon, May 9, 2016 at 10:44 AM, Thomas 'PointedEars' Lahn wrote:
> >> Also, it would be a good idea if you posted under your real name. 
> >> Internet is the thing with cables; Usenet is the thing with people.
> >> I for one tend to avoid communicating with few-letter entities;
> >> exceptions to that would probably include only E.T., M.J., ALF, and
> >> K.I.T.T.
> > 
> > I'm not using Usenet, Mr PointedEars.
> 
> I don't care.  This basic courtesy extended to strangers whose help you seek 
> originates in real life, not Usenet.

And it is objectionable to discriminate on people's names; the same way it is 
objectionable to discriminate on people's skin-color, religion, country, sex etc

See: http://www.alphr.com/computing/1000378/facebook-rejects-native-american-names-as-fake-again
-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Steven D'Aprano <steve+comp.lang.python () pearwood ! info>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 06:46:07 +0000
Message-ID: <573183b1$0$2741$c3e8da3$76491128 () news ! astraweb ! com>
--------------------
On Tuesday 10 May 2016 13:45, Rustom Mody wrote:

> See:
> http://www.alphr.com/computing/1000378/facebook-rejects-native-american-
names-as-fake-again


Somebody should set up a kick-starter to pay someone to change their legal 
name to "Facebook-Are-Arseholes", then open a Facebook account with it. I'd 
contribute a couple of bucks.

("That's MISTER Facebook-Are-Arseholes to you!")

Unfortunately, Australia's naming laws almost certainly wouldn't allow such 
a name. But I think the US would.


-- 
Steve

-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Paul Rubin <no.email () nospam ! invalid>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 07:13:51 +0000
Message-ID: <87twi675cg.fsf () jester ! gateway ! pace ! com>
--------------------
Steven D'Aprano <steve+comp.lang.python@pearwood.info> writes:
> Australia's naming laws almost certainly wouldn't allow such a name. 

https://en.wikipedia.org/wiki/Facebook_real-name_policy_controversy#Vietnamese
-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Steven D'Aprano <steve+comp.lang.python () pearwood ! info>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 07:54:07 +0000
Message-ID: <573193a0$0$11094$c3e8da3 () news ! astraweb ! com>
--------------------
T24gVHVlc2RheSAxMCBNYXkgMjAxNiAxNzoxMywgUGF1bCBSdWJpbiB3cm90ZToKCj4gU3RldmVu
IEQnQXByYW5vIDxzdGV2ZStjb21wLmxhbmcucHl0aG9uQHBlYXJ3b29kLmluZm8+IHdyaXRlczoK
Pj4gQXVzdHJhbGlhJ3MgbmFtaW5nIGxhd3MgYWxtb3N0IGNlcnRhaW5seSB3b3VsZG4ndCBhbGxv
dyBzdWNoIGEgbmFtZS4KPiAKPiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GYWNlYm9v
a19yZWFsLQpuYW1lX3BvbGljeV9jb250cm92ZXJzeSNWaWV0bmFtZXNlCgoiUGh1YyBEYXQgQmlj
aCIgd2FzIGEgaG9heCwgYnV0IGl0IHByb2JhYmx5IHdvdWxkIGJlIGFsbG93ZWQgaW4gQXVzdHJh
bGlhLgoKSSdtIHN1cnByaXNlZCB0aGF0IFNwYW5pc2ggbmFtZXMgYXJlIG5vdCBhZmZlY3RlZC4g
Q29uc2lkZXIgYSB3b21hbiB3aG8gZ29lcyBieSAKdGhlIHBlcnNvbmFsIG5hbWUgb2YgTWFyaWEg
VGVyZXNhLCB3aG9zZSBmYXRoZXIncyBmaXJzdCBzdXJuYW1lIHdhcyBHYXJjw61hIGFuZCAKbW90
aGVyJ3MgZmlyc3Qgc3VybmFtZSB3YXMgUmFtw61yZXouIEhlciBuYW1lIHdvdWxkIHRoZXJlZm9y
ZSBiZSBNYXJpYSBUZXJlc2EgCkdhcmPDrWEgUmFtw61yZXouIElmIHNoZSBtYXJyaWVzIEVsw60g
QXJyb3lvIEzDs3BleiwgdGhlbiBzaGUgbWlnaHQgY2hhbmdlIGhlciBuYW1lIAp0byBNYXJpYSBU
ZXJlc2EgR2FyY8OtYSBSYW3DrXJleiBkZSBBcnJveW8uIFdpdGggc2l4IHdvcmRzLCB0aGF0IHdv
dWxkIGZhbGwgZm91bCAKb2YgRmFjZWJvb2sncyBmb3VsIG5hbWluZyBwb2xpY3kuCgoKaHR0cDov
L3d3dy5rYWx6dW1ldXMuY29tLzIwMTAvMDYvMTcvZmFsc2Vob29kcy1wcm9ncmFtbWVycy1iZWxp
ZXZlLWFib3V0LW5hbWVzLwoKCi0tIApTdGV2ZQoKLS0gCmh0dHBzOi8vbWFpbC5weXRob24ub3Jn
L21haWxtYW4vbGlzdGluZm8vcHl0aG9uLWxpc3QK
================================================================================

From: David Palao <dpalao.python () gmail ! com>
To: python-list
Subject: Re: String concatenation
Date: Tue, 10 May 2016 08:15:51 +0000
Message-ID: <CAKUKWzkjxtas2+-McpwX8zTa369qC6PPRwK0PoAAE9s9F1YROg () mail ! gmail ! com>
--------------------
MjAxNi0wNS0xMCA5OjU0IEdNVCswMjowMCBTdGV2ZW4gRCdBcHJhbm8KPHN0ZXZlK2NvbXAubGFu
Zy5weXRob25AcGVhcndvb2QuaW5mbz46Cj4gT24gVHVlc2RheSAxMCBNYXkgMjAxNiAxNzoxMywg
UGF1bCBSdWJpbiB3cm90ZToKPgo+PiBTdGV2ZW4gRCdBcHJhbm8gPHN0ZXZlK2NvbXAubGFuZy5w
eXRob25AcGVhcndvb2QuaW5mbz4gd3JpdGVzOgo+Pj4gQXVzdHJhbGlhJ3MgbmFtaW5nIGxhd3Mg
YWxtb3N0IGNlcnRhaW5seSB3b3VsZG4ndCBhbGxvdyBzdWNoIGEgbmFtZS4KPj4KPj4gaHR0cHM6
Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmFjZWJvb2tfcmVhbC0KPiBuYW1lX3BvbGljeV9jb250
cm92ZXJzeSNWaWV0bmFtZXNlCj4KPiAiUGh1YyBEYXQgQmljaCIgd2FzIGEgaG9heCwgYnV0IGl0
IHByb2JhYmx5IHdvdWxkIGJlIGFsbG93ZWQgaW4gQXVzdHJhbGlhLgo+Cj4gSSdtIHN1cnByaXNl
ZCB0aGF0IFNwYW5pc2ggbmFtZXMgYXJlIG5vdCBhZmZlY3RlZC4gQ29uc2lkZXIgYSB3b21hbiB3
aG8gZ29lcyBieQo+IHRoZSBwZXJzb25hbCBuYW1lIG9mIE1hcmlhIFRlcmVzYSwgd2hvc2UgZmF0
aGVyJ3MgZmlyc3Qgc3VybmFtZSB3YXMgR2FyY8OtYSBhbmQKPiBtb3RoZXIncyBmaXJzdCBzdXJu
YW1lIHdhcyBSYW3DrXJlei4gSGVyIG5hbWUgd291bGQgdGhlcmVmb3JlIGJlIE1hcmlhIFRlcmVz
YQo+IEdhcmPDrWEgUmFtw61yZXouIElmIHNoZSBtYXJyaWVzIEVsw60gQXJyb3lvIEzDs3Bleiwg
dGhlbiBzaGUgbWlnaHQgY2hhbmdlIGhlciBuYW1lCj4gdG8gTWFyaWEgVGVyZXNhIEdhcmPDrWEg
UmFtw61yZXogZGUgQXJyb3lvLiBXaXRoIHNpeCB3b3JkcywgdGhhdCB3b3VsZCBmYWxsIGZvdWwK
PiBvZiBGYWNlYm9vaydzIGZvdWwgbmFtaW5nIHBvbGljeS4KPgo+Cj4gaHR0cDovL3d3dy5rYWx6
dW1ldXMuY29tLzIwMTAvMDYvMTcvZmFsc2Vob29kcy1wcm9ncmFtbWVycy1iZWxpZXZlLWFib3V0
LW5hbWVzLwo+Cj4KPiAtLQo+IFN0ZXZlCj4KPiAtLQo+IGh0dHBzOi8vbWFpbC5weXRob24ub3Jn
L21haWxtYW4vbGlzdGluZm8vcHl0aG9uLWxpc3QKCkluIFNwYWluICJkZSBBcnJveW8iIG9mZmlj
aWFsbHkgZG9lcyBub3QgYmVjb21lIHBhcnQgb2YgdGhlIG5hbWUuIFRoZQpzYW1lIGFwcGxpZXMg
dG8gb3RoZXIgY291bnRyaWVzIGFzIHdlbGwuIE5vdCAxMDAlIHN1cmUgdGhhdCBpdCBpcyB0cnVl
CmluIGV2ZXJ5IFNwYW5pc2ggc3BlYWtpbmcgY291bnRyeSB0aG91Z2guCgpCZXN0Ci0tIApodHRw
czovL21haWwucHl0aG9uLm9yZy9tYWlsbWFuL2xpc3RpbmZvL3B5dGhvbi1saXN0Cg==
================================================================================

From: sohcahtoa82 () gmail ! com
To: python-list
Subject: Re: String concatenation
Date: Wed, 11 May 2016 21:30:31 +0000
Message-ID: <2bb362b3-0763-422b-ac05-32b9f3a09b09 () googlegroups ! com>
--------------------
On Wednesday, May 11, 2016 at 12:14:43 PM UTC-7, Thomas 'PointedEars' Lahn wrote:
> sohcahtoa82@gmail.com wrote:
> 
> > I don't blame people for not wanting to use their real name on the
> > Internet, especially if you're a woman.  There are a lot of crazy people
> > out there that will find out where you live and send death threats just
> > because you disagree with them or you happen to be a woman that enjoys
> > video games or exists in the tech world.
> 
> FUD and paranoia.  And this is _not_ the Internet.
> 
> -- 
> PointedEars
> 
> Twitter: @PointedEars2
> Please do not cc me. / Bitte keine Kopien per E-Mail.

You call it FUD and paranoia, I call it reality.  Are you familiar with the term "doxxing"?  Are you familiar with the shenanigans of GamerGate and Anonymous/4chan?  Or even some people on reddit.  It doesn't just happen to celebrities, either.  Is it likely to happen to me?  No, not really, but that doesn't mean I shouldn't be concerned at the possibility.

And how is this mailing list NOT part of the Internet?
-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Ned Batchelder <ned () nedbatchelder ! com>
To: python-list
Subject: Re: String concatenation
Date: Wed, 11 May 2016 21:50:05 +0000
Message-ID: <1bb847c1-7ac2-4c5e-a1ed-11ded09367dd () googlegroups ! com>
--------------------
On Wednesday, May 11, 2016 at 5:30:48 PM UTC-4, sohca...@gmail.com wrote:
> On Wednesday, May 11, 2016 at 12:14:43 PM UTC-7, Thomas 'PointedEars' Lahn wrote:
> > sohcahtoa82@gmail.com wrote:
> > 
> > > I don't blame people for not wanting to use their real name on the
> > > Internet, especially if you're a woman.  There are a lot of crazy people
> > > out there that will find out where you live and send death threats just
> > > because you disagree with them or you happen to be a woman that enjoys
> > > video games or exists in the tech world.
> > 
> > FUD and paranoia.  And this is _not_ the Internet.
> > 
> > -- 
> > PointedEars
> > 
> > Twitter: @PointedEars2
> > Please do not cc me. / Bitte keine Kopien per E-Mail.
> 
> You call it FUD and paranoia, I call it reality.  Are you familiar with the term "doxxing"?  Are you familiar with the shenanigans of GamerGate and Anonymous/4chan?  Or even some people on reddit.  It doesn't just happen to celebrities, either.  Is it likely to happen to me?  No, not really, but that doesn't mean I shouldn't be concerned at the possibility.
> 
> And how is this mailing list NOT part of the Internet?

It's really not worth debating this point.  Thomas has a fixation on people
needing to supply their real names, but is the only one who feels this way.

--NMB.
-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Steven D'Aprano <steve+comp.lang.python () pearwood ! info>
To: python-list
Subject: Re: String concatenation
Date: Thu, 12 May 2016 07:27:52 +0000
Message-ID: <57343078$0$1509$c3e8da3$5496439d () news ! astraweb ! com>
--------------------
T24gVHVlc2RheSAxMCBNYXkgMjAxNiAxODoxNSwgRGF2aWQgUGFsYW8gd3JvdGU6Cgo+IDIwMTYt
MDUtMTAgOTo1NCBHTVQrMDI6MDAgU3RldmVuIEQnQXByYW5vCj4gPHN0ZXZlK2NvbXAubGFuZy5w
eXRob25AcGVhcndvb2QuaW5mbz46Cgo+PiBJJ20gc3VycHJpc2VkIHRoYXQgU3BhbmlzaCBuYW1l
cyBhcmUgbm90IGFmZmVjdGVkLiBDb25zaWRlciBhIHdvbWFuIHdobyBnb2VzCj4+IGJ5IHRoZSBw
ZXJzb25hbCBuYW1lIG9mIE1hcmlhIFRlcmVzYSwgd2hvc2UgZmF0aGVyJ3MgZmlyc3Qgc3VybmFt
ZSB3YXMKPj4gR2FyY8OtYSBhbmQgbW90aGVyJ3MgZmlyc3Qgc3VybmFtZSB3YXMgUmFtw61yZXou
IEhlciBuYW1lIHdvdWxkIHRoZXJlZm9yZSBiZQo+PiBNYXJpYSBUZXJlc2EgR2FyY8OtYSBSYW3D
rXJlei4gSWYgc2hlIG1hcnJpZXMgRWzDrSBBcnJveW8gTMOzcGV6LCB0aGVuIHNoZSBtaWdodAo+
PiBjaGFuZ2UgaGVyIG5hbWUgdG8gTWFyaWEgVGVyZXNhIEdhcmPDrWEgUmFtw61yZXogZGUgQXJy
b3lvLiBXaXRoIHNpeCB3b3JkcywKPj4gdGhhdCB3b3VsZCBmYWxsIGZvdWwgb2YgRmFjZWJvb2sn
cyBmb3VsIG5hbWluZyBwb2xpY3kuCgo+IEluIFNwYWluICJkZSBBcnJveW8iIG9mZmljaWFsbHkg
ZG9lcyBub3QgYmVjb21lIHBhcnQgb2YgdGhlIG5hbWUuIFRoZQo+IHNhbWUgYXBwbGllcyB0byBv
dGhlciBjb3VudHJpZXMgYXMgd2VsbC4gTm90IDEwMCUgc3VyZSB0aGF0IGl0IGlzIHRydWUKPiBp
biBldmVyeSBTcGFuaXNoIHNwZWFraW5nIGNvdW50cnkgdGhvdWdoLgoKVGhhbmtzIGZvciB0aGUg
Y2xhcmlmaWNhdGlvbiBEYXZpZC4gTmV2ZXJ0aGVsZXNzLCB3aGV0aGVyIGl0IGlzIHBhcnQgb2Yg
aGVyIAoqbGVnYWwqIG5hbWUgb3Igbm90LCBzb21lIFNwYW5pc2ggd29tZW4gcHJlZmVyIHRvIHVz
ZSBoZXIgaHVzYmFuZCdzIG5hbWUgYXMgCnBhcnQgb2YgaGVyIHByZWZlcnJlZCByZWFsIG5hbWUs
IHRoYXQgaXMsIHRoZSBuYW1lIHNoZSBhbnN3ZXJzIHRvIGFuZCB0aGUgbmFtZSAKc2hlIHByZWZl
cnMgdG8gc2lnbiBvbiBjb3JyZXNwb25kZW5jZS4gTWF5YmUgaXQncyBhIGdlbmVyYXRpb24gdGhp
bmc/IFBlcmhhcHMgCmluIFNwYWluIHRoZSB3b21lbiB1c2luZyBGYWNlYm9vayBhbmQgdGhlIHdv
bWVuIHRha2luZyB0aGVpciBodXNiYW5kJ3MgbmFtZSAKZG9uJ3QgaW50ZXJzZWN0PwoKCi0tIApT
dGV2ZQoKLS0gCmh0dHBzOi8vbWFpbC5weXRob24ub3JnL21haWxtYW4vbGlzdGluZm8vcHl0aG9u
LWxpc3QK
================================================================================

From: Steven D'Aprano <steve+comp.lang.python () pearwood ! info>
To: python-list
Subject: Re: String concatenation
Date: Thu, 12 May 2016 07:43:08 +0000
Message-ID: <5734340d$0$2804$c3e8da3$76491128 () news ! astraweb ! com>
--------------------
On Tuesday 10 May 2016 12:42, Chris Angelico wrote:

> On Tue, May 10, 2016 at 12:32 PM, Steven D'Aprano <steve@pearwood.info>
> wrote:
>> Floats are old (they go back to the first release of Python), they have
>> many quirks (x + y - x is not necessarily equal to y), and people make
>> many errors with floats. Does this mean they are deprecated? Of course
>> not.
> 
> Careful there Steven - now that cdecimal is in core, people might
> start saying that. 

They *might*, but they haven't *yet*.

And people can say all sorts of things, doesn't make them true.


> Particularly if (as is periodically requested, and
> which I think would be a good idea) Decimal literals become a thing.
> And the removal of core types HAS happened. Correct me if I'm wrong,
> but didn't the first release of Python have only the short integer
> type, and then a completely new 'long' type was added? 

The oldest Python I have installed is 0.9.1, which not only lacks the L suffix, 
but it also lacks ** for exponentiation. There's also no "long" type:

>>> n = 2
>>> for i in range(100):
... 	n = n * 2
... 
Unhandled exception: run-time error: integer overflow
Stack backtrace (innermost last):
  File "<stdin>", line 2



> Automatic
> promotion blurred the distinction, and then Python 3.0 removed the
> 'int' type and renamed 'long'. So it's theoretically possible for
> Decimal to replace float...
> 
> ... except that that would actually be a bad idea, which a lot of
> people don't realize.

Indeed. Decimal might not be old, but it does have quirks and it can certainly 
lead to errors (both misuse and rounding errors, among others). It is subject 
to the same sorts of floating point issues as binary floats.



-- 
Steve

-- 
https://mail.python.org/mailman/listinfo/python-list
================================================================================


################################################################################

=== Thread: The Alvilda Optimizing Compiler ===

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: The Alvilda Optimizing Compiler
Date: Mon, 03 May 2004 01:05:39 +0000
Message-ID: <40959AE3.1080207 () numba-tu ! com>
--------------------
I think I mentioned a little optimizing compiler I co-wrote 11 years 
ago.  Well, I dug it out and put it up on 
http://not.meko.dk/Alvilda/The_Alvilda_Optimizing_Compiler.html along 
with some detail.  The internal representation is a structured variant 
of SSA/RTL.  It made a lot of things easier, but I'm not suggesting 
sparse adopts a similar representation.  (For one, C doesn't enforce 
structure).

I think it's still kind of cool and there are some parts that I hope to 
port to sparse.

Tommy



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: The Alvilda Optimizing Compiler
Date: Tue, 04 May 2004 01:04:39 +0000
Message-ID: <20040504010439.GB2136 () 64m ! dyndns ! org>
--------------------
Very impressive. I found the docs is not some thing I can read
and the indentation is the GNU style. Other than that looks
very cool.

Chris

On Sun, May 02, 2004 at 06:05:39PM -0700, Tommy Thorn wrote:
> I think I mentioned a little optimizing compiler I co-wrote 11 years 
> ago.  Well, I dug it out and put it up on 
> http://not.meko.dk/Alvilda/The_Alvilda_Optimizing_Compiler.html along 
> with some detail.  The internal representation is a structured variant 
> of SSA/RTL.  It made a lot of things easier, but I'm not suggesting 
> sparse adopts a similar representation.  (For one, C doesn't enforce 
> structure).
> 
> I think it's still kind of cool and there are some parts that I hope to 
> port to sparse.
> 
> Tommy
> 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: The stanford checker paper ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: The stanford checker paper
Date: Mon, 26 Apr 2004 22:20:45 +0000
Message-ID: <20040426222045.GA17118 () 64m ! dyndns ! org>
--------------------
Hi Linus,

I found this paper at Prof. Dawson Engler's home page, who lead the
Stanford checker(metacompiler) project.

http://www.stanford.edu/~engler/mc-osdi.pdf

This paper describe some level of the checker language, it is pretty much 
like a pattern match stat machine embed some C code. The language itself
looks not very complicated. I wonder what it takes to have something like
that on sparse. Should not be too complicate.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: The stanford checker paper
Date: Tue, 27 Apr 2004 15:22:39 +0000
Message-ID: <Pine.LNX.4.58.0404270813580.19703 () ppc970 ! osdl ! org>
--------------------


On Mon, 26 Apr 2004, Christopher Li wrote:
> 
> I found this paper at Prof. Dawson Engler's home page, who lead the
> Stanford checker(metacompiler) project.
> 
> http://www.stanford.edu/~engler/mc-osdi.pdf
> 
> This paper describe some level of the checker language, it is pretty much 
> like a pattern match stat machine embed some C code. The language itself
> looks not very complicated. I wonder what it takes to have something like
> that on sparse. Should not be too complicate.

The stanford checker was largely what inspired me to do sparse in the 
first place. I felt that we should be able to do what the stanford thing 
does with an open-source tool, instead of having the stanford people mail 
us every few months with reports of bugs that we have to check out.

(The problem with the stanford approach is that when you get a hundred
reports of things that might be wrogn in one day, it's just not
psychologically very easy to go through them. Especially without havign
the tool that gave the report).

So I'd love to see something like the stanford stuff..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: The stanford checker paper
Date: Wed, 28 Apr 2004 11:56:16 +0000
Message-ID: <20040428115616.GK15737 () redhat ! com>
--------------------
On Tue, Apr 27, 2004 at 08:22:39AM -0700, Linus Torvalds wrote:

 > (The problem with the stanford approach is that when you get a hundred
 > reports of things that might be wrogn in one day, it's just not
 > psychologically very easy to go through them. Especially without havign
 > the tool that gave the report).

The database they have at coverity.com is *huge*. They added a bunch of
extra tests over time vs the old checker, but as you already saw from
my half-arsed patches last week or so, theres a lot of stuff they pick
up which is 'noise'. Noise which is still nice to clean up all the same,
but it's getting harder to seperate the real important nasty bugs from
the 'trivial' stuff as time goes on.   The 'hundred' reports you mentioned
above is now in the order of 'thousands'.

What I'm doing with that is every so often, I pick something at random
(drivers/net for eg) and sift through just those bugs. Even that is a
quick way to blow away an evening.

 > So I'd love to see something like the stanford stuff..

Ditto. It's a real shame their stuff ended up closed, but at least we
can go query the results every so often on their website (sign up
required).

		Dave

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: The stanford checker paper
Date: Wed, 28 Apr 2004 16:19:03 +0000
Message-ID: <20040428161903.GA21183 () 64m ! dyndns ! org>
--------------------
On Wed, Apr 28, 2004 at 12:56:16PM +0100, Dave Jones wrote:
> On Tue, Apr 27, 2004 at 08:22:39AM -0700, Linus Torvalds wrote:
> 
> The database they have at coverity.com is *huge*. They added a bunch of
> extra tests over time vs the old checker, but as you already saw from
> my half-arsed patches last week or so, theres a lot of stuff they pick
> up which is 'noise'. Noise which is still nice to clean up all the same,
> but it's getting harder to seperate the real important nasty bugs from
> the 'trivial' stuff as time goes on.   The 'hundred' reports you mentioned
> above is now in the order of 'thousands'.

It is easy to write checker that catch simple errors and maintain false
positive low. All the bugs in the database already get manual filtered.
It is a labor intensive work.

I can image that the false positive rate will raise if the checker try
to catch more elusive bugs. e.g. touching some member of the structure
without holding certain locks. It needs people familiar with the kernel
to write more complicate checkers.

> What I'm doing with that is every so often, I pick something at random
> (drivers/net for eg) and sift through just those bugs. Even that is a
> quick way to blow away an evening.

I know in some company it is a full time job just to use the meta compiler.

> Ditto. It's a real shame their stuff ended up closed, but at least we

I believe we will get there one day.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Unable to reproduce 'shift too big for type' ===

From: Eric Sesterhenn / snakebyte <snakebyte () gmx ! de>
To: linux-sparse
Subject: Unable to reproduce 'shift too big for type'
Date: Thu, 16 Sep 2004 19:30:26 +0000
Message-ID: <1095363025.18169.5.camel () alice>
--------------------
Hi,

I am currently trying to understand sparse and its code, by trying to
document the warnings sparse spits out. I am using the bk snapshots from
http://www.codemonkey.org.uk/projects/bitkeeper/sparse/.
I tried with the version from 10. and 15. Sept to reproduce the warning
"shift too big for type".

As far as I understand it, the following code should trigger the
warning:

----------snip-----------
#include <stdio.h>
#include <stdlib.h>


int main(void) {
	int b;
	b = 36;
	b = b>>3000;
	return b;
}
---------snap-----------

With gcc 3.4.1-r2 from gentoo i get the following warning

 test.c: In function `main':
 test.c:8: warning: right shift count >= width of type

It does not seem to matter by which value I shift b, check_shift_count()
always retrieves a 16 as count. And it also doesnt seem to matter what
type b is, the ctype->bit_size is always 32. 

Maybe someone can give me some hints to understand this.

 Thanks, Eric

-- 
 www.cobra-basket.de -- just my stuff

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Unable to reproduce 'shift too big for type'
Date: Thu, 16 Sep 2004 19:56:09 +0000
Message-ID: <Pine.LNX.4.58.0409161253160.2333 () ppc970 ! osdl ! org>
--------------------


On Thu, 16 Sep 2004, Eric Sesterhenn / snakebyte wrote:
> 
> I am currently trying to understand sparse and its code, by trying to
> document the warnings sparse spits out. I am using the bk snapshots from
> http://www.codemonkey.org.uk/projects/bitkeeper/sparse/.
> I tried with the version from 10. and 15. Sept to reproduce the warning
> "shift too big for type".

Heh. It's been broken for some time, apparently. Probably since July when
simplify_int_binop was simplified. The code that checks the shift for 
being too large only triggers if _both_ sides of the shift are constants.

I'll fix it ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Unable to reproduce 'shift too big for type'
Date: Thu, 16 Sep 2004 20:15:21 +0000
Message-ID: <Pine.LNX.4.58.0409161313130.2333 () ppc970 ! osdl ! org>
--------------------


On Thu, 16 Sep 2004, Eric Sesterhenn / snakebyte wrote:
> 
> As far as I understand it, the following code should trigger the
> warning:

Of, fix checked in and pushed out. Your test program now outputs the 
expected

	test.c:7:7: warning: shift too big (3000) for type int 

which is also a lot more readable than the old error message that only 
printed out the modifiers for the type (as a hex number, to make sure that 
it made no sense at ALL to anybody but me ;).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Using "-" to specify stdin ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Using "-" to specify stdin
Date: Tue, 16 Nov 2004 15:17:52 +0000
Message-ID: <20041116151752.9F3981422D56 () darter ! rentec ! com>
--------------------



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 cgcc    |    3 +++
 check.c |   12 ++++++++----
 2 files changed, 11 insertions(+), 4 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/11/16 1.939)
   check.c:
     Teach check that "-" is stdin.
   cgcc:
     Teach cgcc that "-" is a file.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-11-16 10:16:33 -05:00
+++ b/cgcc	2004-11-16 10:16:33 -05:00
@@ -16,6 +16,9 @@
     # with arguments, but it seems to do the job.)
     $do_check = 1 if /^[^-].*\.c$/;
 
+    # Ditto for stdin.
+    $do_check = 1 if $_ eq '-';
+
     $m64 = 1 if /^-m64$/;
 
     if (/^-specs=(.*)$/) {
diff -Nru a/check.c b/check.c
--- a/check.c	2004-11-16 10:16:33 -05:00
+++ b/check.c	2004-11-16 10:16:33 -05:00
@@ -126,7 +126,7 @@
 		char *arg = *++args;
 		if (!arg)
 			break;
-		if (arg[0] == '-') {
+		if (arg[0] == '-' && arg[1]) {
 			args = handle_switch(arg+1, args);
 			continue;
 		}
@@ -146,9 +146,13 @@
 
 	do_predefined(filename);
 
-	fd = open(filename, O_RDONLY);
-	if (fd < 0)
-		die("No such file: %s", filename);
+	if (strcmp (filename, "-") == 0) {
+		fd = 0;
+	} else {
+		fd = open(filename, O_RDONLY);
+		if (fd < 0)
+			die("No such file: %s", filename);
+	}
 
 	// Tokenize the input stream
 	token = tokenize(filename, fd, NULL, includepath);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Valgrind. ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Valgrind.
Date: Fri, 13 Aug 2004 18:12:10 +0000
Message-ID: <20040813181210.GA7813 () redhat ! com>
--------------------
For kicks, I decided to see what happens when you run
sparse under valgrind.  Here's what happened... 

		Dave

==2355== Memcheck, a memory error detector for x86-linux.
==2355== Copyright (C) 2002-2004, and GNU GPL'd, by Julian Seward et al.
==2355== Using valgrind-2.1.2, a program supervision framework for x86-linux.
==2355== Copyright (C) 2000-2004, and GNU GPL'd, by Julian Seward et al.
==2355== For more details, rerun with: -v
==2355== 
==2355== Warning: invalid file descriptor -1 in syscall read()
==2355== Conditional jump or move depends on uninitialised value(s)
==2355==    at 0x8048D67: match_idents (parse.c:48)
==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
==2355==    by 0x804B660: translation_unit (parse.c:1347)
==2355==    by 0x8048D16: main (check.c:118)
==2355== 
==2355== Conditional jump or move depends on uninitialised value(s)
==2355==    at 0x8048D6C: match_idents (parse.c:50)
==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
==2355==    by 0x804B660: translation_unit (parse.c:1347)
==2355==    by 0x8048D16: main (check.c:118)
==2355== 
==2355== Conditional jump or move depends on uninitialised value(s)
==2355==    at 0x8048D67: match_idents (parse.c:48)
==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
==2355==    by 0x804ADBA: compound_statement (parse.c:1106)
==2355==    by 0x804B1C6: parse_function_body (parse.c:1215)
==2355== 
==2355== Conditional jump or move depends on uninitialised value(s)
==2355==    at 0x8048D6C: match_idents (parse.c:50)
==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
==2355==    by 0x804ADBA: compound_statement (parse.c:1106)
==2355==    by 0x804B1C6: parse_function_body (parse.c:1215)
==2355== 
==2355== Conditional jump or move depends on uninitialised value(s)
==2355==    at 0x8048D67: match_idents (parse.c:48)
==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
==2355==    by 0x804ADBA: compound_statement (parse.c:1106)
==2355==    by 0x804ABCF: statement (parse.c:1048)
==2355== 
==2355== Conditional jump or move depends on uninitialised value(s)
==2355==    at 0x8048D6C: match_idents (parse.c:50)
==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
==2355==    by 0x804ADBA: compound_statement (parse.c:1106)
==2355==    by 0x804ABCF: statement (parse.c:1048)
==2355== 
==2355== ERROR SUMMARY: 1557 errors from 6 contexts (suppressed: 13 from 1)
==2355== malloc/free: in use at exit: 97888 bytes in 750 blocks.
==2355== malloc/free: 761 allocs, 11 frees, 101248 bytes allocated.
==2355== For counts of detected errors, rerun with: -v
==2355== searching for pointers to 750 not-freed blocks.
==2355== checked 2687744 bytes.
==2355== 
==2355== 
==2355== 2016 bytes in 1 blocks are still reachable in loss record 1 of 2
==2355==    at 0x1B903506: realloc (vg_replace_malloc.c:197)
==2355==    by 0x804B943: init_stream (tokenize.c:156)
==2355==    by 0x804D1F6: tokenize (tokenize.c:884)
==2355==    by 0x804E22D: try_include (pre-process.c:608)
==2355== 
==2355== 
==2355== 95872 bytes in 749 blocks are still reachable in loss record 2 of 2
==2355==    at 0x1B902A9C: malloc (vg_replace_malloc.c:131)
==2355==    by 0x80507B7: add_ptr_list (lib.c:229)
==2355==    by 0x8051058: bind_scope (lib.h:264)
==2355==    by 0x804FE4B: bind_symbol (symbol.c:329)
==2355== 
==2355== LEAK SUMMARY:
==2355==    definitely lost: 0 bytes in 0 blocks.
==2355==    possibly lost:   0 bytes in 0 blocks.
==2355==    still reachable: 97888 bytes in 750 blocks.
==2355==         suppressed: 0 bytes in 0 blocks.
==2357== Memcheck, a memory error detector for x86-linux.
==2357== Copyright (C) 2002-2004, and GNU GPL'd, by Julian Seward et al.
==2357== Using valgrind-2.1.2, a program supervision framework for x86-linux.
==2357== Copyright (C) 2000-2004, and GNU GPL'd, by Julian Seward et al.
==2357== For more details, rerun with: -v
==2357== 
==2357== 
==2357== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 13 from 1)
==2357== malloc/free: in use at exit: 576 bytes in 3 blocks.
==2357== malloc/free: 3 allocs, 0 frees, 576 bytes allocated.
==2357== For counts of detected errors, rerun with: -v
==2357== searching for pointers to 3 not-freed blocks.
==2357== checked 1574464 bytes.
==2357== 
==2357== 256 bytes in 2 blocks are still reachable in loss record 1 of 2
==2357==    at 0x1B902A9C: malloc (vg_replace_malloc.c:131)
==2357==    by 0x80507B7: add_ptr_list (lib.c:229)
==2357==    by 0x8051058: bind_scope (lib.h:264)
==2357==    by 0x804FE4B: bind_symbol (symbol.c:329)
==2357== 
==2357== 
==2357== 320 bytes in 1 blocks are still reachable in loss record 2 of 2
==2357==    at 0x1B902A9C: malloc (vg_replace_malloc.c:131)
==2357==    by 0x1B90348B: realloc (vg_replace_malloc.c:189)
==2357==    by 0x804B943: init_stream (tokenize.c:156)
==2357==    by 0x804FF13: init_symbols (symbol.c:536)
==2357== 
==2357== LEAK SUMMARY:
==2357==    definitely lost: 0 bytes in 0 blocks.
==2357==    possibly lost:   0 bytes in 0 blocks.
==2357==    still reachable: 576 bytes in 3 blocks.
==2357==         suppressed: 0 bytes in 0 blocks.
make: *** [target.o] Interrupt
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Valgrind.
Date: Fri, 13 Aug 2004 18:33:54 +0000
Message-ID: <Pine.LNX.4.58.0408131118130.1839 () ppc970 ! osdl ! org>
--------------------


On Fri, 13 Aug 2004, Dave Jones wrote:
> ==2355== 
> ==2355== Warning: invalid file descriptor -1 in syscall read()

Ok, I can't guess at this one.

> ==2355== Conditional jump or move depends on uninitialised value(s)
> ==2355==    at 0x8048D67: match_idents (parse.c:48)
> ==2355==    by 0x804B2B4: external_declaration (parse.c:1244)
> ==2355==    by 0x804B660: translation_unit (parse.c:1347)
> ==2355==    by 0x8048D16: main (check.c:118)

Hey, what a wonderful tool. Fixed.


> ==2355== ERROR SUMMARY: 1557 errors from 6 contexts (suppressed: 13 from 1)
> ==2355== malloc/free: in use at exit: 97888 bytes in 750 blocks.
> ==2355== malloc/free: 761 allocs, 11 frees, 101248 bytes allocated.

Now, this is by design. I've long since decided (correctly or not) that
one of the biggest problems of gcc is memory usage. And when I did sparse
and decided to do a whole-file interface, some very early statistics
showed that an average C file had more than a million tokens in it with
all the header file expansion - and that was _without_ the kind of include
file mess that a lot of projects have "include one header file that
contains everything, because it's too hard to keep track of them
otherwise".

My total WAG was that C++ often makes that an order of magnitude worse.

That's the reason why "struct token" is made as small as humanly possible. 
It also made me decide that ref-counting was a bad idea. With a 16-byte 
"struct token" (on a 32-bit architecture) ref-counting would have made 
tokens 25% larger, and would in general not have helped any.

So I made all the data structures (except "struct symbol", which is a sad 
pig, dammit!) be as small as I could make them, and pack tightly for good 
cache behaviour. The allocators are also tweaked for good cache behaviour: 
aI tried very hard to make sure that when we walk the token stream, we 
have nice access patters. 

The "token->next" thing may _look_ like it's following pointers all the 
time, but the fact is, it should almost always point to the very next 
position in memory, and with 128-byte cachelines on a P4, the plan was 
that you'd basically have 8 contiguous tokens in one single cacheline.

I may have screwed something up, of course. But I don't think I did too
badly: at least my early numbers (back when I bothered to benchmark) said
that sparse did the whole parse tree evaluation in about the same time
that gcc does preprocessing. And that's with the modern heavily
_optimized_ gcc preprocessor.

Things may have gone south since, of course.

Anyway, what this all boils down to is that I very much depend on just 
allocating everything as small as I can, and not trying to do any silly 
houskeeping. Let "exit()" sort it all out.

Side note: I do try to be "nice". See "clear_token_alloc()" in
translation_unit() - I drop _all_ tokens after I've created the parse
tree. So from a memory pressure standpoint we have two clear phases: 
"generate token stream" and "work on the parse tree". Last I checked (but 
that was before doing linearization) the two phases used roughly the same 
amount of memory.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Value of assignments to bitfields ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Value of assignments to bitfields
Date: Fri, 24 Sep 2004 18:19:49 +0000
Message-ID: <20040924181949.B22621422D53 () darter ! rentec ! com>
--------------------

The program...

-----------------------------------------------------------------------------
#include <stdio.h>

int main (int argc, char **argv)
{
  struct { unsigned int b : 3; } x;
  int i;
  i = (x.b = -1);
  printf ("%d\n", i);  
  return 0;
}
-----------------------------------------------------------------------------

...should print 7 because the x.b assignment stores 7 in x.b.  But if I
read the linearizer output right, it will print -1 under sparse.

Morten


        %r1 <- 4294967295
        %r2 <- x
        %r3 <- 0
        %r4 <- add  %r2, %r3
        load %r5 <- [%r4]
        %r6 <- -8
        %r7 <- and  %r5, %r6
        %r8 <- 7
        %r9 <- and  %r1, %r8
        %r10 <- or  %r7, %r9
        store %r10 -> [%r4]
        %r11 <- i
        store %r1 -> [%r11]
        %r12 <- <noident>
        %r13 <- i
        load %r14 <- [%r13]
        %r15 <- printf
        %r16 <- CALL %r15, %r12, %r14
        %r17 <- 0
        ret %r17
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: Value of assignments to bitfields
Date: Fri, 24 Sep 2004 18:53:15 +0000
Message-ID: <Pine.LNX.4.58.0409241138270.2317 () ppc970 ! osdl ! org>
--------------------


On Fri, 24 Sep 2004, Morten Welinder wrote:
> 
> The program...
> 
> -----------------------------------------------------------------------------
> #include <stdio.h>
> 
> int main (int argc, char **argv)
> {
>   struct { unsigned int b : 3; } x;
>   int i;
>   i = (x.b = -1);
>   printf ("%d\n", i);  
>   return 0;
> }
> -----------------------------------------------------------------------------
> 
> ...should print 7 because the x.b assignment stores 7 in x.b.  But if I
> read the linearizer output right, it will print -1 under sparse.

Yes.  I have to admit that sparse doesn't really handle bitfields at all, 
except from a pure type standpoint (ie all the bitfield code is really 
geared towards making a struct _layout_ be correct, rather than anything 
else).

The problem here is the lack of casting to a bitfield type. Look at the 
function "compatible_assignment_types()": it is supposed to create the 
right type out of the right-hand side for assigning to the left-hand side. 
It even gets half-way:

		...
	        if (is_int_type(target)) {
	                if (is_int_type(source)) {
	                        if (target->bit_size != source->bit_size)
	                                goto Cast;
		...
	Cast:
	        *rp = cast_to(*rp, target);
		return 1;

but the thing is, we never get here, because the bitfield type is 
considered to be identical to an integer type by "type_difference()", 
because both of them end up being plain 32-bit integers.

As to why the left-hand side evaluates as a regular 32-bit integer: I
believe that the answer is that we are looking at the wrong left-hand
expression. The assignment just looks at the result of dereferencing the
left side (ie it looks at the _result_ of the EXPR_PREOP(*) or the
EXPR_BITFIELD operator), and it doesn't look any deeper into what we
actually are dereferencing.

Now, when we're assigning a normal EXPR_PREOP(*), this all works right, 
because the type of the dereference is literally the right type: it's the 
type of whatever the lvalue is pointing to. But the type of a 
EXPR_BITFIELD is "int", not the actual type of the thing we dereference.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: Warning ===

From: "G. Roderick Singleton" <grsingleton () openoffice ! org>
To: openoffice-discuss
Subject: Re: Warning
Date: Thu, 11 Dec 2003 01:50:41 +0000
Message-ID: <br8ihh$15a$2 () sea ! gmane ! org>
--------------------
Sander Vesik wrote:
> Daniel Carrera wrote:
> 
>> Warning:  This page is unnecessarily graphic.
>>
> 
> oh crap, this sneaked through the list?
> 

Human error or software?

>> I don't need to see disfigured people to know that drinking and 
>> driving is dangerous.  I am not so disensitized, nor so dumb, as to 
>> need this kind of material to do what's sensible.  Also, I certainly 
>> don't think that THIS belongs in an OOo list.  Even at 'discuss'.
>>
>> What this some sort of spam?  It looked like the headers had been 
>> altered.
>>
>> In any event.  I felt that a warning was warranted.
>>
>>
>> On Wed, Dec 10, 2003 at 06:36:49PM -0500, BBSBaby2@aol.com wrote:
>>
>>> <A HREF="http://duyanh.whatisthis.com/drunk.htm">Click here: MSN 
>>> Hotmail - Message</A> or
>>> <A 
>>> HREF="http://duyanh.whatisthis.com/drunk.htm">http://duyanh.whatisthis.com/drunk.htm</A> 
>>>
>>
>>
>>
>> ---------------------------------------------------------------------
>> To unsubscribe, e-mail: discuss-unsubscribe@openoffice.org
>> For additional commands, e-mail: discuss-help@openoffice.org
>>


-- 
Postest nocenti contingere ut lateat, latendi fides non postest.



================================================================================


################################################################################

=== Thread: [BK PATCH] Compat file for Solaris. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Compat file for Solaris.
Date: Sun, 03 Oct 2004 02:00:38 +0000
Message-ID: <200410030200.i9320cv03858 () troll ! rentec ! com>
--------------------


Linus,

this does the Solaris compatibility in the way you outlined.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/solaris

This will update the following files:

 Makefile               |    6 +++++
 compat-linux.c         |   52 ++-----------------------------------------------
 compat-solaris.c       |   34 ++++++++++++++++++++++++++++++++
 compat/id-files-stat.c |    7 ++++++
 compat/mmap-blob.c     |   33 +++++++++++++++++++++++++++++++
 compat/strtold.c       |    6 +++++
 6 files changed, 89 insertions(+), 49 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/02 1.832.1.1)
   Add compatibility file for solaris.

diff -Nru a/Makefile b/Makefile
--- a/Makefile	2004-10-02 21:54:43 -04:00
+++ b/Makefile	2004-10-02 21:54:43 -04:00
@@ -74,6 +74,12 @@
 check.o: $(LIB_H)
 obfuscate.o: $(LIB_H)
 
+compat-linux.o: compat/strtold.c compat/id-files-stat.c compat/mmap-blob.c \
+	$(LIB_H)
+compat-solaris.o: compat/id-files-stat.c compat/mmap-blob.c $(LIB_H)
+compat-mingw.o: $(LIB_H)
+compat-cygwin.o: $(LIB_H)
+
 pre-process.h:
 	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h
 
diff -Nru a/compat/id-files-stat.c b/compat/id-files-stat.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/compat/id-files-stat.c	2004-10-02 21:54:43 -04:00
@@ -0,0 +1,7 @@
+#include "../token.h"
+#include <sys/stat.h>
+
+int identical_files(struct stream* s, struct stat *st, const char * name)
+{
+	return s->dev == st->st_dev && s->ino == st->st_ino;
+}
diff -Nru a/compat/mmap-blob.c b/compat/mmap-blob.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/compat/mmap-blob.c	2004-10-02 21:54:43 -04:00
@@ -0,0 +1,33 @@
+#include <sys/mman.h>
+#include <sys/types.h>
+
+/*
+ * Allow old BSD naming too, it would be a pity to have to make a
+ * separate file just for this.
+ */
+#ifndef MAP_ANONYMOUS
+#define MAP_ANONYMOUS MAP_ANON
+#endif
+
+/*
+ * Our blob allocator enforces the strict CHUNK size
+ * requirement, as a portability check.
+ */
+void *blob_alloc(unsigned long size)
+{
+	void *ptr;
+
+	if (size & ~CHUNK)
+		die("internal error: bad allocation size (%d bytes)", size);
+	ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
+	if (ptr == MAP_FAILED)
+		ptr = NULL;
+	return ptr;
+}
+
+void blob_free(void *addr, unsigned long size)
+{
+	if (!size || (size & ~CHUNK) || ((unsigned long) addr & 512))
+		die("internal error: bad blob free (%d bytes at %p)", size, addr);
+	munmap(addr, size);
+}
diff -Nru a/compat/strtold.c b/compat/strtold.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/compat/strtold.c	2004-10-02 21:54:43 -04:00
@@ -0,0 +1,6 @@
+#include <stdlib.h>
+
+long double string_to_ld(const char *nptr, char **endptr)
+{
+	return strtold(nptr, endptr);
+}
diff -Nru a/compat-linux.c b/compat-linux.c
--- a/compat-linux.c	2004-10-02 21:54:43 -04:00
+++ b/compat-linux.c	2004-10-02 21:54:43 -04:00
@@ -1,53 +1,7 @@
-/*
- * Sane compat.c for Linux
- */
 #define _GNU_SOURCE
 
-#include <stdlib.h>
-#include <sys/mman.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-
 #include "lib.h"
-#include "token.h"
-
-/*
- * Allow old BSD naming too, it would be a pity to have to make a
- * separate file just for this.
- */
-#ifndef MAP_ANONYMOUS
-#define MAP_ANONYMOUS MAP_ANON
-#endif
-
-/*
- * Our blob allocator enforces the strict CHUNK size
- * requirement, as a portability check.
- */
-void *blob_alloc(unsigned long size)
-{
-	void *ptr;
-
-	if (size & ~CHUNK)
-		die("internal error: bad allocation size (%d bytes)", size);
-	ptr = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
-	if (ptr == MAP_FAILED)
-		ptr = NULL;
-	return ptr;
-}
-
-void blob_free(void *addr, unsigned long size)
-{
-	if (!size || (size & ~CHUNK) || ((unsigned long) addr & 512))
-		die("internal error: bad blob free (%d bytes at %p)", size, addr);
-	munmap(addr, size);
-}
-
-long double string_to_ld(const char *nptr, char **endptr)
-{
-	return strtold(nptr, endptr);
-}
 
-int identical_files(struct stream* s, struct stat *st, const char * name)
-{
-	return s->dev == st->st_dev && s->ino == st->st_ino;
-}
+#include "compat/id-files-stat.c"
+#include "compat/mmap-blob.c"
+#include "compat/strtold.c"
diff -Nru a/compat-solaris.c b/compat-solaris.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/compat-solaris.c	2004-10-02 21:54:43 -04:00
@@ -0,0 +1,34 @@
+#include "lib.h"
+
+#include "compat/id-files-stat.c"
+#include "compat/mmap-blob.c"
+
+
+#include <floatingpoint.h>
+#include <limits.h>
+#include <errno.h>
+
+long double string_to_ld(const char *str, char **endptr)
+{
+	long double res;
+	decimal_record dr;
+	enum decimal_string_form form;
+	decimal_mode dm;
+	fp_exception_field_type excp;
+	char *echar;
+
+	string_to_decimal ((char **)&str, INT_MAX, 0,
+			   &dr, &form, &echar);
+	if (endptr) *endptr = (char *)str;
+
+	if (form == invalid_form) {
+		errno = EINVAL;
+		return 0.0;
+	}
+
+	dm.rd = fp_nearest;
+	decimal_to_quadruple (&res, &dm, &dr, &excp);
+        if (excp & ((1 << fp_overflow) | (1 << fp_underflow)))
+                errno = ERANGE;
+	return res;
+}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Compiling from stdin ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Compiling from stdin
Date: Sun, 21 Nov 2004 18:35:39 +0000
Message-ID: <20041121183539.A971F1422D5B () darter ! rentec ! com>
--------------------

This seems to have gotten lost in all the linarizer excitement.
This basically teaches sparse that "-" as filename is stdin.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 cgcc    |    3 +++
 check.c |   12 ++++++++----
 2 files changed, 11 insertions(+), 4 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/11/16 1.939)
   check.c:
     Teach check that "-" is stdin.
   cgcc:
     Teach cgcc that "-" is a file.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-11-17 09:46:47 -05:00
+++ b/cgcc	2004-11-17 09:46:47 -05:00
@@ -16,6 +16,9 @@
     # with arguments, but it seems to do the job.)
     $do_check = 1 if /^[^-].*\.c$/;
 
+    # Ditto for stdin.
+    $do_check = 1 if $_ eq '-';
+
     $m64 = 1 if /^-m64$/;
 
     if (/^-specs=(.*)$/) {
diff -Nru a/check.c b/check.c
--- a/check.c	2004-11-17 09:46:47 -05:00
+++ b/check.c	2004-11-17 09:46:47 -05:00
@@ -126,7 +126,7 @@
 		char *arg = *++args;
 		if (!arg)
 			break;
-		if (arg[0] == '-') {
+		if (arg[0] == '-' && arg[1]) {
 			args = handle_switch(arg+1, args);
 			continue;
 		}
@@ -146,9 +146,13 @@
 
 	do_predefined(filename);
 
-	fd = open(filename, O_RDONLY);
-	if (fd < 0)
-		die("No such file: %s", filename);
+	if (strcmp (filename, "-") == 0) {
+		fd = 0;
+	} else {
+		fd = open(filename, O_RDONLY);
+		if (fd < 0)
+			die("No such file: %s", filename);
+	}
 
 	// Tokenize the input stream
 	token = tokenize(filename, fd, NULL, includepath);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Getting __SIZE_TYPE__ right ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Getting __SIZE_TYPE__ right
Date: Wed, 29 Sep 2004 15:29:56 +0000
Message-ID: <20040929152956.ED75F1422D58 () darter ! rentec ! com>
--------------------

This helps with function pointers involving size_t on glibc systems.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 check.c |    9 ++-------
 lib.c   |   27 ++++++++++++++++++++++-----
 lib.h   |    1 +
 3 files changed, 25 insertions(+), 12 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/29 1.825)
   Move builin prototypes from check.c to lib.c
   
   Take extra care in defining __SIZE_TYPE__ as newer glibcs actually
   define size_t from it.

diff -Nru a/check.c b/check.c
--- a/check.c	2004-09-29 11:26:23 -04:00
+++ b/check.c	2004-09-29 11:26:23 -04:00
@@ -48,13 +48,6 @@
 	init_symbols();
 
 	create_builtin_stream();
-	add_pre_buffer("#define __CHECKER__ 1\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
-	add_pre_buffer("extern void *__builtin_return_address(int);\n");
-	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
-	add_pre_buffer("extern void __builtin_trap(void);\n");
-	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
-	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
 
 	args = argv;
 	for (;;) {
@@ -70,6 +63,8 @@
 
 	if (!filename)
 		die("no input files given");
+
+	create_builtin_prototypes();
 
 	// Initialize type system
 	init_ctype();
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-09-29 11:26:23 -04:00
+++ b/lib.c	2004-09-29 11:26:23 -04:00
@@ -759,6 +759,28 @@
 	return rc;
 }
 
+void create_builtin_prototypes(void)
+{
+	add_pre_buffer("#define __CHECKER__ 1\n");
+	// gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
+	// solaris/sparc that is really "unsigned int" and for linux/x86_64
+	// it is "long unsigned int".
+	// Newer versions of glibc seem to actually use __SIZE_TYPE__ to
+	// define size_t, so getting it right is important.
+	add_pre_buffer("#ifndef __SIZE_TYPE__\n");
+	if (bits_in_long > bits_in_int)
+		add_pre_buffer("#define __SIZE_TYPE__ long unsigned int\n");
+	else
+		add_pre_buffer("#define __SIZE_TYPE__ unsigned int\n");
+	add_pre_buffer("#endif\n");
+	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
+	add_pre_buffer("extern void *__builtin_return_address(int);\n");
+	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
+	add_pre_buffer("extern void __builtin_trap(void);\n");
+	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
+	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+}
+
 void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __linux__ 1\n");
@@ -771,11 +793,6 @@
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
-	// gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
-	// solaris/sparc that is really "unsigned int" and for linux/x86_64
-	// it is "long unsigned int".  In either case we can probably
-	// get away with this:
-	add_pre_buffer("#define __SIZE_TYPE__ long unsigned int\n");
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-09-29 11:26:23 -04:00
+++ b/lib.h	2004-09-29 11:26:23 -04:00
@@ -144,6 +144,7 @@
 extern int Wbitwise;
 extern int Wtypesign;
 
+extern void create_builtin_prototypes(void);
 extern void create_builtin_stream(void);
 
 static inline int symbol_list_size(struct symbol_list* list)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] Getting __SIZE_TYPE__ right
Date: Wed, 29 Sep 2004 19:54:01 +0000
Message-ID: <Pine.LNX.4.58.0409291250180.2317 () ppc970 ! osdl ! org>
--------------------


On Wed, 29 Sep 2004, Morten Welinder wrote:
> 
> This helps with function pointers involving size_t on glibc systems.

Does gcc really use a #define, or a builtin thing? To me, it would make 
more sense to make the thing a "__builtin_size_t" typedef, and have some 
way to dynamically set it - it's entirely possible that some 32-bit 
environments want "unsigned long" too.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [BK PATCH] Getting __SIZE_TYPE__ right
Date: Wed, 29 Sep 2004 19:57:59 +0000
Message-ID: <20040929195759.2148E1422D58 () darter ! rentec ! com>
--------------------

> Does gcc really use a #define, or a builtin thing? To me, it would make 
> more sense to make the thing a "__builtin_size_t" typedef, and have some 
> way to dynamically set it - it's entirely possible that some 32-bit 
> environments want "unsigned long" too.

Yes, gcc uses a #define.  You can expand it by calling "gcc -E" on
a foo.c file containing "__SIZE_TYPE__".  And newer glibcs then do

    typedef __SIZE_TYPE__ size_t;

Note, that I wrapped the define in #ifndef, so it is still possible
to override if that should be necessary.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Handle "-U" and define __SIZE_TYPE__ in cgcc ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Handle "-U" and define __SIZE_TYPE__ in cgcc
Date: Thu, 07 Oct 2004 15:51:27 +0000
Message-ID: <20041007155127.924781422D5B () darter ! rentec ! com>
--------------------

This teaches lib.c about "-UFO" to undefine the FO macro.  It also
makes cgcc define the right version of __SIZE_TYPE__ for the platform.

Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/cgcc

This will update the following files:

 cgcc  |   30 ++++++++++++++++++++++++++----
 lib.c |   14 ++++++++++++--
 2 files changed, 38 insertions(+), 6 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/07 1.844)
   lib.c:
     Handle -U.
   cgcc:
     Teach cgcc about "-v".
     Teach cgcc not to run compiler when "-E" is seen.
     Add define for __SIZE_TYPE__.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-10-07 11:47:45 -04:00
+++ b/cgcc	2004-10-07 11:47:45 -04:00
@@ -8,6 +8,7 @@
 my $has_specs = 0;
 my $do_check = 0;
 my $do_compile = 1;
+my $verbose = 0;
 
 foreach (@ARGV) {
     # Look for a .c file.  We don't want to run the checker on .o or .so files
@@ -23,11 +24,16 @@
 	next;
     }
 
-    if (/^-no-compile$/) {
+    if ($_ eq '-no-compile') {
 	$do_compile = 0;
 	next;
     }
 
+    # If someone adds "-E", don't pre-process twice.
+    $do_compile = 0 if $_ eq '-E';
+
+    $verbose = 1 if $_ eq '-v';
+
     my $this_arg = ' ' . &quote_arg ($_);
     $cc .= $this_arg unless &check_only_option ($_);
     $check .= $this_arg;
@@ -39,9 +45,11 @@
     if ($arch =~ /^(i.?86|athlon)$/) {
 	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
 	$check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
+	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
     } elsif ($arch =~ /^(sun4u)$/) {
 	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
 	$check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
+	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
     }
 
     if (!$has_specs) {
@@ -49,14 +57,20 @@
 	chomp $os;
 	$check .= &add_specs (lc $os);
     }
+}
 
-#    print "$check\n";
+
+if ($do_check) {
+    print "$check\n" if $verbose;
 #    exit 1;
+    system ($check);
 }
 
+if ($do_compile) {
+    print "$cc\n" if $verbose;
+    exec ($cc);
+}
 
-system ($check) if $do_check;
-exec ($cc) if $do_compile;
 exit 0;
 
 # -----------------------------------------------------------------------------
@@ -170,6 +184,14 @@
 	}
     }
     return $result;
+}
+
+# -----------------------------------------------------------------------------
+
+sub define_size_t {
+    my ($text) = @_;
+    # We have to undef in order to override checks internal definition.
+    return ' -U__SIZE_TYPE__ ' . &quote_arg ("-D__SIZE_TYPE__=$text");
 }
 
 # -----------------------------------------------------------------------------
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-10-07 11:47:45 -04:00
+++ b/lib.c	2004-10-07 11:47:45 -04:00
@@ -677,7 +677,7 @@
 		return next;     // "-ofoo" or (bogus) terminal "-o"
 }
 
-struct warning {
+const struct warning {
 	const char *name;
 	int *flag;
 } warnings[] = {
@@ -713,6 +713,15 @@
 	return next;
 }
 
+char **handle_switch_U(char *arg, char **next)
+{
+	const char *name = arg + 1;
+	add_pre_buffer ("#undef %s\n", name);
+	return next;
+}
+
+
+
 char **handle_nostdinc(char *arg, char **next)
 {
 	add_pre_buffer("#nostdinc\n");
@@ -736,12 +745,13 @@
 	switch (*arg) {
 	case 'D': rc = handle_switch_D(arg, next); break;
 	case 'E': rc = handle_switch_E(arg, next); break;
-	case 'v': rc = handle_switch_v(arg, next); break;
 	case 'I': rc = handle_switch_I(arg, next); break;
 	case 'i': rc = handle_switch_i(arg, next); break;
 	case 'M': rc = handle_switch_M(arg, next); break;
 	case 'm': rc = handle_switch_m(arg, next); break;
 	case 'o': rc = handle_switch_o(arg, next); break;
+	case 'U': rc = handle_switch_U(arg, next); break;
+	case 'v': rc = handle_switch_v(arg, next); break;
 	case 'W': rc = handle_switch_W(arg, next); break;
 	default:
 		break;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Janitorial trivialities ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Janitorial trivialities
Date: Mon, 13 Sep 2004 19:26:19 +0000
Message-ID: <20040913192619.BD09E1422D5E () darter ! rentec ! com>
--------------------

This spreads a few "const" and "static" around.  We're not almost clean
with -Wwrite-strings which makes strings in gcc have the reasonable, but
non-C99, type "const char *".  (There is one instance left in
replace_with_defined which would require a cast.)

In other words: trivialities.

Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 check.c        |    2 +-
 compile-i386.c |   10 +++++-----
 linearize.c    |    2 +-
 pre-process.c  |    2 +-
 show-parse.c   |    2 +-
 test-lexing.c  |    2 +-
 6 files changed, 10 insertions(+), 10 deletions(-)

through these ChangeSets:

<welinder@darter.rentec.com> (04/09/13 1.789)
   Janitorial trivialities.

diff -Nru a/check.c b/check.c
--- a/check.c	2004-09-13 15:20:16 -04:00
+++ b/check.c	2004-09-13 15:20:16 -04:00
@@ -98,7 +98,7 @@
 		while (!eof_token(token)) {
 			int prec = 1;
 			struct token *next = token->next;
-			char * separator = "";
+			const char *separator = "";
 			if (next->pos.whitespace)
 				separator = " ";
 			if (next->pos.newline) {
diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	2004-09-13 15:20:16 -04:00
+++ b/compile-i386.c	2004-09-13 15:20:16 -04:00
@@ -286,10 +286,10 @@
 	const unsigned char regs[30];
 };
 
-struct regclass regclass_8 = { "8-bit", { AL, DL, CL, BL, AH, DH, CH, BH }};
-struct regclass regclass_16 = { "16-bit", { AX, DX, CX, BX, SI, DI, BP }};
-struct regclass regclass_32 = { "32-bit", { EAX, EDX, ECX, EBX, ESI, EDI, EBP }};
-struct regclass regclass_64 = { "64-bit", { EAX_EDX, ECX_EBX, ESI_EDI }};
+static struct regclass regclass_8 = { "8-bit", { AL, DL, CL, BL, AH, DH, CH, BH }};
+static struct regclass regclass_16 = { "16-bit", { AX, DX, CX, BX, SI, DI, BP }};
+static struct regclass regclass_32 = { "32-bit", { EAX, EDX, ECX, EBX, ESI, EDI, EBP }};
+static struct regclass regclass_64 = { "64-bit", { EAX_EDX, ECX_EBX, ESI_EDI }};
 
 struct regclass regclass_32_8 = { "32-bit bytes", { EAX, EDX, ECX, EBX }};
 
@@ -1126,7 +1126,7 @@
 	case 16: c = 'w'; break;
 	case 32: c = 'l'; break;
 	case 64: c = 'q'; break;
-	default: assert(0); break;
+	default: abort(); break;
 	}
 
 	sprintf(opbits_str, "%s%c", insn, c);
diff -Nru a/linearize.c b/linearize.c
--- a/linearize.c	2004-09-13 15:20:16 -04:00
+++ b/linearize.c	2004-09-13 15:20:16 -04:00
@@ -143,7 +143,7 @@
 	
 	case OP_PHI: {
 		struct phi *phi;
-		char *s = " ";
+		const char *s = " ";
 		printf("\t%%r%d <- phi", insn->target->nr);
 		FOR_EACH_PTR(insn->phi_list, phi) {
 			printf("%s(%%r%d, .L%p)", s, phi->pseudo->nr, phi->source);
diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-13 15:20:16 -04:00
+++ b/pre-process.c	2004-09-13 15:20:16 -04:00
@@ -95,7 +95,7 @@
 
 static void replace_with_defined(struct token *token)
 {
-	char *string[] = { "0", "1" };
+	static char *string[] = { "0", "1" };
 	int defined = 0;
 	if (token_type(token) != TOKEN_IDENT)
 		warning(token->pos, "operator \"defined\" requires an identifier");
diff -Nru a/show-parse.c b/show-parse.c
--- a/show-parse.c	2004-09-13 15:20:16 -04:00
+++ b/show-parse.c	2004-09-13 15:20:16 -04:00
@@ -159,7 +159,7 @@
 	const char *mod;
 	static struct ctype_name {
 		struct symbol *sym;
-		char *name;
+		const char *name;
 	} typenames[] = {
 		{ & char_ctype,  "char" },
 		{ &schar_ctype,  "signed char" },
diff -Nru a/test-lexing.c b/test-lexing.c
--- a/test-lexing.c	2004-09-13 15:20:16 -04:00
+++ b/test-lexing.c	2004-09-13 15:20:16 -04:00
@@ -38,7 +38,7 @@
 	while (!eof_token(token)) {
 		int prec = 1;
 		struct token *next = token->next;
-		char * separator = "";
+		const char *separator = "";
 		if (next->pos.whitespace)
 			separator = " ";
 		if (next->pos.newline) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] Janitorial trivialities
Date: Mon, 13 Sep 2004 19:38:25 +0000
Message-ID: <Pine.LNX.4.58.0409131237570.2378 () ppc970 ! osdl ! org>
--------------------


On Mon, 13 Sep 2004, Morten Welinder wrote:
> 
> This spreads a few "const" and "static" around.  We're not almost clean
> with -Wwrite-strings which makes strings in gcc have the reasonable, but
> non-C99, type "const char *".  (There is one instance left in
> replace_with_defined which would require a cast.)

Or, alternatively, just simplifying:

		Linus

---
===== token.h 1.44 vs edited =====
--- 1.44/token.h	2004-09-01 11:45:46 -07:00
+++ edited/token.h	2004-09-13 12:37:13 -07:00
@@ -150,7 +150,7 @@
 	struct position pos;
 	struct token *next;
 	union {
-		char *number;
+		const char *number;
 		struct ident *ident;
 		unsigned int special;
 		struct string *string;
===== pre-process.c 1.107 vs edited =====
--- 1.107/pre-process.c	2004-09-13 12:19:01 -07:00
+++ edited/pre-process.c	2004-09-13 12:37:26 -07:00
@@ -382,11 +382,13 @@
 		left->pos.noexpand = 0;
 		return 1;
 
-	case TOKEN_NUMBER:
+	case TOKEN_NUMBER: {
+		char *number = __alloc_bytes(strlen(buffer) + 1);
+		memcpy(number, buffer, strlen(buffer) + 1);
 		token_type(left) = TOKEN_NUMBER;	/* could be . + num */
-		left->number = __alloc_bytes(strlen(buffer) + 1);
-		memcpy(left->number, buffer, strlen(buffer) + 1);
+		left->number = number;
 		return 1;
+	}
 
 	case TOKEN_SPECIAL:
 		if (buffer[2] && buffer[3])
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Misc janitorial stuff ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Misc janitorial stuff
Date: Mon, 11 Oct 2004 13:37:19 +0000
Message-ID: <20041011133719.9BB2C1422D5B () darter ! rentec ! com>
--------------------

test-linearize got behind on builtin function declarations so I factored
those out into lib.c

I also added stubs for __builtin_va_alist and __builtin_va_arg_incr as used
by solaris/sparc vararg magic.  With this I no longer seem to need my
special Solaris tree.

Morten






Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 check.c          |   30 +++++++++++++-----------------
 lib.c            |   19 ++++++++++++++++++-
 lib.h            |    1 +
 test-linearize.c |   10 +++++-----
 4 files changed, 37 insertions(+), 23 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/11 1.851)
   test-linearize.c:
     Simplify using declare_builtin_functions.
   lib.h:
     declare declare_builtin_functions.
   lib.c:
     New declare_builtin_functions extracted from check.c
     Fix __builtin_ffs prototype.
     Define __SIZE_TYPE__ only conditionally to allow it to be overwritten
     from command line by cgcc.
     Add __builtin_va_alist and __builtin_va_arg_incr stubs.
   check.c:
     Move builtin declarations to lib.c

<welinder@troll.com> (04/10/08 1.849)
   Don't add declarations when -E is used.

diff -Nru a/check.c b/check.c
--- a/check.c	2004-10-11 09:33:17 -04:00
+++ b/check.c	2004-10-11 09:33:17 -04:00
@@ -67,14 +67,8 @@
 
 	create_builtin_stream();
 	add_pre_buffer("#define __CHECKER__ 1\n");
-	if (!preprocess_only) {
-		add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
-		add_pre_buffer("extern void *__builtin_return_address(int);\n");
-		add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
-		add_pre_buffer("extern void __builtin_trap(void);\n");
-		add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
-		add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
-	}
+	if (!preprocess_only)
+		declare_builtin_functions();
 
 	do_predefined(filename);
 
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-10-11 09:33:17 -04:00
+++ b/lib.c	2004-10-11 09:33:17 -04:00
@@ -771,19 +771,36 @@
 	return rc;
 }
 
+void declare_builtin_functions(void)
+{
+	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
+	add_pre_buffer("extern void *__builtin_return_address(int);\n");
+	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
+	add_pre_buffer("extern void __builtin_trap(void);\n");
+	add_pre_buffer("extern int __builtin_ffs(int);\n");
+	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+}
+
 void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
+
+	add_pre_buffer("#ifndef __SIZE_TYPE__\n");
 	// gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
 	// solaris/sparc that is really "unsigned int" and for linux/x86_64
 	// it is "long unsigned int".  In either case we can probably
-	// get away with this:
+	// get away with this.  We need the #ifndef as cgcc will define
+	// the right __SIZE_TYPE__.
 	add_pre_buffer("#define __SIZE_TYPE__ long unsigned int\n");
+	add_pre_buffer("#endif\n");
+
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
+	add_pre_buffer("#define __builtin_va_alist (*(void *)0)\n");
+	add_pre_buffer("#define __builtin_va_arg_incr(x) ((x) + 1)\n");
 	add_pre_buffer("#define __builtin_va_end(arg)\n");
 }
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-10-11 09:33:17 -04:00
+++ b/lib.h	2004-10-11 09:33:17 -04:00
@@ -148,6 +148,7 @@
 extern int Wbitwise;
 extern int Wtypesign;
 
+extern void declare_builtin_functions(void);
 extern void create_builtin_stream(void);
 
 static inline int symbol_list_size(struct symbol_list* list)
diff -Nru a/test-linearize.c b/test-linearize.c
--- a/test-linearize.c	2004-10-11 09:33:17 -04:00
+++ b/test-linearize.c	2004-10-11 09:33:17 -04:00
@@ -42,11 +42,6 @@
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
 
-	create_builtin_stream();
-	add_pre_buffer("#define __CHECKER__ 1\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, unsigned long);\n");
-	add_pre_buffer("extern void * __builtin_return_address(int);\n");
-
 	args = argv;
 	for (;;) {
 		char *arg = *++args;
@@ -61,6 +56,11 @@
 
 	// Initialize type system
 	init_ctype();
+
+	create_builtin_stream();
+	add_pre_buffer("#define __CHECKER__ 1\n");
+	if (!preprocess_only)
+		declare_builtin_functions();
 
 	fd = open(filename, O_RDONLY);
 	if (fd < 0)
diff -Nru a/check.c b/check.c
--- a/check.c	2004-10-11 09:33:18 -04:00
+++ b/check.c	2004-10-11 09:33:18 -04:00
@@ -47,15 +47,6 @@
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
 
-	create_builtin_stream();
-	add_pre_buffer("#define __CHECKER__ 1\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
-	add_pre_buffer("extern void *__builtin_return_address(int);\n");
-	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
-	add_pre_buffer("extern void __builtin_trap(void);\n");
-	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
-	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
-
 	args = argv;
 	for (;;) {
 		char *arg = *++args;
@@ -73,6 +64,17 @@
 
 	// Initialize type system
 	init_ctype();
+
+	create_builtin_stream();
+	add_pre_buffer("#define __CHECKER__ 1\n");
+	if (!preprocess_only) {
+		add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
+		add_pre_buffer("extern void *__builtin_return_address(int);\n");
+		add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
+		add_pre_buffer("extern void __builtin_trap(void);\n");
+		add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
+		add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	}
 
 	do_predefined(filename);
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] More portability stuff. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] More portability stuff.
Date: Tue, 05 Oct 2004 14:59:08 +0000
Message-ID: <20041005145908.7397D1422D5B () darter ! rentec ! com>
--------------------

"#define __linux__ 1" is, surprisingly, Linux specific, so this
patch moves that into the compat-foo files.

I don't really know what to do for cygwin and mingw so I have just
maintained status quo.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/solaris

This will update the following files:

 compat-cygwin.c  |    6 ++++++
 compat-linux.c   |    6 ++++++
 compat-mingw.c   |    6 ++++++
 compat-solaris.c |   23 +++++++++++++++++++++++
 lib.c            |    5 +++--
 lib.h            |    1 +
 6 files changed, 45 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/05 1.836)
   Allow platforms to define their own set of predefines.

diff -Nru a/compat-cygwin.c b/compat-cygwin.c
--- a/compat-cygwin.c	2004-10-05 10:55:58 -04:00
+++ b/compat-cygwin.c	2004-10-05 10:55:58 -04:00
@@ -42,3 +42,9 @@
 {	
 	return (s->dev == st->st_dev && s->ino == st->st_ino);	
 }	
+
+void create_platform_builtin_stream(void)
+{
+	add_pre_buffer("#define __linux__ 1\n");
+	add_pre_buffer("#define linux linux\n");
+}
diff -Nru a/compat-linux.c b/compat-linux.c
--- a/compat-linux.c	2004-10-05 10:55:58 -04:00
+++ b/compat-linux.c	2004-10-05 10:55:58 -04:00
@@ -5,3 +5,9 @@
 #include "compat/id-files-stat.c"
 #include "compat/mmap-blob.c"
 #include "compat/strtold.c"
+
+void create_platform_builtin_stream(void)
+{
+	add_pre_buffer("#define __linux__ 1\n");
+	add_pre_buffer("#define linux linux\n");
+}
diff -Nru a/compat-mingw.c b/compat-mingw.c
--- a/compat-mingw.c	2004-10-05 10:55:58 -04:00
+++ b/compat-mingw.c	2004-10-05 10:55:58 -04:00
@@ -58,3 +58,9 @@
 	CloseHandle(file2);	
 	return same;	
 }	
+
+void create_platform_builtin_stream(void)
+{
+	add_pre_buffer("#define __linux__ 1\n");
+	add_pre_buffer("#define linux linux\n");
+}
diff -Nru a/compat-solaris.c b/compat-solaris.c
--- a/compat-solaris.c	2004-10-05 10:55:58 -04:00
+++ b/compat-solaris.c	2004-10-05 10:55:58 -04:00
@@ -32,3 +32,26 @@
                 errno = ERANGE;
 	return res;
 }
+
+void create_platform_builtin_stream(void)
+{
+	add_pre_buffer("#define __sun__ 1\n");
+	add_pre_buffer("#define __sun 1\n");
+	add_pre_buffer("#define sun 1\n");
+	add_pre_buffer("#define __svr4__ 1\n");
+	add_pre_buffer("#define SVR4 1\n");
+	// The system definition (either 0 or 0L) is just not useful.
+	// Luckily, it is conditionally defined.
+	add_pre_buffer("#define NULL ((void *)0)\n");
+	// gcc specs define the following on solaris:
+	add_pre_buffer("#define _REENTRANT\n");
+	add_pre_buffer("#define _SOLARIS_THREADS\n");
+	// I'm just guessing here:
+	add_pre_buffer("#define __builtin_va_alist (*(void *)0)\n");
+	add_pre_buffer("#define __builtin_va_arg_incr(x) ((x) + 1)\n");
+	// System headers really want this:
+	add_pre_buffer("#define __sparc__ 1\n");
+	add_pre_buffer("#define __sparc 1\n");
+	add_pre_buffer("#define sparc 1\n");
+	add_pre_buffer("#define __STDC__ 0\n");
+}
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-10-05 10:55:58 -04:00
+++ b/lib.c	2004-10-05 10:55:58 -04:00
@@ -763,12 +763,13 @@
 
 void create_builtin_stream(void)
 {
-	add_pre_buffer("#define __linux__ 1\n");
-	add_pre_buffer("#define linux linux\n");
+	create_platform_builtin_stream();
 	add_pre_buffer("#define unix 1\n");
 	add_pre_buffer("#define __unix 1\n");
 	add_pre_buffer("#define __unix__ 1\n");
+	add_pre_buffer("#ifndef __STDC__\n");
 	add_pre_buffer("#define __STDC__ 1\n");
+	add_pre_buffer("#endif\n");
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __extension__\n");
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-10-05 10:55:58 -04:00
+++ b/lib.h	2004-10-05 10:55:58 -04:00
@@ -148,6 +148,7 @@
 extern int Wbitwise;
 extern int Wtypesign;
 
+extern void create_platform_builtin_stream(void);
 extern void create_builtin_stream(void);
 
 static inline int symbol_list_size(struct symbol_list* list)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] More portability stuff.
Date: Tue, 05 Oct 2004 15:08:48 +0000
Message-ID: <Pine.LNX.4.58.0410050805570.8290 () ppc970 ! osdl ! org>
--------------------


On Tue, 5 Oct 2004, Morten Welinder wrote:
> 
> "#define __linux__ 1" is, surprisingly, Linux specific, so this
> patch moves that into the compat-foo files.

Hmm.. I'd much rather remove it entirely, and have your compiler script 
add these flags. Ok?

For example, if you do a cross-compile of the Linux kernel on Solaris 
(yeah, I realize it's a far-fetched example, but run with the idea), you 
do _not_ want to have __solaris__ enabled. You want the Linux kernel tree 
flags.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Number token length ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Number token length
Date: Thu, 28 Oct 2004 16:59:16 +0000
Message-ID: <20041028165916.C35201422D53 () darter ! rentec ! com>
--------------------

The current limit on number token length is 255 characters.  That's too
small -- I have observed 311 characters in the wild for some testing code.
I cannot find a limit in the C99 standard so I am randomly picking the
line length limit of 4095 characters.

Also, with this patch an error will be output instead of trashing whatever
comes after the buffer.  That's nicer.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 tokenize.c |   19 +++++++++++++++----
 1 files changed, 15 insertions(+), 4 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/28 1.884)
   Allow longer number tokens (up to 4095 characters) and catch
   violations instead of crashing.

diff -Nru a/tokenize.c b/tokenize.c
--- a/tokenize.c	2004-10-28 12:54:32 -04:00
+++ b/tokenize.c	2004-10-28 12:54:32 -04:00
@@ -396,8 +396,8 @@
 static int get_one_number(int c, int next, stream_t *stream)
 {
 	struct token *token;
-	static char buffer[256];
-	char *p = buffer, *buf;
+	static char buffer[4095];
+	char *p = buffer, *buf, *buffer_end = buffer + sizeof (buffer);
 	int len;
 
 	*p++ = c;
@@ -405,15 +405,26 @@
 		long class =  cclass[next + 1];
 		if (!(class & (Dot | Digit | Letter)))
 			break;
-		*p++ = next;
+		if (p != buffer_end)
+			*p++ = next;
 		next = nextchar(stream);
 		if (class & Exp) {
 			if (next == '-' || next == '+') {
-				*p++ = next;
+				if (p != buffer_end)
+					*p++ = next;
 				next = nextchar(stream);
 			}
 		}
 	}
+
+	if (p == buffer_end) {
+		error(stream->pos, "number token exceeds %d characters",
+		      buffer_end - buffer);
+		// Pretend we saw just "1".
+		buffer[0] = '1';
+		p = buffer + 1;
+	}
+
 	*p++ = 0;
 	len = p - buffer;
 	buf = __alloc_bytes(len);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Re: Linearizer problem ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [BK PATCH] Re: Linearizer problem
Date: Mon, 16 Aug 2004 13:15:57 +0000
Message-ID: <20040816131557.GB18567 () 64m ! dyndns ! org>
--------------------
My fault. You are right about the assigned value is dropped.

Here is the patch to fix it.

Thanks

Chris

===================================================================
--- sparse-be.orig/linearize.c  2004-08-15 20:52:45.000000000 -0400
+++ sparse-be/linearize.c       2004-08-16 09:09:22.000000000 -0400
@@ -385,9 +385,10 @@
                }
                orig = add_load(ep, expr, addr);
                andmask = add_const_value(ep, expr->pos, &uint_ctype, ~mask);
-               value = add_binary_op(ep, expr, OP_AND, orig, andmask);
+               orig = add_binary_op(ep, expr, OP_AND, orig, andmask);
                ormask = add_const_value(ep, expr->pos, &uint_ctype, mask);
-               value = add_binary_op(ep, expr, OP_OR, orig, ormask);
+               value = add_binary_op(ep, expr, OP_AND, value, ormask);
+               value = add_binary_op(ep, expr, OP_OR, orig, value);
        }
 
        store->target = value;


On Mon, Aug 16, 2004 at 11:11:40AM -0400, Morten Welinder wrote:
> 
> The assignment generates the following code for me:
> 
>         %r1 <- 2
>         %r2 <- foo
>         %r3 <- 0
>         %r4 <- add  %r2, %r3
>         load %r5 <- [%r4]
>         %r6 <- -4
>         %r7 <- and  %r5, %r6
>         %r8 <- 3
>         %r9 <- or  %r5, %r8
>         store %r9 -> [%r4]
> 
> Note, that the value to be assigned, %r1, is never used.
> 
> Morten
> 
> 
> 
> -----------------------------------------------------------------------------
> #include <stdio.h>
> 
> enum Foo { FOO, BAR, BAZ, BOOZE };
> 
> int
> main (int argc, char **argv)
> {
>   struct {
>     enum Foo foo : 2;
>   } foo;
>   foo.foo = BAZ;
> 
>   if (foo.foo == BAZ)
>     printf ("Equal\n");
> 
>   return 0;
> }
> -----------------------------------------------------------------------------
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Resend: various fixes ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Resend: various fixes
Date: Sun, 19 Sep 2004 18:53:04 +0000
Message-ID: <200409191853.i8JIr4C11545 () troll ! rentec ! com>
--------------------

Resending these two memory overwriting problems and a lot of
warning->error changes.

Morten






Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c    |   76 +++++++++++++++++++++++++++++-----------------------------
 expand.c      |   10 +++----
 parse.c       |   66 +++++++++++++++++++++++++-------------------------
 pre-process.c |    4 +--
 4 files changed, 78 insertions(+), 78 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/14 1.794)
   dynamically allocate (and in some sense leak) the message constructed
   for different function argument types.  Functions with function
   arguments could overwrite the static buffer.

<welinder@troll.com> (04/09/14 1.793)
   Change lots of warning() calls to error() calls.

<welinder@troll.com> (04/09/14 1.792)
   Fix off-by-one allocation and sign confusion in replace_with_integer.

diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-09-19 14:49:16 -04:00
+++ b/evaluate.c	2004-09-19 14:49:16 -04:00
@@ -554,12 +554,12 @@
 			PREPARE_PTR_LIST(source->arguments, arg2);
 			i = 1;
 			for (;;) {
-				const char *diff;
-				diff = type_difference(arg1, arg2, 0, 0);
-				if (diff) {
-					static char argdiff[80];
-					sprintf(argdiff, "incompatible argument %d (%s)", i, diff);
-					return argdiff;
+				const char *argdiff;
+				argdiff = type_difference(arg1, arg2, 0, 0);
+				if (argdiff) {
+					char *diff = __alloc_bytes (40 + strlen (argdiff));
+					sprintf(diff, "incompatible argument %d (%s)", i, argdiff);
+					return diff;
 				}
 				if (!arg1)
 					break;
diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-09-19 14:49:16 -04:00
+++ b/evaluate.c	2004-09-19 14:49:16 -04:00
@@ -40,17 +40,17 @@
 			expr->ctype = &int_ctype;
 			return &int_ctype;
 		}
-		warning(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		error(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
 	examine_symbol_type(sym);
 	if ((sym->ctype.context ^ current_context) & (sym->ctype.contextmask & current_contextmask))
-		warning(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
+		error(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
 
 	base_type = sym->ctype.base_type;
 	if (!base_type) {
-		warning(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		error(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -215,7 +215,7 @@
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warning(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
+	error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -387,7 +387,7 @@
 
 	ctype = degenerate(ptr);
 	if (!ctype->ctype.base_type) {
-		warning(expr->pos, "missing type information");
+		error(expr->pos, "missing type information");
 		return NULL;
 	}
 
@@ -623,7 +623,7 @@
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warning(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			error(expr->pos, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -633,7 +633,7 @@
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warning(expr->pos, "subtraction of functions? Share your drugs");
+		error(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = ctype->ctype.base_type;
@@ -892,7 +892,7 @@
 	ctype = compatible_restricted_binop('?', &expr->left, &expr->right);
 	if (ctype)
 		goto out;
-	warning(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	error(expr->pos, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -963,7 +963,7 @@
 		}
 	}
 
-	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	error(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1069,7 +1069,7 @@
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		warning(expr->pos, "not an lvalue");
+		error(expr->pos, "not an lvalue");
 		return NULL;
 	}
 
@@ -1239,7 +1239,7 @@
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warning(expr->pos, "strange non-value function or array");
+			error(expr->pos, "strange non-value function or array");
 			return NULL;
 		}
 		*expr = *expr->unop;
@@ -1257,7 +1257,7 @@
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warning(expr->pos, "not addressable");
+		error(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1296,7 +1296,7 @@
 
 	switch (ctype->type) {
 	default:
-		warning(expr->pos, "cannot derefence this type");
+		error(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		merge_type(node, ctype);
@@ -1318,7 +1318,7 @@
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warning(op->pos, "non-lvalue array??");
+			error(op->pos, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1350,11 +1350,11 @@
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		warning(expr->pos, "need lvalue expression for ++/--");
+		error(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warning(expr->pos, "bad operation on restricted");
+		error(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1510,7 +1510,7 @@
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warning(expr->pos, "bad member name");
+		error(expr->pos, "bad member name");
 		return NULL;
 	}
 
@@ -1523,7 +1523,7 @@
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warning(expr->pos, "expected structure or union");
+		error(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1536,8 +1536,8 @@
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warning(expr->pos, "no member '%s' in %s %.*s",
-			show_ident(ident), type, namelen, name);
+		error(expr->pos, "no member '%s' in %s %.*s",
+		      show_ident(ident), type, namelen, name);
 		return NULL;
 	}
 
@@ -1641,7 +1641,7 @@
 				size = bits_in_int;
 		}
 		if (is_bitfield_type(what->ctype))
-			warning(expr->pos, "sizeof applied to bitfield type");
+			error(expr->pos, "sizeof applied to bitfield type");
 	}
 	if (size & 7)
 		warning(expr->pos, "cannot size expression");
@@ -1661,7 +1661,7 @@
 			return NULL;
 	}
 	if (is_bitfield_type(type))
-		warning(expr->pos, "alignof applied to bitfield type");
+		error(expr->pos, "alignof applied to bitfield type");
 	examine_symbol_type(type);
 	expr->type = EXPR_VALUE;
 	expr->value = type->ctype.alignment;
@@ -1693,7 +1693,7 @@
 			return 0;
 
 		if (context_clash(f, ctype))
-			warning(expr->pos, "argument %d used in wrong context", i);
+			error(expr->pos, "argument %d used in wrong context", i);
 
 		ctype = degenerate(expr);
 
@@ -1749,7 +1749,7 @@
 static int evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr, unsigned long offset)
 {
 	if (offset || expression_list_size(expr->expr_list) != 1) {
-		warning(expr->pos, "unexpected compound initializer");
+		error(expr->pos, "unexpected compound initializer");
 		return 0;
 	}
 	return evaluate_array_initializer(ctype, expr, 0);
@@ -1772,7 +1772,7 @@
 			RESET_PTR_LIST(sym);
 			for (;;) {
 				if (!sym) {
-					warning(entry->pos, "unknown named initializer '%s'", show_ident(ident));
+					error(entry->pos, "unknown named initializer '%s'", show_ident(ident));
 					return 0;
 				}
 				if (sym->ident == ident)
@@ -1783,7 +1783,7 @@
 		}
 
 		if (!sym) {
-			warning(expr->pos, "too many initializers for struct/union");
+			error(expr->pos, "too many initializers for struct/union");
 			return 0;
 		}
 
@@ -1957,7 +1957,7 @@
 		warning(expr->pos, "cast to non-scalar");
 
 	if (!target->ctype) {
-		warning(expr->pos, "cast from unknown type");
+		error(expr->pos, "cast from unknown type");
 		goto out;
 	}
 
@@ -2052,7 +2052,7 @@
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warning(expr->pos, "not a function %s", show_ident(sym->ident));
+		error(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
@@ -2079,7 +2079,7 @@
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warning(expr->pos, "value expression without a type");
+		error(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2129,7 +2129,7 @@
 	case EXPR_CALL:
 		return evaluate_call(expr);
 	case EXPR_BITFIELD:
-		warning(expr->pos, "bitfield generated by parser");
+		error(expr->pos, "bitfield generated by parser");
 		return NULL;
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
@@ -2160,10 +2160,10 @@
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warning(expr->pos, "internal front-end error: initializer in expression");
+		error(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
+		error(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-09-19 14:49:16 -04:00
+++ b/expand.c	2004-09-19 14:49:16 -04:00
@@ -739,7 +739,7 @@
 		return expand_call(expr);
 
 	case EXPR_DEREF:
-		warning(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
+		error(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
 		return UNSAFE;
 
 	case EXPR_BITFIELD:
@@ -772,7 +772,7 @@
 
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warning(expr->pos, "internal front-end error: sizeof in expansion?");
+		error(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -783,7 +783,7 @@
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warning(expr->pos, "Expected constant expression in %s", where);
+			error(expr->pos, "Expected constant expression in %s", where);
 	}
 }
 
@@ -919,12 +919,12 @@
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warning(expr->pos, "bad constant expression type");
+		error(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warning(expr->pos, "bad constant expression");
+		error(expr->pos, "bad constant expression");
 		return 0;
 	}
 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-09-19 14:49:17 -04:00
+++ b/parse.c	2004-09-19 14:49:17 -04:00
@@ -134,7 +134,7 @@
 
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected declaration");
+		error(token->pos, "expected declaration");
 		ctype->base_type = &bad_type;
 		return token;
 	}
@@ -193,7 +193,7 @@
 	struct symbol *sym;
 
 	if (!match_op(token, '(')) {
-		warning(token->pos, "expected '(' after typeof");
+		error(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -351,7 +351,7 @@
 	token = expect(token, '(', "after attribute");
 
 	for (;;) {
-		const char *error;
+		const char *err;
 		struct ident *attribute_name;
 		struct expression *attribute_expr;
 
@@ -366,9 +366,9 @@
 		attribute_expr = NULL;
 		if (match_op(token, '('))
 			token = parens_expression(token, &attribute_expr, "in attribute");
-		error = handle_attribute(ctype, attribute_name, attribute_expr);
-		if (error)
-			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
+		err = handle_attribute(ctype, attribute_name, attribute_expr);
+		if (err)
+			error(token->pos, "attribute '%s': %s", show_ident(attribute_name), err);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -440,29 +440,29 @@
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warning(pos, "Just how %sdo you want this type to be?",
-				modifier_string(dup));
+			error(pos, "Just how %sdo you want this type to be?",
+			      modifier_string(dup));
 
 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warning(pos, "You cannot have both long and short modifiers.");
+			error(pos, "You cannot have both long and short modifiers.");
 
 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warning(pos, "You cannot have both signed and unsigned modifiers.");
+			error(pos, "You cannot have both signed and unsigned modifiers.");
 
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warning(pos, "multiple storage classes");
+			error(pos, "multiple storage classes");
 
 		ctype->modifiers = old | mod | extra;
 	}
 
 	/* Context mask and value */
 	if ((ctype->context ^ thistype->context) & (ctype->contextmask & thistype->contextmask)) {
-		warning(pos, "inconsistent attribute types");
+		error(pos, "inconsistent attribute types");
 		thistype->context = 0;
 		thistype->contextmask = 0;
 	}
@@ -471,7 +471,7 @@
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
-		warning(pos, "I don't like non-power-of-2 alignments");
+		error(pos, "I don't like non-power-of-2 alignments");
 		thistype->alignment = 0;
 	}
 	if (thistype->alignment > ctype->alignment)
@@ -506,8 +506,8 @@
 
 	wrong = mod & banned;
 	if (wrong)
-		warning(*pos, "modifier %sis invalid in this context",
-		     modifier_string (wrong));
+		error(*pos, "modifier %sis invalid in this context",
+		      modifier_string (wrong));
 }
 
 
@@ -588,7 +588,7 @@
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warning(token->pos, "invalid modifier");
+			error(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -724,7 +724,7 @@
 	long long width;
 
 	if (!is_int_type(ctype->base_type)) {
-		warning(token->pos, "invalid bitfield specifier for type %s.",
+		error(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -736,10 +736,10 @@
 	bitfield->fieldwidth = width;
 
 	if (width < 0) {
-		warning(token->pos, "invalid negative bitfield width, %lld.", width);
+		error(token->pos, "invalid negative bitfield width, %lld.", width);
 		bitfield->fieldwidth = 8;
 	} else if (decl->ident && width == 0) {
-		warning(token->pos, "invalid named zero-width bitfield `%s'",
+		error(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		bitfield->fieldwidth = 8;
 	} else if (width != bitfield->fieldwidth) {
@@ -787,7 +787,7 @@
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warning(token->pos, "expected ; at end of declaration");
+			error(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1013,7 +1013,7 @@
 	struct symbol *sym;
 
 	if (!target) {
-		warning(stmt->pos, "not in switch scope");
+		error(stmt->pos, "not in switch scope");
 		return;
 	}
 	sym = alloc_symbol(stmt->pos, SYM_NODE);
@@ -1096,7 +1096,7 @@
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warning(token->pos, "expected 'while' after 'do'");
+		error(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");
 
 	stmt->iterator_post_condition = expr;
@@ -1131,7 +1131,7 @@
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warning(stmt->pos, "break/continue not in iterator scope");
+				error(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1175,7 +1175,7 @@
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warning(token->pos, "Expected identifier or goto expression");
+				error(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1233,7 +1233,7 @@
 
 		if (match_op(token, SPECIAL_ELLIPSIS)) {
 			if (!*list)
-				warning(token->pos, "variadic functions must have one named argument");
+				error(token->pos, "variadic functions must have one named argument");
 			fn->variadic = 1;
 			token = token->next;
 			break;
@@ -1245,7 +1245,7 @@
 			/* Special case: (void) */
 			if (!*list && !sym->ident)
 				break;
-			warning(token->pos, "void parameter");
+			error(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
@@ -1284,7 +1284,7 @@
 	if (to) {
 		idx_to = get_expression_value(to);
 		if (idx_to < idx_from || idx_from < 0)
-			warning(from->pos, "nonsense array initializer index range");
+			error(from->pos, "nonsense array initializer index range");
 	}
 	expr->idx_from = idx_from;
 	expr->idx_to = idx_to;
@@ -1339,7 +1339,7 @@
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warning(sym->pos, "no identifier for function argument");
+		error(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1417,7 +1417,7 @@
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warning(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
+		error(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1429,7 +1429,7 @@
 
 	FOR_EACH_PTR(argtypes, arg) {
 		if (!arg->used)
-			warning(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
+			error(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
 	} END_FOR_EACH_PTR(arg);
 
 }
@@ -1447,7 +1447,7 @@
 	apply_k_r_types(args, decl);
 
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected function body");
+		error(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1513,7 +1513,7 @@
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (!is_typedef && base_type == &void_ctype && !(decl->ctype.modifiers & MOD_EXTERN)) {
-		warning(token->pos, "void declaration");
+		error(token->pos, "void declaration");
 	}
 
 	for (;;) {
@@ -1552,7 +1552,7 @@
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, &decl, &ident);
 		if (!ident) {
-			warning(token->pos, "expected identifier name in type definition");
+			error(token->pos, "expected identifier name in type definition");
 			return token;
 		}
 
diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-19 14:49:17 -04:00
+++ b/pre-process.c	2004-09-19 14:49:17 -04:00
@@ -87,8 +87,8 @@
 
 static void replace_with_integer(struct token *token, unsigned int val)
 {
-	char *buf = __alloc_bytes(10);
-	sprintf(buf, "%d", val);
+	char *buf = __alloc_bytes(11);
+	sprintf(buf, "%u", val);
 	token_type(token) = TOKEN_NUMBER;
 	token->number = buf;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] Resend: various fixes
Date: Sun, 19 Sep 2004 20:07:24 +0000
Message-ID: <Pine.LNX.4.58.0409191306160.4715 () ppc970 ! osdl ! org>
--------------------


On Sun, 19 Sep 2004, Morten Welinder wrote:
> 
> <welinder@troll.com> (04/09/14 1.794)
>    dynamically allocate (and in some sense leak) the message constructed
>    for different function argument types.  Functions with function
>    arguments could overwrite the static buffer.

I really think this is wrong, because of the allocation problem. 

You could make the caller allocate the string, and switch things around 
that way perhaps..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [BK PATCH] Resend: various fixes
Date: Sun, 19 Sep 2004 20:42:43 +0000
Message-ID: <200409192042.i8JKghj23265 () troll ! rentec ! com>
--------------------

> I really think this is wrong, because of the allocation problem.

The clean solution is to always allocate.  That way we don't have to
guess the size needed.

But it's really overkill -- this is after all the failure path of the
type check.  Apart from uses of == on types, we would only leak (a
small chunk of memory) in case of errors.

We have silly error messages, btw.: we carefully tell that there is a
mismatch for argument 3, then list function types where all the args
have been replaced by "..."

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Skip builtin-declarations when -E is given ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Skip builtin-declarations when -E is given
Date: Fri, 08 Oct 2004 18:25:50 +0000
Message-ID: <20041008182550.04AAC1422D56 () darter ! rentec ! com>
--------------------

We don't want things like

    extern void __builtin_trap(void);

to escape when we run check with -E.

Morten






Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 check.c |   20 +++++++++++---------
 1 files changed, 11 insertions(+), 9 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/08 1.849)
   Don't add declarations when -E is used.

diff -Nru a/check.c b/check.c
--- a/check.c	2004-10-08 14:24:10 -04:00
+++ b/check.c	2004-10-08 14:24:10 -04:00
@@ -47,15 +47,6 @@
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
 
-	create_builtin_stream();
-	add_pre_buffer("#define __CHECKER__ 1\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
-	add_pre_buffer("extern void *__builtin_return_address(int);\n");
-	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
-	add_pre_buffer("extern void __builtin_trap(void);\n");
-	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
-	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
-
 	args = argv;
 	for (;;) {
 		char *arg = *++args;
@@ -73,6 +64,17 @@
 
 	// Initialize type system
 	init_ctype();
+
+	create_builtin_stream();
+	add_pre_buffer("#define __CHECKER__ 1\n");
+	if (!preprocess_only) {
+		add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
+		add_pre_buffer("extern void *__builtin_return_address(int);\n");
+		add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
+		add_pre_buffer("extern void __builtin_trap(void);\n");
+		add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
+		add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
+	}
 
 	do_predefined(filename);
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] Tokenize patches ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] Tokenize patches
Date: Mon, 01 Nov 2004 16:20:09 +0000
Message-ID: <20041101162009.3E1761422D4F () darter ! rentec ! com>
--------------------


This fixes a buffer overrun in show_string.  It could be triggered by
"check -E" on a file with long strings.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 tokenize.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/11/01 1.891.1.2)
   Prevent buffer overrun in show_string.

<welinder@troll.com> (04/11/01 1.891.1.1)
   fix confusion between ptrdiff_t and int.
   From: Ralf Wildenhues <Ralf.Wildenhues@gmx.de>

diff -Nru a/tokenize.c b/tokenize.c
--- a/tokenize.c	2004-11-01 11:17:59 -05:00
+++ b/tokenize.c	2004-11-01 11:17:59 -05:00
@@ -83,7 +83,7 @@
 
 const char *show_string(const struct string *string)
 {
-	static char buffer[256];
+	static char buffer[4 * MAX_STRING + 3];
 	char *ptr;
 	int i;
 
diff -Nru a/tokenize.c b/tokenize.c
--- a/tokenize.c	2004-11-01 11:17:59 -05:00
+++ b/tokenize.c	2004-11-01 11:17:59 -05:00
@@ -419,7 +419,7 @@
 
 	if (p == buffer_end) {
 		error(stream->pos, "number token exceeds %d characters",
-		      buffer_end - buffer);
+		      (int)(buffer_end - buffer));
 		// Pretend we saw just "1".
 		buffer[0] = '1';
 		p = buffer + 1;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] Tokenize patches
Date: Mon, 01 Nov 2004 18:00:54 +0000
Message-ID: <Pine.LNX.4.58.0411011000340.28839 () ppc970 ! osdl ! org>
--------------------


On Mon, 1 Nov 2004, Morten Welinder wrote:
> 
> <welinder@troll.com> (04/11/01 1.891.1.1)
>    fix confusion between ptrdiff_t and int.
>    From: Ralf Wildenhues <Ralf.Wildenhues@gmx.de>

Me no likee. Please redo a tree without this one.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] [RESEND] Sorting... ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] [RESEND] Sorting...
Date: Wed, 29 Sep 2004 13:21:14 +0000
Message-ID: <20040929132114.8746C1422D58 () darter ! rentec ! com>
--------------------

No comments, so I'll try again...

M.





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/sort

This will update the following files:


through these ChangeSets:

<welinder@anemone.rentec.com> (04/09/26 1.826)
   Ignore test-sort binary.

<welinder@anemone.rentec.com> (04/09/26 1.825)
   New BitKeeper file ``test-sort.c''

<welinder@anemone.rentec.com> (04/09/26 1.824)
   Make sure sort does not degenerate.

<welinder@anemone.rentec.com> (04/09/26 1.823)
   This file uses NULL, so include stdlib.h

diff -Nru a/Makefile b/Makefile
--- a/Makefile	2004-09-26 14:15:08 -04:00
+++ b/Makefile	2004-09-26 14:15:08 -04:00
@@ -37,6 +37,9 @@
 test-linearize: test-linearize.o $(LIB_FILE)
 	$(CC) $(LDFLAGS) -o $@ $< $(LIBS)
 
+test-sort: test-sort.o $(LIB_FILE)
+	gcc $(LDFLAGS) -o $@ $< $(LIBS)
+
 compile: compile.o compile-i386.o $(LIB_FILE)
 	$(CC) $(LDFLAGS) -o $@ $< compile-i386.o $(LIBS)
 
diff -Nru a/test-sort.c b/test-sort.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/test-sort.c	2004-09-26 14:15:08 -04:00
@@ -0,0 +1,45 @@
+#include "lib.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+static int
+int_cmp (const void *_a, const void *_b)
+{
+  const int *a = _a;
+  const int *b = _b;
+  return *a - *b;
+}
+
+#define MIN(_x,_y) ((_x) < (_y) ? (_x) : (_y))
+
+int
+main (int argc, char **argv)
+{
+  struct ptr_list *l = NULL, *l2;
+  int i, *e;
+  const int N = argv[1] ? atoi (argv[1]) : 10000;
+
+  srand (N);
+  for (i = 0; i < 1000; i++)
+    (void)rand ();
+
+  for (i = 0; i < N; i++) {
+    e = (int *)malloc (sizeof (int));
+    *e = rand ();
+    add_ptr_list (&l, e);
+  }
+  sort_list (&l, int_cmp);
+  // Sort already sorted stuff.
+  sort_list (&l, int_cmp);
+
+  l2 = l;
+  do {
+    l2->nr = MIN (l2->nr, rand () % 3);
+    for (i = 0; i < l2->nr; i++)
+      *((int*)(l2->list[i])) = rand();
+    l2 = l2->next;
+  } while (l2 != l);
+  sort_list (&l, int_cmp);
+
+  return 0;
+}
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-09-26 14:15:08 -04:00
+++ b/expand.c	2004-09-26 14:15:08 -04:00
@@ -758,23 +758,23 @@
 {
 	const struct expression *a = _a;
 	const struct expression *b = _b;
+	int r;
+
+	r = (b->type != EXPR_POS) - (a->type != EXPR_POS);
+	if (r) return r;
 
-	if (a->type != EXPR_POS)
-		return 1;
-	if (b->type != EXPR_POS)
-		return -1;
 	if (a->init_offset < b->init_offset)
-		return 1;
-	if (a->init_offset > b->init_offset)
 		return -1;
+	if (a->init_offset > b->init_offset)
+		return +1;
 	/* Check bitfield offset.. */
 	a = a->init_expr;
 	b = b->init_expr;
 	if (a && b) {
 		if (a->ctype && b->ctype) {
 			if (a->ctype->bit_offset < b->ctype->bit_offset)
-				return 1;
-			return -1;
+				return -1;
+			return +1;
 		}
 	}
 	return 0;
diff -Nru a/sort.c b/sort.c
--- a/sort.c	2004-09-26 14:15:08 -04:00
+++ b/sort.c	2004-09-26 14:15:08 -04:00
@@ -1,101 +1,289 @@
 /*
- * This is a horribly stupid list sort. We
- * use it to sort C initializers into ascending
- * order.
+ * sort_list: a stable sort for lists.
  *
- * These things tend to be sorted already, so we
- * should optimize for that case and not really
- * care about the other ones.
+ * Time complexity: O(n*log n)
+ *   [assuming limited zero-element fragments]
+ *
+ * Space complexity: O(1).
+ *
+ * Stable: yes.
  */
-#include <stdio.h>
+
 #include "lib.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#undef PARANOIA
+#undef COVERAGE
 
+#ifdef PARANOIA
+#include <assert.h>
+#else
+#define assert(x)
+#endif
+
+#ifdef COVERAGE
+static unsigned char been_there[256];
+#define BEEN_THERE(_c)					\
+  do {							\
+	if (!been_there[_c]) {				\
+		been_there[_c] = 1;			\
+		printf ("Been there: %c\n", _c);	\
+	}						\
+  } while (0)
+#else
+#define BEEN_THERE(_c) do { } while (0)
+#endif
+
+// Sort one fragment.  LIST_NODE_NR (==29) is a bit too high for my
+// taste for something this simple.  But, hey, it's O(1).
+//
+// I would use libc qsort for this, but its comparison function
+// gets a pointer indirection extra.
 static void array_sort(void **ptr, int nr, int (*cmp)(const void *, const void *))
 {
 	int i;
 	for (i = 1; i < nr; i++) {
 		void *p = ptr[i];
-		if (cmp(ptr[i-1],p) < 0) {
+		if (cmp(ptr[i-1],p) > 0) {
 			int j = i;
 			do {
 				ptr[j] = ptr[j-1];
 				if (!--j)
 					break;
-			} while (cmp(ptr[j-1], p) < 0);
+			} while (cmp(ptr[j-1], p) > 0);
 			ptr[j] = p;
 		}
 	}
 }
 
-static int merge_array(void **arr1, int nr1, void **arr2, int nr2, int (*cmp)(const void *, const void *))
+#ifdef PARANOIA
+static void verify_seq_sorted (struct ptr_list *l, int n,
+			       int (*cmp)(const void *, const void *))
 {
-	int i, j;
-	void *a, *b;
+	int i = 0;
+	const void *a;
+	struct ptr_list *head = l;
+
+	while (l->nr == 0) {
+		l = l->next;
+		if (--n == 0)
+			return;
+		assert (l != head);
+	}
 
-	if (!nr1 || !nr2)
-		return 0;
+	a = l->list[0];
+	while (n > 0) {
+		const void *b;
+		if (++i >= l->nr) {
+			i = 0;
+			l = l->next;
+			n--;
+			assert (l != head || n == 0);
+			continue;
+		}
+		b = l->list[i];
+		assert (cmp (a, b) <= 0);
+		a = b;
+	}
+}
+#endif
 
-	i = nr1-1;
-	j = 0;
-	a = arr1[i];	/* last entry of first array */
-	b = arr2[j];	/* first entry of last array */
-
-	/* If they are already sorted, don't do anything else */
-	if (cmp(a, b) >= 0)
-		return 0;
-
-	/*
-	 * Remember: we don't care. The above was
-	 * the speedpath. This is a joke. Although
-	 * it happens to be a joke that gets the
-	 * reverse sorted case right, I think.
-	 *
-	 * Damn, it's been _ages_ since I did sort
-	 * routines. I feel like a first-year CS
-	 * student again.
-	 */
-	do {
-		arr2[j] = a;
-		arr1[i] = b;
-		if (--i < 0)
-			break;
-		if (++j == nr2)
-			break;
-		a = arr1[i];
-		b = arr2[j];
-	} while (cmp(a, b) < 0);
 
-	array_sort(arr1, nr1, cmp);
-	array_sort(arr2, nr2, cmp);
+#define FLUSH_TO(b)						\
+  do {								\
+	int nr = (b)->nr;					\
+	assert (nbuf >= nr);					\
+	memcpy ((b)->list, buffer, nr * sizeof (void *));	\
+	nbuf -= nr;						\
+	memcpy (buffer, buffer + nr, nbuf * sizeof (void *));	\
+  } while (0)
+
+#define DUMP_TO(b)						\
+  do {								\
+        assert (nbuf <= (b)->nr);				\
+	memcpy ((b)->list, buffer, nbuf * sizeof (void *));	\
+  } while (0)
+
+
+// Merge two already-sorted sequences of blocks:
+//   (b1_1, ..., b1_n)  and  (b2_1, ..., b2_m)
+// Since we may be moving blocks around, we return the new head
+// of the merged list.
+static struct ptr_list *
+merge_block_seqs (struct ptr_list *b1, int n,
+		  struct ptr_list *b2, int m,
+		  int (*cmp)(const void *, const void *))
+{
+	int i1 = 0, i2 = 0;
+	const void *buffer[2 * LIST_NODE_NR];
+	int nbuf = 0;
+	struct ptr_list *newhead = b1;
+
+	// printf ("Merging %d blocks at %p with %d blocks at %p\n", n, b1, m, b2);
+
+	// Skip empty blocks in b2.
+	while (b2->nr == 0) {
+		BEEN_THERE('F');
+		b2 = b2->next;
+		if (--m == 0) {
+			BEEN_THERE('G');
+			return newhead;
+		}
+	}
+
+	// Do a quick skip in case entire blocks from b1 are
+	// already less than smallest element in b2.
+	while (b1->nr == 0 ||
+	       cmp (b1->list[b1->nr - 1], b2->list[0]) < 0) {
+		// printf ("Skipping whole block.\n");
+		BEEN_THERE('H');
+		b1 = b1->next;
+		if (--n == 0) {
+			BEEN_THERE('I');
+			return newhead;	
+		}
+	}
 
-	return 1;
+	while (1) {
+		const void *d1 = b1->list[i1];
+		const void *d2 = b2->list[i2];
+
+		assert (i1 >= 0 && i1 < b1->nr);
+		assert (i2 >= 0 && i2 < b2->nr);
+		assert (b1 != b2);
+		assert (n > 0);
+		assert (m > 0);
+
+		if (cmp (d1, d2) <= 0) {
+			BEEN_THERE('J');
+			buffer[nbuf++] = d1;
+			// Element from b1 is smaller
+			if (++i1 >= b1->nr) {
+				BEEN_THERE('L');
+				FLUSH_TO(b1);
+				do {
+					b1 = b1->next;
+					if (--n == 0) {
+						BEEN_THERE('O');
+						while (b1 != b2) {
+							BEEN_THERE('P');
+							FLUSH_TO(b1);
+							b1 = b1->next;
+						}
+						assert (nbuf == i2);
+						DUMP_TO(b2);
+						return newhead;
+					}
+				} while (b1->nr == 0);
+				i1 = 0;
+			}
+		} else {
+			BEEN_THERE('K');
+			// Element from b2 is smaller
+			buffer[nbuf++] = d2;
+			if (++i2 >= b2->nr) {
+				BEEN_THERE('M');
+				// Ok, we finished with b2.  Pull it out
+				// and plug it in before b1.
+				struct ptr_list *l = b2;
+
+				b2 = b2->next;
+				b2->prev = l->prev;
+				b2->prev->next = b2;
+				l->next = b1;
+				l->prev = b1->prev;
+				l->next->prev = l;
+				l->prev->next = l;
+
+				if (b1 == newhead) {
+					BEEN_THERE('N');
+					newhead = l;
+				}
+
+				FLUSH_TO(l);
+				b2 = b2->prev;
+				do {
+					b2 = b2->next;
+					if (--m == 0) {
+						BEEN_THERE('Q');
+						assert (nbuf == i1);
+						DUMP_TO(b1);
+						return newhead;
+					}
+				} while (b2->nr == 0);
+				i2 = 0;
+			}
+		}
+	}
 }
 
-void sort_list(struct ptr_list **list, int (*cmp)(const void *, const void *))
+
+void sort_list(struct ptr_list **plist, int (*cmp)(const void *, const void *))
 {
-	struct ptr_list *head = *list;
+	struct ptr_list *head = *plist;
+	int blocks = 1;
 
-	if (head) {
-		int repeat;
+	if (!head)
+		return;
 
-		/* Sort all the sub-lists */
-		struct ptr_list *list = head, *next;
-		do {
-			array_sort(list->list, list->nr, cmp);
-			list = list->next;
-		} while (list != head);
+	// Sort all the sub-lists
+	struct ptr_list *list = head;
+	do {
+		array_sort(list->list, list->nr, cmp);
+#ifdef PARANOIA
+		verify_seq_sorted (list, 1, cmp);
+#endif
+		list = list->next;
+	} while (list != head);
+
+	// Merge the damn things together
+	while (1) {
+		struct ptr_list *block1 = head;
 
-		/* Merge the damn things together .. */
 		do {
-			repeat = 0;
+			struct ptr_list *block2 = block1;
+			struct ptr_list *next, *newhead;
+			int i;
+
+			for (i = 0; i < blocks; i++) {
+				block2 = block2->next;
+				if (block2 == head) {
+					if (block1 == head) {
+						BEEN_THERE('A');
+						*plist = head;
+						return;
+					}
+					BEEN_THERE('B');
+					goto next_pass;
+				}						
+			}
 
-			list = head;
-			next = list->next;
-			while (next != head) {
-				repeat |= merge_array(list->list, list->nr, next->list, next->nr, cmp);
-				list = next;
+			next = block2;
+			for (i = 0; i < blocks; ) {
 				next = next->next;
+				i++;
+				if (next == head) {
+					BEEN_THERE('C');
+					break;
+				}
+				BEEN_THERE('D');
+			}
+
+			newhead = merge_block_seqs (block1, blocks,
+						    block2, i,
+						    cmp);
+#ifdef PARANOIA
+			verify_seq_sorted (newhead, blocks + i, cmp);
+#endif
+			if (block1 == head) {
+				BEEN_THERE('E');
+				head = newhead;
 			}
-		} while (repeat);
+			block1 = next;
+		} while (block1 != head);
+	next_pass:
+		blocks <<= 1;
 	}
 }
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-09-26 14:15:08 -04:00
+++ b/lib.h	2004-09-26 14:15:08 -04:00
@@ -1,5 +1,8 @@
 #ifndef LIB_H
 #define LIB_H
+
+#include <stdlib.h>
+
 /*
  * Basic helper routine descriptions for 'sparse'.
  *
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] __FUNCTION__ and __PRETTY_FUNCTION__ ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] __FUNCTION__ and __PRETTY_FUNCTION__
Date: Wed, 06 Oct 2004 14:45:59 +0000
Message-ID: <20041006144559.7C9331422D56 () darter ! rentec ! com>
--------------------

This patch adds (re-adds?) defines for __FUNCTION__ and
__PRETTY_FUNCTION__.  Old code uses them and parsing fails
spectacularly without producing tons of error messages.

Morten


Speaking of error messages...  Here's a pretty good one.  Taking
its advice might take a while, :-)

------------------------- Remote trigger message --------------------------
NOTICE: You are currently using an old version of BitKeeper (bk-3.2.3)
        Please update to the current release (3.2.3) to avoid this
        message.
---------------------------------------------------------------------------




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 lib.c   |    7 ++++++-
 parse.c |    2 +-
 2 files changed, 7 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/06 1.842)
   Add __FUNCTION__ and __PRETTY_FUNCTION__ defines.

<welinder@troll.com> (04/10/06 1.841)
   Handle asm __volatile variant too.
   Will someone please dispatch a firing squad to gcc HQ?

diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-10-06 10:39:20 -04:00
+++ b/lib.c	2004-10-06 10:39:20 -04:00
@@ -775,5 +775,10 @@
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
-	add_pre_buffer("#define __builtin_va_end(arg)\n");	
+	add_pre_buffer("#define __builtin_va_end(arg)\n");
+	// These live somewhere between parse-land (they need to know the
+	// function name) and pre-processor-land (they concatenate with
+	// strings).  Punt.
+	add_pre_buffer("#define __FUNCTION__ \"function\"\n");
+	add_pre_buffer("#define __PRETTY_FUNCTION__ \"function\"\n");
 }
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-10-06 10:39:21 -04:00
+++ b/parse.c	2004-10-06 10:39:21 -04:00
@@ -968,7 +968,7 @@
 	struct expression *expr;
 
 	stmt->type = STMT_ASM;
-	if (match_idents(token, &__volatile___ident, &volatile_ident, NULL)) {
+	if (match_idents(token, &__volatile___ident, &__volatile_ident, &volatile_ident, NULL)) {
 		token = token->next;
 	}
 	token = expect(token, '(', "after asm");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] __FUNCTION__ and __PRETTY_FUNCTION__
Date: Fri, 08 Oct 2004 15:48:33 +0000
Message-ID: <Pine.LNX.4.58.0410080843090.6454 () ppc970 ! osdl ! org>
--------------------


On Wed, 6 Oct 2004, Morten Welinder wrote:
> 
> This patch adds (re-adds?) defines for __FUNCTION__ and
> __PRETTY_FUNCTION__.  Old code uses them and parsing fails
> spectacularly without producing tons of error messages.

This broke the kernel compile, since the kernel does

	#define __FUNCTION__ (__func__)

to make sure that nobody depends on the historical use of __FUNCTION__. 
Your patch made sparse complain about redefininf the symbol.

So I made __func__/__FUNCTION__/__PRETTY_FUNCTION__ all work the same way: 
they are a special case at parse time, and get automagically converted to 
a constant string. This means that string concatenation etc should all 
work, the way __FUNCTION__ always did (and the way __func__ is _not_ 
supposed to, but hey, whatever).

Pls kick the tires on this thing, I've only tested it on the kernel (which 
doesn't care for the concatenation semantics).

Btw, the way I've done it, you can always override the thing, so sparse
will allow you to use a variable called __FUNCTION__ or whatever, exactly
because it's not actually a preprocessor symbol at all. It's very much a
special case that only takes effect for a otherwise undefined magic
special symbol. Silly, I know, but it's the most permissive thing I could 
come up with.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] __FUNCTION__ and __PRETTY_FUNCTION__
Date: Fri, 08 Oct 2004 15:53:59 +0000
Message-ID: <Pine.LNX.4.58.0410080849220.6454 () ppc970 ! osdl ! org>
--------------------


On Fri, 8 Oct 2004, Linus Torvalds wrote:
> 
> Pls kick the tires on this thing, I've only tested it on the kernel (which 
> doesn't care for the concatenation semantics).

Ok, I tested it a bit more:

	char *tmp = __FUNCTION__;
	char * hello_goodbye(void)
	{
		char *fn;
		fn = __FUNCTION__ "()";
		return fn;
	}

	int __FUNCTION__ = 1;

this shows the funny sparse behaviour:

 - the first __FUNCTION__ isn't touched at all, since it's not inside a 
   function. So sparse says

	"test.c:1:13: warning: undefined identifier '__FUNCTION__'

 - the second one concatenates the strings, and sparse will say

	movi.32         v2,&"hello_goodbye()"

 - the third one ends up as a normal integer:

	.align 4
	int [addressable] [toplevel] __FUNCTION__ = 
	        movi.32         v9,$1

   and anybody using that name (while it is in scope) will get the integer 
   instead.

But I _suspect_ that I should change the first case to "<toplevel>" or
something, instead of leaving it untouched. Somebody might want to use a
debugging macro in various contexts. What do real compilers do for the
non-fn case? gcc seems to give an empty string, which is kind of 
pointless.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [BK PATCH] __FUNCTION__ and __PRETTY_FUNCTION__
Date: Fri, 08 Oct 2004 16:40:14 +0000
Message-ID: <20041008164014.B0A071422D56 () darter ! rentec ! com>
--------------------

Since __FUNCTION__ is a gcc-only thing to begin with, I suggest
doing what gcc does, i.e., use an empty string.

If gcc had been smart enough to contant-fold (__FUNCTION__[0]==0)
it might actually be useful.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] asm __volatile ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] asm __volatile
Date: Wed, 06 Oct 2004 13:27:12 +0000
Message-ID: <20041006132712.C9C5C1422D56 () darter ! rentec ! com>
--------------------

Make "asm __volatile" work.  Why we need three variants is beyond me.

M.



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 parse.c |    2 +-
 1 files changed, 1 insertion(+), 1 deletion(-)

through these ChangeSets:

<welinder@troll.com> (04/10/06 1.841)
   Handle asm __volatile variant too.
   Will someone please dispatch a firing squad to gcc HQ?

diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-10-06 09:25:46 -04:00
+++ b/parse.c	2004-10-06 09:25:46 -04:00
@@ -968,7 +968,7 @@
 	struct expression *expr;
 
 	stmt->type = STMT_ASM;
-	if (match_idents(token, &__volatile___ident, &volatile_ident, NULL)) {
+	if (match_idents(token, &__volatile___ident, &__volatile_ident, &volatile_ident, NULL)) {
 		token = token->next;
 	}
 	token = expect(token, '(', "after asm");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] cgcc ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] cgcc
Date: Tue, 05 Oct 2004 15:48:46 +0000
Message-ID: <20041005154846.A1A701422D5B () darter ! rentec ! com>
--------------------

Ok, so you want it there...  Fine.

cgcc can create quite an impressive command line by now:

/scratch/welinder/cgcc/check /home/welinder/foo.c -D__CHAR_BIT__=8 -D__SCHAR_MAX__=127 -D__SHRT_MAX__=32767 -D__INT_MAX__=2147483647 -D__LONG_MAX__=2147483647L -D__LONG_LONG_MAX__=9223372036854775807LL -D__FLT_RADIX__=2 -D__FINITE_MATH_ONLY__=0 -D__DECIMAL_DIG__=33 -D__FLT_MANT_DIG__=24 -D__FLT_DIG__=6 -D__FLT_MIN_EXP__='(-125)' -D__FLT_MAX_EXP__=128 -D__FLT_MIN_10_EXP__='(-37)' -D__FLT_MAX_10_EXP__=38 -D__FLT_HAS_INFINITY__=1 -D__FLT_HAS_QUIET_NAN__=1 -D__FLT_DENORM_MIN__=1.40129846e-45F -D__FLT_EPSILON__=1.19209290e-7F -D__FLT_MAX__=3.40282347e+38F -D__FLT_MIN__=1.17549435e-38F -D__DBL_MANT_DIG__=53 -D__DBL_DIG__=15 -D__DBL_MIN_EXP__='(-1021)' -D__DBL_MAX_EXP__=1024 -D__DBL_MIN_10_EXP__='(-307)' -D__DBL_MAX_10_EXP__=308 -D__DBL_HAS_INFINITY__=1 -D__DBL_HAS_QUIET_NAN__=1 -D__DBL_DENORM_MIN__=4.9406564584124654e-324 -D__DBL_EPSILON__=2.2204460492503131e-16 -D__DBL_MAX__=1.7976931348623157e+308 -D__DBL_MIN__=2.2250738585072014e-308 -D__LDBL_MANT_DIG__=113 -D__LDBL_DIG__=33 -D_
 _LDBL_MIN_EXP__='(-16381)' -D__LDBL_MAX_EXP__=16384 -D__LDBL_MIN_10_EXP__='(-4931)' -D__LDBL_MAX_10_EXP__=4932 -D__LDBL_HAS_INFINITY__=1 -D__LDBL_HAS_QUIET_NAN__=1 -D__LDBL_DENORM_MIN__=6.47517511943802511092443895822764655e-4966L -D__LDBL_EPSILON__=1.92592994438723585305597794258492732e-34L -D__LDBL_MAX__=1.18973149535723176508575932662800702e+4932L -D__LDBL_MIN__=3.36210314311209350626267781732175260e-4932L -Dunix=1 -D__unix=1 -D__unix__=1 -Dsparc=1 -D__sparc=1 -D__sparc__=1 -D__sun__=1 -D__sun=1 -Dsun=1 -D__svr4__=1 -DSVR4=1 -D__STDC__=0 -D_REENTRANT -D_SOLARIS_THREADS -DNULL="((void *)0)"

Got that?  There will be a test after the break...

Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/cgcc

This will update the following files:

 cgcc  |  147 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 lib.c |    6 --
 2 files changed, 146 insertions(+), 7 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/05 1.839)
   Handle predefines for integer types, floating point types,
   and system in cgcc.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-10-05 11:44:39 -04:00
+++ b/cgcc	2004-10-05 11:44:39 -04:00
@@ -4,18 +4,44 @@
 my $cc = $ENV{'REAL_CC'} || 'cc';
 my $check = $ENV{'CHECK'} || 'check';
 
+my $m64 = 0;
 my $seen_a_c_file = 0;
+my $has_specs = 0;
 foreach (@ARGV) {
     # Look for a .c file.  We don't want to run the checker on .o or .so files
     # in the link run.  (This simplistic check knows nothing about options
     # with arguments, but it seems to do the job.)
-    $seen_a_c_file = 1 if /^[^-].*\.c/;
+    $seen_a_c_file = 1 if /^[^-].*\.c$/;
+    $m64 = 1 if /^-m64$/;
+    if (/^-specs=(.*)$/) {
+	$check .= &add_specs ($1);
+	$has_specs = 1;
+    }
 
     my $this_arg = ' ' . &quote_arg ($_);
     $cc .= $this_arg unless &check_only_option ($_);
     $check .= $this_arg;
 }
 
+my $arch = `uname -m`;
+chomp $arch;
+if ($arch =~ /^(i.?86|athlon)$/) {
+    $check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
+    $check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
+} elsif ($arch =~ /^(sun4u)$/) {
+    $check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
+    $check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
+}
+
+if (!$has_specs) {
+    my $os = `uname -s`;
+    chomp $os;
+    $check .= &add_specs (lc $os);
+}
+
+# print "$check\n";
+# exit 1;
+
 system ($check) if $seen_a_c_file;
 exec ($cc);
 
@@ -25,6 +51,7 @@
 sub check_only_option {
     my ($arg) = @_;
     return 1 if $arg =~ /^-W(no-?)?(default-bitfield-sig|bitwise|typesign)$/;
+    return 1 if $arg =~ /^-specs=/;
     return 0;
 }
 
@@ -38,6 +65,124 @@
 		 map {
 		     m|^[-a-zA-Z0-9._/,=]+$| ? $_ : "\\" . $_;
 		 } (split (//, $arg)));
+}
+
+# -----------------------------------------------------------------------------
+
+sub integer_types {
+    my ($char,@dummy) = @_;
+
+    my %pow2m1 =
+	(8 => '127',
+	 16 => '32767',
+	 32 => '2147483647',
+	 64 => '9223372036854775807',
+	 );
+    my @types = (['SCHAR',''], ['SHRT',''], ['INT',''], ['LONG','L'], ['LONG_LONG','LL']);
+
+    my $result = " -D__CHAR_BIT__=$char";
+    while (@types) {
+	my $bits = shift @_;
+	my ($name,$suffix) = @{ shift @types };
+	die "$0: wierd number of bits." unless exists $pow2m1{$bits};
+	$result .= " -D__${name}_MAX__=" . $pow2m1{$bits} . $suffix;
+    }
+    return $result;
+}
+
+# -----------------------------------------------------------------------------
+
+sub float_types {
+    my ($has_inf,$has_qnan,$dec_dig,@bitsizes) = @_;
+    my $result = " -D__FLT_RADIX__=2";
+    $result .= " -D__FINITE_MATH_ONLY__=" . ($has_inf || $has_qnan ? '0' : '1');
+    $result .= " -D__DECIMAL_DIG__=$dec_dig";
+
+    my %constants =
+	(24 =>
+	 {
+	     'MIN' => '1.17549435e-38',
+	     'MAX' => '3.40282347e+38',
+	     'EPSILON' => '1.19209290e-7',
+	     'DENORM_MIN' => '1.40129846e-45',
+	 },
+	 53 =>
+	 {
+	     'MIN' => '2.2250738585072014e-308',
+	     'MAX' => '1.7976931348623157e+308',
+	     'EPSILON' => '2.2204460492503131e-16',
+	     'DENORM_MIN' => '4.9406564584124654e-324',
+	 },
+	 64 =>
+	 {
+	     'MIN' => '3.36210314311209350626e-4932',
+	     'MAX' => '1.18973149535723176502e+4932',
+	     'EPSILON' => '1.08420217248550443401e-19',
+	     'DENORM_MIN' => '3.64519953188247460253e-4951',
+	 },
+	 113 =>
+	 {
+	     'MIN' => '3.36210314311209350626267781732175260e-4932',
+	     'MAX' => '1.18973149535723176508575932662800702e+4932',
+	     'EPSILON' => '1.92592994438723585305597794258492732e-34',
+	     'DENORM_MIN' => '6.47517511943802511092443895822764655e-4966',
+	 },
+	 );	     
+
+    my @types = (['FLT','F'], ['DBL',''], ['LDBL','L']);
+    while (@types) {
+	my ($mant_bits,$exp_bits) = @{ shift @bitsizes };
+	my ($name,$suffix) = @{ shift @types };
+
+	my $h = $constants{$mant_bits};
+	die "$0: wierd number of mantissa bits." unless $h;
+
+	my $mant_dig = int (($mant_bits - 1) * log (2) / log (10));
+	my $max_exp = 1 << ($exp_bits - 1);
+	my $min_exp = 3 - $max_exp;
+	my $max_10_exp = int ($max_exp * log (2) / log (10));
+	my $min_10_exp = -int (-$min_exp * log (2) / log (10));
+
+	$result .= " -D__${name}_MANT_DIG__=$mant_bits";
+	$result .= " -D__${name}_DIG__=$mant_dig";
+	$result .= " -D__${name}_MIN_EXP__='($min_exp)'";
+	$result .= " -D__${name}_MAX_EXP__=$max_exp";
+	$result .= " -D__${name}_MIN_10_EXP__='($min_10_exp)'";
+	$result .= " -D__${name}_MAX_10_EXP__=$max_10_exp";
+	$result .= " -D__${name}_HAS_INFINITY__=" . ($has_inf ? '1' : '0');
+	$result .= " -D__${name}_HAS_QUIET_NAN__=" . ($has_qnan ? '1' : '0');;
+
+	foreach my $inf (sort keys %$h) {
+	    $result .= " -D__${name}_${inf}__=" . $h->{$inf} . $suffix;
+	}
+    }
+    return $result;
+}
+
+# -----------------------------------------------------------------------------
+
+sub add_specs {
+    my ($spec) = @_;
+    if ($spec eq 'sunos') {
+	return &add_specs ('unix') .
+	    &add_specs ('sparc') .
+	    ' -D__sun__=1 -D__sun=1 -Dsun=1' .
+	    ' -D__svr4__=1 -DSVR4=1' .
+	    ' -D__STDC__=0' .
+	    ' -D_REENTRANT' .
+	    ' -D_SOLARIS_THREADS' .
+	    ' -DNULL="((void *)0)"';
+    } elsif ($spec eq 'linux') {
+	return &add_specs ('unix') .
+	    ' -D__linux__=1 -Dlinux=linux' .
+	    ' -D__STDC__=1';
+    } elsif ($spec eq 'unix') {
+	return ' -Dunix=1 -D__unix=1 -D__unix__=1';
+    } elsif ($spec eq 'sparc') {
+	return ' -Dsparc=1 -D__sparc=1 -D__sparc__=1';
+    } else {
+	die "$0: invalid specs: $spec\n";
+    }
 }
 
 # -----------------------------------------------------------------------------
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-10-05 11:44:39 -04:00
+++ b/lib.c	2004-10-05 11:44:39 -04:00
@@ -763,12 +763,6 @@
 
 void create_builtin_stream(void)
 {
-	add_pre_buffer("#define __linux__ 1\n");
-	add_pre_buffer("#define linux linux\n");
-	add_pre_buffer("#define unix 1\n");
-	add_pre_buffer("#define __unix 1\n");
-	add_pre_buffer("#define __unix__ 1\n");
-	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __extension__\n");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] cgcc
Date: Tue, 05 Oct 2004 16:49:37 +0000
Message-ID: <Pine.LNX.4.58.0410050944220.8290 () ppc970 ! osdl ! org>
--------------------


On Tue, 5 Oct 2004, Morten Welinder wrote:
> 
> Ok, so you want it there...  Fine.

Applied. One more request (which you may already have, for all I know) - 
si there some way to not run the compiler from cgcc? I'm not a perl 
person, so it all looks like line noise to me...

Yeah, I can do "export REAL_CC=echo" (even line noise has _some_ 
information in it), and that effectively disables it, but I was thinking 
something easier-to-use..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [BK PATCH] cgcc
Date: Wed, 06 Oct 2004 13:14:59 +0000
Message-ID: <20041006131459.AEB491422D56 () darter ! rentec ! com>
--------------------

This adds "-no-compile" for people who don't want to say REAL_CC=true


Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/cgcc

This will update the following files:

 cgcc |   53 +++++++++++++++++++++++++++++++++--------------------
 1 files changed, 33 insertions(+), 20 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/06 1.841)
   Add -no-compile

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-10-06 09:12:09 -04:00
+++ b/cgcc	2004-10-06 09:12:09 -04:00
@@ -5,17 +5,27 @@
 my $check = $ENV{'CHECK'} || 'check';
 
 my $m64 = 0;
-my $seen_a_c_file = 0;
 my $has_specs = 0;
+my $do_check = 0;
+my $do_compile = 1;
+
 foreach (@ARGV) {
     # Look for a .c file.  We don't want to run the checker on .o or .so files
     # in the link run.  (This simplistic check knows nothing about options
     # with arguments, but it seems to do the job.)
-    $seen_a_c_file = 1 if /^[^-].*\.c$/;
+    $do_check = 1 if /^[^-].*\.c$/;
+
     $m64 = 1 if /^-m64$/;
+
     if (/^-specs=(.*)$/) {
 	$check .= &add_specs ($1);
 	$has_specs = 1;
+	next;
+    }
+
+    if (/^-no-compile$/) {
+	$do_compile = 0;
+	next;
     }
 
     my $this_arg = ' ' . &quote_arg ($_);
@@ -23,27 +33,31 @@
     $check .= $this_arg;
 }
 
-my $arch = `uname -m`;
-chomp $arch;
-if ($arch =~ /^(i.?86|athlon)$/) {
-    $check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-    $check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
-} elsif ($arch =~ /^(sun4u)$/) {
-    $check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-    $check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
-}
+if ($do_check) {
+    my $arch = `uname -m`;
+    chomp $arch;
+    if ($arch =~ /^(i.?86|athlon)$/) {
+	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
+	$check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
+    } elsif ($arch =~ /^(sun4u)$/) {
+	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
+	$check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
+    }
+
+    if (!$has_specs) {
+	my $os = `uname -s`;
+	chomp $os;
+	$check .= &add_specs (lc $os);
+    }
 
-if (!$has_specs) {
-    my $os = `uname -s`;
-    chomp $os;
-    $check .= &add_specs (lc $os);
+#    print "$check\n";
+#    exit 1;
 }
 
-# print "$check\n";
-# exit 1;
 
-system ($check) if $seen_a_c_file;
-exec ($cc);
+system ($check) if $do_check;
+exec ($cc) if $do_compile;
+exit 0;
 
 # -----------------------------------------------------------------------------
 # Check if an option is for "check" only.
@@ -51,7 +65,6 @@
 sub check_only_option {
     my ($arg) = @_;
     return 1 if $arg =~ /^-W(no-?)?(default-bitfield-sig|bitwise|typesign)$/;
-    return 1 if $arg =~ /^-specs=/;
     return 0;
 }
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] cgcc
Date: Fri, 05 Nov 2004 20:21:25 +0000
Message-ID: <20041105202125.576291422D4F () darter ! rentec ! com>
--------------------

This old patch of mine seems to have fallen between the cracks.
Basically, this mostly allows for cross-compiling.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/cgcc

This will update the following files:

 cgcc |   48 +++++++++++++++++++++++++-----------------------
 1 files changed, 25 insertions(+), 23 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/08 1.849)
   Reorganize integer and floating point defines into specs.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-11-05 15:19:09 -05:00
+++ b/cgcc	2004-11-05 15:19:09 -05:00
@@ -40,27 +40,10 @@
 }
 
 if ($do_check) {
-    my $arch = `uname -m`;
-    chomp $arch;
-    if ($arch =~ /^(i.?86|athlon)$/) {
-	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-	$check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
-	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
-    } elsif ($arch =~ /^(sun4u)$/) {
-	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-	$check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
-	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
-    }
-
     if (!$has_specs) {
-	my $os = `uname -s`;
-	chomp $os;
-	$check .= &add_specs (lc $os);
+	$check .= &add_specs ('host_arch_specs');
+	$check .= &add_specs ('host_os_specs');
     }
-}
-
-
-if ($do_check) {
     print "$check\n" if $verbose;
 #    exit 1;
     system ($check);
@@ -190,7 +173,7 @@
 
 sub define_size_t {
     my ($text) = @_;
-    # We have to undef in order to override checks internal definition.
+    # We have to undef in order to override check's internal definition.
     return ' -U__SIZE_TYPE__ ' . &quote_arg ("-D__SIZE_TYPE__=$text");
 }
 
@@ -200,7 +183,6 @@
     my ($spec) = @_;
     if ($spec eq 'sunos') {
 	return &add_specs ('unix') .
-	    &add_specs ('sparc') .
 	    ' -D__sun__=1 -D__sun=1 -Dsun=1' .
 	    ' -D__svr4__=1 -DSVR4=1' .
 	    ' -D__STDC__=0' .
@@ -209,12 +191,32 @@
 	    ' -DNULL="((void *)0)"';
     } elsif ($spec eq 'linux') {
 	return &add_specs ('unix') .
-	    ' -D__linux__=1 -Dlinux=linux' .
+	    ' -D__linux__=1 -D__linux=1 -Dlinux=linux' .
 	    ' -D__STDC__=1';
     } elsif ($spec eq 'unix') {
 	return ' -Dunix=1 -D__unix=1 -D__unix__=1';
+    } elsif ($spec eq 'i86') {
+	return (' -Di386=1 -D__i386=1 -D__i386__=1' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 21, [24,8], [53,11], [64,15]) .
+		&define_size_t ($m64 ? "long unsigned int" : "unsigned int"));
     } elsif ($spec eq 'sparc') {
-	return ' -Dsparc=1 -D__sparc=1 -D__sparc__=1';
+	return (' -Dsparc=1 -D__sparc=1 -D__sparc__=1' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
+		&define_size_t ($m64 ? "long unsigned int" : "unsigned int"));
+    } elsif ($spec eq 'host_os_specs') {
+	my $os = `uname -s`;
+	chomp $os;
+	return &add_specs (lc $os);
+    } elsif ($spec eq 'host_arch_specs') {
+	my $arch = `uname -m`;
+	chomp $arch;
+	if ($arch =~ /^(i.?86|athlon)$/i) {
+	    return &add_specs ('i86');
+	} elsif ($arch =~ /^(sun4u)$/i) {
+	    return &add_specs ('sparc');
+	}
     } else {
 	die "$0: invalid specs: $spec\n";
     }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] cgcc
Date: Fri, 05 Nov 2004 20:21:25 +0000
Message-ID: <20041105202125.576291422D4F () darter ! rentec ! com>
--------------------

This old patch of mine seems to have fallen between the cracks.
Basically, this mostly allows for cross-compiling.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/cgcc

This will update the following files:

 cgcc |   48 +++++++++++++++++++++++++-----------------------
 1 files changed, 25 insertions(+), 23 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/08 1.849)
   Reorganize integer and floating point defines into specs.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-11-05 15:19:09 -05:00
+++ b/cgcc	2004-11-05 15:19:09 -05:00
@@ -40,27 +40,10 @@
 }
 
 if ($do_check) {
-    my $arch = `uname -m`;
-    chomp $arch;
-    if ($arch =~ /^(i.?86|athlon)$/) {
-	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-	$check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
-	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
-    } elsif ($arch =~ /^(sun4u)$/) {
-	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-	$check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
-	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
-    }
-
     if (!$has_specs) {
-	my $os = `uname -s`;
-	chomp $os;
-	$check .= &add_specs (lc $os);
+	$check .= &add_specs ('host_arch_specs');
+	$check .= &add_specs ('host_os_specs');
     }
-}
-
-
-if ($do_check) {
     print "$check\n" if $verbose;
 #    exit 1;
     system ($check);
@@ -190,7 +173,7 @@
 
 sub define_size_t {
     my ($text) = @_;
-    # We have to undef in order to override checks internal definition.
+    # We have to undef in order to override check's internal definition.
     return ' -U__SIZE_TYPE__ ' . &quote_arg ("-D__SIZE_TYPE__=$text");
 }
 
@@ -200,7 +183,6 @@
     my ($spec) = @_;
     if ($spec eq 'sunos') {
 	return &add_specs ('unix') .
-	    &add_specs ('sparc') .
 	    ' -D__sun__=1 -D__sun=1 -Dsun=1' .
 	    ' -D__svr4__=1 -DSVR4=1' .
 	    ' -D__STDC__=0' .
@@ -209,12 +191,32 @@
 	    ' -DNULL="((void *)0)"';
     } elsif ($spec eq 'linux') {
 	return &add_specs ('unix') .
-	    ' -D__linux__=1 -Dlinux=linux' .
+	    ' -D__linux__=1 -D__linux=1 -Dlinux=linux' .
 	    ' -D__STDC__=1';
     } elsif ($spec eq 'unix') {
 	return ' -Dunix=1 -D__unix=1 -D__unix__=1';
+    } elsif ($spec eq 'i86') {
+	return (' -Di386=1 -D__i386=1 -D__i386__=1' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 21, [24,8], [53,11], [64,15]) .
+		&define_size_t ($m64 ? "long unsigned int" : "unsigned int"));
     } elsif ($spec eq 'sparc') {
-	return ' -Dsparc=1 -D__sparc=1 -D__sparc__=1';
+	return (' -Dsparc=1 -D__sparc=1 -D__sparc__=1' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
+		&define_size_t ($m64 ? "long unsigned int" : "unsigned int"));
+    } elsif ($spec eq 'host_os_specs') {
+	my $os = `uname -s`;
+	chomp $os;
+	return &add_specs (lc $os);
+    } elsif ($spec eq 'host_arch_specs') {
+	my $arch = `uname -m`;
+	chomp $arch;
+	if ($arch =~ /^(i.?86|athlon)$/i) {
+	    return &add_specs ('i86');
+	} elsif ($arch =~ /^(sun4u)$/i) {
+	    return &add_specs ('sparc');
+	}
     } else {
 	die "$0: invalid specs: $spec\n";
     }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] cgcc: Reorganize integer and floating point defines into specs. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] cgcc: Reorganize integer and floating point defines into specs.
Date: Fri, 08 Oct 2004 17:13:48 +0000
Message-ID: <20041008171348.BFB091422D56 () darter ! rentec ! com>
--------------------

With this patch, one can really start doing cross-platform checks.
Running cgcc with no specs arguments is now equivalent to

    cgcc -specs=host_arch_specs -specs=host_os_specs

and if you wanted to simulate Solaris on Sparc you would do...

    cgcc -specs=sparc -specs=sunos

Cute, eh?  It almost works, even.

No amount of -Dfoo is going to change the fact that we use the host's
"long double" to manipulate floating point values.  And i86's long
double is much, much smaller than sparc's.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/cgcc

This will update the following files:

 cgcc |   48 +++++++++++++++++++++++++-----------------------
 1 files changed, 25 insertions(+), 23 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/10/08 1.849)
   Reorganize integer and floating point defines into specs.

diff -Nru a/cgcc b/cgcc
--- a/cgcc	2004-10-08 13:06:49 -04:00
+++ b/cgcc	2004-10-08 13:06:49 -04:00
@@ -40,27 +40,10 @@
 }
 
 if ($do_check) {
-    my $arch = `uname -m`;
-    chomp $arch;
-    if ($arch =~ /^(i.?86|athlon)$/) {
-	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-	$check .= &float_types (1, 1, 21, [24,8], [53,11], [64,15]);
-	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
-    } elsif ($arch =~ /^(sun4u)$/) {
-	$check .= &integer_types (8, 16, 32, $m64 ? 64 : 32, 64);
-	$check .= &float_types (1, 1, 33, [24,8], [53,11], [113,15]);
-	$check .= &define_size_t ($m64 ? "long unsigned int" : "unsigned int");
-    }
-
     if (!$has_specs) {
-	my $os = `uname -s`;
-	chomp $os;
-	$check .= &add_specs (lc $os);
+	$check .= &add_specs ('host_arch_specs');
+	$check .= &add_specs ('host_os_specs');
     }
-}
-
-
-if ($do_check) {
     print "$check\n" if $verbose;
 #    exit 1;
     system ($check);
@@ -190,7 +173,7 @@
 
 sub define_size_t {
     my ($text) = @_;
-    # We have to undef in order to override checks internal definition.
+    # We have to undef in order to override check's internal definition.
     return ' -U__SIZE_TYPE__ ' . &quote_arg ("-D__SIZE_TYPE__=$text");
 }
 
@@ -200,7 +183,6 @@
     my ($spec) = @_;
     if ($spec eq 'sunos') {
 	return &add_specs ('unix') .
-	    &add_specs ('sparc') .
 	    ' -D__sun__=1 -D__sun=1 -Dsun=1' .
 	    ' -D__svr4__=1 -DSVR4=1' .
 	    ' -D__STDC__=0' .
@@ -209,12 +191,32 @@
 	    ' -DNULL="((void *)0)"';
     } elsif ($spec eq 'linux') {
 	return &add_specs ('unix') .
-	    ' -D__linux__=1 -Dlinux=linux' .
+	    ' -D__linux__=1 -D__linux=1 -Dlinux=linux' .
 	    ' -D__STDC__=1';
     } elsif ($spec eq 'unix') {
 	return ' -Dunix=1 -D__unix=1 -D__unix__=1';
+    } elsif ($spec eq 'i86') {
+	return (' -Di386=1 -D__i386=1 -D__i386__=1' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 21, [24,8], [53,11], [64,15]) .
+		&define_size_t ($m64 ? "long unsigned int" : "unsigned int"));
     } elsif ($spec eq 'sparc') {
-	return ' -Dsparc=1 -D__sparc=1 -D__sparc__=1';
+	return (' -Dsparc=1 -D__sparc=1 -D__sparc__=1' .
+		&integer_types (8, 16, 32, $m64 ? 64 : 32, 64) .
+		&float_types (1, 1, 33, [24,8], [53,11], [113,15]) .
+		&define_size_t ($m64 ? "long unsigned int" : "unsigned int"));
+    } elsif ($spec eq 'host_os_specs') {
+	my $os = `uname -s`;
+	chomp $os;
+	return &add_specs (lc $os);
+    } elsif ($spec eq 'host_arch_specs') {
+	my $arch = `uname -m`;
+	chomp $arch;
+	if ($arch =~ /^(i.?86|athlon)$/i) {
+	    return &add_specs ('i86');
+	} elsif ($arch =~ /^(sun4u)$/i) {
+	    return &add_specs ('sparc');
+	}
     } else {
 	die "$0: invalid specs: $spec\n";
     }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] functions with function arguments ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] functions with function arguments
Date: Tue, 14 Sep 2004 18:19:56 +0000
Message-ID: <20040914181956.AA2A31422D53 () darter ! rentec ! com>
--------------------

In addition to the waring->error stuff from yesterday, here's a small
patch that fixes type_difference for functions with function arguments.
A static buffer won't work well there.

[Tree rebuilt to get rid of merges.]

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c    |   76 +++++++++++++++++++++++++++++-----------------------------
 expand.c      |   10 +++----
 parse.c       |   66 +++++++++++++++++++++++++-------------------------
 pre-process.c |    4 +--
 4 files changed, 78 insertions(+), 78 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/14 1.794)
   dynamically allocate (and in some sense leak) the message constructed
   for different function argument types.  Functions with function
   arguments could overwrite the static buffer.

<welinder@troll.com> (04/09/14 1.793)
   Change lots of warning() calls to error() calls.

<welinder@troll.com> (04/09/14 1.792)
   Fix off-by-one allocation and sign confusion in replace_with_integer.

diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-09-14 14:17:13 -04:00
+++ b/evaluate.c	2004-09-14 14:17:13 -04:00
@@ -554,12 +554,12 @@
 			PREPARE_PTR_LIST(source->arguments, arg2);
 			i = 1;
 			for (;;) {
-				const char *diff;
-				diff = type_difference(arg1, arg2, 0, 0);
-				if (diff) {
-					static char argdiff[80];
-					sprintf(argdiff, "incompatible argument %d (%s)", i, diff);
-					return argdiff;
+				const char *argdiff;
+				argdiff = type_difference(arg1, arg2, 0, 0);
+				if (argdiff) {
+					char *diff = __alloc_bytes (40 + strlen (argdiff));
+					sprintf(diff, "incompatible argument %d (%s)", i, argdiff);
+					return diff;
 				}
 				if (!arg1)
 					break;
diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-09-14 14:17:13 -04:00
+++ b/evaluate.c	2004-09-14 14:17:13 -04:00
@@ -40,17 +40,17 @@
 			expr->ctype = &int_ctype;
 			return &int_ctype;
 		}
-		warning(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		error(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
 	examine_symbol_type(sym);
 	if ((sym->ctype.context ^ current_context) & (sym->ctype.contextmask & current_contextmask))
-		warning(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
+		error(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
 
 	base_type = sym->ctype.base_type;
 	if (!base_type) {
-		warning(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		error(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -215,7 +215,7 @@
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warning(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
+	error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -387,7 +387,7 @@
 
 	ctype = degenerate(ptr);
 	if (!ctype->ctype.base_type) {
-		warning(expr->pos, "missing type information");
+		error(expr->pos, "missing type information");
 		return NULL;
 	}
 
@@ -623,7 +623,7 @@
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warning(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			error(expr->pos, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -633,7 +633,7 @@
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warning(expr->pos, "subtraction of functions? Share your drugs");
+		error(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = ctype->ctype.base_type;
@@ -892,7 +892,7 @@
 	ctype = compatible_restricted_binop('?', &expr->left, &expr->right);
 	if (ctype)
 		goto out;
-	warning(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	error(expr->pos, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -963,7 +963,7 @@
 		}
 	}
 
-	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	error(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1069,7 +1069,7 @@
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		warning(expr->pos, "not an lvalue");
+		error(expr->pos, "not an lvalue");
 		return NULL;
 	}
 
@@ -1239,7 +1239,7 @@
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warning(expr->pos, "strange non-value function or array");
+			error(expr->pos, "strange non-value function or array");
 			return NULL;
 		}
 		*expr = *expr->unop;
@@ -1257,7 +1257,7 @@
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warning(expr->pos, "not addressable");
+		error(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1296,7 +1296,7 @@
 
 	switch (ctype->type) {
 	default:
-		warning(expr->pos, "cannot derefence this type");
+		error(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		merge_type(node, ctype);
@@ -1318,7 +1318,7 @@
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warning(op->pos, "non-lvalue array??");
+			error(op->pos, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1350,11 +1350,11 @@
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		warning(expr->pos, "need lvalue expression for ++/--");
+		error(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warning(expr->pos, "bad operation on restricted");
+		error(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1510,7 +1510,7 @@
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warning(expr->pos, "bad member name");
+		error(expr->pos, "bad member name");
 		return NULL;
 	}
 
@@ -1523,7 +1523,7 @@
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warning(expr->pos, "expected structure or union");
+		error(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1536,8 +1536,8 @@
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warning(expr->pos, "no member '%s' in %s %.*s",
-			show_ident(ident), type, namelen, name);
+		error(expr->pos, "no member '%s' in %s %.*s",
+		      show_ident(ident), type, namelen, name);
 		return NULL;
 	}
 
@@ -1641,7 +1641,7 @@
 				size = bits_in_int;
 		}
 		if (is_bitfield_type(what->ctype))
-			warning(expr->pos, "sizeof applied to bitfield type");
+			error(expr->pos, "sizeof applied to bitfield type");
 	}
 	if (size & 7)
 		warning(expr->pos, "cannot size expression");
@@ -1661,7 +1661,7 @@
 			return NULL;
 	}
 	if (is_bitfield_type(type))
-		warning(expr->pos, "alignof applied to bitfield type");
+		error(expr->pos, "alignof applied to bitfield type");
 	examine_symbol_type(type);
 	expr->type = EXPR_VALUE;
 	expr->value = type->ctype.alignment;
@@ -1693,7 +1693,7 @@
 			return 0;
 
 		if (context_clash(f, ctype))
-			warning(expr->pos, "argument %d used in wrong context", i);
+			error(expr->pos, "argument %d used in wrong context", i);
 
 		ctype = degenerate(expr);
 
@@ -1749,7 +1749,7 @@
 static int evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr, unsigned long offset)
 {
 	if (offset || expression_list_size(expr->expr_list) != 1) {
-		warning(expr->pos, "unexpected compound initializer");
+		error(expr->pos, "unexpected compound initializer");
 		return 0;
 	}
 	return evaluate_array_initializer(ctype, expr, 0);
@@ -1772,7 +1772,7 @@
 			RESET_PTR_LIST(sym);
 			for (;;) {
 				if (!sym) {
-					warning(entry->pos, "unknown named initializer '%s'", show_ident(ident));
+					error(entry->pos, "unknown named initializer '%s'", show_ident(ident));
 					return 0;
 				}
 				if (sym->ident == ident)
@@ -1783,7 +1783,7 @@
 		}
 
 		if (!sym) {
-			warning(expr->pos, "too many initializers for struct/union");
+			error(expr->pos, "too many initializers for struct/union");
 			return 0;
 		}
 
@@ -1957,7 +1957,7 @@
 		warning(expr->pos, "cast to non-scalar");
 
 	if (!target->ctype) {
-		warning(expr->pos, "cast from unknown type");
+		error(expr->pos, "cast from unknown type");
 		goto out;
 	}
 
@@ -2052,7 +2052,7 @@
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warning(expr->pos, "not a function %s", show_ident(sym->ident));
+		error(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
@@ -2079,7 +2079,7 @@
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warning(expr->pos, "value expression without a type");
+		error(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2129,7 +2129,7 @@
 	case EXPR_CALL:
 		return evaluate_call(expr);
 	case EXPR_BITFIELD:
-		warning(expr->pos, "bitfield generated by parser");
+		error(expr->pos, "bitfield generated by parser");
 		return NULL;
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
@@ -2160,10 +2160,10 @@
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warning(expr->pos, "internal front-end error: initializer in expression");
+		error(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
+		error(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-09-14 14:17:13 -04:00
+++ b/expand.c	2004-09-14 14:17:13 -04:00
@@ -739,7 +739,7 @@
 		return expand_call(expr);
 
 	case EXPR_DEREF:
-		warning(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
+		error(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
 		return UNSAFE;
 
 	case EXPR_BITFIELD:
@@ -772,7 +772,7 @@
 
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warning(expr->pos, "internal front-end error: sizeof in expansion?");
+		error(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -783,7 +783,7 @@
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warning(expr->pos, "Expected constant expression in %s", where);
+			error(expr->pos, "Expected constant expression in %s", where);
 	}
 }
 
@@ -919,12 +919,12 @@
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warning(expr->pos, "bad constant expression type");
+		error(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warning(expr->pos, "bad constant expression");
+		error(expr->pos, "bad constant expression");
 		return 0;
 	}
 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-09-14 14:17:13 -04:00
+++ b/parse.c	2004-09-14 14:17:13 -04:00
@@ -134,7 +134,7 @@
 
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected declaration");
+		error(token->pos, "expected declaration");
 		ctype->base_type = &bad_type;
 		return token;
 	}
@@ -193,7 +193,7 @@
 	struct symbol *sym;
 
 	if (!match_op(token, '(')) {
-		warning(token->pos, "expected '(' after typeof");
+		error(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -351,7 +351,7 @@
 	token = expect(token, '(', "after attribute");
 
 	for (;;) {
-		const char *error;
+		const char *err;
 		struct ident *attribute_name;
 		struct expression *attribute_expr;
 
@@ -366,9 +366,9 @@
 		attribute_expr = NULL;
 		if (match_op(token, '('))
 			token = parens_expression(token, &attribute_expr, "in attribute");
-		error = handle_attribute(ctype, attribute_name, attribute_expr);
-		if (error)
-			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
+		err = handle_attribute(ctype, attribute_name, attribute_expr);
+		if (err)
+			error(token->pos, "attribute '%s': %s", show_ident(attribute_name), err);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -440,29 +440,29 @@
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warning(pos, "Just how %sdo you want this type to be?",
-				modifier_string(dup));
+			error(pos, "Just how %sdo you want this type to be?",
+			      modifier_string(dup));
 
 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warning(pos, "You cannot have both long and short modifiers.");
+			error(pos, "You cannot have both long and short modifiers.");
 
 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warning(pos, "You cannot have both signed and unsigned modifiers.");
+			error(pos, "You cannot have both signed and unsigned modifiers.");
 
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warning(pos, "multiple storage classes");
+			error(pos, "multiple storage classes");
 
 		ctype->modifiers = old | mod | extra;
 	}
 
 	/* Context mask and value */
 	if ((ctype->context ^ thistype->context) & (ctype->contextmask & thistype->contextmask)) {
-		warning(pos, "inconsistent attribute types");
+		error(pos, "inconsistent attribute types");
 		thistype->context = 0;
 		thistype->contextmask = 0;
 	}
@@ -471,7 +471,7 @@
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
-		warning(pos, "I don't like non-power-of-2 alignments");
+		error(pos, "I don't like non-power-of-2 alignments");
 		thistype->alignment = 0;
 	}
 	if (thistype->alignment > ctype->alignment)
@@ -506,8 +506,8 @@
 
 	wrong = mod & banned;
 	if (wrong)
-		warning(*pos, "modifier %sis invalid in this context",
-		     modifier_string (wrong));
+		error(*pos, "modifier %sis invalid in this context",
+		      modifier_string (wrong));
 }
 
 
@@ -588,7 +588,7 @@
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warning(token->pos, "invalid modifier");
+			error(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -724,7 +724,7 @@
 	long long width;
 
 	if (!is_int_type(ctype->base_type)) {
-		warning(token->pos, "invalid bitfield specifier for type %s.",
+		error(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -736,10 +736,10 @@
 	bitfield->fieldwidth = width;
 
 	if (width < 0) {
-		warning(token->pos, "invalid negative bitfield width, %lld.", width);
+		error(token->pos, "invalid negative bitfield width, %lld.", width);
 		bitfield->fieldwidth = 8;
 	} else if (decl->ident && width == 0) {
-		warning(token->pos, "invalid named zero-width bitfield `%s'",
+		error(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		bitfield->fieldwidth = 8;
 	} else if (width != bitfield->fieldwidth) {
@@ -787,7 +787,7 @@
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warning(token->pos, "expected ; at end of declaration");
+			error(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1013,7 +1013,7 @@
 	struct symbol *sym;
 
 	if (!target) {
-		warning(stmt->pos, "not in switch scope");
+		error(stmt->pos, "not in switch scope");
 		return;
 	}
 	sym = alloc_symbol(stmt->pos, SYM_NODE);
@@ -1096,7 +1096,7 @@
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warning(token->pos, "expected 'while' after 'do'");
+		error(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");
 
 	stmt->iterator_post_condition = expr;
@@ -1131,7 +1131,7 @@
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warning(stmt->pos, "break/continue not in iterator scope");
+				error(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1175,7 +1175,7 @@
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warning(token->pos, "Expected identifier or goto expression");
+				error(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1233,7 +1233,7 @@
 
 		if (match_op(token, SPECIAL_ELLIPSIS)) {
 			if (!*list)
-				warning(token->pos, "variadic functions must have one named argument");
+				error(token->pos, "variadic functions must have one named argument");
 			fn->variadic = 1;
 			token = token->next;
 			break;
@@ -1245,7 +1245,7 @@
 			/* Special case: (void) */
 			if (!*list && !sym->ident)
 				break;
-			warning(token->pos, "void parameter");
+			error(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
@@ -1284,7 +1284,7 @@
 	if (to) {
 		idx_to = get_expression_value(to);
 		if (idx_to < idx_from || idx_from < 0)
-			warning(from->pos, "nonsense array initializer index range");
+			error(from->pos, "nonsense array initializer index range");
 	}
 	expr->idx_from = idx_from;
 	expr->idx_to = idx_to;
@@ -1339,7 +1339,7 @@
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warning(sym->pos, "no identifier for function argument");
+		error(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1417,7 +1417,7 @@
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warning(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
+		error(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1429,7 +1429,7 @@
 
 	FOR_EACH_PTR(argtypes, arg) {
 		if (!arg->used)
-			warning(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
+			error(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
 	} END_FOR_EACH_PTR(arg);
 
 }
@@ -1447,7 +1447,7 @@
 	apply_k_r_types(args, decl);
 
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected function body");
+		error(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1513,7 +1513,7 @@
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (!is_typedef && base_type == &void_ctype && !(decl->ctype.modifiers & MOD_EXTERN)) {
-		warning(token->pos, "void declaration");
+		error(token->pos, "void declaration");
 	}
 
 	for (;;) {
@@ -1552,7 +1552,7 @@
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, &decl, &ident);
 		if (!ident) {
-			warning(token->pos, "expected identifier name in type definition");
+			error(token->pos, "expected identifier name in type definition");
 			return token;
 		}
 
diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-14 14:17:14 -04:00
+++ b/pre-process.c	2004-09-14 14:17:14 -04:00
@@ -87,8 +87,8 @@
 
 static void replace_with_integer(struct token *token, unsigned int val)
 {
-	char *buf = __alloc_bytes(10);
-	sprintf(buf, "%d", val);
+	char *buf = __alloc_bytes(11);
+	sprintf(buf, "%u", val);
 	token_type(token) = TOKEN_NUMBER;
 	token->number = buf;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] replace_with_integer ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] replace_with_integer
Date: Mon, 13 Sep 2004 19:55:52 +0000
Message-ID: <20040913195552.4F45C1422D5E () darter ! rentec ! com>
--------------------

Today's next trivial patch fixes replace_with_integer to avoid a buffer
run.  Now, mind you, replace_with_integer in only used for __LINE__
currently so you would need a billion-line file to get hit.  If you have
those, it might be time to split it into smaller unit.  IMHO.

Also, the code is arguing with itself over signed vs unsigned.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 pre-process.c |    3 ++-
 1 files changed, 2 insertions(+), 1 deletion(-)

through these ChangeSets:

<welinder@troll.com> (04/09/13 1.790)
   Allocate enough for a 32-bit integer.

diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-13 15:52:28 -04:00
+++ b/pre-process.c	2004-09-13 15:52:28 -04:00
@@ -87,7 +87,8 @@
 
 static void replace_with_integer(struct token *token, unsigned int val)
 {
-	char *buf = __alloc_bytes(10);
+	char *buf = __alloc_bytes(11);
+	// FIXME: to be signed or not to be
 	sprintf(buf, "%d", val);
 	token_type(token) = TOKEN_NUMBER;
 	token->number = buf;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK PATCH] replace_with_integer
Date: Mon, 13 Sep 2004 20:02:41 +0000
Message-ID: <Pine.LNX.4.58.0409131302240.2378 () ppc970 ! osdl ! org>
--------------------


On Mon, 13 Sep 2004, Morten Welinder wrote:
> 
> Today's next trivial patch fixes replace_with_integer to avoid a buffer
> run.  Now, mind you, replace_with_integer in only used for __LINE__
> currently so you would need a billion-line file to get hit.  If you have
> those, it might be time to split it into smaller unit.  IMHO.
> 
> Also, the code is arguing with itself over signed vs unsigned.

You might as well fix that too, and use %u.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] s/Wundefined-preprocessor-symbol/Wundef/ ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] s/Wundefined-preprocessor-symbol/Wundef/
Date: Tue, 05 Oct 2004 15:06:30 +0000
Message-ID: <20041005150630.B076C1422D5B () darter ! rentec ! com>
--------------------

We might as well follow gcc's warning naming.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 lib.c |    2 +-
 1 files changed, 1 insertion(+), 1 deletion(-)

through these ChangeSets:

<welinder@troll.com> (04/10/05 1.835)
   Rename -Wundefined-preprocessor-symbol to -Wundef to match
   gcc.

diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-10-05 11:05:36 -04:00
+++ b/lib.c	2004-10-05 11:05:36 -04:00
@@ -682,7 +682,7 @@
 	int *flag;
 } warnings[] = {
 	{ "default-bitfield-sign", &Wdefault_bitfield_sign },
-	{ "undefined-preprocessor-symbol", &Wundefined_preprocessor },
+	{ "undef", &Wundefined_preprocessor },
 	{ "bitwise", &Wbitwise },
 	{ "typesign", &Wtypesign },
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] warn->warning, etc. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] warn->warning, etc.
Date: Mon, 13 Sep 2004 14:51:26 +0000
Message-ID: <20040913145126.8D3D11422D5E () darter ! rentec ! com>
--------------------

It's quiet out there.  A good time for an invasive patch.

Here's the change of warn to warning and error to error_die.  I introduced
a new error, but so far it isn't being called.

Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 compile-i386.c |   20 +++++------
 evaluate.c     |   98 ++++++++++++++++++++++++++++-----------------------------
 expand.c       |   24 ++++++-------
 expression.c   |   20 +++++------
 inline.c       |   10 ++---
 lib.c          |   25 ++++++++++++--
 lib.h          |   13 +++++--
 linearize.c    |   10 ++---
 obfuscate.c    |    8 ++--
 parse.c        |   80 +++++++++++++++++++++++-----------------------
 pre-process.c  |   68 +++++++++++++++++++--------------------
 show-parse.c   |   12 +++---
 symbol.c       |   14 ++++----
 tokenize.c     |   24 ++++++-------
 14 files changed, 226 insertions(+), 200 deletions(-)

through these ChangeSets:

<welinder@darter.rentec.com> (04/09/13 1.787)
   Many files:
     warn->warning
     error->error_die
     new error
   lib.h:
     warn->warning
     error->error_die
     new error
     Add gcc format checking to warning/error/...

diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	2004-09-13 10:49:00 -04:00
+++ b/compile-i386.c	2004-09-13 10:49:00 -04:00
@@ -1371,15 +1371,15 @@
 			opname = "mul";
 		break;
 	case SPECIAL_LOGICAL_AND:
-		warn(expr->pos, "bogus bitwise and for logical op (should use '2*setne + and' or something)");
+		warning(expr->pos, "bogus bitwise and for logical op (should use '2*setne + and' or something)");
 		opname = "and";
 		break;
 	case SPECIAL_LOGICAL_OR:
-		warn(expr->pos, "bogus bitwise or for logical op (should use 'or + setne' or something)");
+		warning(expr->pos, "bogus bitwise or for logical op (should use 'or + setne' or something)");
 		opname = "or";
 		break;
 	default:
-		error(expr->pos, "unhandled binop '%s'\n", show_special(expr->op));
+		error_die(expr->pos, "unhandled binop '%s'\n", show_special(expr->op));
 		break;
 	}
 
@@ -2061,7 +2061,7 @@
 	char s[64];
 
 	if (!expr->ctype) {
-		warn(expr->pos, "\tcall with no type!");
+		warning(expr->pos, "\tcall with no type!");
 		return NULL;
 	}
 
@@ -2355,7 +2355,7 @@
 	case EXPR_DEREF:
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warn(expr->pos, "invalid expression after evaluation");
+		warning(expr->pos, "invalid expression after evaluation");
 		return NULL;
 	case EXPR_CAST:
 		return emit_cast_expr(expr);
@@ -2380,19 +2380,19 @@
 	// None of these should exist as direct expressions: they are only
 	// valid as sub-expressions of initializers.
 	case EXPR_POS:
-		warn(expr->pos, "unable to show plain initializer position expression");
+		warning(expr->pos, "unable to show plain initializer position expression");
 		return NULL;
 	case EXPR_IDENTIFIER:
-		warn(expr->pos, "unable to show identifier expression");
+		warning(expr->pos, "unable to show identifier expression");
 		return NULL;
 	case EXPR_INDEX:
-		warn(expr->pos, "unable to show index expression");
+		warning(expr->pos, "unable to show index expression");
 		return NULL;
 	case EXPR_TYPE:
-		warn(expr->pos, "unable to show type expression");
+		warning(expr->pos, "unable to show type expression");
 		return NULL;
 	case EXPR_FVALUE:
-		warn(expr->pos, "floating point support is not implemented");
+		warning(expr->pos, "floating point support is not implemented");
 		return NULL;
 	}
 	return NULL;
diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-09-13 10:49:00 -04:00
+++ b/evaluate.c	2004-09-13 10:49:00 -04:00
@@ -40,17 +40,17 @@
 			expr->ctype = &int_ctype;
 			return &int_ctype;
 		}
-		warn(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		warning(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
 	examine_symbol_type(sym);
 	if ((sym->ctype.context ^ current_context) & (sym->ctype.contextmask & current_contextmask))
-		warn(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
+		warning(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
 
 	base_type = sym->ctype.base_type;
 	if (!base_type) {
-		warn(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		warning(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -215,7 +215,7 @@
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warn(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
+	warning(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -387,7 +387,7 @@
 
 	ctype = degenerate(ptr);
 	if (!ctype->ctype.base_type) {
-		warn(expr->pos, "missing type information");
+		warning(expr->pos, "missing type information");
 		return NULL;
 	}
 
@@ -582,7 +582,7 @@
 	if (expr->type != EXPR_VALUE || expr->value)
 		return 0;
 	if (!is_ptr_type(expr->ctype))
-		warn(expr->pos, "Using plain integer as NULL pointer");
+		warning(expr->pos, "Using plain integer as NULL pointer");
 	return 1;
 }
 
@@ -623,7 +623,7 @@
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warn(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			warning(expr->pos, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -633,7 +633,7 @@
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warn(expr->pos, "subtraction of functions? Share your drugs");
+		warning(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = ctype->ctype.base_type;
@@ -682,12 +682,12 @@
 		return NULL;
 
 	if (expr->type == EXPR_ASSIGNMENT)
-		warn(expr->pos, "assignment expression in conditional");
+		warning(expr->pos, "assignment expression in conditional");
 
 	ctype = evaluate_expression(expr);
 	if (ctype) {
 		if (is_safe_type(ctype))
-			warn(expr->pos, "testing a 'safe expression'");
+			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
 			struct expression *comp;
 			/*
@@ -801,7 +801,7 @@
 		goto OK;
 
 	if (is_safe_type(ltype) || is_safe_type(rtype))
-		warn(expr->pos, "testing a 'safe expression'");
+		warning(expr->pos, "testing a 'safe expression'");
 
 	/* Pointer types? */
 	if (is_ptr_type(ltype) || is_ptr_type(rtype)) {
@@ -892,7 +892,7 @@
 	ctype = compatible_restricted_binop('?', &expr->left, &expr->right);
 	if (ctype)
 		goto out;
-	warn(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	warning(expr->pos, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -963,7 +963,7 @@
 		}
 	}
 
-	warn(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1057,7 +1057,7 @@
 static void evaluate_assign_to(struct expression *left, struct symbol *type)
 {
 	if (type->ctype.modifiers & MOD_CONST)
-		warn(left->pos, "assignment to const expression");
+		warning(left->pos, "assignment to const expression");
 	if (type->type == SYM_NODE)
 		type->ctype.modifiers |= MOD_ASSIGNED;
 }
@@ -1069,7 +1069,7 @@
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		warn(expr->pos, "not an lvalue");
+		warning(expr->pos, "not an lvalue");
 		return NULL;
 	}
 
@@ -1154,7 +1154,7 @@
 	access_symbol(sym);
 	sym->ctype.modifiers |= MOD_ADDRESSABLE;
 	if (sym->ctype.modifiers & MOD_REGISTER) {
-		warn(expr->pos, "taking address of 'register' variable '%s'", show_ident(sym->ident));
+		warning(expr->pos, "taking address of 'register' variable '%s'", show_ident(sym->ident));
 		sym->ctype.modifiers &= ~MOD_REGISTER;
 	}
 	if (sym->type == SYM_NODE) {
@@ -1239,7 +1239,7 @@
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warn(expr->pos, "strange non-value function or array");
+			warning(expr->pos, "strange non-value function or array");
 			return NULL;
 		}
 		*expr = *expr->unop;
@@ -1257,7 +1257,7 @@
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warn(expr->pos, "not addressable");
+		warning(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1296,7 +1296,7 @@
 
 	switch (ctype->type) {
 	default:
-		warn(expr->pos, "cannot derefence this type");
+		warning(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		merge_type(node, ctype);
@@ -1318,7 +1318,7 @@
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warn(op->pos, "non-lvalue array??");
+			warning(op->pos, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1350,11 +1350,11 @@
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		warn(expr->pos, "need lvalue expression for ++/--");
+		warning(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warn(expr->pos, "bad operation on restricted");
+		warning(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1415,7 +1415,7 @@
 
 	case '!':
 		if (is_safe_type(ctype))
-			warn(expr->pos, "testing a 'safe expression'");
+			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
 			struct expression *arg = expr->unop;
 			expr->type = EXPR_BINOP;
@@ -1510,7 +1510,7 @@
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warn(expr->pos, "bad member name");
+		warning(expr->pos, "bad member name");
 		return NULL;
 	}
 
@@ -1523,7 +1523,7 @@
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warn(expr->pos, "expected structure or union");
+		warning(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1536,7 +1536,7 @@
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warn(expr->pos, "no member '%s' in %s %.*s",
+		warning(expr->pos, "no member '%s' in %s %.*s",
 			show_ident(ident), type, namelen, name);
 		return NULL;
 	}
@@ -1641,10 +1641,10 @@
 				size = bits_in_int;
 		}
 		if (is_bitfield_type(what->ctype))
-			warn(expr->pos, "sizeof applied to bitfield type");
+			warning(expr->pos, "sizeof applied to bitfield type");
 	}
 	if (size & 7)
-		warn(expr->pos, "cannot size expression");
+		warning(expr->pos, "cannot size expression");
 	expr->type = EXPR_VALUE;
 	expr->value = size >> 3;
 	expr->ctype = size_t_ctype;
@@ -1661,7 +1661,7 @@
 			return NULL;
 	}
 	if (is_bitfield_type(type))
-		warn(expr->pos, "alignof applied to bitfield type");
+		warning(expr->pos, "alignof applied to bitfield type");
 	examine_symbol_type(type);
 	expr->type = EXPR_VALUE;
 	expr->value = type->ctype.alignment;
@@ -1693,7 +1693,7 @@
 			return 0;
 
 		if (context_clash(f, ctype))
-			warn(expr->pos, "argument %d used in wrong context", i);
+			warning(expr->pos, "argument %d used in wrong context", i);
 
 		ctype = degenerate(expr);
 
@@ -1749,7 +1749,7 @@
 static int evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr, unsigned long offset)
 {
 	if (offset || expression_list_size(expr->expr_list) != 1) {
-		warn(expr->pos, "unexpected compound initializer");
+		warning(expr->pos, "unexpected compound initializer");
 		return 0;
 	}
 	return evaluate_array_initializer(ctype, expr, 0);
@@ -1772,7 +1772,7 @@
 			RESET_PTR_LIST(sym);
 			for (;;) {
 				if (!sym) {
-					warn(entry->pos, "unknown named initializer '%s'", show_ident(ident));
+					warning(entry->pos, "unknown named initializer '%s'", show_ident(ident));
 					return 0;
 				}
 				if (sym->ident == ident)
@@ -1783,7 +1783,7 @@
 		}
 
 		if (!sym) {
-			warn(expr->pos, "too many initializers for struct/union");
+			warning(expr->pos, "too many initializers for struct/union");
 			return 0;
 		}
 
@@ -1954,10 +1954,10 @@
 			goto out;
 	}
 	if (type == SYM_ARRAY || type == SYM_UNION || type == SYM_STRUCT)
-		warn(expr->pos, "cast to non-scalar");
+		warning(expr->pos, "cast to non-scalar");
 
 	if (!target->ctype) {
-		warn(expr->pos, "cast from unknown type");
+		warning(expr->pos, "cast from unknown type");
 		goto out;
 	}
 
@@ -1965,10 +1965,10 @@
 	if (type == SYM_NODE)
 		type = target->ctype->ctype.base_type->type;
 	if (type == SYM_ARRAY || type == SYM_UNION || type == SYM_STRUCT)
-		warn(expr->pos, "cast from non-scalar");
+		warning(expr->pos, "cast from non-scalar");
 
 	if (!get_as(ctype) && get_as(target->ctype) > 0)
-		warn(expr->pos, "cast removes address space of expression");
+		warning(expr->pos, "cast removes address space of expression");
 
 	if (!(ctype->ctype.modifiers & MOD_FORCE)) {
 		struct symbol *t1 = ctype, *t2 = target->ctype;
@@ -1978,9 +1978,9 @@
 			t2 = t2->ctype.base_type;
 		if (t1 != t2) {
 			if (t1->type == SYM_RESTRICT)
-				warn(expr->pos, "cast to restricted type");
+				warning(expr->pos, "cast to restricted type");
 			if (t2->type == SYM_RESTRICT)
-				warn(expr->pos, "cast from restricted type");
+				warning(expr->pos, "cast from restricted type");
 		}
 	}
 
@@ -2052,15 +2052,15 @@
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warn(expr->pos, "not a function %s", show_ident(sym->ident));
+		warning(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
 	fnargs = symbol_list_size(ctype->arguments);
 	if (args < fnargs)
-		warn(expr->pos, "not enough arguments for function %s", show_ident(sym->ident));
+		warning(expr->pos, "not enough arguments for function %s", show_ident(sym->ident));
 	if (args > fnargs && !ctype->variadic)
-		warn(expr->pos, "too many arguments for function %s", show_ident(sym->ident));
+		warning(expr->pos, "too many arguments for function %s", show_ident(sym->ident));
 	if (sym->type == SYM_NODE) {
 		if (evaluate_symbol_call(expr))
 			return expr->ctype;
@@ -2079,7 +2079,7 @@
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warn(expr->pos, "value expression without a type");
+		warning(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2129,7 +2129,7 @@
 	case EXPR_CALL:
 		return evaluate_call(expr);
 	case EXPR_BITFIELD:
-		warn(expr->pos, "bitfield generated by parser");
+		warning(expr->pos, "bitfield generated by parser");
 		return NULL;
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
@@ -2160,10 +2160,10 @@
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warn(expr->pos, "internal front-end error: initializer in expression");
+		warning(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warn(expr->pos, "internal front-end error: SLICE re-evaluated");
+		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
@@ -2178,7 +2178,7 @@
 		evaluate_symbol(next);
 		typediff = type_difference(sym, next, 0, 0);
 		if (typediff) {
-			warn(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
+			warning(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
 				show_ident(sym->ident),
 				input_streams[next->pos.stream].name, next->pos.line, typediff);
 			return;
@@ -2244,12 +2244,12 @@
 	fntype = current_fn->ctype.base_type;
 	if (!fntype || fntype == &void_ctype) {
 		if (expr && ctype != &void_ctype)
-			warn(expr->pos, "return expression in %s function", fntype?"void":"typeless");
+			warning(expr->pos, "return expression in %s function", fntype?"void":"typeless");
 		return NULL;
 	}
 
 	if (!expr) {
-		warn(stmt->pos, "return with no return value");
+		warning(stmt->pos, "return with no return value");
 		return NULL;
 	}
 	if (!ctype)
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-09-13 10:49:00 -04:00
+++ b/expand.c	2004-09-13 10:49:00 -04:00
@@ -42,7 +42,7 @@
 	 * The preprocessor can cause unknown symbols to be generated
 	 */
 	if (!sym) {
-		warn(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
+		warning(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
 		expr->type = EXPR_VALUE;
 		expr->value = 0;
 		return UNSAFE;
@@ -120,7 +120,7 @@
 static int check_shift_count(struct expression *expr, struct symbol *ctype, unsigned int count)
 {
 	if (count >= ctype->bit_size) {
-		warn(expr->pos, "shift too big for type (%x)", ctype->ctype.modifiers);
+		warning(expr->pos, "shift too big for type (%x)", ctype->ctype.modifiers);
 		count &= ctype->bit_size-1;
 	}
 	return count;
@@ -233,10 +233,10 @@
 	expr->type = EXPR_VALUE;
 	return 1;
 Div:
-	warn(expr->pos, "division by zero");
+	warning(expr->pos, "division by zero");
 	return 0;
 Overflow:
-	warn(expr->pos, "constant integer operation overflow");
+	warning(expr->pos, "constant integer operation overflow");
 	return 0;
 }
 
@@ -315,7 +315,7 @@
 	expr->fvalue = res;
 	return 1;
 Div:
-	warn(expr->pos, "division by zero");
+	warning(expr->pos, "division by zero");
 	return 0;
 }
 
@@ -511,7 +511,7 @@
 	 * test for me to get the type evaluation right..
 	 */
 	if (expr->ctype->ctype.modifiers & MOD_NODEREF)
-		warn(unop->pos, "dereference of noderef expression");
+		warning(unop->pos, "dereference of noderef expression");
 
 	if (unop->type == EXPR_SYMBOL) {
 		struct symbol *sym = unop->symbol;
@@ -565,7 +565,7 @@
 	return 1;
 
 Overflow:
-	warn(expr->pos, "constant integer operation overflow");
+	warning(expr->pos, "constant integer operation overflow");
 	return 0;
 }
 
@@ -739,7 +739,7 @@
 		return expand_call(expr);
 
 	case EXPR_DEREF:
-		warn(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
+		warning(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
 		return UNSAFE;
 
 	case EXPR_BITFIELD:
@@ -772,7 +772,7 @@
 
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warn(expr->pos, "internal front-end error: sizeof in expansion?");
+		warning(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -783,7 +783,7 @@
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warn(expr->pos, "Expected constant expression in %s", where);
+			warning(expr->pos, "Expected constant expression in %s", where);
 	}
 }
 
@@ -919,12 +919,12 @@
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warn(expr->pos, "bad constant expression type");
+		warning(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warn(expr->pos, "bad constant expression");
+		warning(expr->pos, "bad constant expression");
 		return 0;
 	}
 
diff -Nru a/expression.c b/expression.c
--- a/expression.c	2004-09-13 10:49:00 -04:00
+++ b/expression.c	2004-09-13 10:49:00 -04:00
@@ -75,7 +75,7 @@
 		} while (token_type(next) == TOKEN_STRING);
 
 		if (totlen > MAX_STRING) {
-			warn(token->pos, "trying to concatenate %d-character string (%d bytes max)", totlen, MAX_STRING);
+			warning(token->pos, "trying to concatenate %d-character string (%d bytes max)", totlen, MAX_STRING);
 			totlen = MAX_STRING;
 		}
 
@@ -179,18 +179,18 @@
 	if (!(value & (1ULL << bits)))
 		goto got_it;
 	if (!try_unsigned)
-		warn(expr->pos, "decimal constant %s is too big for long long",
+		warning(expr->pos, "decimal constant %s is too big for long long",
 			show_token(token));
 	modifiers |= MOD_UNSIGNED;
 got_it:
 	if (do_warn)
-		warn(expr->pos, "constant %s is so big it is%s%s%s",
+		warning(expr->pos, "constant %s is so big it is%s%s%s",
 			show_token(token),
 			(modifiers & MOD_UNSIGNED) ? " unsigned":"",
 			(modifiers & MOD_LONG) ? " long":"",
 			(modifiers & MOD_LONGLONG) ? " long":"");
 	if (do_warn & 2)
-		warn(expr->pos,
+		warning(expr->pos,
 			"decimal constant %s is between LONG_MAX and ULONG_MAX."
 			" For C99 that means long long, C90 compilers are very "
 			"likely to produce unsigned long (and a warning) here",
@@ -200,7 +200,7 @@
         expr->value = value;
 	return;
 Eoverflow:
-	error(expr->pos, "constant %s is too big even for unsigned long long",
+	error_die(expr->pos, "constant %s is too big even for unsigned long long",
 			show_token(token));
 	return;
 Float:
@@ -224,7 +224,7 @@
 	return;
 
 Enoint:
-	error(expr->pos, "constant %s is not a valid number", show_token(token));
+	error_die(expr->pos, "constant %s is not a valid number", show_token(token));
 }
 
 struct token *primary_expression(struct token *token, struct expression **tree)
@@ -258,7 +258,7 @@
 		 *	if (typeof(a) == int) ..
 		 */
 		if (sym && sym->namespace == NS_TYPEDEF) {
-			warn(token->pos, "typename in expression");
+			warning(token->pos, "typename in expression");
 			sym = NULL;
 		}
 		expr->symbol_name = token->ident;
@@ -359,7 +359,7 @@
 			deref->deref = expr;
 			token = token->next;
 			if (token_type(token) != TOKEN_IDENT) {
-				warn(token->pos, "Expected member name");
+				warning(token->pos, "Expected member name");
 				break;
 			}
 			deref->member = token->ident;
@@ -435,7 +435,7 @@
 
 			next = cast_expression(token->next, &unop);
 			if (!unop) {
-				warn(token->pos, "Syntax error in unary expression");
+				warning(token->pos, "Syntax error in unary expression");
 				return next;
 			}
 			unary = alloc_expression(token->pos, EXPR_PREOP);
@@ -522,7 +522,7 @@
 			top = alloc_expression(next->pos, type);	\
 			next = inner(next->next, &right);		\
 			if (!right) {					\
-				warn(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
+				warning(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
 			top->op = op;					\
diff -Nru a/inline.c b/inline.c
--- a/inline.c	2004-09-13 10:49:00 -04:00
+++ b/inline.c	2004-09-13 10:49:00 -04:00
@@ -37,7 +37,7 @@
 	if (sym->ctype.modifiers & (MOD_STATIC | MOD_EXTERN | MOD_TOPLEVEL | MOD_INLINE))
 		return sym;
 	if (!sym->replace) {
-		warn(pos, "unreplaced symbol '%s'", show_ident(sym->ident));
+		warning(pos, "unreplaced symbol '%s'", show_ident(sym->ident));
 		return sym;
 	}
 	return sym->replace;
@@ -220,7 +220,7 @@
 	}
 
 	default:
-		warn(expr->pos, "trying to copy expression type %d", expr->type);
+		warning(expr->pos, "trying to copy expression type %d", expr->type);
 	}
 	return expr;
 }
@@ -235,7 +235,7 @@
 {
 	struct symbol *r = sym->replace;
 	if (!r) {
-		warn(sym->pos, "symbol '%s' not replaced?", show_ident(sym->ident));
+		warning(sym->pos, "symbol '%s' not replaced?", show_ident(sym->ident));
 		return;
 	}
 	r->replace = NULL;
@@ -351,7 +351,7 @@
 		break;
 	}
 	default:
-		warn(stmt->pos, "trying to copy statement type %d", stmt->type);
+		warning(stmt->pos, "trying to copy statement type %d", stmt->type);
 		break;
 	}
 	return stmt;
@@ -419,7 +419,7 @@
 	struct expression *arg;
 
 	if (!fn->inline_stmt) {
-		warn(fn->pos, "marked inline, but without a definition");
+		warning(fn->pos, "marked inline, but without a definition");
 		return 0;
 	}
 	if (fn->expanding)
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-09-13 10:49:00 -04:00
+++ b/lib.c	2004-09-13 10:49:00 -04:00
@@ -40,8 +40,8 @@
 		static struct token bad_token;
 		if (token != &bad_token) {
 			bad_token.next = token;
-			warn(token->pos, "Expected %s %s", show_special(op), where);
-			warn(token->pos, "got %s", show_token(token));
+			warning(token->pos, "Expected %s %s", show_special(op), where);
+			warning(token->pos, "got %s", show_token(token));
 		}
 		if (op == ';')
 			return skip_to(token, op);
@@ -496,7 +496,7 @@
 	va_end(args);
 }
 
-void warn(struct position pos, const char * fmt, ...)
+void warning(struct position pos, const char * fmt, ...)
 {
 	static int warnings = 0;
 	va_list args;
@@ -516,6 +516,25 @@
 }	
 
 void error(struct position pos, const char * fmt, ...)
+{
+	static int errors = 0;
+	va_list args;
+
+	if (errors > 100) {
+		static int once = 0;
+		if (once)
+			return;
+		fmt = "too many errors";
+		once = 1;
+	}
+
+	va_start(args, fmt);
+	do_warn("error: ", pos, fmt, args);
+	va_end(args);
+	errors++;
+}	
+
+void error_die(struct position pos, const char * fmt, ...)
 {
 	va_list args;
 	va_start(args, fmt);
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-09-13 10:49:00 -04:00
+++ b/lib.h	2004-09-13 10:49:00 -04:00
@@ -42,9 +42,16 @@
 
 struct token *skip_to(struct token *, int);
 struct token *expect(struct token *, int, const char *);
-extern void info(struct position, const char *, ...);
-extern void warn(struct position, const char *, ...);
-extern void error(struct position, const char *, ...);
+#ifdef __GNUC__
+#define FORMAT_ATTR __attribute__ ((__format__ (__printf__, 2, 3)))
+#else
+#define FORMAT_ATTR
+#endif
+extern void info(struct position, const char *, ...) FORMAT_ATTR;
+extern void warning(struct position, const char *, ...) FORMAT_ATTR;
+extern void error(struct position, const char *, ...) FORMAT_ATTR;
+extern void error_die(struct position, const char *, ...) FORMAT_ATTR;
+#undef FORMAT_ATTR
 
 #define __DECLARE_ALLOCATOR(type, x)		\
 	extern type *__alloc_##x(int);		\
diff -Nru a/linearize.c b/linearize.c
--- a/linearize.c	2004-09-13 10:49:00 -04:00
+++ b/linearize.c	2004-09-13 10:49:00 -04:00
@@ -272,7 +272,7 @@
 static void bind_label(struct symbol *label, struct basic_block *bb, struct position pos)
 {
 	if (label->bb_target)
-		warn(pos, "label '%s' already bound", show_ident(label->ident));
+		warning(pos, "label '%s' already bound", show_ident(label->ident));
 	label->bb_target = bb;
 }
 
@@ -370,7 +370,7 @@
 		return linearize_expression(ep, expr->unop);
 	if (expr->type == EXPR_BITFIELD)
 		return linearize_expression(ep, expr->address);
-	warn(expr->pos, "generating address of non-lvalue");
+	warning(expr->pos, "generating address of non-lvalue");
 	return VOID;
 }
 
@@ -452,7 +452,7 @@
 		return add_binary_op(ep, expr, OP_AND, new, mask);
 	}
 
-	warn(expr->pos, "loading unknown expression");
+	warning(expr->pos, "loading unknown expression");
 	return new;		
 }
 
@@ -570,7 +570,7 @@
 	pseudo_t retval;
 
 	if (!expr->ctype) {
-		warn(expr->pos, "call with no type!");
+		warning(expr->pos, "call with no type!");
 		return VOID;
 	}
 
@@ -829,7 +829,7 @@
 		return linearize_slice(ep, expr);
 
 	default: 
-		warn(expr->pos, "unknown expression (%d %d)", expr->type, expr->op);
+		warning(expr->pos, "unknown expression (%d %d)", expr->type, expr->op);
 		return VOID;
 	}
 	return VOID;
diff -Nru a/obfuscate.c b/obfuscate.c
--- a/obfuscate.c	2004-09-13 10:49:00 -04:00
+++ b/obfuscate.c	2004-09-13 10:49:00 -04:00
@@ -29,11 +29,11 @@
 	const char *name = show_ident(sym->ident);
 
 	if (size <= 0) {
-		warn(sym->pos, "emitting insized symbol");
+		warning(sym->pos, "emitting insized symbol");
 		size = 8;
 	}
 	if (size & 7)
-		warn(sym->pos, "emitting symbol of size %d bits\n", size);
+		warning(sym->pos, "emitting symbol of size %d bits\n", size);
 	size = (size+7) >> 3;
 	if (alignment < 1)
 		alignment = 1;
@@ -67,7 +67,7 @@
 
 	evaluate_symbol(sym);
 	if (sym->type != SYM_NODE) {
-		warn(sym->pos, "I really want to emit nodes, not pure types!");
+		warning(sym->pos, "I really want to emit nodes, not pure types!");
 		return;
 	}
 
@@ -87,7 +87,7 @@
 		emit_fn(sym);
 		return;
 	default:
-		warn(sym->pos, "what kind of strange node do you want me to emit again?");
+		warning(sym->pos, "what kind of strange node do you want me to emit again?");
 		return;
 	}
 }
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-09-13 10:49:00 -04:00
+++ b/parse.c	2004-09-13 10:49:00 -04:00
@@ -117,7 +117,7 @@
 			bind_symbol(sym, token->ident, NS_STRUCT);
 		}
 		if (sym->type != type)
-			error(token->pos, "invalid tag applied to %s", show_typename (sym));
+			error_die(token->pos, "invalid tag applied to %s", show_typename (sym));
 		token = token->next;
 		ctype->base_type = sym;
 		if (match_op(token, '{')) {
@@ -125,7 +125,7 @@
 			// structs, but (1) they are not C99, (2) gcc does
 			// the same thing, and (3) it's easier.
 			if (sym->symbol_list)
-				error(token->pos, "redefinition of %s", show_typename (sym));
+				error_die(token->pos, "redefinition of %s", show_typename (sym));
 			token = parse(token->next, sym);
 			token = expect(token, '}', "at end of struct-union-enum-specifier");
 		}
@@ -134,7 +134,7 @@
 
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warn(token->pos, "expected declaration");
+		warning(token->pos, "expected declaration");
 		ctype->base_type = &bad_type;
 		return token;
 	}
@@ -193,7 +193,7 @@
 	struct symbol *sym;
 
 	if (!match_op(token, '(')) {
-		warn(token->pos, "expected '(' after typeof");
+		warning(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -368,7 +368,7 @@
 			token = parens_expression(token, &attribute_expr, "in attribute");
 		error = handle_attribute(ctype, attribute_name, attribute_expr);
 		if (error)
-			warn(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
+			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -440,29 +440,29 @@
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warn(pos, "Just how %sdo you want this type to be?",
+			warning(pos, "Just how %sdo you want this type to be?",
 				modifier_string(dup));
 
 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warn(pos, "You cannot have both long and short modifiers.");
+			warning(pos, "You cannot have both long and short modifiers.");
 
 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warn(pos, "You cannot have both signed and unsigned modifiers.");
+			warning(pos, "You cannot have both signed and unsigned modifiers.");
 
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warn(pos, "multiple storage classes");
+			warning(pos, "multiple storage classes");
 
 		ctype->modifiers = old | mod | extra;
 	}
 
 	/* Context mask and value */
 	if ((ctype->context ^ thistype->context) & (ctype->contextmask & thistype->contextmask)) {
-		warn(pos, "inconsistent attribute types");
+		warning(pos, "inconsistent attribute types");
 		thistype->context = 0;
 		thistype->contextmask = 0;
 	}
@@ -471,7 +471,7 @@
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
-		warn(pos, "I don't like non-power-of-2 alignments");
+		warning(pos, "I don't like non-power-of-2 alignments");
 		thistype->alignment = 0;
 	}
 	if (thistype->alignment > ctype->alignment)
@@ -506,7 +506,7 @@
 
 	wrong = mod & banned;
 	if (wrong)
-		warn(*pos, "modifier %sis invalid in this context",
+		warning(*pos, "modifier %sis invalid in this context",
 		     modifier_string (wrong));
 }
 
@@ -588,7 +588,7 @@
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warn(token->pos, "invalid modifier");
+			warning(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -724,7 +724,7 @@
 	long long width;
 
 	if (!is_int_type(ctype->base_type)) {
-		warn(token->pos, "invalid bitfield specifier for type %s.",
+		warning(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -736,31 +736,31 @@
 	bitfield->fieldwidth = width;
 
 	if (width < 0) {
-		warn(token->pos, "invalid negative bitfield width, %lld.", width);
+		warning(token->pos, "invalid negative bitfield width, %lld.", width);
 		bitfield->fieldwidth = 8;
 	} else if (decl->ident && width == 0) {
-		warn(token->pos, "invalid named zero-width bitfield `%s'",
+		warning(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		bitfield->fieldwidth = 8;
 	} else if (width != bitfield->fieldwidth) {
 		// Overflow.
 		unsigned int stupid_gcc = -1;
 		bitfield->fieldwidth = stupid_gcc;
-		warn(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
+		warning(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
 	} else if (decl->ident) {
 		struct symbol *base_type = bitfield->ctype.base_type;
 		int is_signed = !(base_type->ctype.modifiers & MOD_UNSIGNED);
 		if (bitfield->fieldwidth == 1 && is_signed) {
 			// Valid values are either {-1;0} or {0}, depending on integer
 			// representation.  The latter makes for very efficient code...
-			warn(token->pos, "dubious one-bit signed bitfield");
+			warning(token->pos, "dubious one-bit signed bitfield");
 		}
 		if (Wdefault_bitfield_sign &&
 		    base_type->type != SYM_ENUM &&
 		    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) &&
 		    is_signed) {
 			// The sign of bitfields is unspecified by default.
-			warn (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
+			warning (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
 		}
 	}
 	return token;
@@ -787,7 +787,7 @@
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warn(token->pos, "expected ; at end of declaration");
+			warning(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1003,7 +1003,7 @@
 static void end_switch(struct statement *stmt)
 {
 	if (!stmt->switch_case->symbol_list)
-		warn(stmt->pos, "switch with no cases");
+		warning(stmt->pos, "switch with no cases");
 	end_symbol_scope();
 }
 
@@ -1013,7 +1013,7 @@
 	struct symbol *sym;
 
 	if (!target) {
-		warn(stmt->pos, "not in switch scope");
+		warning(stmt->pos, "not in switch scope");
 		return;
 	}
 	sym = alloc_symbol(stmt->pos, SYM_NODE);
@@ -1028,7 +1028,7 @@
 	struct symbol *target = lookup_symbol(&return_ident, NS_ITERATOR);
 
 	if (!target)
-		error(token->pos, "internal error: return without a function target");
+		error_die(token->pos, "internal error: return without a function target");
 	stmt->type = STMT_RETURN;
 	stmt->ret_target = target;
 	return expression_statement(token->next, &stmt->ret_value);
@@ -1096,7 +1096,7 @@
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warn(token->pos, "expected 'while' after 'do'");
+		warning(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");
 
 	stmt->iterator_post_condition = expr;
@@ -1131,7 +1131,7 @@
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warn(stmt->pos, "break/continue not in iterator scope");
+				warning(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1175,7 +1175,7 @@
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warn(token->pos, "Expected identifier or goto expression");
+				warning(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1224,7 +1224,7 @@
 		// No warning for "void oink ();"
 		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
 		if (!match_op(token->next, ';'))
-			warn(token->pos, "non-ANSI function declaration");
+			warning(token->pos, "non-ANSI function declaration");
 		return token;
 	}
 
@@ -1233,7 +1233,7 @@
 
 		if (match_op(token, SPECIAL_ELLIPSIS)) {
 			if (!*list)
-				warn(token->pos, "variadic functions must have one named argument");
+				warning(token->pos, "variadic functions must have one named argument");
 			fn->variadic = 1;
 			token = token->next;
 			break;
@@ -1245,7 +1245,7 @@
 			/* Special case: (void) */
 			if (!*list && !sym->ident)
 				break;
-			warn(token->pos, "void parameter");
+			warning(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
@@ -1284,7 +1284,7 @@
 	if (to) {
 		idx_to = get_expression_value(to);
 		if (idx_to < idx_from || idx_from < 0)
-			warn(from->pos, "nonsense array initializer index range");
+			warning(from->pos, "nonsense array initializer index range");
 	}
 	expr->idx_from = idx_from;
 	expr->idx_to = idx_to;
@@ -1339,7 +1339,7 @@
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warn(sym->pos, "no identifier for function argument");
+		warning(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1364,7 +1364,7 @@
 
 	if (decl->ctype.modifiers & MOD_EXTERN) {
 		if (!(decl->ctype.modifiers & MOD_INLINE))
-			warn(decl->pos, "function with external linkage has definition");
+			warning(decl->pos, "function with external linkage has definition");
 	}
 	if (!(decl->ctype.modifiers & MOD_STATIC))
 		decl->ctype.modifiers |= MOD_EXTERN;
@@ -1385,7 +1385,7 @@
 	function_symbol_list = NULL;
 	if (function_computed_goto_list) {
 		if (!function_computed_target_list)
-			warn(decl->pos, "function has computed goto but no targets?");
+			warning(decl->pos, "function has computed goto but no targets?");
 		else {
 			struct statement *stmt;
 			FOR_EACH_PTR(function_computed_goto_list, stmt) {
@@ -1417,7 +1417,7 @@
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warn(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
+		warning(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1429,7 +1429,7 @@
 
 	FOR_EACH_PTR(argtypes, arg) {
 		if (!arg->used)
-			warn(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
+			warning(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
 	} END_FOR_EACH_PTR(arg);
 
 }
@@ -1439,7 +1439,7 @@
 {
 	struct symbol_list *args = NULL;
 
-	warn(token->pos, "non-ANSI function declaration");
+	warning(token->pos, "non-ANSI function declaration");
 	do {
 		token = external_declaration(token, &args);
 	} while (lookup_type(token));
@@ -1447,7 +1447,7 @@
 	apply_k_r_types(args, decl);
 
 	if (!match_op(token, '{')) {
-		warn(token->pos, "expected function body");
+		warning(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1513,7 +1513,7 @@
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (!is_typedef && base_type == &void_ctype && !(decl->ctype.modifiers & MOD_EXTERN)) {
-		warn(token->pos, "void declaration");
+		warning(token->pos, "void declaration");
 	}
 
 	for (;;) {
@@ -1528,7 +1528,7 @@
 		}
 		if (!is_typedef && match_op(token, '=')) {
 			if (decl->ctype.modifiers & MOD_EXTERN) {
-				warn(decl->pos, "symbol with external linkage has initializer");
+				warning(decl->pos, "symbol with external linkage has initializer");
 				decl->ctype.modifiers &= ~MOD_EXTERN;
 			}
 			token = initializer(&decl->initializer, token->next);
@@ -1552,7 +1552,7 @@
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, &decl, &ident);
 		if (!ident) {
-			warn(token->pos, "expected identifier name in type definition");
+			warning(token->pos, "expected identifier name in type definition");
 			return token;
 		}
 
diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-13 10:49:00 -04:00
+++ b/pre-process.c	2004-09-13 10:49:00 -04:00
@@ -98,7 +98,7 @@
 	char *string[] = { "0", "1" };
 	int defined = 0;
 	if (token_type(token) != TOKEN_IDENT)
-		warn(token->pos, "operator \"defined\" requires an identifier");
+		warning(token->pos, "operator \"defined\" requires an identifier");
 	else if (lookup_symbol(token->ident, NS_MACRO))
 		defined = 1;
 	token_type(token) = TOKEN_NUMBER;
@@ -237,7 +237,7 @@
 	return 1;
 
 Efew:
-	warn(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
+	warning(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
 		show_token(what), wanted, count);
 	goto out;
 Emany:
@@ -247,11 +247,11 @@
 	}
 	if (eof_token(next))
 		goto Eclosing;
-	warn(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
+	warning(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
 		show_token(what), count, wanted);
 	goto out;
 Eclosing:
-	warn(what->pos, "unterminated argument list invoking macro \"%s\"",
+	warning(what->pos, "unterminated argument list invoking macro \"%s\"",
 		show_token(what));
 out:
 	what->next = next->next;
@@ -400,7 +400,7 @@
 	default:
 		;
 	}
-	warn(left->pos, "'##' failed: concatenation is not a valid token");
+	warning(left->pos, "'##' failed: concatenation is not a valid token");
 	return 0;
 }
 
@@ -581,7 +581,7 @@
 	}
 	*ptr = 0;
 	if (endop && !match_op(token, endop))
-		warn(start->pos, "expected '>' at end of filename");
+		warning(start->pos, "expected '>' at end of filename");
 	return buffer;
 }
 
@@ -649,7 +649,7 @@
 	if (do_include_path(path, list, token, filename, flen))
 		return;
 out:
-	error(token->pos, "unable to open '%s'", filename);
+	error_die(token->pos, "unable to open '%s'", filename);
 }
 
 static int handle_include_path(struct stream *stream, struct token **list, struct token *token, const char **path)
@@ -843,20 +843,20 @@
 
 
 Emissing:
-	warn(arg->pos, "parameter name missing");
+	warning(arg->pos, "parameter name missing");
 	return NULL;
 Ebadstuff:
-	warn(arg->pos, "\"%s\" may not appear in macro parameter list",
+	warning(arg->pos, "\"%s\" may not appear in macro parameter list",
 		show_token(arg));
 	return NULL;
 Enotclosed:
-	warn(arg->pos, "missing ')' in macro parameter list");
+	warning(arg->pos, "missing ')' in macro parameter list");
 	return NULL;
 Eva_args:
-	warn(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro");
+	warning(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro");
 	return NULL;
 Eargs:
-	warn(arg->pos, "too many arguments in macro definition");
+	warning(arg->pos, "too many arguments in macro definition");
 	return NULL;
 }
 
@@ -950,14 +950,14 @@
 	return expansion;
 
 Equote:
-	warn(token->pos, "'#' is not followed by a macro parameter");
+	warning(token->pos, "'#' is not followed by a macro parameter");
 	return NULL;
 
 Econcat:
-	warn(token->pos, "'##' cannot appear at the ends of macro expansion");
+	warning(token->pos, "'##' cannot appear at the ends of macro expansion");
 	return NULL;
 Earg:
-	warn(token->pos, "too many instances of argument in body");
+	warning(token->pos, "too many instances of argument in body");
 	return NULL;
 }
 
@@ -969,7 +969,7 @@
 	struct ident *name;
 
 	if (token_type(left) != TOKEN_IDENT) {
-		warn(token->pos, "expected identifier to 'define'");
+		warning(token->pos, "expected identifier to 'define'");
 		return 0;
 	}
 	if (false_nesting)
@@ -997,7 +997,7 @@
 	if (sym) {
 		if (token_list_different(sym->expansion, expansion) || 
 		    token_list_different(sym->arglist, arglist)) {
-			warn(left->pos, "preprocessor token %.*s redefined",
+			warning(left->pos, "preprocessor token %.*s redefined",
 					name->len, name->name);
 			info(sym->pos, "this was the original definition");
 		}
@@ -1017,7 +1017,7 @@
 	struct symbol **sym;
 
 	if (token_type(left) != TOKEN_IDENT) {
-		warn(token->pos, "expected identifier to 'undef'");
+		warning(token->pos, "expected identifier to 'undef'");
 		return 0;
 	}
 	if (false_nesting)
@@ -1043,7 +1043,7 @@
 	if (if_nesting == 0)
 		unmatched_if = token;
 	if (if_nesting >= MAX_NEST)
-		error(token->pos, "Maximum preprocessor conditional level exhausted");
+		error_die(token->pos, "Maximum preprocessor conditional level exhausted");
 	elif_ignore[if_nesting] = (false_nesting || true) ? ELIF_IGNORE : 0;
 	if (false_nesting || !true) {
 		false_nesting++;
@@ -1058,7 +1058,7 @@
 	if (token_type(token) == TOKEN_IDENT)
 		return lookup_symbol(token->ident, NS_MACRO) != NULL;
 
-	warn(token->pos, "expected identifier for #if[n]def");
+	warning(token->pos, "expected identifier for #if[n]def");
 	return 0;
 }
 
@@ -1125,7 +1125,7 @@
 		case 3:
 			state = 0;
 			if (!match_op(p, ')'))
-				warn(p->pos, "missing ')' after \"defined\"");
+				warning(p->pos, "missing ')' after \"defined\"");
 			*list = p->next;
 			continue;
 		}
@@ -1134,7 +1134,7 @@
 
 	p = constant_expression(*where, &expr);
 	if (!eof_token(p))
-		warn(p->pos, "garbage at end: %s", show_token_sequence(p));
+		warning(p->pos, "garbage at end: %s", show_token_sequence(p));
 	value = get_expression_value(expr);
 	return value != 0;
 }
@@ -1160,12 +1160,12 @@
 		MARK_STREAM_NONCONST(token->pos);
 
 	if (stream->nesting > if_nesting) {
-		warn(token->pos, "unmatched #elif");
+		warning(token->pos, "unmatched #elif");
 		return 1;
 	}
 
 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warn(token->pos, "#elif after #else");
+		warning(token->pos, "#elif after #else");
 
 	if (false_nesting) {
 		/* If this whole if-thing is if'ed out, an elif cannot help */
@@ -1189,12 +1189,12 @@
 		MARK_STREAM_NONCONST(token->pos);
 
 	if (stream->nesting > if_nesting) {
-		warn(token->pos, "unmatched #else");
+		warning(token->pos, "unmatched #else");
 		return 1;
 	}
 
 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warn(token->pos, "#else after #else");
+		warning(token->pos, "#else after #else");
 	else
 		elif_ignore[if_nesting-1] |= ELIF_SEEN_ELSE;
 
@@ -1218,7 +1218,7 @@
 		stream->constant = CONSTANT_FILE_MAYBE;
 
 	if (stream->nesting > if_nesting)
-		warn(token->pos, "unmatched #endif");
+		warning(token->pos, "unmatched #endif");
 	else if (false_nesting)
 		false_nesting--;
 	else
@@ -1239,7 +1239,7 @@
 		int len = strlen(val);
 
 		if (ptr + whitespace + len >= buffer + sizeof(buffer)) {
-			warn(token->pos, "too long token expansion");
+			warning(token->pos, "too long token expansion");
 			break;
 		}
 
@@ -1260,7 +1260,7 @@
 		return 1;
 	if (stream->constant == CONSTANT_FILE_MAYBE)
 		MARK_STREAM_NONCONST(token->pos);
-	warn(token->pos, "%s", show_token_sequence(token->next));
+	warning(token->pos, "%s", show_token_sequence(token->next));
 	return 1;
 }
 
@@ -1270,7 +1270,7 @@
 		return 1;
 	if (stream->constant == CONSTANT_FILE_MAYBE)
 		MARK_STREAM_NONCONST(token->pos);
-	warn(token->pos, "%s", show_token_sequence(token->next));
+	warning(token->pos, "%s", show_token_sequence(token->next));
 	return 1;
 }
 
@@ -1307,7 +1307,7 @@
 
 	/* Need one free entry.. */
 	if (includepath[INCLUDEPATHS-2])
-		error(token->pos, "too many include path entries");
+		error_die(token->pos, "too many include path entries");
 
 	next = path;
 	dst = sys_includepath;
@@ -1335,7 +1335,7 @@
 		if (eof_token(token))
 			return 1;
 		if (token_type(token) != TOKEN_STRING) {
-			warn(token->pos, "expected path string");
+			warning(token->pos, "expected path string");
 			return 1;
 		}
 		add_path_entry(token, token->string->data);
@@ -1428,7 +1428,7 @@
 			return;
 	}
 
-	warn(token->pos, "unrecognized preprocessor line '%s'", show_token_sequence(token));
+	warning(token->pos, "unrecognized preprocessor line '%s'", show_token_sequence(token));
 }
 
 static void preprocessor_line(struct stream *stream, struct token **line)
@@ -1464,7 +1464,7 @@
 		switch (token_type(next)) {
 		case TOKEN_STREAMEND:
 			if (stream->nesting < if_nesting + 1) {
-				warn(unmatched_if->pos, "unterminated preprocessor conditional");
+				warning(unmatched_if->pos, "unterminated preprocessor conditional");
 				// Pretend to see a series of #endifs
 				MARK_STREAM_NONCONST(next->pos);
 				do {
diff -Nru a/show-parse.c b/show-parse.c
--- a/show-parse.c	2004-09-13 10:49:00 -04:00
+++ b/show-parse.c	2004-09-13 10:49:00 -04:00
@@ -586,7 +586,7 @@
 	int framesize;
 
 	if (!expr->ctype) {
-		warn(expr->pos, "\tcall with no type!");
+		warning(expr->pos, "\tcall with no type!");
 		return 0;
 	}
 
@@ -994,7 +994,7 @@
 	case EXPR_DEREF:
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warn(expr->pos, "invalid expression after evaluation");
+		warning(expr->pos, "invalid expression after evaluation");
 		return 0;
 	case EXPR_CAST:
 		return show_cast_expr(expr);
@@ -1021,16 +1021,16 @@
 	// None of these should exist as direct expressions: they are only
 	// valid as sub-expressions of initializers.
 	case EXPR_POS:
-		warn(expr->pos, "unable to show plain initializer position expression");
+		warning(expr->pos, "unable to show plain initializer position expression");
 		return 0;
 	case EXPR_IDENTIFIER:
-		warn(expr->pos, "unable to show identifier expression");
+		warning(expr->pos, "unable to show identifier expression");
 		return 0;
 	case EXPR_INDEX:
-		warn(expr->pos, "unable to show index expression");
+		warning(expr->pos, "unable to show index expression");
 		return 0;
 	case EXPR_TYPE:
-		warn(expr->pos, "unable to show type expression");
+		warning(expr->pos, "unable to show type expression");
 		return 0;
 	}
 	return 0;
diff -Nru a/symbol.c b/symbol.c
--- a/symbol.c	2004-09-13 10:49:00 -04:00
+++ b/symbol.c	2004-09-13 10:49:00 -04:00
@@ -123,7 +123,7 @@
 		sym->offset = (bit_size - bit_offset) >> 3;
 		sym->bit_offset = bit_offset;
 		info->bit_size = bit_size + width;
-		// warn (sym->pos, "bitfield: offset=%d:%d  size=:%d", sym->offset, sym->bit_offset, width);
+		// warning (sym->pos, "bitfield: offset=%d:%d  size=:%d", sym->offset, sym->bit_offset, width);
 
 		return;
 	}
@@ -135,7 +135,7 @@
 	sym->offset = bit_size >> 3;
 
 	info->bit_size = bit_size + sym->bit_size;
-	// warn (sym->pos, "regular: offset=%d", sym->offset);
+	// warning (sym->pos, "regular: offset=%d", sym->offset);
 }
 
 static void examine_struct_union_type(struct symbol *sym, int advance)
@@ -182,7 +182,7 @@
 	examine_symbol_type(base_type);
 	bit_size = base_type->bit_size;
 	if (sym->fieldwidth > bit_size) {
-		warn(sym->pos, "impossible field-width, %d, for this type",
+		warning(sym->pos, "impossible field-width, %d, for this type",
 		     sym->fieldwidth);
 		sym->fieldwidth = bit_size;
 	}
@@ -257,7 +257,7 @@
 	case SYM_TYPEOF: {
 		struct symbol *base = evaluate_expression(sym->initializer);
 		if (is_bitfield_type (base))
-			warn(base->pos, "typeof applied to bitfield type");
+			warning(base->pos, "typeof applied to bitfield type");
 		if (base) {
 			if (base->type == SYM_NODE)
 				base = base->ctype.base_type;
@@ -266,10 +266,10 @@
 		}
 		break;
 	case SYM_PREPROCESSOR:
-		warn(sym->pos, "ctype on preprocessor command? (%s)", show_ident(sym->ident));
+		warning(sym->pos, "ctype on preprocessor command? (%s)", show_ident(sym->ident));
 		return NULL;
 	case SYM_UNINITIALIZED:
-		warn(sym->pos, "ctype on uninitialized symbol %p", sym);
+		warning(sym->pos, "ctype on uninitialized symbol %p", sym);
 		return NULL;
 	}
 	default:
@@ -332,7 +332,7 @@
 {
 	struct scope *scope;
 	if (sym->id_list) {
-		warn(sym->pos, "internal error: symbol type already bound");
+		warning(sym->pos, "internal error: symbol type already bound");
 		return;
 	}
 	sym->namespace = ns;
diff -Nru a/tokenize.c b/tokenize.c
--- a/tokenize.c	2004-09-13 10:49:00 -04:00
+++ b/tokenize.c	2004-09-13 10:49:00 -04:00
@@ -240,7 +240,7 @@
 	} else {
 		if (c == '\n') {
 			if (complain)
-				warn(stream->pos, "non-ASCII data stream");
+				warning(stream->pos, "non-ASCII data stream");
 			spliced = 1;
 			goto restart;
 		}
@@ -252,7 +252,7 @@
 out:
 	stream->offset = offset;
 	if (complain)
-		warn(stream->pos, "non-ASCII data stream");
+		warning(stream->pos, "non-ASCII data stream");
 
 	return c;
 
@@ -262,11 +262,11 @@
 		goto out;
 	}
 	if (stream->pos.pos)
-		warn(stream->pos, "no newline at end of file");
+		warning(stream->pos, "no newline at end of file");
 	else if (had_cr)
-		warn(stream->pos, "non-ASCII data stream");
+		warning(stream->pos, "non-ASCII data stream");
 	else if (spliced)
-		warn(stream->pos, "backslash-newline at end of file");
+		warning(stream->pos, "backslash-newline at end of file");
 	return EOF;
 }
 
@@ -433,7 +433,7 @@
 	value = first;
 
 	if (first == '\n')
-		warn(stream->pos, "Newline in string or character constant");
+		warning(stream->pos, "Newline in string or character constant");
 
 	if (first == '\\' && next != EOF) {
 		value = next;
@@ -471,7 +471,7 @@
 			case '"':
 				break;
 			case '\n':
-				warn(stream->pos, "Newline in string or character constant");
+				warning(stream->pos, "Newline in string or character constant");
 				break;
 			case '0'...'7': {
 				int nr = 2;
@@ -500,7 +500,7 @@
 			}
 			/* Fallthrough */
 			default:
-				warn(stream->pos, "Unknown escape '%c'", value);
+				warning(stream->pos, "Unknown escape '%c'", value);
 			}
 		}
 		/* Mark it as escaped */
@@ -517,7 +517,7 @@
 
 	next = escapechar(next, '\'', stream, &value);
 	if (value == '\'' || next != '\'') {
-		warn(stream->pos, "Bad character constant");
+		warning(stream->pos, "Bad character constant");
 		drop_token(stream);
 		return next;
 	}
@@ -543,7 +543,7 @@
 		if (val == '"')
 			break;
 		if (next == EOF) {
-			warn(stream->pos, "End of file in middle of string");
+			warning(stream->pos, "End of file in middle of string");
 			return next;
 		}
 		if (len < MAX_STRING)
@@ -552,7 +552,7 @@
 	}
 
 	if (len > MAX_STRING) {
-		warn(stream->pos, "string too long (%d bytes, %d bytes max)", len, MAX_STRING);
+		warning(stream->pos, "string too long (%d bytes, %d bytes max)", len, MAX_STRING);
 		len = MAX_STRING;
 	}
 
@@ -595,7 +595,7 @@
 	for (;;) {
 		int curr = next;
 		if (curr == EOF) {
-			warn(stream->pos, "End of file in the middle of a comment");
+			warning(stream->pos, "End of file in the middle of a comment");
 			return curr;
 		}
 		next = nextchar(stream);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK PATCH] warning -> error ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK PATCH] warning -> error
Date: Mon, 13 Sep 2004 20:33:48 +0000
Message-ID: <20040913203348.68CD51422D5E () darter ! rentec ! com>
--------------------

This changes a ton of warning() calls to error() calls.  The only effect
right now of that is that they will print "error", not "warning".  (Well,
and they get their own limit of 100.)

I could easily have forgotten a bunch.  We can fix those as we stumble
upon them.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c    |   64 ++++++++++++++++++++++++++++----------------------------
 expand.c      |   10 ++++----
 parse.c       |   66 +++++++++++++++++++++++++++++-----------------------------
 pre-process.c |    6 ++---
 4 files changed, 73 insertions(+), 73 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/13 1.793)
   Change many warning() calls to error() calls.

<welinder@troll.com> (04/09/13 1.792)
   Ok, unsigned it is.

<welinder@troll.com> (04/09/13 1.789.1.1)
   Allocate enough for a 32-bit integer.

diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-09-13 16:29:46 -04:00
+++ b/evaluate.c	2004-09-13 16:29:46 -04:00
@@ -40,17 +40,17 @@
 			expr->ctype = &int_ctype;
 			return &int_ctype;
 		}
-		warning(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		error(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
 	examine_symbol_type(sym);
 	if ((sym->ctype.context ^ current_context) & (sym->ctype.contextmask & current_contextmask))
-		warning(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
+		error(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
 
 	base_type = sym->ctype.base_type;
 	if (!base_type) {
-		warning(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		error(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -215,7 +215,7 @@
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warning(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
+	error(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -387,7 +387,7 @@
 
 	ctype = degenerate(ptr);
 	if (!ctype->ctype.base_type) {
-		warning(expr->pos, "missing type information");
+		error(expr->pos, "missing type information");
 		return NULL;
 	}
 
@@ -623,7 +623,7 @@
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warning(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			error(expr->pos, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -633,7 +633,7 @@
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warning(expr->pos, "subtraction of functions? Share your drugs");
+		error(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = ctype->ctype.base_type;
@@ -892,7 +892,7 @@
 	ctype = compatible_restricted_binop('?', &expr->left, &expr->right);
 	if (ctype)
 		goto out;
-	warning(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	error(expr->pos, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -963,7 +963,7 @@
 		}
 	}
 
-	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	error(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1069,7 +1069,7 @@
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		warning(expr->pos, "not an lvalue");
+		error(expr->pos, "not an lvalue");
 		return NULL;
 	}
 
@@ -1239,7 +1239,7 @@
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warning(expr->pos, "strange non-value function or array");
+			error(expr->pos, "strange non-value function or array");
 			return NULL;
 		}
 		*expr = *expr->unop;
@@ -1257,7 +1257,7 @@
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warning(expr->pos, "not addressable");
+		error(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1296,7 +1296,7 @@
 
 	switch (ctype->type) {
 	default:
-		warning(expr->pos, "cannot derefence this type");
+		error(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		merge_type(node, ctype);
@@ -1318,7 +1318,7 @@
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warning(op->pos, "non-lvalue array??");
+			error(op->pos, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1350,11 +1350,11 @@
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		warning(expr->pos, "need lvalue expression for ++/--");
+		error(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warning(expr->pos, "bad operation on restricted");
+		error(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1510,7 +1510,7 @@
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warning(expr->pos, "bad member name");
+		error(expr->pos, "bad member name");
 		return NULL;
 	}
 
@@ -1523,7 +1523,7 @@
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warning(expr->pos, "expected structure or union");
+		error(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1536,8 +1536,8 @@
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warning(expr->pos, "no member '%s' in %s %.*s",
-			show_ident(ident), type, namelen, name);
+		error(expr->pos, "no member '%s' in %s %.*s",
+		      show_ident(ident), type, namelen, name);
 		return NULL;
 	}
 
@@ -1641,7 +1641,7 @@
 				size = bits_in_int;
 		}
 		if (is_bitfield_type(what->ctype))
-			warning(expr->pos, "sizeof applied to bitfield type");
+			error(expr->pos, "sizeof applied to bitfield type");
 	}
 	if (size & 7)
 		warning(expr->pos, "cannot size expression");
@@ -1661,7 +1661,7 @@
 			return NULL;
 	}
 	if (is_bitfield_type(type))
-		warning(expr->pos, "alignof applied to bitfield type");
+		error(expr->pos, "alignof applied to bitfield type");
 	examine_symbol_type(type);
 	expr->type = EXPR_VALUE;
 	expr->value = type->ctype.alignment;
@@ -1693,7 +1693,7 @@
 			return 0;
 
 		if (context_clash(f, ctype))
-			warning(expr->pos, "argument %d used in wrong context", i);
+			error(expr->pos, "argument %d used in wrong context", i);
 
 		ctype = degenerate(expr);
 
@@ -1749,7 +1749,7 @@
 static int evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr, unsigned long offset)
 {
 	if (offset || expression_list_size(expr->expr_list) != 1) {
-		warning(expr->pos, "unexpected compound initializer");
+		error(expr->pos, "unexpected compound initializer");
 		return 0;
 	}
 	return evaluate_array_initializer(ctype, expr, 0);
@@ -1772,7 +1772,7 @@
 			RESET_PTR_LIST(sym);
 			for (;;) {
 				if (!sym) {
-					warning(entry->pos, "unknown named initializer '%s'", show_ident(ident));
+					error(entry->pos, "unknown named initializer '%s'", show_ident(ident));
 					return 0;
 				}
 				if (sym->ident == ident)
@@ -1783,7 +1783,7 @@
 		}
 
 		if (!sym) {
-			warning(expr->pos, "too many initializers for struct/union");
+			error(expr->pos, "too many initializers for struct/union");
 			return 0;
 		}
 
@@ -1957,7 +1957,7 @@
 		warning(expr->pos, "cast to non-scalar");
 
 	if (!target->ctype) {
-		warning(expr->pos, "cast from unknown type");
+		error(expr->pos, "cast from unknown type");
 		goto out;
 	}
 
@@ -2052,7 +2052,7 @@
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warning(expr->pos, "not a function %s", show_ident(sym->ident));
+		error(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
@@ -2079,7 +2079,7 @@
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warning(expr->pos, "value expression without a type");
+		error(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2129,7 +2129,7 @@
 	case EXPR_CALL:
 		return evaluate_call(expr);
 	case EXPR_BITFIELD:
-		warning(expr->pos, "bitfield generated by parser");
+		error(expr->pos, "bitfield generated by parser");
 		return NULL;
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
@@ -2160,10 +2160,10 @@
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warning(expr->pos, "internal front-end error: initializer in expression");
+		error(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
+		error(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-09-13 16:29:46 -04:00
+++ b/expand.c	2004-09-13 16:29:46 -04:00
@@ -739,7 +739,7 @@
 		return expand_call(expr);
 
 	case EXPR_DEREF:
-		warning(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
+		error(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
 		return UNSAFE;
 
 	case EXPR_BITFIELD:
@@ -772,7 +772,7 @@
 
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warning(expr->pos, "internal front-end error: sizeof in expansion?");
+		error(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -783,7 +783,7 @@
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warning(expr->pos, "Expected constant expression in %s", where);
+			error(expr->pos, "Expected constant expression in %s", where);
 	}
 }
 
@@ -919,12 +919,12 @@
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warning(expr->pos, "bad constant expression type");
+		error(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warning(expr->pos, "bad constant expression");
+		error(expr->pos, "bad constant expression");
 		return 0;
 	}
 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-09-13 16:29:46 -04:00
+++ b/parse.c	2004-09-13 16:29:46 -04:00
@@ -134,7 +134,7 @@
 
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected declaration");
+		error(token->pos, "expected declaration");
 		ctype->base_type = &bad_type;
 		return token;
 	}
@@ -193,7 +193,7 @@
 	struct symbol *sym;
 
 	if (!match_op(token, '(')) {
-		warning(token->pos, "expected '(' after typeof");
+		error(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -351,7 +351,7 @@
 	token = expect(token, '(', "after attribute");
 
 	for (;;) {
-		const char *error;
+		const char *err;
 		struct ident *attribute_name;
 		struct expression *attribute_expr;
 
@@ -366,9 +366,9 @@
 		attribute_expr = NULL;
 		if (match_op(token, '('))
 			token = parens_expression(token, &attribute_expr, "in attribute");
-		error = handle_attribute(ctype, attribute_name, attribute_expr);
-		if (error)
-			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
+		err = handle_attribute(ctype, attribute_name, attribute_expr);
+		if (err)
+			error(token->pos, "attribute '%s': %s", show_ident(attribute_name), err);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -440,29 +440,29 @@
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warning(pos, "Just how %sdo you want this type to be?",
-				modifier_string(dup));
+			error(pos, "Just how %sdo you want this type to be?",
+			      modifier_string(dup));
 
 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warning(pos, "You cannot have both long and short modifiers.");
+			error(pos, "You cannot have both long and short modifiers.");
 
 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warning(pos, "You cannot have both signed and unsigned modifiers.");
+			error(pos, "You cannot have both signed and unsigned modifiers.");
 
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warning(pos, "multiple storage classes");
+			error(pos, "multiple storage classes");
 
 		ctype->modifiers = old | mod | extra;
 	}
 
 	/* Context mask and value */
 	if ((ctype->context ^ thistype->context) & (ctype->contextmask & thistype->contextmask)) {
-		warning(pos, "inconsistent attribute types");
+		error(pos, "inconsistent attribute types");
 		thistype->context = 0;
 		thistype->contextmask = 0;
 	}
@@ -471,7 +471,7 @@
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
-		warning(pos, "I don't like non-power-of-2 alignments");
+		error(pos, "I don't like non-power-of-2 alignments");
 		thistype->alignment = 0;
 	}
 	if (thistype->alignment > ctype->alignment)
@@ -506,8 +506,8 @@
 
 	wrong = mod & banned;
 	if (wrong)
-		warning(*pos, "modifier %sis invalid in this context",
-		     modifier_string (wrong));
+		error(*pos, "modifier %sis invalid in this context",
+		      modifier_string (wrong));
 }
 
 
@@ -588,7 +588,7 @@
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warning(token->pos, "invalid modifier");
+			error(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -724,7 +724,7 @@
 	long long width;
 
 	if (!is_int_type(ctype->base_type)) {
-		warning(token->pos, "invalid bitfield specifier for type %s.",
+		error(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -736,10 +736,10 @@
 	bitfield->fieldwidth = width;
 
 	if (width < 0) {
-		warning(token->pos, "invalid negative bitfield width, %lld.", width);
+		error(token->pos, "invalid negative bitfield width, %lld.", width);
 		bitfield->fieldwidth = 8;
 	} else if (decl->ident && width == 0) {
-		warning(token->pos, "invalid named zero-width bitfield `%s'",
+		error(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		bitfield->fieldwidth = 8;
 	} else if (width != bitfield->fieldwidth) {
@@ -787,7 +787,7 @@
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warning(token->pos, "expected ; at end of declaration");
+			error(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1013,7 +1013,7 @@
 	struct symbol *sym;
 
 	if (!target) {
-		warning(stmt->pos, "not in switch scope");
+		error(stmt->pos, "not in switch scope");
 		return;
 	}
 	sym = alloc_symbol(stmt->pos, SYM_NODE);
@@ -1096,7 +1096,7 @@
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warning(token->pos, "expected 'while' after 'do'");
+		error(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");
 
 	stmt->iterator_post_condition = expr;
@@ -1131,7 +1131,7 @@
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warning(stmt->pos, "break/continue not in iterator scope");
+				error(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1175,7 +1175,7 @@
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warning(token->pos, "Expected identifier or goto expression");
+				error(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1233,7 +1233,7 @@
 
 		if (match_op(token, SPECIAL_ELLIPSIS)) {
 			if (!*list)
-				warning(token->pos, "variadic functions must have one named argument");
+				error(token->pos, "variadic functions must have one named argument");
 			fn->variadic = 1;
 			token = token->next;
 			break;
@@ -1245,7 +1245,7 @@
 			/* Special case: (void) */
 			if (!*list && !sym->ident)
 				break;
-			warning(token->pos, "void parameter");
+			error(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
@@ -1284,7 +1284,7 @@
 	if (to) {
 		idx_to = get_expression_value(to);
 		if (idx_to < idx_from || idx_from < 0)
-			warning(from->pos, "nonsense array initializer index range");
+			error(from->pos, "nonsense array initializer index range");
 	}
 	expr->idx_from = idx_from;
 	expr->idx_to = idx_to;
@@ -1339,7 +1339,7 @@
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warning(sym->pos, "no identifier for function argument");
+		error(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1417,7 +1417,7 @@
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warning(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
+		error(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1429,7 +1429,7 @@
 
 	FOR_EACH_PTR(argtypes, arg) {
 		if (!arg->used)
-			warning(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
+			error(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
 	} END_FOR_EACH_PTR(arg);
 
 }
@@ -1447,7 +1447,7 @@
 	apply_k_r_types(args, decl);
 
 	if (!match_op(token, '{')) {
-		warning(token->pos, "expected function body");
+		error(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1513,7 +1513,7 @@
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (!is_typedef && base_type == &void_ctype && !(decl->ctype.modifiers & MOD_EXTERN)) {
-		warning(token->pos, "void declaration");
+		error(token->pos, "void declaration");
 	}
 
 	for (;;) {
@@ -1552,7 +1552,7 @@
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, &decl, &ident);
 		if (!ident) {
-			warning(token->pos, "expected identifier name in type definition");
+			error(token->pos, "expected identifier name in type definition");
 			return token;
 		}
 
diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-13 16:29:46 -04:00
+++ b/pre-process.c	2004-09-13 16:29:46 -04:00
@@ -88,8 +88,7 @@
 static void replace_with_integer(struct token *token, unsigned int val)
 {
 	char *buf = __alloc_bytes(11);
-	// FIXME: to be signed or not to be
-	sprintf(buf, "%d", val);
+	sprintf(buf, "%u", val);
 	token_type(token) = TOKEN_NUMBER;
 	token->number = buf;
 }
diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-13 16:29:47 -04:00
+++ b/pre-process.c	2004-09-13 16:29:47 -04:00
@@ -87,7 +87,8 @@
 
 static void replace_with_integer(struct token *token, unsigned int val)
 {
-	char *buf = __alloc_bytes(10);
+	char *buf = __alloc_bytes(11);
+	// FIXME: to be signed or not to be
 	sprintf(buf, "%d", val);
 	token_type(token) = TOKEN_NUMBER;
 	token->number = buf;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [BK] Patch flood ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [BK] Patch flood
Date: Fri, 13 Aug 2004 15:56:02 +0000
Message-ID: <20040813155602.916461422D58 () darter ! rentec ! com>
--------------------

I fixed a minor conflict with Al Viro's slicing stuff.  Of course that
seems to totally screw the way I was generating patch, so...

I created a new repository without anything remotely controversial.
However, I cannot seem to completely remove a changeset in the middle,
so I had to "cset -x" the potentially controversial ones.  The final
effect should be the same.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 cgcc          |   22 +++++++
 check.c       |    5 +
 expand.c      |   21 +++++--
 lib.c         |  169 ++++++++++++++++++++++++++++++++--------------------------
 lib.h         |    8 +-
 parse.c       |  102 +++++++++++++++++++++++++++--------
 pre-process.c |    4 -
 show-parse.c  |    2 
 symbol.c      |   23 ++++++-
 symbol.h      |    1 
 10 files changed, 241 insertions(+), 116 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/13 1.729)
   Fix merge issue with Al's stuff.

<welinder@troll.com> (04/08/13 1.728)
   Cset exclude: welinder@troll.com|ChangeSet|20040812190944|57264
   Cset exclude: welinder@troll.com|ChangeSet|20040812190029|57250
   Cset exclude: welinder@troll.com|ChangeSet|20040812184608|57271
   Cset exclude: welinder@troll.com|ChangeSet|20040812175907|57697
   Cset exclude: welinder@troll.com|ChangeSet|20040812160921|53242

<welinder@troll.com> (04/08/12 1.726)  [EXCLUDED by 1.728]
   lib.c:
     Muck with solaris predefines to suit solaris libc.

<welinder@troll.com> (04/08/12 1.725)  [EXCLUDED by 1.728]
   lib.c:
     Linux/Solaris split.  Keep it minimal for now.

<welinder@troll.com> (04/08/12 1.724)  [EXCLUDED by 1.728]
   expand.c:
     Don't complain over undefined preprocessor symbols that start
     with an underscore.
     This helps quiet a gazillion errors with _cplusplus and others
     used by solaris' system headers.
     This change may or may not be approapriate on a glibc system.

<welinder@troll.com> (04/08/12 1.723)
   check.c:
     Use __SIZE_TYPE__
     Define __builtin_alloca.
   lib.c:
     Pre-define __SIZE_TYPE__

<welinder@troll.com> (04/08/12 1.722)
   lib.c:
     Add __unix__ and variants to create_builtin_stream.

<welinder@troll.com> (04/08/12 1.721)  [EXCLUDED by 1.728]
   lib.c, lib.h:
     Under __sun__, implement a strtold.

<welinder@troll.com> (04/08/12 1.720)
   parse.c:
     Don't clear MOD_EXPLICITLY_SIGNED in indirect.\
   symbol.c:
     Add modifier MOD_EXPLICITLY_SIGNED to all versions of "signed".
     check for integer bitfields that are just "int foo : 42".
   symbol.h:
     Define MOD_EXPLICITLY_SIGNED.
     This will be used to distinguish "int" and "signed int".
   show-parse.c:
     Show MOD_EXPLICITLY_SIGNED as "[explicitly-signed]".

<welinder@troll.com> (04/08/12 1.719)
   parse.c:
     Move bitfield parsing into struct/union parsing where it belongs.
     Sanity check bitfield widths.

<welinder@troll.com> (04/08/12 1.718)
   symbol.c:
     Check for signed one-bit bitfields.

<welinder@troll.com> (04/08/12 1.717)
   parse.c:
     Handle __noreturn__ as noreturn (==ignore).

<welinder@troll.com> (04/08/12 1.716)
   parse.c:
     Disallow "void" parameters and "void" variables.

<welinder@troll.com> (04/08/12 1.715)
   parse.c:
     Check that "signed", "unsigned", "long", ... only occur where they may.
     Notably not as "signed double" or "long struct { ... }".

<welinder@troll.com> (04/08/12 1.714)
   pre-process.c, lib.c:
     Never call isdigit/isspace on type char, use unsigned char only.

<welinder@troll.com> (04/08/12 1.713)
   parse.c:
     Check for multiple storage classes such as "static extern".

<welinder@troll.com> (04/08/12 1.712)
   lib.c:
     Handle -MF foo, -MQ foo, and -MT foo.

<welinder@troll.com> (04/08/12 1.711)
   expand.c:
     Handle integer overflow in unary minus.

<welinder@troll.com> (04/08/12 1.710)
   pre-process.c:
     Gnome needs lots of -Ipath -- just up the limit a whole lot.

<welinder@troll.com> (04/08/12 1.709)
   Wrapper to run check and gcc in series.

<welinder@troll.com> (04/08/12 1.708)  [EXCLUDED by 1.728]
   config:
     MW prefs.




diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/check.c sparse-for-linus/check.c
--- linus-sparse/check.c	Fri Aug 13 11:48:01 2004
+++ sparse-for-linus/check.c	Fri Aug 13 11:10:21 2004
@@ -49,11 +49,12 @@
 
 	create_builtin_stream();
 	add_pre_buffer("#define __CHECKER__ 1\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, unsigned long);\n");
+	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
 	add_pre_buffer("extern void *__builtin_return_address(int);\n");
-	add_pre_buffer("extern void *__builtin_memset(void *, int, unsigned long);\n");	
+	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
+	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
 
 	args = argv;
 	for (;;) {
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/expand.c sparse-for-linus/expand.c
--- linus-sparse/expand.c	Fri Aug 13 11:48:01 2004
+++ sparse-for-linus/expand.c	Fri Aug 13 11:20:11 2004
@@ -544,19 +544,28 @@
 
 	if (op->type != EXPR_VALUE)
 		return 0;
+
+	mask = 1ULL << (expr->ctype->bit_size-1);
 	v = op->value;
 	switch (expr->op) {
 	case '+': break;
-	case '-': v = -v; break;
+	case '-':
+		if (v == mask && !(expr->ctype->ctype.modifiers & MOD_UNSIGNED))
+			goto Overflow;
+		v = -v;
+		break;
 	case '!': v = !v; break;
 	case '~': v = ~v; break;
 	default: return 0;
 	}
-	mask = 1ULL << (expr->ctype->bit_size-1);
 	mask = mask | (mask-1);
 	expr->value = v & mask;
 	expr->type = EXPR_VALUE;
 	return 1;
+
+Overflow:
+	warn(expr->pos, "constant integer operation overflow");
+	return 0;
 }
 
 static int simplify_float_preop(struct expression *expr)
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/lib.c sparse-for-linus/lib.c
--- linus-sparse/lib.c	Fri Aug 13 11:48:02 2004
+++ sparse-for-linus/lib.c	Fri Aug 13 11:52:12 2004
@@ -569,7 +569,7 @@
 		c = *++arg;
 		if (!c)
 			break;
-		if (isspace(c) || c == '=') {
+		if (isspace((unsigned char)c) || c == '=') {
 			*arg = '\0';
 			value = arg + 1;
 			break;
@@ -616,6 +616,16 @@
 	return next;
 }
 
+char **handle_switch_M(char *arg, char **next)
+{
+	if (!strcmp(arg, "MF") || !strcmp(arg,"MQ") || !strcmp(arg,"MT")) {
+		if (!*next)
+			die("missing argument for -%s option", arg);
+		return next + 1;
+	}
+	return next;
+}
+
 char **handle_switch_m(char *arg, char **next)
 {
 	if (!strcmp(arg, "m64")) {
@@ -645,6 +655,7 @@
 	case 'v': rc = handle_switch_v(arg, next); break;
 	case 'I': rc = handle_switch_I(arg, next); break;
 	case 'i': rc = handle_switch_i(arg, next); break;
+	case 'M': rc = handle_switch_M(arg, next); break;
 	case 'm': rc = handle_switch_m(arg, next); break;
 	case 'o': rc = handle_switch_o(arg, next); break;
 	default:
@@ -660,13 +671,21 @@
 void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __linux__ 1\n");
-	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define linux linux\n");
+	add_pre_buffer("#define unix 1\n");
+	add_pre_buffer("#define __unix 1\n");
+	add_pre_buffer("#define __unix__ 1\n");
+	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __func__ \"function\"\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
+	// gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
+	// solaris/sparc that is really "unsigned int" and for linux/x86_64
+	// it is "long unsigned int".  In either case we can probably
+	// get away with this:
+	add_pre_buffer("#define __SIZE_TYPE__ long unsigned int\n");
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/parse.c sparse-for-linus/parse.c
--- linus-sparse/parse.c	Fri Aug 13 11:48:02 2004
+++ sparse-for-linus/parse.c	Fri Aug 13 11:52:12 2004
@@ -68,7 +68,7 @@
 	struct symbol *sym = alloc_symbol(pos, type);
 
 	sym->ctype.base_type = ctype->base_type;
-	sym->ctype.modifiers = ctype->modifiers & ~MOD_STORAGE;
+	sym->ctype.modifiers = ctype->modifiers & ~(MOD_STORAGE | MOD_EXPLICITLY_SIGNED);
 
 	ctype->base_type = sym;
 	ctype->modifiers &= MOD_STORAGE;
@@ -301,7 +301,8 @@
 	if (match_string_ident(attribute, "const") ||
 	    match_string_ident(attribute, "__const__"))
 		return NULL;
-	if (match_string_ident(attribute, "noreturn"))
+	if (match_string_ident(attribute, "noreturn") ||
+	    match_string_ident(attribute, "__noreturn__"))
 		return NULL;
 	if (match_string_ident(attribute, "regparm"))
 		return NULL;
@@ -420,12 +421,18 @@
 		if (conflict)
 			warn(pos, "You cannot have both signed and unsigned modifiers.");
 
+		// Only one storage modifier allowed, except that "inline" doesn't count.
+		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
+		conflict &= (conflict - 1);
+		if (conflict)
+			warn(pos, "multiple storage classes");
+
 		ctype->modifiers = old | mod | extra;
 	}
 
 	/* Context mask and value */
 	if ((ctype->context ^ thistype->context) & (ctype->contextmask & thistype->contextmask)) {
-		warn(pos, "inconsistend attribute types");
+		warn(pos, "inconsistent attribute types");
 		thistype->context = 0;
 		thistype->contextmask = 0;
 	}
@@ -444,6 +451,35 @@
 	ctype->as = thistype->as;
 }
 
+static void check_modifiers(struct position *pos, struct symbol *s, unsigned long mod)
+{
+	unsigned long banned, wrong;
+	unsigned long this_mod = s->ctype.modifiers;
+	const unsigned long BANNED_SIZE = MOD_LONG | MOD_LONGLONG | MOD_SHORT;
+	const unsigned long BANNED_SIGN = MOD_SIGNED | MOD_UNSIGNED;
+
+	if (this_mod & (MOD_STRUCTOF | MOD_UNIONOF | MOD_ENUMOF))
+		banned = BANNED_SIZE | BANNED_SIGN;
+	else if (this_mod & MOD_SPECIALBITS)
+		banned = 0;
+	else if (s->ctype.base_type == &fp_type)
+		banned = BANNED_SIGN;
+	else if (s->ctype.base_type == &int_type || !s->ctype.base_type || is_int_type (s))
+		banned = 0;
+	else {
+		// label_type
+		// void_type
+		// bad_type
+		// vector_type <-- whatever that is
+		banned = BANNED_SIZE | BANNED_SIGN;
+	}
+
+	wrong = mod & banned;
+	if (wrong)
+		warn(*pos, "modifier %sis invalid in this context",
+		     modifier_string (wrong));
+}
+
 
 static struct token *declaration_specifiers(struct token *next, struct ctype *ctype, int qual)
 {
@@ -467,6 +503,7 @@
 		mod = thistype.modifiers;
 		if (qual && (mod & ~(MOD_ATTRIBUTE | MOD_CONST | MOD_VOLATILE)))
 			break;
+		check_modifiers(&token->pos, s, ctype->modifiers);
 		if (mod & MOD_SPECIALBITS) {
 			if (mod & MOD_STRUCTOF)
 				next = struct_or_union_specifier(SYM_STRUCT, next, &thistype);
@@ -589,21 +626,6 @@
 			ctype = &array->ctype;
 			continue;
 		}
-		if (token->special == ':') {
-			if (is_int_type (ctype->base_type)) {
-				struct symbol *bitfield = indirect(token->pos, ctype, SYM_BITFIELD);
-				struct expression *expr;
-				token = conditional_expression(token->next, &expr);
-				bitfield->fieldwidth = get_expression_value(expr);
-			} else
-				error(token->pos, "Invalid bitfield specifier for type %s.", show_typename (ctype->base_type));
-			while (match_idents(token, &__attribute___ident, &__attribute_ident, NULL)) {
-				struct ctype thistype = { 0, };
-				token = attribute_specifier(token->next, &thistype);
-				apply_ctype(token->pos, &thistype, ctype);
-			}
-			break;
-		}
 		break;
 	}
 	if (p) {
@@ -660,8 +682,39 @@
 			decl->ctype = ctype;
 			token = declarator(token, &decl, &ident);
 			if (match_op(token, ':')) {
+				struct ctype *ctype = &decl->ctype;
 				struct expression *expr;
-				token = parse_expression(token->next, &expr);
+				struct symbol *bitfield;
+				long long width;
+
+				if (is_int_type (ctype->base_type)) {
+					bitfield = indirect(token->pos, ctype, SYM_BITFIELD);
+					token = conditional_expression(token->next, &expr);
+					width = get_expression_value(expr);
+					bitfield->fieldwidth = width;
+					if (width < 0) {
+						warn(token->pos, "invalid negative bitfield width, %lld.", width);
+						bitfield->fieldwidth = 8;
+					} else if (decl->ident && width == 0) {
+						warn(token->pos, "invalid named zero-width bitfield `%s'",
+						     show_ident (decl->ident));
+						bitfield->fieldwidth = 8;
+					} else if (width != bitfield->fieldwidth) {
+						// Overflow.
+						unsigned int stupid_gcc = -1;
+						bitfield->fieldwidth = stupid_gcc;
+						warn(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
+					}
+				} else {
+					warn(token->pos, "invalid bitfield specifier for type %s.", show_typename (ctype->base_type));
+					// Parse this to recover gracefully.
+					token = conditional_expression(token->next, &expr);
+				}
+				while (match_idents(token, &__attribute___ident, &__attribute_ident, NULL)) {
+					struct ctype thistype = { 0, };
+					token = attribute_specifier(token->next, &thistype);
+					apply_ctype(token->pos, &thistype, ctype);
+				}
 			}
 			add_symbol(list, decl);
 			if (!match_op(token, ','))
@@ -1088,9 +1141,12 @@
 			break;
 		}
 		token = parameter_declaration(token, &sym);
-		/* Special case: (void) */
-		if (!*list && !sym->ident && sym->ctype.base_type == &void_ctype)
-			break;
+		if (sym->ctype.base_type == &void_ctype) {
+			/* Special case: (void) */
+			if (!*list && !sym->ident)
+				break;
+			warn(token->pos, "void parameter");
+		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
 			break;
@@ -1289,6 +1345,8 @@
 
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
+	} else if (!is_typedef && base_type == &void_ctype) {
+		warn(token->pos, "void declaration");
 	}
 
 	for (;;) {
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/pre-process.c sparse-for-linus/pre-process.c
--- linus-sparse/pre-process.c	Fri Aug 13 11:48:02 2004
+++ sparse-for-linus/pre-process.c	Fri Aug 13 11:10:22 2004
@@ -36,7 +36,7 @@
 static char elif_ignore[MAX_NEST];
 #define if_nesting (true_nesting + false_nesting)
 
-#define INCLUDEPATHS 32
+#define INCLUDEPATHS 300
 const char *includepath[INCLUDEPATHS+1] = {
 	NULL
 };
@@ -368,7 +368,7 @@
 		return TOKEN_NUMBER;
 	}
 
-	if (p[0] == '.' && isdigit(p[1]))
+	if (p[0] == '.' && isdigit((unsigned char)p[1]))
 		return TOKEN_NUMBER;
 
 	return TOKEN_SPECIAL;
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/show-parse.c sparse-for-linus/show-parse.c
--- linus-sparse/show-parse.c	Fri Aug 13 11:48:02 2004
+++ sparse-for-linus/show-parse.c	Fri Aug 13 11:10:22 2004
@@ -78,7 +78,7 @@
 		"[typeof]", "[attribute]", "inline", "[addressable]",
 		"[nocast]", "[noderef]", "[accessed]", "[toplevel]",
 		"[label]", "[assigned]", "[type]", "[safe]",
-		"[usertype]", "[force]",
+		"[usertype]", "[force]", "[explicitly-signed]",
 		NULL
 	};
 	ptr = names;
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/symbol.c sparse-for-linus/symbol.c
--- linus-sparse/symbol.c	Fri Aug 13 11:48:02 2004
+++ sparse-for-linus/symbol.c	Fri Aug 13 11:10:22 2004
@@ -161,15 +161,30 @@
 {
 	struct symbol *base_type = sym->ctype.base_type;
 	unsigned long bit_size, alignment;
+	int is_signed;
 
 	if (!base_type)
 		return;
 	examine_symbol_type(base_type);
 	bit_size = base_type->bit_size;
 	if (sym->fieldwidth > bit_size) {
-		warn(sym->pos, "impossible field-width for this type");
+		warn(sym->pos, "impossible field-width, %d, for this type",
+		     sym->fieldwidth);
 		sym->fieldwidth = bit_size;
 	}
+
+	is_signed = !(base_type->ctype.modifiers & MOD_UNSIGNED);
+	if (sym->fieldwidth == 1 && is_signed) {
+		// Valid values are either {-1;0} or {0}, depending on integer
+		// representation.  The latter makes for very efficient code...
+		warn(sym->pos, "dubious one-bit signed bitfield");
+	}
+	if (base_type->type != SYM_ENUM &&
+	    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) && is_signed) {
+		// The sign of bitfields is unspecified by default.
+		warn (sym->pos, "dubious bitfield without explicit `signed' or `unsigned'");
+	}
+
 	alignment = base_type->ctype.alignment;
 	if (!sym->ctype.alignment)
 		sym->ctype.alignment = alignment;
@@ -388,9 +403,9 @@
 	{ "long",	NULL,		MOD_LONG },
 	{ "float",	&fp_type,	0 },
 	{ "double",	&fp_type,	MOD_LONG },
-	{ "signed",	NULL,		MOD_SIGNED },
-	{ "__signed",	NULL,		MOD_SIGNED },
-	{ "__signed__",	NULL,		MOD_SIGNED },
+	{ "signed",	NULL,		MOD_SIGNED | MOD_EXPLICITLY_SIGNED },
+	{ "__signed",	NULL,		MOD_SIGNED | MOD_EXPLICITLY_SIGNED },
+	{ "__signed__",	NULL,		MOD_SIGNED | MOD_EXPLICITLY_SIGNED },
 	{ "unsigned",	NULL,		MOD_UNSIGNED },
 	{ "__label__",	&label_type,	MOD_LABEL | MOD_UNSIGNED },
 
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/symbol.h sparse-for-linus/symbol.h
--- linus-sparse/symbol.h	Fri Aug 13 11:48:02 2004
+++ sparse-for-linus/symbol.h	Fri Aug 13 11:10:22 2004
@@ -143,6 +143,7 @@
 
 #define MOD_USERTYPE	0x10000000
 #define MOD_FORCE	0x20000000
+#define MOD_EXPLICITLY_SIGNED	0x40000000
 
 /* Basic types */
 extern struct symbol	void_type,
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK] Patch flood
Date: Fri, 13 Aug 2004 19:15:41 +0000
Message-ID: <Pine.LNX.4.58.0408131206410.1839 () ppc970 ! osdl ! org>
--------------------


On Fri, 13 Aug 2004, Morten Welinder wrote:
> 
> I fixed a minor conflict with Al Viro's slicing stuff.  Of course that
> seems to totally screw the way I was generating patch, so...

Ok. That

	warning: dubious bitfield without explicit `signed' or `unsigned'

triggers a fair amount on the kernel. Some of them seem to be valid, but
in general I wonder if we shouldn't just make it a "verbose" warning, and
make the sign of a bitfield follow the sign of the base type (that seems
to be what gcc does). Undefined behaviour or not, I can't imagine that 
anybody does anything else.

Which leaves the 

	warning: dubious one-bit signed bitfield

which I think I heartily agree with. That is indeed dubious. 

Oh, and Morten:

	arch/ppc64/kernel/sys_ppc32.c:572:16: warning: incorrect type in initializer (different modifiers)
	arch/ppc64/kernel/sys_ppc32.c:572:16:    expected int const [noderef] *__gu_addr<asn:1>
	arch/ppc64/kernel/sys_ppc32.c:572:16:    got int [noderef] [usertype] [explicitly-signed] *offset<asn:1>

it seems you clear the MOD_EXPLICITLY_SIGNED thing on indirect(), which is
very confusing, since it's not cleared anywhere else. Why?

Either it should be ignored entirely for type comparisons (add it to
MOD_IGNORE), or it should at least not be sometimes cleared, sometimes
not. As it is, you get the warning even for the same type depending on how
the type has been generated (the above was due to a "typeof" thing).

I kind of like having the explicit sign as part of the type, but at the
same time it's certainly questionable whether

	signed int a;
	int b;

	if (&a == &b)

should generate a warning..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [BK] Patch flood
Date: Fri, 13 Aug 2004 21:04:15 +0000
Message-ID: <20040813210415.69ED91422D58 () darter ! rentec ! com>
--------------------

>   warning: dubious bitfield without explicit `signed' or `unsigned'
>
> triggers a fair amount on the kernel. Some of them seem to be valid, but
> in general I wonder if we shouldn't just make it a "verbose" warning, and
> make the sign of a bitfield follow the sign of the base type (that seems
> to be what gcc does). Undefined behaviour or not, I can't imagine that 
> anybody does anything else.

I have make an option, sure.  "-Wdefault_bitfield_sign" or "-v"?
For now, I have just made it ignore unnamed bitfields.

Considering the number of "int foo:1" fields I have been, it does look like
half the world still thinks in terms of K&R's unsigned-only bitfields.

> it seems you clear the MOD_EXPLICITLY_SIGNED thing on indirect(), which is
> very confusing, since it's not cleared anywhere else. Why?

Excellent question.  I think the [bad] answer is that at one time I was
testing the signedness of the wrong modifier.  I added it to MOD_IGNORE
where MOD_SIGNED and MOD_UNSIGNED are present too.  The noise-to-signal
ratio may be too high otherwise.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c |    4 +++-
 parse.c    |   18 +++++++++++++++++-
 symbol.c   |   13 -------------
 3 files changed, 20 insertions(+), 15 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/13 1.732)
   evaluate.c:
     Ignore MOD_EXPLICITLY_SIGNED for type comparisons.

<welinder@troll.com> (04/08/13 1.731)
   Don't complain over sign problems with unnamed bitfields.

diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/evaluate.c sparse-for-linus/evaluate.c
--- linus-sparse/evaluate.c	Fri Aug 13 17:02:10 2004
+++ sparse-for-linus/evaluate.c	Fri Aug 13 17:02:27 2004
@@ -379,7 +379,9 @@
 }
 
 #define MOD_SIZE (MOD_CHAR | MOD_SHORT | MOD_LONG | MOD_LONGLONG)
-#define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE | MOD_SIGNED | MOD_UNSIGNED | MOD_ASSIGNED | MOD_USERTYPE | MOD_FORCE | MOD_ACCESSED)
+#define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
+	MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED |		\
+	MOD_ASSIGNED | MOD_USERTYPE | MOD_FORCE | MOD_ACCESSED)
 
 const char * type_difference(struct symbol *target, struct symbol *source,
 	unsigned long target_mod_ignore, unsigned long source_mod_ignore)
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/parse.c sparse-for-linus/parse.c
--- linus-sparse/parse.c	Fri Aug 13 17:02:10 2004
+++ sparse-for-linus/parse.c	Fri Aug 13 16:49:53 2004
@@ -68,7 +68,7 @@
 	struct symbol *sym = alloc_symbol(pos, type);
 
 	sym->ctype.base_type = ctype->base_type;
-	sym->ctype.modifiers = ctype->modifiers & ~(MOD_STORAGE | MOD_EXPLICITLY_SIGNED);
+	sym->ctype.modifiers = ctype->modifiers & ~MOD_STORAGE;
 
 	ctype->base_type = sym;
 	ctype->modifiers &= MOD_STORAGE;
@@ -704,6 +704,22 @@
 						unsigned int stupid_gcc = -1;
 						bitfield->fieldwidth = stupid_gcc;
 						warn(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
+					} else {
+						int is_signed = !(ctype->modifiers & MOD_UNSIGNED);
+						if (decl->ident &&
+						    bitfield->fieldwidth == 1 &&
+						    is_signed) {
+							// Valid values are either {-1;0} or {0}, depending on integer
+							// representation.  The latter makes for very efficient code...
+							warn(token->pos, "dubious one-bit signed bitfield");
+						}
+						if (decl->ident &&
+						    ctype->base_type->type != SYM_ENUM &&
+						    !(ctype->modifiers & MOD_EXPLICITLY_SIGNED) &&
+						    is_signed) {
+							// The sign of bitfields is unspecified by default.
+							warn (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
+						}
 					}
 				} else {
 					warn(token->pos, "invalid bitfield specifier for type %s.", show_typename (ctype->base_type));
diff --exclude=SCCS --exclude=BitKeeper -ur linus-sparse/symbol.c sparse-for-linus/symbol.c
--- linus-sparse/symbol.c	Fri Aug 13 17:02:10 2004
+++ sparse-for-linus/symbol.c	Fri Aug 13 16:49:53 2004
@@ -161,7 +161,6 @@
 {
 	struct symbol *base_type = sym->ctype.base_type;
 	unsigned long bit_size, alignment;
-	int is_signed;
 
 	if (!base_type)
 		return;
@@ -171,18 +170,6 @@
 		warn(sym->pos, "impossible field-width, %d, for this type",
 		     sym->fieldwidth);
 		sym->fieldwidth = bit_size;
-	}
-
-	is_signed = !(base_type->ctype.modifiers & MOD_UNSIGNED);
-	if (sym->fieldwidth == 1 && is_signed) {
-		// Valid values are either {-1;0} or {0}, depending on integer
-		// representation.  The latter makes for very efficient code...
-		warn(sym->pos, "dubious one-bit signed bitfield");
-	}
-	if (base_type->type != SYM_ENUM &&
-	    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) && is_signed) {
-		// The sign of bitfields is unspecified by default.
-		warn (sym->pos, "dubious bitfield without explicit `signed' or `unsigned'");
 	}
 
 	alignment = base_type->ctype.alignment;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [BK] Patch flood
Date: Fri, 13 Aug 2004 21:13:12 +0000
Message-ID: <Pine.LNX.4.58.0408131407320.1839 () ppc970 ! osdl ! org>
--------------------


On Fri, 13 Aug 2004, Morten Welinder wrote:
> 
> Considering the number of "int foo:1" fields I have been, it does look like
> half the world still thinks in terms of K&R's unsigned-only bitfields.

Well, the fact is, no compilers actually do that. So I think it's a matter 
of "it doesn't matter". 

You can still assign an unsigned value to it, and nobody actually looks at
whether it retors 1 or -1 when you read a non-zero value (gcc definitely
returns -1). So to some degree a "int :1" is really a virtual boolean - 
you don't assign a value to it, you assign "true" or "false", and it works 
fine as that regardless of sign.

That said, I think the :1 case is fairly obvious, and the kernel just 
shouldn't do it.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [Fwd: Re: [sparse, be] operand size work] ===

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: [Fwd: Re: [sparse, be] operand size work]
Date: Thu, 12 Feb 2004 21:37:14 +0000
Message-ID: <32036.65.113.40.130.1076621834.squirrel () numba-tu ! com>
--------------------
[Sorry I screwed up my first mail, meant to send it to the list]

---------------------------- Original Message ----------------------------
Subject: Re: [sparse, be] operand size work
From:    "Tommy Thorn" <tommy@numba-tu.com>
Date:    Thu, February 12, 2004 13:33
To:      "Linus Torvalds" <torvalds@osdl.org>
--------------------------------------------------------------------------

> That said, the real reason for liking them is that they are _simple_.
They are in fact a lot simpler (in my opinion) than even the traditional
basic block, because you don't have to worry about the issue that some
basic blocks have just one (fallthrough) exit, while some have two. With
superblocks, there are no special cases. There is always one
fallthrough, and can barnch out any which way they damn well please, yet
still maintaining the "only one entry" thing.

I like them too, but don't be mislead.  The one crucial difference (IMO)
between basic blocks and superblocks is that for the former the property
holds that if any instruction in a basic block is executed then they all
are, in other words, all instruction in a basic block share the same
control dependence.  That is not true for a superblock and that means that
you have to be more careful in a lot of places (any kind of value flow and
code motion).  I don't know which is better, but let's see how we do with
superblocks.

I also don't know your plan for sparse, but we really can do anything
without know about loops and preferably dominance as well.  I started
attacking the former and should have a Havlak algorithm done this weekend.
(But do let us know where you like to see this going).

In a former life I also implemented a Preston Brigg's style optimistic
graph register allocator, so that can come in for free as well, though I
think an Appel style constrain based allocator is the best way to go for
an x86.


> And that "one entry" part ends up being so important for simplicity that
I don't believe in any more complex data structures. Anything else ends
up being so complex that whatever gain it gets is not worth it.

Amen.  If anyone doubt this, I'll be happy to supply evidence.


> I also wanted the format to be space-efficient: not only am I actually
re-using all the regular statements and just copying the pointers, the
format itself is quite dense (and I'm pretty proud over how damn well my
"pointer list" abstraction has worked).

It's cool, but I think it would be interesting to slim it down a bit more
and optimize it for cache line size.  It might start to matter if we end
up doing heaps of graph based optimizations.  But first rule of
optimization is: Don't.


> Oh, I never meant for anybody to only look at a single basic block.
That's why there is "struct entry_point", which is the function
entrypoint and contains a list of all the basic blocks.

I need to be able to traverse bb in reverse direction, are you ok with
adding pointer lists to each bb?


Fun fun,

  Tommy



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [Fwd: Re: [sparse, be] operand size work]
Date: Thu, 12 Feb 2004 23:49:07 +0000
Message-ID: <402C10F3.7080500 () pobox ! com>
--------------------
Tommy Thorn wrote:
> I also don't know your plan for sparse, but we really can do anything
> without know about loops and preferably dominance as well.  I started
> attacking the former and should have a Havlak algorithm done this weekend.
> (But do let us know where you like to see this going).
> 
> In a former life I also implemented a Preston Brigg's style optimistic
> graph register allocator, so that can come in for free as well, though I
> think an Appel style constrain based allocator is the best way to go for
> an x86.

In terms of backend, x86 definitely needs to be separate from RISC-y 
backends.  Register allocation is a strange beast with so few registers, 
and register renaming thrown in the mix.  You also want to be 
(painfully) aware of the pipeline, and the uops generated.

So, I am a big believer in a custom register allocator for x86.  I don't 
think x86 can fit into a neat little box of <this> algorithm or <that> 
algorithm.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: [Fwd: Re: [sparse, be] operand size work]
Date: Fri, 13 Feb 2004 00:31:48 +0000
Message-ID: <5404.65.113.40.130.1076632308.squirrel () numba-tu ! com>
--------------------
> In terms of backend, x86 definitely needs to be separate from RISC-y
> backends.  Register allocation is a strange beast with so few registers,
> and register renaming thrown in the mix.  You also want to be
> (painfully) aware of the pipeline, and the uops generated.

Not that I disagree.  I just note that currently there's no register
allocation at all and no scheduling.  Crawl before you run.


> So, I am a big believer in a custom register allocator for x86.  I don't
> think x86 can fit into a neat little box of <this> algorithm or <that>
> algorithm.

Any targeted register allocator is a custom register allocator, but you
have to start with some general strategy, otherwise what you're really
getting is an ad-hoc register allocator and they tend to suck.

I can't seem to find the article I had in mind, but this one comes close:
Optimal Spilling for CISC Machines with Few Registers
http://ncstrl.cs.princeton.edu/expand.php?id=TR-630-00
("CISC Machines with Few Registers" is an academic shorthand for x86.)

All the best,

  Tommy



================================================================================


################################################################################

=== Thread: [PATCH/TEST] warn on using C/C++ keywords as identifiers ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: [PATCH/TEST] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 03:37:19 +0000
Message-ID: <20041004203719.1663e024.rddunlap () osdl ! org>
--------------------

This isn't quite done, but I'm blocked and need something (like a beer
or some help).


It's complaining a lot, in header files and in the test .c file, e.g.:

lib.h:301:20: warning: C keyword used as identifier: __func__
lib.h:306:20: warning: C keyword used as identifier: return
lib.h:306:20: warning: C keyword used as identifier: __func__
token.h:166:28: warning: C keyword used as identifier: return
token.h:166:28: warning: C keyword used as identifier: __func__
symbol.h:214:19: warning: C keyword used as identifier: __func__
symbol.h:224:19: warning: C keyword used as identifier: return
symbol.h:224:19: warning: C keyword used as identifier: __func__
expression.h:148:33: warning: C keyword used as identifier: return
expression.h:148:33: warning: C keyword used as identifier: __func__
test_cpp.c:35:5: warning: C keyword used as identifier: return
test_cpp.c:35:5: warning: C keyword used as identifier: __func__
test_cpp.c:46:15: warning: C keyword used as identifier: return
test_cpp.c:46:15: warning: C keyword used as identifier: __func__
test_cpp.c:59:5: warning: C keyword used as identifier: return
test_cpp.c:59:5: warning: C keyword used as identifier: __func__
test_cpp.c:66:5: warning: C keyword used as identifier: return
test_cpp.c:66:5: warning: C keyword used as identifier: __func__


Here's the current patch.


Check for C or C++ keywords being used as identifiers.
Use -k (or -kc) to check for C, use -kp to check for C++ keywords.

diffstat:=
 ident-list.h |   34 +++++++++++++++++++++++++++++-
 lib.c        |   20 ++++++++++++++++++
 lib.h        |    2 +
 symbol.c     |   65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 symbol.h     |    2 +
 token.h      |    3 +-
 6 files changed, 124 insertions(+), 2 deletions(-)

diff -Naurp ./lib.h~check_keywords ./lib.h
--- ./lib.h~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./lib.h	2004-10-04 17:37:33.872260968 -0700
@@ -147,6 +147,8 @@ extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise;
 extern int Wtypesign;
+extern int check_c_keywords;
+extern int check_cpp_keywords;
 
 extern void create_builtin_stream(void);
 
diff -Naurp ./symbol.h~check_keywords ./symbol.h
--- ./symbol.h~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./symbol.h	2004-10-04 17:00:00.425836896 -0700
@@ -174,6 +174,8 @@ extern struct symbol	bool_ctype, void_ct
 			string_ctype, ptr_ctype, lazy_ptr_ctype,
 			incomplete_ctype, label_ctype, bad_enum_ctype;
 
+extern const char *c_keywords[];
+extern const char *cpp_keywords[];
 
 #define __IDENT(n,str) \
 	extern struct ident n
diff -Naurp ./lib.c~check_keywords ./lib.c
--- ./lib.c~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./lib.c	2004-10-04 17:32:31.343252368 -0700
@@ -561,6 +561,9 @@ int Wundefined_preprocessor = 0;
 int preprocess_only;
 char *include;
 int include_fd = -1;
+int check_c_keywords = 0;
+int check_cpp_keywords = 0;
+
 
 void add_pre_buffer(const char *fmt, ...)
 {
@@ -648,6 +651,22 @@ char **handle_switch_i(char *arg, char *
 	return next;
 }
 
+/*
+ * -k[c]	: check for use of C keywords as identifiers
+ * -kp		: check for use of C & C++ keywords as identifiers
+ */
+char **handle_switch_k(char *arg, char **next)
+{
+	const char *which = arg + 1;
+
+	if (*which == 'c' || *which == '\0')
+		check_c_keywords = 1;
+	else if (*which == 'p')
+		check_cpp_keywords = 1;
+
+	return next;
+}
+
 char **handle_switch_M(char *arg, char **next)
 {
 	if (!strcmp(arg, "MF") || !strcmp(arg,"MQ") || !strcmp(arg,"MT")) {
@@ -739,6 +758,7 @@ char **handle_switch(char *arg, char **n
 	case 'v': rc = handle_switch_v(arg, next); break;
 	case 'I': rc = handle_switch_I(arg, next); break;
 	case 'i': rc = handle_switch_i(arg, next); break;
+	case 'k': rc = handle_switch_k(arg, next); break;
 	case 'M': rc = handle_switch_M(arg, next); break;
 	case 'm': rc = handle_switch_m(arg, next); break;
 	case 'o': rc = handle_switch_o(arg, next); break;
diff -Naurp ./ident-list.h~check_keywords ./ident-list.h
--- ./ident-list.h~check_keywords	2004-09-05 16:00:32.000000000 -0700
+++ ./ident-list.h	2004-10-04 16:40:36.194826912 -0700
@@ -1,4 +1,3 @@
-
 #ifndef IDENT
 #define IDENT(n) __IDENT(n## _ident, #n)
 #endif
@@ -36,4 +35,37 @@ __IDENT(__FILE___ident, "__FILE__");
 __IDENT(__func___ident, "__func__");
 
 #undef __IDENT
+#undef IDENT
+#undef C_IDENT_RESERVED
+#undef CPP_IDENT_RESERVED
+
+#ifdef IDENT_KEYWORDS
+
+const char *c_keywords[] = {
+	"asm", "__asm__", "auto", "_Bool", "break",
+	"case", "char", "_Complex", "const", "continue",
+	"default", "do", "double", "else", "enum", "extern",
+	"float", "for", "__func__", "__FUNCTION__",
+	"goto", "if", "_Imaginary", "inline", "__inline__", "int",
+	"long", "__PRETTY_FUNCTION__",
+	"register", "restrict", "return",
+	"short", "signed", "sizeof", "static", "struct", "switch",
+	"__thread", "typedef", "typeof",
+	"union", "unsigned", "void", "volatile", "while",
+	NULL};
+
+const char *cpp_keywords[] = {
+	"bool", "catch", "class", "complex", "__complex__",
+	"const_cast", "delete", "dynamic_cast",
+	"explicit", "export",
+	"false", "friend", "mutable",
+	"namespace", "new", "operator",
+	"private", "protected", "public",
+	"reinterpret_cast", "static_cast",
+	"template", "this", "throw", "true", "try",
+	"typeid", "typename",
+	"using", "virtual", "wchar_t",
+	NULL};
 
+#undef IDENT_KEYWORDS
+#endif
diff -Naurp ./symbol.c~check_keywords ./symbol.c
--- ./symbol.c~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./symbol.c	2004-10-04 20:22:27.570190264 -0700
@@ -14,6 +14,7 @@
 #include "lib.h"
 #include "token.h"
 #include "parse.h"
+#define IDENT_KEYWORDS
 #include "symbol.h"
 #include "scope.h"
 #include "expression.h"
@@ -350,9 +351,36 @@ void check_declaration(struct symbol *sy
 	}
 }
 
+static int is_c_keyword(const char *name)
+{
+	int kx;
+
+	for (kx = 0; c_keywords[kx]; kx++)
+		if (strcmp(name, c_keywords[kx]) == 0)
+			return 1;
+	return 0;
+}
+
+// Check for either C or C++ keyword.
+static int is_cpp_keyword(const char *name)
+{
+	int kx;
+
+	if (is_c_keyword(name))
+		return 1;
+
+	for (kx = 0; cpp_keywords[kx]; kx++)
+		if (strcmp(name, cpp_keywords[kx]) == 0)
+			return 1;
+	return 0;
+}
+
 void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
 {
 	struct scope *scope;
+	struct symbol *ctype;
+	char idname[256];
+
 	if (sym->id_list) {
 		warning(sym->pos, "internal error: symbol type already bound");
 		return;
@@ -362,6 +390,43 @@ void bind_symbol(struct symbol *sym, str
 	ident->symbols = sym;
 	sym->id_list = &ident->symbols;
 
+#if 0
+	evaluate_symbol(sym);
+#endif
+
+	ctype = sym->ctype.base_type;
+
+	if (ctype && (check_cpp_keywords || check_c_keywords)) {
+		switch (ctype->type) {
+		case SYM_NODE:
+		case SYM_PTR:
+		case SYM_ARRAY:
+		case SYM_STRUCT:
+		case SYM_UNION:
+		case SYM_ENUM:
+		case SYM_TYPEDEF:
+		case SYM_BITFIELD:
+		case SYM_BASETYPE:
+		case SYM_FN:
+			sprintf(idname, "%s", show_ident(ident));
+			if (check_cpp_keywords && is_cpp_keyword(idname)) {
+				warning(sym->pos,
+					"C++ keyword used as identifier: %s",
+					idname);
+				ident->tainted = 1;
+			}
+			else if (is_c_keyword(idname)) {
+				warning(sym->pos,
+					"C keyword used as identifier: %s",
+					idname);
+				ident->tainted = 1;
+			}
+			break;
+		default:
+			break;
+		}
+	}
+
 	scope = block_scope;
 	if (ns == NS_SYMBOL && toplevel(scope)) {
 		sym->ctype.modifiers |= MOD_TOPLEVEL | MOD_ADDRESSABLE;
diff -Naurp ./token.h~check_keywords ./token.h
--- ./token.h~check_keywords	2004-09-13 16:00:30.000000000 -0700
+++ ./token.h	2004-10-03 20:45:00.910247792 -0700
@@ -54,7 +54,8 @@ struct ident {
 	struct ident *next;	/* Hash chain of identifiers */
 	struct symbol *symbols;	/* Pointer to semantic meaning list */
 	unsigned char len;	/* Length of identifier name */
-	unsigned char tainted;
+	unsigned char tainted:1;
+	unsigned char reserved:1; /* Reserved identifier */
 	char name[];		/* Actual identifier */
 };
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH/TEST] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 05:27:00 +0000
Message-ID: <Pine.LNX.4.58.0410042217440.8290 () ppc970 ! osdl ! org>
--------------------


On Mon, 4 Oct 2004, Randy.Dunlap wrote:
> 
> lib.h:301:20: warning: C keyword used as identifier: __func__
> lib.h:306:20: warning: C keyword used as identifier: return

Ahh. Sparse internally binds to a number of magic identifiers, so you 
should only check for reserved identifiers for the user C namespaces:
NS_TYPEDEF, NS_STRUCT, NS_LABEL and NS_SYMBOL (they're done as 
powers-of-two, so you can check against multiple namespaces at once by 
just doing a 

	if (ns & (NS_TYPEDEF | NS_STRUCT | NS_LABEL | NS_SYMBOL))
		if (ident->reserved)
			warning(..

The NS_MACRO namespace is for the C preprocessor macros, and
NS_PREPROCESSOR is for C preprocessor commands. And NS_ITERATOR is for
internal C nesting stuff ('break' and 'continue' label nesting for
iterators, and 'return' for regular/inline function return value: the 
name scoping rules end up being _exactly_ the right thing to use, so we 
use namespaces for those virtual "symbols" too).

The __func__ thing is because it's not a C keyword as far as parse is 
concerned. It really shouldn't be. It's exactly the same as "this" in C++, 
it's really just an implied variable, and only sub-standard C compilers 
think it needs to be a keyword.

Sadly, they're all substandard. That doesn't mean sparse has to be.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [PATCH/TEST] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 13:15:01 +0000
Message-ID: <20041005131501.2AEDC1422D5B () darter ! rentec ! com>
--------------------

__func__ isn't a keyword, just an identifier that is implicitly defined
inside functions.  It is only reserved in the sense that it starts with
two underscores.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH/TEST] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 16:43:06 +0000
Message-ID: <20041005094306.2612255a.rddunlap () osdl ! org>
--------------------
On Tue,  5 Oct 2004 09:15:01 -0400 (EDT) Morten Welinder wrote:

| 
| __func__ isn't a keyword, just an identifier that is implicitly defined
| inside functions.  It is only reserved in the sense that it starts with
| two underscores.

OK, I removed most of the __symbols from the list.

Thanks,
-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH/v2] warn on using C/C++ keywords as identifiers ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: [PATCH/v2] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 18:39:25 +0000
Message-ID: <20041005113925.2185dd4c.rddunlap () osdl ! org>
--------------------
On Mon, 4 Oct 2004 22:27:00 -0700 (PDT) Linus Torvalds wrote:

Thanks.  Your reply was very helpful (of course).

How's this version look?

-- 


Check for C or C++ keywords being used as identifiers.
Use -k (or -kc) to check for C, use -kp to check for C++ keywords.


diffstat:=
 ident-list.h |   33 ++++++++++++++++++++++++++++++++-
 lib.c        |   20 ++++++++++++++++++++
 lib.h        |    2 ++
 symbol.c     |   46 ++++++++++++++++++++++++++++++++++++++++++++++
 symbol.h     |    2 ++
 token.h      |    3 ++-
 6 files changed, 104 insertions(+), 2 deletions(-)

diff -Naurp ./lib.h~check_keywords ./lib.h
--- ./lib.h~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./lib.h	2004-10-04 17:37:33.872260968 -0700
@@ -147,6 +147,8 @@ extern int Wdefault_bitfield_sign;
 extern int Wundefined_preprocessor;
 extern int Wbitwise;
 extern int Wtypesign;
+extern int check_c_keywords;
+extern int check_cpp_keywords;
 
 extern void create_builtin_stream(void);
 
diff -Naurp ./symbol.h~check_keywords ./symbol.h
--- ./symbol.h~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./symbol.h	2004-10-04 17:00:00.425836896 -0700
@@ -174,6 +174,8 @@ extern struct symbol	bool_ctype, void_ct
 			string_ctype, ptr_ctype, lazy_ptr_ctype,
 			incomplete_ctype, label_ctype, bad_enum_ctype;
 
+extern const char *c_keywords[];
+extern const char *cpp_keywords[];
 
 #define __IDENT(n,str) \
 	extern struct ident n
diff -Naurp ./lib.c~check_keywords ./lib.c
--- ./lib.c~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./lib.c	2004-10-04 17:32:31.343252368 -0700
@@ -561,6 +561,9 @@ int Wundefined_preprocessor = 0;
 int preprocess_only;
 char *include;
 int include_fd = -1;
+int check_c_keywords = 0;
+int check_cpp_keywords = 0;
+
 
 void add_pre_buffer(const char *fmt, ...)
 {
@@ -648,6 +651,22 @@ char **handle_switch_i(char *arg, char *
 	return next;
 }
 
+/*
+ * -k[c]	: check for use of C keywords as identifiers
+ * -kp		: check for use of C & C++ keywords as identifiers
+ */
+char **handle_switch_k(char *arg, char **next)
+{
+	const char *which = arg + 1;
+
+	if (*which == 'c' || *which == '\0')
+		check_c_keywords = 1;
+	else if (*which == 'p')
+		check_cpp_keywords = 1;
+
+	return next;
+}
+
 char **handle_switch_M(char *arg, char **next)
 {
 	if (!strcmp(arg, "MF") || !strcmp(arg,"MQ") || !strcmp(arg,"MT")) {
@@ -739,6 +758,7 @@ char **handle_switch(char *arg, char **n
 	case 'v': rc = handle_switch_v(arg, next); break;
 	case 'I': rc = handle_switch_I(arg, next); break;
 	case 'i': rc = handle_switch_i(arg, next); break;
+	case 'k': rc = handle_switch_k(arg, next); break;
 	case 'M': rc = handle_switch_M(arg, next); break;
 	case 'm': rc = handle_switch_m(arg, next); break;
 	case 'o': rc = handle_switch_o(arg, next); break;
diff -Naurp ./ident-list.h~check_keywords ./ident-list.h
--- ./ident-list.h~check_keywords	2004-09-05 16:00:32.000000000 -0700
+++ ./ident-list.h	2004-10-05 09:29:45.211977168 -0700
@@ -1,4 +1,3 @@
-
 #ifndef IDENT
 #define IDENT(n) __IDENT(n## _ident, #n)
 #endif
@@ -36,4 +35,36 @@ __IDENT(__FILE___ident, "__FILE__");
 __IDENT(__func___ident, "__func__");
 
 #undef __IDENT
+#undef IDENT
+#undef C_IDENT_RESERVED
+#undef CPP_IDENT_RESERVED
+
+#ifdef IDENT_KEYWORDS
+
+const char *c_keywords[] = {
+	"asm", "__asm__", "auto", "_Bool", "break",
+	"case", "char", "_Complex", "const", "continue",
+	"default", "do", "double", "else", "enum", "extern",
+	"float", "for", "goto",
+	"if", "_Imaginary", "inline", "__inline__", "int",
+	"long", "register", "restrict", "return",
+	"short", "signed", "sizeof", "static", "struct", "switch",
+	"__thread", "typedef", "typeof",
+	"union", "unsigned", "void", "volatile", "while",
+	NULL};
+
+const char *cpp_keywords[] = {
+	"bool", "catch", "class", "complex", "__complex__",
+	"const_cast", "delete", "dynamic_cast",
+	"explicit", "export",
+	"false", "friend", "mutable",
+	"namespace", "new", "operator",
+	"private", "protected", "public",
+	"reinterpret_cast", "static_cast",
+	"template", "this", "throw", "true", "try",
+	"typeid", "typename",
+	"using", "virtual", "wchar_t",
+	NULL};
 
+#undef IDENT_KEYWORDS
+#endif
diff -Naurp ./symbol.c~check_keywords ./symbol.c
--- ./symbol.c~check_keywords	2004-09-30 16:00:29.000000000 -0700
+++ ./symbol.c	2004-10-05 09:30:02.088411560 -0700
@@ -14,6 +14,7 @@
 #include "lib.h"
 #include "token.h"
 #include "parse.h"
+#define IDENT_KEYWORDS
 #include "symbol.h"
 #include "scope.h"
 #include "expression.h"
@@ -350,9 +351,35 @@ void check_declaration(struct symbol *sy
 	}
 }
 
+static int is_c_keyword(const char *name)
+{
+	int kx;
+
+	for (kx = 0; c_keywords[kx]; kx++)
+		if (strcmp(name, c_keywords[kx]) == 0)
+			return 1;
+	return 0;
+}
+
+// Check for either C or C++ keyword.
+static int is_cpp_keyword(const char *name)
+{
+	int kx;
+
+	if (is_c_keyword(name))
+		return 1;
+
+	for (kx = 0; cpp_keywords[kx]; kx++)
+		if (strcmp(name, cpp_keywords[kx]) == 0)
+			return 1;
+	return 0;
+}
+
 void bind_symbol(struct symbol *sym, struct ident *ident, enum namespace ns)
 {
 	struct scope *scope;
+	char idname[256];
+
 	if (sym->id_list) {
 		warning(sym->pos, "internal error: symbol type already bound");
 		return;
@@ -371,6 +398,25 @@ void bind_symbol(struct symbol *sym, str
 	if (ns == NS_LABEL)
 		scope = function_scope;
 	bind_scope(sym, scope);
+
+	if ((check_cpp_keywords || check_c_keywords)) {
+		if (ns & (NS_TYPEDEF | NS_STRUCT | NS_LABEL | NS_SYMBOL)) {
+
+			sprintf(idname, "%s", show_ident(ident));
+			if (check_cpp_keywords && is_cpp_keyword(idname)) {
+				warning(sym->pos,
+					"C++ keyword used as identifier: %s",
+					idname);
+				ident->reserved = 1;
+			}
+			else if (is_c_keyword(idname)) {
+				warning(sym->pos,
+					"C keyword used as identifier: %s",
+					idname);
+				ident->reserved = 1;
+			}
+		}
+	}
 }
 
 struct symbol *create_symbol(int stream, const char *name, int type, int namespace)
diff -Naurp ./token.h~check_keywords ./token.h
--- ./token.h~check_keywords	2004-09-13 16:00:30.000000000 -0700
+++ ./token.h	2004-10-03 20:45:00.910247792 -0700
@@ -54,7 +54,8 @@ struct ident {
 	struct ident *next;	/* Hash chain of identifiers */
 	struct symbol *symbols;	/* Pointer to semantic meaning list */
 	unsigned char len;	/* Length of identifier name */
-	unsigned char tainted;
+	unsigned char tainted:1;
+	unsigned char reserved:1; /* Reserved identifier */
 	char name[];		/* Actual identifier */
 };
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH/v2] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 19:17:30 +0000
Message-ID: <Pine.LNX.4.58.0410051211070.8290 () ppc970 ! osdl ! org>
--------------------


On Tue, 5 Oct 2004, Randy.Dunlap wrote:
> 
> How's this version look?

Argh. I committed a different patch. It doesn't do all the C keywords, and 
it does none of the C++ ones, but it sets up the infrastructure so that 
any checking process can basically just do

	/* Make the idenfitier 'xxx' be reserved */
	struct ident *ident = built_in_ident("xxx");
	ident->reserved = 1;

so now you can do your C++ checking with something trivial like

	static const char *reserved_words[] = {
		"this", "new", ..
	}

	...
	for (i = 0; i < sizeof(reserved_words) / sizeof(char *)) {
		struct ident *ident = built_in_ident(reserved_words[i]);
		ident->reserved = 1;
	}

and you're done. Sparse will complain with something like

	warning: Trying to use reserved word 'struct' as identifier

and refuse to bind it (hmm. Maybe I should allow the bind to take place, 
and just do the warning? Whatever).

		Linus


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH/v2] warn on using C/C++ keywords as identifiers
Date: Tue, 05 Oct 2004 19:47:41 +0000
Message-ID: <20041005124741.0a532743.rddunlap () osdl ! org>
--------------------
On Tue, 5 Oct 2004 12:17:30 -0700 (PDT) Linus Torvalds wrote:

| 
| 
| On Tue, 5 Oct 2004, Randy.Dunlap wrote:
| > 
| > How's this version look?
| 
| Argh. I committed a different patch. It doesn't do all the C keywords, and 
| it does none of the C++ ones, but it sets up the infrastructure so that 
| any checking process can basically just do

[snip]


OK, that's fine.  Thanks for your help.

on to my next idea...

-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]  __builtin_frame_address ===

From: frank zago <fzago () systemfabricworks ! com>
To: linux-sparse
Subject: [PATCH]  __builtin_frame_address
Date: Sat, 30 Oct 2004 23:12:05 +0000
Message-ID: <41841FC5.8070108 () systemfabricworks ! com>
--------------------
This is a multi-part message in MIME format.
--------------000807070805080209030408
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Adds support for __builtin_frame_address and fixes the prototype of 
__builtin_return_address (according to 
http://gcc.gnu.org/onlinedocs/gcc-3.4.2/gcc/Return-Address.html#index-_005f_005fbuiltin_005freturn_005faddress-1773)


--------------000807070805080209030408
Content-Type: text/x-patch;
 name="lib.diff"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="lib.diff"

--- lib.c.org	2004-10-30 17:31:03.000000000 -0500
+++ lib.c	2004-10-30 17:33:12.000000000 -0500
@@ -757,7 +757,8 @@
 void declare_builtin_functions(void)
 {
 	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
-	add_pre_buffer("extern void *__builtin_return_address(int);\n");
+	add_pre_buffer("extern void *__builtin_return_address(unsigned int);\n");
+	add_pre_buffer("extern void *__builtin_frame_address(unsigned int);\n");
 	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(int);\n");

--------------000807070805080209030408--

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Add __unix__ and variants to create_builtin_stream. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Add __unix__ and variants to create_builtin_stream.
Date: Thu, 12 Aug 2004 20:32:42 +0000
Message-ID: <20040812203242.A8A6E1422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 14:15:18-04:00 welinder@troll.com 
#   lib.c:
#     Add __unix__ and variants to create_builtin_stream.
# 
# lib.c
#   2004/08/12 14:14:51-04:00 welinder@troll.com +4 -1
#   Add __unix__ and variants to create_builtin_stream.
# 
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-08-12 13:58:53 -04:00
+++ b/lib.c	2004-08-12 14:14:51 -04:00
@@ -671,8 +671,11 @@
 void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __linux__ 1\n");
-	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define linux linux\n");
+	add_pre_buffer("#define unix 1\n");
+	add_pre_buffer("#define __unix 1\n");
+	add_pre_buffer("#define __unix__ 1\n");
+	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __func__ \"function\"\n");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Altix system controller communication driver ===

From: Greg Howard <ghoward () sgi ! com>
To: linux-kernel
Subject: [PATCH] Altix system controller communication driver
Date: Tue, 27 Jul 2004 20:07:49 +0000
Message-ID: <Pine.SGI.4.58.0407271457240.1364 () gallifrey ! americas ! sgi ! com>
--------------------
Hi Andrew,

The following patch ("altix-system-controller-driver.patch")
implements a driver that allows user applications to access the system
controllers on SGI Altix machines.  It applies on top of the
2.6.8-rc-mm1 patch.

Most of the patch is just the new file drivers/char/snsc.c.  It allows
system-controller-related applications (e.g., "flashsc" which flashes
the system controller firmware) to forward data to SAL; SAL contains
the code that multiplexes this system controller traffic with other
such traffic (including console I/O).  It's expected that each node
will have a corresponding system controller device file, and each such
device file can be used to open a number of "subchannels".  The data
structures and macros for the new driver are kept in a separate header
file (snsc.h), since I anticipate eventually adding an additional file
that will leverage some of this code to log environmental event
notifications coming from the system controllers. Inline wrapper
functions for the the SAL services used by the driver have been added
to include/asm-ia64/sn/sn_sal.h.

The only other significant (though small) change is in the Altix
console driver, drivers/serial/sn_console.c.  This driver must share
an interrupt with snsc.c.  A few config-related files are also patched
(sn2_defconfig and drivers/char/[Kconfig,Makefile]).

Thanks - Greg

Signed-off-by: Greg Howard <ghoward@sgi.com>

 arch/ia64/configs/sn2_defconfig |    1
 drivers/char/Kconfig            |    7
 drivers/char/Makefile           |    1
 drivers/char/snsc.c             |  491 ++++++++++++++++++++++++++++++++++++++++
 drivers/char/snsc.h             |   50 ++++
 drivers/serial/sn_console.c     |    3
 include/asm-ia64/sn/sn_sal.h    |  142 +++++++++++
 7 files changed, 693 insertions(+), 2 deletions(-)

diff -uprN -X dontdiff original/arch/ia64/configs/sn2_defconfig changed/arch/ia64/configs/sn2_defconfig
--- original/arch/ia64/configs/sn2_defconfig	2004-07-11 12:33:53.000000000 -0500
+++ changed/arch/ia64/configs/sn2_defconfig	2004-07-27 14:32:50.000000000 -0500
@@ -529,6 +529,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_STALDRV is not set
 CONFIG_SGI_L1_SERIAL=y
 CONFIG_SGI_L1_SERIAL_CONSOLE=y
+CONFIG_SGI_SNSC=y

 #
 # Serial drivers
diff -uprN -X dontdiff original/drivers/char/Kconfig changed/drivers/char/Kconfig
--- original/drivers/char/Kconfig	2004-07-27 13:32:37.000000000 -0500
+++ changed/drivers/char/Kconfig	2004-07-27 14:32:50.000000000 -0500
@@ -424,6 +424,13 @@ config A2232
 	  will also be built as a module. This has to be loaded before
 	  "ser_a2232". If you want to do this, answer M here.

+config SGI_SNSC
+	bool "SGI Altix system controller communication support"
+	help
+	  If you have an SGI Altix and you want to enable system
+	  controller communication from user space (you want this!),
+	  say Y.  Otherwise, say N.
+
 source "drivers/serial/Kconfig"

 config UNIX98_PTYS
diff -uprN -X dontdiff original/drivers/char/Makefile changed/drivers/char/Makefile
--- original/drivers/char/Makefile	2004-07-27 13:32:37.000000000 -0500
+++ changed/drivers/char/Makefile	2004-07-27 14:32:50.000000000 -0500
@@ -41,6 +41,7 @@ obj-$(CONFIG_SX)		+= sx.o generic_serial
 obj-$(CONFIG_RIO)		+= rio/ generic_serial.o
 obj-$(CONFIG_HVC_CONSOLE)	+= hvc_console.o
 obj-$(CONFIG_RAW_DRIVER)	+= raw.o
+obj-$(CONFIG_SGI_SNSC)		+= snsc.o
 obj-$(CONFIG_VIOCONS) += viocons.o
 obj-$(CONFIG_VIOTAPE)		+= viotape.o

diff -uprN -X dontdiff original/drivers/char/snsc.c changed/drivers/char/snsc.c
--- original/drivers/char/snsc.c	1969-12-31 18:00:00.000000000 -0600
+++ changed/drivers/char/snsc.c	2004-07-27 14:32:50.000000000 -0500
@@ -0,0 +1,491 @@
+/*
+ * SN Platform system controller communication support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+/*
+ * System controller communication driver
+ *
+ * This driver allows a user process to communicate with the system
+ * controller (a.k.a. "IRouter") network in an SGI SN system.
+ */
+
+#include "snsc.h"
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/poll.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/sn/sn_sal.h>
+#include <asm/sn/nodepda.h>
+
+
+#define SYSCTL_BASENAME	"snsc"
+
+#define SCDRV_BUFSZ	2048
+
+#ifdef SCDRV_DEBUG
+#define DPRINTF(x...)	printk(x)
+#else
+#define DPRINTF(x...)	do {} while(0)
+#endif
+
+static int scdrv_open(struct inode *, struct file *);
+static int scdrv_release(struct inode *, struct file *);
+static ssize_t scdrv_read(struct file *, char *, size_t, loff_t *);
+static ssize_t scdrv_write(struct file *, const char *, size_t, loff_t *);
+static unsigned int scdrv_poll(struct file *, struct poll_table_struct *);
+static irqreturn_t scdrv_interrupt(int, void *, struct pt_regs *);
+
+static struct file_operations scdrv_fops = {
+	owner:THIS_MODULE,
+	read:scdrv_read,
+	write:scdrv_write,
+	poll:scdrv_poll,
+	open:scdrv_open,
+	release:scdrv_release,
+};
+
+/*
+ * scdrv_wait
+ *
+ * Call this function to wait on one of the queues associated with an
+ * open subchannel.  Avoid races by entering this function with a held
+ * lock that protects the wait queue; don't release the lock until after
+ * we've added ourselves to the queue.
+ */
+static inline int
+scdrv_wait(wait_queue_head_t * waitq_head, spinlock_t * waitq_lock,
+	   unsigned long flags, unsigned long timeout)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int ret;
+
+	add_wait_queue(waitq_head, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irqrestore(waitq_lock, flags);
+
+	if (timeout) {
+		ret = schedule_timeout(timeout);
+	} else {
+		schedule();
+	}
+
+	remove_wait_queue(waitq_head, &wait);
+
+	if (signal_pending(current)) {
+		return (timeout ? -ret : -1);
+	}
+	return (timeout ? ret : 1);
+}
+
+/*
+ * scdrv_init
+ *
+ * Called at boot time to initialize the system controller communication
+ * facility.
+ */
+int __init
+scdrv_init(void)
+{
+	geoid_t geoid;
+	cmoduleid_t cmod;
+	int i;
+	char devname[32];
+	char *devnamep;
+	module_t *m;
+	struct sysctl_data_s *scd;
+	void *salbuf;
+	struct class_simple *snsc_class;
+	dev_t first_dev, dev;
+
+	if (alloc_chrdev_region(&first_dev, 0, (MAX_SLABS*nummodules), "snsc")
+	    < 0) {
+		printk("%s: failed to register SN system controller device\n",
+		       __FUNCTION__);
+		return -ENODEV;
+	}
+	snsc_class = class_simple_create(THIS_MODULE, SYSCTL_BASENAME);
+
+	for (cmod = 0; cmod < nummodules; cmod++) {
+		m = sn_modules[cmod];
+		for (i = 0; i <= MAX_SLABS; i++) {
+
+			if (m->nodes[i] == -1) {
+				/* node is not alive in module */
+				continue;
+			}
+
+			geoid = m->geoid[i];
+			devnamep = devname;
+			format_module_id(devnamep, geo_module(geoid),
+					 MODULE_FORMAT_BRIEF);
+			devnamep = devname + strlen(devname);
+			sprintf(devnamep, "#%d", geo_slab(geoid));
+
+			/* allocate sysctl device data */
+			scd =
+			    (struct sysctl_data_s *) kmalloc
+				(sizeof (struct sysctl_data_s), GFP_KERNEL);
+			if (!scd) {
+				printk("%s: failed to allocate device info"
+				       "for %s/%s\n", __FUNCTION__,
+				       SYSCTL_BASENAME, devname);
+				continue;
+			}
+			memset(scd, 0, sizeof (struct sysctl_data_s));
+
+			/* initialize sysctl device data fields */
+			scd->scd_nasid = cnodeid_to_nasid(m->nodes[i]);
+			if (!(salbuf = kmalloc(SCDRV_BUFSZ, GFP_KERNEL))) {
+				printk("%s: failed to allocate driver buffer"
+				       "(%s%s)\n", __FUNCTION__,
+				       SYSCTL_BASENAME, devname);
+				kfree(scd);
+				continue;
+			}
+
+			if (ia64_sn_irtr_init(scd->scd_nasid, salbuf,
+					      SCDRV_BUFSZ) < 0) {
+				printk
+				    ("%s: failed to initialize SAL for"
+				     " system controller communication"
+				     " (%s/%s): outdated PROM?\n",
+				     __FUNCTION__, SYSCTL_BASENAME, devname);
+				kfree(scd);
+				kfree(salbuf);
+				continue;
+			}
+
+			dev = first_dev + m->nodes[i];
+			cdev_init(&scd->scd_cdev, &scdrv_fops);
+			if (cdev_add(&scd->scd_cdev, dev, 1)) {
+				printk("%s: failed to register system"
+				       " controller device (%s%s)\n",
+				       __FUNCTION__, SYSCTL_BASENAME, devname);
+				kfree(scd);
+				kfree(salbuf);
+				continue;
+			}
+
+			class_simple_device_add(snsc_class, dev, NULL,
+						"%s", devname);
+
+			ia64_sn_irtr_intr_enable(scd->scd_nasid,
+						 0 /*ignored */ ,
+						 SAL_IROUTER_INTR_RECV);
+		}
+	}
+	return 0;
+}
+
+/*
+ * scdrv_open
+ *
+ * Reserve a subchannel for system controller communication.
+ */
+
+static int
+scdrv_open(struct inode *inode, struct file *file)
+{
+	struct sysctl_data_s *scd;
+	struct subch_data_s *sd;
+	int rv;
+
+	/* look up device info for this device file */
+	scd = container_of(inode->i_cdev, struct sysctl_data_s, scd_cdev);
+
+	if (!scd) {
+		printk("%s: no such device\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	/* allocate memory for subchannel data */
+	sd = (struct subch_data_s *)
+		kmalloc(sizeof (struct subch_data_s), GFP_KERNEL);
+	if (sd == NULL) {
+		printk("%s: couldn't allocate subchannel data\n",
+		       __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* initialize subch_data_s fields */
+	memset(sd, 0, sizeof (struct subch_data_s));
+	sd->sd_nasid = scd->scd_nasid;
+	sd->sd_subch = ia64_sn_irtr_open(scd->scd_nasid);
+
+	if (sd->sd_subch < 0) {
+		kfree(sd);
+		printk("%s: couldn't allocate subchannel\n", __FUNCTION__);
+		return -EBUSY;
+	}
+
+	spin_lock_init(&sd->sd_rlock);
+	spin_lock_init(&sd->sd_wlock);
+	init_waitqueue_head(&sd->sd_rq);
+	init_waitqueue_head(&sd->sd_wq);
+	sema_init(&sd->sd_rbs, 1);
+	sema_init(&sd->sd_wbs, 1);
+
+	file->private_data = sd;
+
+	/* hook this subchannel up to the system controller interrupt */
+	rv = request_irq(SGI_UART_VECTOR, scdrv_interrupt,
+			 SA_SHIRQ | SA_INTERRUPT,
+			 SYSCTL_BASENAME, sd);
+	if (rv) {
+		ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);
+		kfree(sd);
+		printk("%s: irq request failed (%d)\n", __FUNCTION__, rv);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*
+ * scdrv_release
+ *
+ * Release a previously-reserved subchannel.
+ */
+
+static int
+scdrv_release(struct inode *inode, struct file *file)
+{
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+	int rv;
+
+	/* free the interrupt */
+	free_irq(SGI_UART_VECTOR, sd);
+
+	/* ask SAL to close the subchannel */
+	rv = ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);
+
+	kfree(sd);
+	return rv;
+}
+
+/*
+ * scdrv_read
+ *
+ * Called to read bytes from the open IRouter pipe.
+ *
+ */
+
+static inline int
+read_status_check(struct subch_data_s * sd, int *len)
+{
+	return ia64_sn_irtr_recv(sd->sd_nasid, sd->sd_subch, sd->sd_rb, len);
+}
+
+static ssize_t
+scdrv_read(struct file *file, char *buf, size_t count, loff_t * f_pos)
+{
+	int status;
+	int len;
+	unsigned long flags;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+
+	/* try to get control of the read buffer */
+	if (down_trylock(&sd->sd_rbs)) {
+		/* somebody else has it now;
+		 * if we're non-blocking, then exit...
+		 */
+		if (file->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		/* ...or if we want to block, then do so here */
+		if (down_interruptible(&sd->sd_rbs)) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+	}
+
+	/* anything to read? */
+	len = CHUNKSIZE;
+	spin_lock_irqsave(&sd->sd_rlock, flags);
+	status = read_status_check(sd, &len);
+
+	/* if not, and we're blocking I/O, loop */
+	while (status < 0) {
+		if (file->f_flags & O_NONBLOCK) {
+			spin_unlock_irqrestore(&sd->sd_rlock, flags);
+			return -EAGAIN;
+		}
+		len = CHUNKSIZE;
+		if (scdrv_wait(&sd->sd_rq, &sd->sd_rlock, flags, 1000) < 0) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+		/* sd->sd_rlock was unlocked by scdrv_wait(), above */
+		spin_lock_irqsave(&sd->sd_rlock, flags);
+		status = read_status_check(sd, &len);
+	}
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+
+	if (len > 0) {
+		/* we read something in the last read_status_check(); copy
+		 * it out to user space
+		 */
+		if (count < len) {
+			DPRINTF("%s: only accepting %d of %d bytes\n",
+				__FUNCTION__, (int) count, len);
+		}
+		len = min((int) count, len);
+		copy_to_user(buf, sd->sd_rb, len);
+	}
+
+	/* release the read buffer and wake anyone who might be
+	 * waiting for it
+	 */
+	up(&sd->sd_rbs);
+
+	/* return the number of characters read in */
+	return len;
+}
+
+/*
+ * scdrv_write
+ *
+ * Writes a chunk of an IRouter packet (or other system controller data)
+ * to the system controller.
+ *
+ */
+static inline int
+write_status_check(struct subch_data_s * sd, int count)
+{
+	return ia64_sn_irtr_send(sd->sd_nasid, sd->sd_subch, sd->sd_wb, count);
+}
+
+static ssize_t
+scdrv_write(struct file *file, const char *buf, size_t count, loff_t * f_pos)
+{
+	unsigned long flags;
+	int status;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+
+	/* try to get control of the write buffer */
+	if (down_trylock(&sd->sd_wbs)) {
+		/* somebody else has it now;
+		 * if we're non-blocking, then exit...
+		 */
+		if (file->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		/* ...or if we want to block, then do so here */
+		if (down_interruptible(&sd->sd_wbs)) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+	}
+
+	count = min((int) count, CHUNKSIZE);
+	copy_from_user(sd->sd_wb, buf, count);
+
+	/* try to send the buffer */
+	spin_lock_irqsave(&sd->sd_wlock, flags);
+	status = write_status_check(sd, count);
+
+	/* if we failed, and we want to block, then loop */
+	while (status <= 0) {
+		if (file->f_flags & O_NONBLOCK) {
+			spin_unlock(&sd->sd_wlock);
+			return -EAGAIN;
+		}
+		if (scdrv_wait(&sd->sd_wq, &sd->sd_wlock, flags, 1000) < 0) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+
+		/* sd->sd_wlock was unlocked by scdrv_wait(), above */
+		spin_lock_irqsave(&sd->sd_wlock, flags);
+		status = write_status_check(sd, count);
+	}
+	spin_unlock_irqrestore(&sd->sd_wlock, flags);
+
+	/* release the write buffer and wake anyone who's waiting for it */
+	up(&sd->sd_wbs);
+
+	/* return the number of characters accepted (should be the complete
+	 * "chunk" as requested)
+	 */
+	if ((status >= 0) && (status < count)) {
+		DPRINTF("Didn't accept the full chunk; %d of %d\n",
+			status, (int) count);
+	}
+	return status;
+}
+
+static inline void
+scdrv_lock_all(struct subch_data_s * sd, unsigned long *flags)
+{
+	spin_lock_irqsave(&sd->sd_rlock, *flags);
+	spin_lock(&sd->sd_wlock);
+}
+
+static inline void
+scdrv_unlock_all(struct subch_data_s * sd, unsigned long flags)
+{
+	spin_unlock(&sd->sd_wlock);
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+}
+
+static unsigned int
+scdrv_poll(struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+	int status = 0;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+	unsigned long flags;
+
+	scdrv_lock_all(sd, &flags);
+	poll_wait(file, &sd->sd_rq, wait);
+	poll_wait(file, &sd->sd_wq, wait);
+
+	status = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);
+	scdrv_unlock_all(sd, flags);
+
+	if (status > 0) {
+		if (status & SAL_IROUTER_INTR_RECV) {
+			mask |= POLLIN | POLLRDNORM;
+		}
+		if (status & SAL_IROUTER_INTR_XMIT) {
+			mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+
+	return mask;
+}
+
+static irqreturn_t
+scdrv_interrupt(int irq, void *subch_data, struct pt_regs *regs)
+{
+	struct subch_data_s *sd = (struct subch_data_s *) subch_data;
+	unsigned long flags;
+	int status;
+
+	scdrv_lock_all(sd, &flags);
+	status = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);
+
+	if (status > 0) {
+		if (status & SAL_IROUTER_INTR_RECV) {
+			wake_up_all(&sd->sd_rq);
+		}
+		if (status & SAL_IROUTER_INTR_XMIT) {
+			ia64_sn_irtr_intr_disable
+			    (sd->sd_nasid, sd->sd_subch,
+			     SAL_IROUTER_INTR_XMIT);
+			wake_up_all(&sd->sd_wq);
+		}
+	}
+	scdrv_unlock_all(sd, flags);
+	return IRQ_HANDLED;
+}
+
+module_init(scdrv_init);
diff -uprN -X dontdiff original/drivers/char/snsc.h changed/drivers/char/snsc.h
--- original/drivers/char/snsc.h	1969-12-31 18:00:00.000000000 -0600
+++ changed/drivers/char/snsc.h	2004-07-27 14:32:50.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * SN Platform system controller communication support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+/*
+ * This file contains macros and data types for communication with the
+ * system controllers in SGI SN systems.
+ */
+
+#ifndef _SN_SYSCTL_H_
+#define _SN_SYSCTL_H_
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/kobject.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <asm/sn/types.h>
+#include <asm/semaphore.h>
+
+#define CHUNKSIZE 127
+
+/* This structure is used to track an open subchannel. */
+struct subch_data_s {
+	nasid_t sd_nasid;	/* node on which the subchannel was opened */
+	int sd_subch;		/* subchannel number */
+	spinlock_t sd_rlock;	/* monitor lock for rsv */
+	spinlock_t sd_wlock;	/* monitor lock for wsv */
+	wait_queue_head_t sd_rq;	/* wait queue for readers */
+	wait_queue_head_t sd_wq;	/* wait queue for writers */
+	struct semaphore sd_rbs;	/* semaphore for read buffer */
+	struct semaphore sd_wbs;	/* semaphore for write buffer */
+
+	char sd_rb[CHUNKSIZE];	/* read buffer */
+	char sd_wb[CHUNKSIZE];	/* write buffer */
+};
+
+struct sysctl_data_s {
+	struct cdev scd_cdev;	/* Character device info */
+	nasid_t scd_nasid;	/* Node on which subchannels are opened. */
+};
+
+#endif /* _SN_SYSCTL_H_ */
diff -uprN -X dontdiff original/drivers/serial/sn_console.c changed/drivers/serial/sn_console.c
--- original/drivers/serial/sn_console.c	2004-07-27 13:32:38.000000000 -0500
+++ changed/drivers/serial/sn_console.c	2004-07-27 14:32:50.000000000 -0500
@@ -712,7 +712,8 @@ sn_sal_interrupt(int irq, void *dev_id,
 static int
 sn_sal_connect_interrupt(struct sn_cons_port *port)
 {
-	if (request_irq(SGI_UART_VECTOR, sn_sal_interrupt, SA_INTERRUPT,
+	if (request_irq(SGI_UART_VECTOR, sn_sal_interrupt,
+			SA_INTERRUPT | SA_SHIRQ,
 			"SAL console driver", port) >= 0) {
 		return SGI_UART_VECTOR;
 	}
diff -uprN -X dontdiff original/include/asm-ia64/sn/sn_sal.h changed/include/asm-ia64/sn/sn_sal.h
--- original/include/asm-ia64/sn/sn_sal.h	2004-07-11 12:35:31.000000000 -0500
+++ changed/include/asm-ia64/sn/sn_sal.h	2004-07-27 14:32:50.000000000 -0500
@@ -8,7 +8,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All rights reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All rights reserved.
  */


@@ -60,6 +60,7 @@
 #define  SN_SAL_SYSCTL_FRU_CAPTURE		   0x0200003f

 #define  SN_SAL_SYSCTL_IOBRICK_PCI_OP		   0x02000042	// reentrant
+#define	 SN_SAL_IROUTER_OP			   0x02000043

 /*
  * Service-specific constants
@@ -86,6 +87,25 @@
 #endif	/* CONFIG_HOTPLUG_PCI_SGI */

 /*
+ * IRouter (i.e. generalized system controller) operations
+ */
+#define SAL_IROUTER_OPEN	0	/* open a subchannel */
+#define SAL_IROUTER_CLOSE	1	/* close a subchannel */
+#define SAL_IROUTER_SEND	2	/* send part of an IRouter packet */
+#define SAL_IROUTER_RECV	3	/* receive part of an IRouter packet */
+#define SAL_IROUTER_INTR_STATUS	4	/* check the interrupt status for
+					 * an open subchannel
+					 */
+#define SAL_IROUTER_INTR_ON	5	/* enable an interrupt */
+#define SAL_IROUTER_INTR_OFF	6	/* disable an interrupt */
+#define SAL_IROUTER_INIT	7	/* initialize IRouter driver */
+
+/* IRouter interrupt mask bits */
+#define SAL_IROUTER_INTR_XMIT	SAL_CONSOLE_INTR_XMIT
+#define SAL_IROUTER_INTR_RECV	SAL_CONSOLE_INTR_RECV
+
+
+/*
  * SN_SAL_GET_PARTITION_ADDR return constants
  */
 #define SALRET_MORE_PASSES	1
@@ -704,4 +724,124 @@ ia64_sn_set_error_handling_features(cons
 	return rv.status;
 }

+
+/*
+ * Open a subchannel for sending arbitrary data to the system
+ * controller network via the system controller device associated with
+ * 'nasid'.  Return the subchannel number or a negative error code.
+ */
+static inline int
+ia64_sn_irtr_open(nasid_t nasid)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_OPEN, nasid,
+			   0, 0, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Close system controller subchannel 'subch' previously opened on 'nasid'.
+ */
+static inline int
+ia64_sn_irtr_close(nasid_t nasid, int subch)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_CLOSE,
+			   (u64) nasid, (u64) subch, 0, 0, 0, 0);
+	return (int) rv.status;
+}
+
+/*
+ * Read data from system controller associated with 'nasid' on
+ * subchannel 'subch'.  The buffer to be filled is pointed to by
+ * 'buf', and its capacity is in the integer pointed to by 'len'.  The
+ * referent of 'len' is set to the number of bytes read by the SAL
+ * call.  The return value is either SALRET_OK (for bytes read) or
+ * SALRET_ERROR (for error or "no data available").
+ */
+static inline int
+ia64_sn_irtr_recv(nasid_t nasid, int subch, char *buf, int *len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_RECV,
+			   (u64) nasid, (u64) subch, (u64) buf, (u64) len,
+			   0, 0);
+	return (int) rv.status;
+}
+
+/*
+ * Write data to the system controller network via the system
+ * controller associated with 'nasid' on suchannel 'subch'.  The
+ * buffer to be written out is pointed to by 'buf', and 'len' is the
+ * number of bytes to be written.  The return value is either the
+ * number of bytes written (which could be zero) or a negative error
+ * code.
+ */
+static inline int
+ia64_sn_irtr_send(nasid_t nasid, int subch, char *buf, int len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_SEND,
+			   (u64) nasid, (u64) subch, (u64) buf, (u64) len,
+			   0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Check whether any interrupts are pending for the system controller
+ * associated with 'nasid' and its subchannel 'subch'.  The return
+ * value is a mask of pending interrupts (SAL_IROUTER_INTR_XMIT and/or
+ * SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr(nasid_t nasid, int subch)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_STATUS,
+			   (u64) nasid, (u64) subch, 0, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Enable the interrupt indicated by the intr parameter (either
+ * SAL_IROUTER_INTR_XMIT or SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr_enable(nasid_t nasid, int subch, u64 intr)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_ON,
+			   (u64) nasid, (u64) subch, intr, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Disable the interrupt indicated by the intr parameter (either
+ * SAL_IROUTER_INTR_XMIT or SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr_disable(nasid_t nasid, int subch, u64 intr)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_OFF,
+			   (u64) nasid, (u64) subch, intr, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Initialize the SAL components of the system controller
+ * communication driver; specifically pass in a sizable buffer that
+ * can be used for allocation of subchannel queues as new subchannels
+ * are opened.  "buf" points to the buffer, and "len" specifies its
+ * length.
+ */
+static inline int
+ia64_sn_irtr_init(nasid_t nasid, void *buf, int len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INIT,
+			   (u64) nasid, (u64) buf, (u64) len, 0, 0, 0);
+	return (int) rv.status;
+}
+
 #endif /* _ASM_IA64_SN_SN_SAL_H */



-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Jes Sorensen <jes () wildopensource ! com>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Wed, 28 Jul 2004 15:11:17 +0000
Message-ID: <yq0fz7c9nfu.fsf () wildopensource ! com>
--------------------
>>>>> "Greg" == Greg Howard <ghoward@sgi.com> writes:

Greg> Hi Andrew, The following patch
Greg> ("altix-system-controller-driver.patch") implements a driver
Greg> that allows user applications to access the system controllers
Greg> on SGI Altix machines.  It applies on top of the 2.6.8-rc-mm1
Greg> patch.

Greg,

A few quick comments, there might be more, I just spotted these two
points quickly:

1) Please update the struct file_operations assignments to use
   .owner THIS_MODULE, etc. instead of owner:

2) Always check the return values from copy_from_user and copy_to_user
   to avoid userland feeing you bogus pointers.

Jes
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () osdl ! org>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Wed, 28 Jul 2004 15:57:37 +0000
Message-ID: <20040728085737.26e0bfd2.akpm () osdl ! org>
--------------------
Greg Howard <ghoward@sgi.com> wrote:
>
> Hi Andrew,
> 
> The following patch ("altix-system-controller-driver.patch")
> implements a driver that allows user applications to access the system
> controllers on SGI Altix machines.  It applies on top of the
> 2.6.8-rc-mm1 patch.
> 
>...
> +static struct file_operations scdrv_fops = {
> +	owner:THIS_MODULE,
> +	read:scdrv_read,
> +	write:scdrv_write,
> +	poll:scdrv_poll,
> +	open:scdrv_open,
> +	release:scdrv_release,
> +};

As Jes says,

	.owner	= THIS_MODULE,

is preferred here.

> +			scd =
> +			    (struct sysctl_data_s *) kmalloc
> +				(sizeof (struct sysctl_data_s), GFP_KERNEL);

There's no need to cast the return value of kmalloc.

	scd = kmalloc(sizeof(*scd), GFP_KERNEL);

would suffice here.

> +static ssize_t
> +scdrv_read(struct file *file, char *buf, size_t count, loff_t * f_pos)
> +{
> +	int status;
> +	int len;
> +	unsigned long flags;
> +	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
> +
> +	/* try to get control of the read buffer */
> +	if (down_trylock(&sd->sd_rbs)) {
> +		/* somebody else has it now;
> +		 * if we're non-blocking, then exit...
> +		 */
> +		if (file->f_flags & O_NONBLOCK) {
> +			return -EAGAIN;
> +		}

hm.  O_NONBLOCK means "don't wait for more input to arrive" rather than
"don't block if someone else is holding a lock I want".  But given that the
semaphore is held by !O_NONBLOCK readers, it has to be done this way.

I guess there's no bug here, but it's a bit odd.

> +		copy_to_user(buf, sd->sd_rb, len);

What Jes said: return -EFAULT if copy_to_user() returns non-zero.

> +static unsigned int
> +scdrv_poll(struct file *file, struct poll_table_struct *wait)
> +{
> +	unsigned int mask = 0;
> +	int status = 0;
> +	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
> +	unsigned long flags;
> +
> +	scdrv_lock_all(sd, &flags);
> +	poll_wait(file, &sd->sd_rq, wait);
> +	poll_wait(file, &sd->sd_wq, wait);

This function will sleep with spinlocks held, won't it?


-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Wed, 28 Jul 2004 16:42:50 +0000
Message-ID: <20040728182126.GB14737 () mars ! ravnborg ! org>
--------------------
On Wed, Jul 28, 2004 at 08:57:37AM -0700, Andrew Morton wrote:
> Greg Howard <ghoward@sgi.com> wrote:
> >
> > Hi Andrew,
> > 
> > The following patch ("altix-system-controller-driver.patch")
> > implements a driver that allows user applications to access the system
> > controllers on SGI Altix machines.  It applies on top of the
> > 2.6.8-rc-mm1 patch.

[Lost the original mail..]

I would also recommend running it through sparse.
http://sparse.bkbits.net
davej has a .tar.gz package somewhere at www.codemonkey.org.uk.

I did not see any particular issue, but noticed no __user annotations
around copy_{to,from}_user().

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Greg Howard <ghoward () sgi ! com>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Wed, 28 Jul 2004 22:11:51 +0000
Message-ID: <Pine.SGI.4.58.0407281641210.1656 () gallifrey ! americas ! sgi ! com>
--------------------
Hi Andrew,

On Wed, 28 Jul 2004, Andrew Morton wrote:

> As Jes says,
>
> 	.owner	= THIS_MODULE,
>
> is preferred here.
. . .
>
> There's no need to cast the return value of kmalloc.
>
> 	scd = kmalloc(sizeof(*scd), GFP_KERNEL);
>
> would suffice here.

I fixed these.  I plan to repost shortly.

. . .
> hm.  O_NONBLOCK means "don't wait for more input to arrive" rather than
> "don't block if someone else is holding a lock I want".  But given that the
> semaphore is held by !O_NONBLOCK readers, it has to be done this way.
>
> I guess there's no bug here, but it's a bit odd.

I'm certainly willing to try other ways, but this was the best I
could think of.  It seems to work at least.

>
> > +		copy_to_user(buf, sd->sd_rb, len);
>
> What Jes said: return -EFAULT if copy_to_user() returns non-zero.

Fixed this.

>
> > +static unsigned int
> > +scdrv_poll(struct file *file, struct poll_table_struct *wait)
> > +{
> > +	unsigned int mask = 0;
> > +	int status = 0;
> > +	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
> > +	unsigned long flags;
> > +
> > +	scdrv_lock_all(sd, &flags);
> > +	poll_wait(file, &sd->sd_rq, wait);
> > +	poll_wait(file, &sd->sd_wq, wait);
>
> This function will sleep with spinlocks held, won't it?

My understanding is that poll_wait just sets up a poll_table
structure; it doesn't sleep itself.

Thanks for the suggestions.
- Greg
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () osdl ! org>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Wed, 28 Jul 2004 23:00:33 +0000
Message-ID: <20040728160033.63205d60.akpm () osdl ! org>
--------------------
Greg Howard <ghoward@sgi.com> wrote:
>
> > > +static unsigned int
> > > +scdrv_poll(struct file *file, struct poll_table_struct *wait)
> > > +{
> > > +	unsigned int mask = 0;
> > > +	int status = 0;
> > > +	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
> > > +	unsigned long flags;
> > > +
> > > +	scdrv_lock_all(sd, &flags);
> > > +	poll_wait(file, &sd->sd_rq, wait);
> > > +	poll_wait(file, &sd->sd_wq, wait);
> >
> > This function will sleep with spinlocks held, won't it?
> 
> My understanding is that poll_wait just sets up a poll_table
> structure; it doesn't sleep itself.

It calls into __pollwait(), which can perform sleeping memory allocations.
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Greg Howard <ghoward () sgi ! com>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Thu, 29 Jul 2004 19:46:35 +0000
Message-ID: <Pine.SGI.4.58.0407291425330.1917 () gallifrey ! americas ! sgi ! com>
--------------------
On Wed, 28 Jul 2004, Sam Ravnborg wrote:

> I would also recommend running it through sparse.
> http://sparse.bkbits.net
> davej has a .tar.gz package somewhere at www.codemonkey.org.uk.
>
> I did not see any particular issue, but noticed no __user annotations
> around copy_{to,from}_user().

I did add the __user annotations to the parameters in scdrv_read() and
scdrv_write().  But I had trouble coming up with a type-casting chant
around my invocations of copy_{to,from}_user() that would satisfy
sparse.  No matter what I did it still gave me some warnings.

FWIW I looked through a couple of other drivers (and ran them through
sparse to see what would happen), and I discovered that I seem to be
in good company as far as this is concerned...  Are there any examples
of a use of copy_{to,from}_user() that use char* parameters (perhaps
cast to something else), but don't cause sparse to complain?

Thanks - Greg
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Greg Howard <ghoward () sgi ! com>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Thu, 29 Jul 2004 19:50:23 +0000
Message-ID: <Pine.SGI.4.58.0407291446550.1917 () gallifrey ! americas ! sgi ! com>
--------------------
On Wed, 28 Jul 2004, Andrew Morton wrote:

> Greg Howard <ghoward@sgi.com> wrote:
> >
> > My understanding is that poll_wait just sets up a poll_table
> > structure; it doesn't sleep itself.
>
> It calls into __pollwait(), which can perform sleeping memory allocations.
>

Ah, okay.  Well, I moved the poll_wait() calls out from under the
lock; from what I can tell that ought to be safe enough anyhow.

Thanks - Greg
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: FW: [PATCH] Altix system controller communication driver
Date: Thu, 29 Jul 2004 21:23:51 +0000
Message-ID: <20040729231028.GA7130 () mars ! ravnborg ! org>
--------------------
Any of you sparsers that can help Greg?

	Sam
	
----- Forwarded message from Greg Howard <ghoward@sgi.com> -----

Subject: Re: [PATCH] Altix system controller communication driver
From: Greg Howard <ghoward@sgi.com>
Date: Thu, 29 Jul 2004 14:46:35 -0500
To: Sam Ravnborg <sam@ravnborg.org>
Cc: Andrew Morton <akpm@osdl.org>, linux-kernel@vger.kernel.org

On Wed, 28 Jul 2004, Sam Ravnborg wrote:

> I would also recommend running it through sparse.
> http://sparse.bkbits.net
> davej has a .tar.gz package somewhere at www.codemonkey.org.uk.
>
> I did not see any particular issue, but noticed no __user annotations
> around copy_{to,from}_user().

I did add the __user annotations to the parameters in scdrv_read() and
scdrv_write().  But I had trouble coming up with a type-casting chant
around my invocations of copy_{to,from}_user() that would satisfy
sparse.  No matter what I did it still gave me some warnings.

FWIW I looked through a couple of other drivers (and ran them through
sparse to see what would happen), and I discovered that I seem to be
in good company as far as this is concerned...  Are there any examples
of a use of copy_{to,from}_user() that use char* parameters (perhaps
cast to something else), but don't cause sparse to complain?

Thanks - Greg

----- End forwarded message -----
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Greg Howard <ghoward () sgi ! com>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Fri, 30 Jul 2004 21:44:58 +0000
Message-ID: <Pine.SGI.4.58.0407301640510.4902 () gallifrey ! americas ! sgi ! com>
--------------------
Andrew, others--

Here's a cleaned-up version of altix-system-controller-driver.patch.
Many thanks to everybody who offered suggestions and help.

- Greg

Signed-off-by: Greg Howard <ghoward@sgi.com>

 arch/ia64/configs/sn2_defconfig |    1
 drivers/char/Kconfig            |    7
 drivers/char/Makefile           |    1
 drivers/char/snsc.c             |  493 ++++++++++++++++++++++++++++++++++++++++
 drivers/char/snsc.h             |   50 ++++
 drivers/serial/sn_console.c     |    3
 include/asm-ia64/sn/sn_sal.h    |  142 +++++++++++
 7 files changed, 695 insertions(+), 2 deletions(-)

diff -uprN -X dontdiff original/arch/ia64/configs/sn2_defconfig changed/arch/ia64/configs/sn2_defconfig
--- original/arch/ia64/configs/sn2_defconfig	2004-07-11 12:33:53.000000000 -0500
+++ changed/arch/ia64/configs/sn2_defconfig	2004-07-30 15:30:49.000000000 -0500
@@ -529,6 +529,7 @@ CONFIG_SERIAL_NONSTANDARD=y
 # CONFIG_STALDRV is not set
 CONFIG_SGI_L1_SERIAL=y
 CONFIG_SGI_L1_SERIAL_CONSOLE=y
+CONFIG_SGI_SNSC=y

 #
 # Serial drivers
diff -uprN -X dontdiff original/drivers/char/Kconfig changed/drivers/char/Kconfig
--- original/drivers/char/Kconfig	2004-07-27 13:32:37.000000000 -0500
+++ changed/drivers/char/Kconfig	2004-07-30 15:30:49.000000000 -0500
@@ -424,6 +424,13 @@ config A2232
 	  will also be built as a module. This has to be loaded before
 	  "ser_a2232". If you want to do this, answer M here.

+config SGI_SNSC
+	bool "SGI Altix system controller communication support"
+	help
+	  If you have an SGI Altix and you want to enable system
+	  controller communication from user space (you want this!),
+	  say Y.  Otherwise, say N.
+
 source "drivers/serial/Kconfig"

 config UNIX98_PTYS
diff -uprN -X dontdiff original/drivers/char/Makefile changed/drivers/char/Makefile
--- original/drivers/char/Makefile	2004-07-27 13:32:37.000000000 -0500
+++ changed/drivers/char/Makefile	2004-07-30 15:30:49.000000000 -0500
@@ -41,6 +41,7 @@ obj-$(CONFIG_SX)		+= sx.o generic_serial
 obj-$(CONFIG_RIO)		+= rio/ generic_serial.o
 obj-$(CONFIG_HVC_CONSOLE)	+= hvc_console.o
 obj-$(CONFIG_RAW_DRIVER)	+= raw.o
+obj-$(CONFIG_SGI_SNSC)		+= snsc.o
 obj-$(CONFIG_VIOCONS) += viocons.o
 obj-$(CONFIG_VIOTAPE)		+= viotape.o

diff -uprN -X dontdiff original/drivers/char/snsc.c changed/drivers/char/snsc.c
--- original/drivers/char/snsc.c	1969-12-31 18:00:00.000000000 -0600
+++ changed/drivers/char/snsc.c	2004-07-30 15:30:49.000000000 -0500
@@ -0,0 +1,493 @@
+/*
+ * SN Platform system controller communication support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+/*
+ * System controller communication driver
+ *
+ * This driver allows a user process to communicate with the system
+ * controller (a.k.a. "IRouter") network in an SGI SN system.
+ */
+
+#include "snsc.h"
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/poll.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/sn/sn_sal.h>
+#include <asm/sn/nodepda.h>
+
+
+#define SYSCTL_BASENAME	"snsc"
+
+#define SCDRV_BUFSZ	2048
+
+#ifdef SCDRV_DEBUG
+#define DPRINTF(x...)	printk(x)
+#else
+#define DPRINTF(x...)	do {} while(0)
+#endif
+
+static int scdrv_open(struct inode *, struct file *);
+static int scdrv_release(struct inode *, struct file *);
+static ssize_t scdrv_read(struct file *, char __user *, size_t, loff_t *);
+static ssize_t scdrv_write(struct file *, const char __user *,
+			   size_t, loff_t *);
+static unsigned int scdrv_poll(struct file *, struct poll_table_struct *);
+static irqreturn_t scdrv_interrupt(int, void *, struct pt_regs *);
+
+static struct file_operations scdrv_fops = {
+	.owner =	THIS_MODULE,
+	.read =		scdrv_read,
+	.write =	scdrv_write,
+	.poll =		scdrv_poll,
+	.open =		scdrv_open,
+	.release =	scdrv_release,
+};
+
+/*
+ * scdrv_wait
+ *
+ * Call this function to wait on one of the queues associated with an
+ * open subchannel.  Avoid races by entering this function with a held
+ * lock that protects the wait queue; don't release the lock until after
+ * we've added ourselves to the queue.
+ */
+static inline int
+scdrv_wait(wait_queue_head_t *waitq_head, spinlock_t *waitq_lock,
+	   unsigned long flags, unsigned long timeout)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int ret;
+
+	add_wait_queue(waitq_head, &wait);
+	set_current_state(TASK_INTERRUPTIBLE);
+	spin_unlock_irqrestore(waitq_lock, flags);
+
+	if (timeout) {
+		ret = schedule_timeout(timeout);
+	} else {
+		schedule();
+	}
+
+	remove_wait_queue(waitq_head, &wait);
+
+	if (signal_pending(current)) {
+		return (timeout ? -ret : -1);
+	}
+	return (timeout ? ret : 1);
+}
+
+/*
+ * scdrv_init
+ *
+ * Called at boot time to initialize the system controller communication
+ * facility.
+ */
+int __init
+scdrv_init(void)
+{
+	geoid_t geoid;
+	cmoduleid_t cmod;
+	int i;
+	char devname[32];
+	char *devnamep;
+	module_t *m;
+	struct sysctl_data_s *scd;
+	void *salbuf;
+	struct class_simple *snsc_class;
+	dev_t first_dev, dev;
+
+	if (alloc_chrdev_region(&first_dev, 0, (MAX_SLABS*nummodules), "snsc")
+	    < 0) {
+		printk("%s: failed to register SN system controller device\n",
+		       __FUNCTION__);
+		return -ENODEV;
+	}
+	snsc_class = class_simple_create(THIS_MODULE, SYSCTL_BASENAME);
+
+	for (cmod = 0; cmod < nummodules; cmod++) {
+		m = sn_modules[cmod];
+		for (i = 0; i <= MAX_SLABS; i++) {
+
+			if (m->nodes[i] == -1) {
+				/* node is not alive in module */
+				continue;
+			}
+
+			geoid = m->geoid[i];
+			devnamep = devname;
+			format_module_id(devnamep, geo_module(geoid),
+					 MODULE_FORMAT_BRIEF);
+			devnamep = devname + strlen(devname);
+			sprintf(devnamep, "#%d", geo_slab(geoid));
+
+			/* allocate sysctl device data */
+			scd = kmalloc(sizeof (struct sysctl_data_s),
+				      GFP_KERNEL);
+			if (!scd) {
+				printk("%s: failed to allocate device info"
+				       "for %s/%s\n", __FUNCTION__,
+				       SYSCTL_BASENAME, devname);
+				continue;
+			}
+			memset(scd, 0, sizeof (struct sysctl_data_s));
+
+			/* initialize sysctl device data fields */
+			scd->scd_nasid = cnodeid_to_nasid(m->nodes[i]);
+			if (!(salbuf = kmalloc(SCDRV_BUFSZ, GFP_KERNEL))) {
+				printk("%s: failed to allocate driver buffer"
+				       "(%s%s)\n", __FUNCTION__,
+				       SYSCTL_BASENAME, devname);
+				kfree(scd);
+				continue;
+			}
+
+			if (ia64_sn_irtr_init(scd->scd_nasid, salbuf,
+					      SCDRV_BUFSZ) < 0) {
+				printk
+				    ("%s: failed to initialize SAL for"
+				     " system controller communication"
+				     " (%s/%s): outdated PROM?\n",
+				     __FUNCTION__, SYSCTL_BASENAME, devname);
+				kfree(scd);
+				kfree(salbuf);
+				continue;
+			}
+
+			dev = first_dev + m->nodes[i];
+			cdev_init(&scd->scd_cdev, &scdrv_fops);
+			if (cdev_add(&scd->scd_cdev, dev, 1)) {
+				printk("%s: failed to register system"
+				       " controller device (%s%s)\n",
+				       __FUNCTION__, SYSCTL_BASENAME, devname);
+				kfree(scd);
+				kfree(salbuf);
+				continue;
+			}
+
+			class_simple_device_add(snsc_class, dev, NULL,
+						"%s", devname);
+
+			ia64_sn_irtr_intr_enable(scd->scd_nasid,
+						 0 /*ignored */ ,
+						 SAL_IROUTER_INTR_RECV);
+		}
+	}
+	return 0;
+}
+
+/*
+ * scdrv_open
+ *
+ * Reserve a subchannel for system controller communication.
+ */
+
+static int
+scdrv_open(struct inode *inode, struct file *file)
+{
+	struct sysctl_data_s *scd;
+	struct subch_data_s *sd;
+	int rv;
+
+	/* look up device info for this device file */
+	scd = container_of(inode->i_cdev, struct sysctl_data_s, scd_cdev);
+
+	if (!scd) {
+		printk("%s: no such device\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	/* allocate memory for subchannel data */
+	sd = kmalloc(sizeof (struct subch_data_s), GFP_KERNEL);
+	if (sd == NULL) {
+		printk("%s: couldn't allocate subchannel data\n",
+		       __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* initialize subch_data_s fields */
+	memset(sd, 0, sizeof (struct subch_data_s));
+	sd->sd_nasid = scd->scd_nasid;
+	sd->sd_subch = ia64_sn_irtr_open(scd->scd_nasid);
+
+	if (sd->sd_subch < 0) {
+		kfree(sd);
+		printk("%s: couldn't allocate subchannel\n", __FUNCTION__);
+		return -EBUSY;
+	}
+
+	spin_lock_init(&sd->sd_rlock);
+	spin_lock_init(&sd->sd_wlock);
+	init_waitqueue_head(&sd->sd_rq);
+	init_waitqueue_head(&sd->sd_wq);
+	sema_init(&sd->sd_rbs, 1);
+	sema_init(&sd->sd_wbs, 1);
+
+	file->private_data = sd;
+
+	/* hook this subchannel up to the system controller interrupt */
+	rv = request_irq(SGI_UART_VECTOR, scdrv_interrupt,
+			 SA_SHIRQ | SA_INTERRUPT,
+			 SYSCTL_BASENAME, sd);
+	if (rv) {
+		ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);
+		kfree(sd);
+		printk("%s: irq request failed (%d)\n", __FUNCTION__, rv);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*
+ * scdrv_release
+ *
+ * Release a previously-reserved subchannel.
+ */
+
+static int
+scdrv_release(struct inode *inode, struct file *file)
+{
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+	int rv;
+
+	/* free the interrupt */
+	free_irq(SGI_UART_VECTOR, sd);
+
+	/* ask SAL to close the subchannel */
+	rv = ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);
+
+	kfree(sd);
+	return rv;
+}
+
+/*
+ * scdrv_read
+ *
+ * Called to read bytes from the open IRouter pipe.
+ *
+ */
+
+static inline int
+read_status_check(struct subch_data_s *sd, int *len)
+{
+	return ia64_sn_irtr_recv(sd->sd_nasid, sd->sd_subch, sd->sd_rb, len);
+}
+
+static ssize_t
+scdrv_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
+{
+	int status;
+	int len;
+	unsigned long flags;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+
+	/* try to get control of the read buffer */
+	if (down_trylock(&sd->sd_rbs)) {
+		/* somebody else has it now;
+		 * if we're non-blocking, then exit...
+		 */
+		if (file->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		/* ...or if we want to block, then do so here */
+		if (down_interruptible(&sd->sd_rbs)) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+	}
+
+	/* anything to read? */
+	len = CHUNKSIZE;
+	spin_lock_irqsave(&sd->sd_rlock, flags);
+	status = read_status_check(sd, &len);
+
+	/* if not, and we're blocking I/O, loop */
+	while (status < 0) {
+		if (file->f_flags & O_NONBLOCK) {
+			spin_unlock_irqrestore(&sd->sd_rlock, flags);
+			return -EAGAIN;
+		}
+		len = CHUNKSIZE;
+		if (scdrv_wait(&sd->sd_rq, &sd->sd_rlock, flags, 1000) < 0) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+		/* sd->sd_rlock was unlocked by scdrv_wait(), above */
+		spin_lock_irqsave(&sd->sd_rlock, flags);
+		status = read_status_check(sd, &len);
+	}
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+
+	if (len > 0) {
+		/* we read something in the last read_status_check(); copy
+		 * it out to user space
+		 */
+		if (count < len) {
+			DPRINTF("%s: only accepting %d of %d bytes\n",
+				__FUNCTION__, (int) count, len);
+		}
+		len = min((int) count, len);
+		if (copy_to_user(buf, sd->sd_rb, len))
+			return -EFAULT;
+	}
+
+	/* release the read buffer and wake anyone who might be
+	 * waiting for it
+	 */
+	up(&sd->sd_rbs);
+
+	/* return the number of characters read in */
+	return len;
+}
+
+/*
+ * scdrv_write
+ *
+ * Writes a chunk of an IRouter packet (or other system controller data)
+ * to the system controller.
+ *
+ */
+static inline int
+write_status_check(struct subch_data_s *sd, int count)
+{
+	return ia64_sn_irtr_send(sd->sd_nasid, sd->sd_subch, sd->sd_wb, count);
+}
+
+static ssize_t
+scdrv_write(struct file *file, const char __user *buf,
+	    size_t count, loff_t *f_pos)
+{
+	unsigned long flags;
+	int status;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+
+	/* try to get control of the write buffer */
+	if (down_trylock(&sd->sd_wbs)) {
+		/* somebody else has it now;
+		 * if we're non-blocking, then exit...
+		 */
+		if (file->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		/* ...or if we want to block, then do so here */
+		if (down_interruptible(&sd->sd_wbs)) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+	}
+
+	count = min((int) count, CHUNKSIZE);
+	if (copy_from_user(sd->sd_wb, buf, count))
+		return -EFAULT;
+
+	/* try to send the buffer */
+	spin_lock_irqsave(&sd->sd_wlock, flags);
+	status = write_status_check(sd, count);
+
+	/* if we failed, and we want to block, then loop */
+	while (status <= 0) {
+		if (file->f_flags & O_NONBLOCK) {
+			spin_unlock(&sd->sd_wlock);
+			return -EAGAIN;
+		}
+		if (scdrv_wait(&sd->sd_wq, &sd->sd_wlock, flags, 1000) < 0) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+
+		/* sd->sd_wlock was unlocked by scdrv_wait(), above */
+		spin_lock_irqsave(&sd->sd_wlock, flags);
+		status = write_status_check(sd, count);
+	}
+	spin_unlock_irqrestore(&sd->sd_wlock, flags);
+
+	/* release the write buffer and wake anyone who's waiting for it */
+	up(&sd->sd_wbs);
+
+	/* return the number of characters accepted (should be the complete
+	 * "chunk" as requested)
+	 */
+	if ((status >= 0) && (status < count)) {
+		DPRINTF("Didn't accept the full chunk; %d of %d\n",
+			status, (int) count);
+	}
+	return status;
+}
+
+static inline void
+scdrv_lock_all(struct subch_data_s *sd, unsigned long *flags)
+{
+	spin_lock_irqsave(&sd->sd_rlock, *flags);
+	spin_lock(&sd->sd_wlock);
+}
+
+static inline void
+scdrv_unlock_all(struct subch_data_s *sd, unsigned long flags)
+{
+	spin_unlock(&sd->sd_wlock);
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+}
+
+static unsigned int
+scdrv_poll(struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+	int status = 0;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+	unsigned long flags;
+
+	poll_wait(file, &sd->sd_rq, wait);
+	poll_wait(file, &sd->sd_wq, wait);
+
+	scdrv_lock_all(sd, &flags);
+	status = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);
+	scdrv_unlock_all(sd, flags);
+
+	if (status > 0) {
+		if (status & SAL_IROUTER_INTR_RECV) {
+			mask |= POLLIN | POLLRDNORM;
+		}
+		if (status & SAL_IROUTER_INTR_XMIT) {
+			mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+
+	return mask;
+}
+
+static irqreturn_t
+scdrv_interrupt(int irq, void *subch_data, struct pt_regs *regs)
+{
+	struct subch_data_s *sd = (struct subch_data_s *) subch_data;
+	unsigned long flags;
+	int status;
+
+	scdrv_lock_all(sd, &flags);
+	status = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);
+
+	if (status > 0) {
+		if (status & SAL_IROUTER_INTR_RECV) {
+			wake_up_all(&sd->sd_rq);
+		}
+		if (status & SAL_IROUTER_INTR_XMIT) {
+			ia64_sn_irtr_intr_disable
+			    (sd->sd_nasid, sd->sd_subch,
+			     SAL_IROUTER_INTR_XMIT);
+			wake_up_all(&sd->sd_wq);
+		}
+	}
+	scdrv_unlock_all(sd, flags);
+	return IRQ_HANDLED;
+}
+
+module_init(scdrv_init);
diff -uprN -X dontdiff original/drivers/char/snsc.h changed/drivers/char/snsc.h
--- original/drivers/char/snsc.h	1969-12-31 18:00:00.000000000 -0600
+++ changed/drivers/char/snsc.h	2004-07-30 15:30:49.000000000 -0500
@@ -0,0 +1,50 @@
+/*
+ * SN Platform system controller communication support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+/*
+ * This file contains macros and data types for communication with the
+ * system controllers in SGI SN systems.
+ */
+
+#ifndef _SN_SYSCTL_H_
+#define _SN_SYSCTL_H_
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/kobject.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <asm/sn/types.h>
+#include <asm/semaphore.h>
+
+#define CHUNKSIZE 127
+
+/* This structure is used to track an open subchannel. */
+struct subch_data_s {
+	nasid_t sd_nasid;	/* node on which the subchannel was opened */
+	int sd_subch;		/* subchannel number */
+	spinlock_t sd_rlock;	/* monitor lock for rsv */
+	spinlock_t sd_wlock;	/* monitor lock for wsv */
+	wait_queue_head_t sd_rq;	/* wait queue for readers */
+	wait_queue_head_t sd_wq;	/* wait queue for writers */
+	struct semaphore sd_rbs;	/* semaphore for read buffer */
+	struct semaphore sd_wbs;	/* semaphore for write buffer */
+
+	char sd_rb[CHUNKSIZE];	/* read buffer */
+	char sd_wb[CHUNKSIZE];	/* write buffer */
+};
+
+struct sysctl_data_s {
+	struct cdev scd_cdev;	/* Character device info */
+	nasid_t scd_nasid;	/* Node on which subchannels are opened. */
+};
+
+#endif /* _SN_SYSCTL_H_ */
diff -uprN -X dontdiff original/drivers/serial/sn_console.c changed/drivers/serial/sn_console.c
--- original/drivers/serial/sn_console.c	2004-07-27 13:32:38.000000000 -0500
+++ changed/drivers/serial/sn_console.c	2004-07-30 15:30:49.000000000 -0500
@@ -712,7 +712,8 @@ sn_sal_interrupt(int irq, void *dev_id,
 static int
 sn_sal_connect_interrupt(struct sn_cons_port *port)
 {
-	if (request_irq(SGI_UART_VECTOR, sn_sal_interrupt, SA_INTERRUPT,
+	if (request_irq(SGI_UART_VECTOR, sn_sal_interrupt,
+			SA_INTERRUPT | SA_SHIRQ,
 			"SAL console driver", port) >= 0) {
 		return SGI_UART_VECTOR;
 	}
diff -uprN -X dontdiff original/include/asm-ia64/sn/sn_sal.h changed/include/asm-ia64/sn/sn_sal.h
--- original/include/asm-ia64/sn/sn_sal.h	2004-07-11 12:35:31.000000000 -0500
+++ changed/include/asm-ia64/sn/sn_sal.h	2004-07-30 15:30:49.000000000 -0500
@@ -8,7 +8,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All rights reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All rights reserved.
  */


@@ -60,6 +60,7 @@
 #define  SN_SAL_SYSCTL_FRU_CAPTURE		   0x0200003f

 #define  SN_SAL_SYSCTL_IOBRICK_PCI_OP		   0x02000042	// reentrant
+#define	 SN_SAL_IROUTER_OP			   0x02000043

 /*
  * Service-specific constants
@@ -86,6 +87,25 @@
 #endif	/* CONFIG_HOTPLUG_PCI_SGI */

 /*
+ * IRouter (i.e. generalized system controller) operations
+ */
+#define SAL_IROUTER_OPEN	0	/* open a subchannel */
+#define SAL_IROUTER_CLOSE	1	/* close a subchannel */
+#define SAL_IROUTER_SEND	2	/* send part of an IRouter packet */
+#define SAL_IROUTER_RECV	3	/* receive part of an IRouter packet */
+#define SAL_IROUTER_INTR_STATUS	4	/* check the interrupt status for
+					 * an open subchannel
+					 */
+#define SAL_IROUTER_INTR_ON	5	/* enable an interrupt */
+#define SAL_IROUTER_INTR_OFF	6	/* disable an interrupt */
+#define SAL_IROUTER_INIT	7	/* initialize IRouter driver */
+
+/* IRouter interrupt mask bits */
+#define SAL_IROUTER_INTR_XMIT	SAL_CONSOLE_INTR_XMIT
+#define SAL_IROUTER_INTR_RECV	SAL_CONSOLE_INTR_RECV
+
+
+/*
  * SN_SAL_GET_PARTITION_ADDR return constants
  */
 #define SALRET_MORE_PASSES	1
@@ -704,4 +724,124 @@ ia64_sn_set_error_handling_features(cons
 	return rv.status;
 }

+
+/*
+ * Open a subchannel for sending arbitrary data to the system
+ * controller network via the system controller device associated with
+ * 'nasid'.  Return the subchannel number or a negative error code.
+ */
+static inline int
+ia64_sn_irtr_open(nasid_t nasid)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_OPEN, nasid,
+			   0, 0, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Close system controller subchannel 'subch' previously opened on 'nasid'.
+ */
+static inline int
+ia64_sn_irtr_close(nasid_t nasid, int subch)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_CLOSE,
+			   (u64) nasid, (u64) subch, 0, 0, 0, 0);
+	return (int) rv.status;
+}
+
+/*
+ * Read data from system controller associated with 'nasid' on
+ * subchannel 'subch'.  The buffer to be filled is pointed to by
+ * 'buf', and its capacity is in the integer pointed to by 'len'.  The
+ * referent of 'len' is set to the number of bytes read by the SAL
+ * call.  The return value is either SALRET_OK (for bytes read) or
+ * SALRET_ERROR (for error or "no data available").
+ */
+static inline int
+ia64_sn_irtr_recv(nasid_t nasid, int subch, char *buf, int *len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_RECV,
+			   (u64) nasid, (u64) subch, (u64) buf, (u64) len,
+			   0, 0);
+	return (int) rv.status;
+}
+
+/*
+ * Write data to the system controller network via the system
+ * controller associated with 'nasid' on suchannel 'subch'.  The
+ * buffer to be written out is pointed to by 'buf', and 'len' is the
+ * number of bytes to be written.  The return value is either the
+ * number of bytes written (which could be zero) or a negative error
+ * code.
+ */
+static inline int
+ia64_sn_irtr_send(nasid_t nasid, int subch, char *buf, int len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_SEND,
+			   (u64) nasid, (u64) subch, (u64) buf, (u64) len,
+			   0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Check whether any interrupts are pending for the system controller
+ * associated with 'nasid' and its subchannel 'subch'.  The return
+ * value is a mask of pending interrupts (SAL_IROUTER_INTR_XMIT and/or
+ * SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr(nasid_t nasid, int subch)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_STATUS,
+			   (u64) nasid, (u64) subch, 0, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Enable the interrupt indicated by the intr parameter (either
+ * SAL_IROUTER_INTR_XMIT or SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr_enable(nasid_t nasid, int subch, u64 intr)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_ON,
+			   (u64) nasid, (u64) subch, intr, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Disable the interrupt indicated by the intr parameter (either
+ * SAL_IROUTER_INTR_XMIT or SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr_disable(nasid_t nasid, int subch, u64 intr)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_OFF,
+			   (u64) nasid, (u64) subch, intr, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Initialize the SAL components of the system controller
+ * communication driver; specifically pass in a sizable buffer that
+ * can be used for allocation of subchannel queues as new subchannels
+ * are opened.  "buf" points to the buffer, and "len" specifies its
+ * length.
+ */
+static inline int
+ia64_sn_irtr_init(nasid_t nasid, void *buf, int len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INIT,
+			   (u64) nasid, (u64) buf, (u64) len, 0, 0, 0);
+	return (int) rv.status;
+}
+
 #endif /* _ASM_IA64_SN_SN_SAL_H */
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Christoph Hellwig <hch () infradead ! org>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Sat, 31 Jul 2004 09:55:13 +0000
Message-ID: <20040731105513.A17256 () infradead ! org>
--------------------
> +config SGI_SNSC
> +	bool "SGI Altix system controller communication support"

this won't compile for non-ia64, so you need a depency here.

> +#include "snsc.h"
> +#include <linux/interrupt.h>
> +#include <linux/sched.h>
> +#include <linux/device.h>
> +#include <linux/poll.h>
> +#include <linux/module.h>
> +#include <linux/slab.h>
> +#include <asm/sn/sn_sal.h>
> +#include <asm/sn/nodepda.h>

please include your private header after system headers.  But I don't
thing you need snsc.h at all, just move it's contents into snsc.c

> +
> +
> +#define SYSCTL_BASENAME	"snsc"
> +
> +#define SCDRV_BUFSZ	2048
> +
> +#ifdef SCDRV_DEBUG
> +#define DPRINTF(x...)	printk(x)
> +#else
> +#define DPRINTF(x...)	do {} while(0)
> +#endif

please use the existing pr_debug, or even dev_dbg where you have a struct
device.

> +static int scdrv_open(struct inode *, struct file *);
> +static int scdrv_release(struct inode *, struct file *);
> +static ssize_t scdrv_read(struct file *, char __user *, size_t, loff_t *);
> +static ssize_t scdrv_write(struct file *, const char __user *,
> +			   size_t, loff_t *);
> +static unsigned int scdrv_poll(struct file *, struct poll_table_struct *);
> +static irqreturn_t scdrv_interrupt(int, void *, struct pt_regs *);
> +
> +static struct file_operations scdrv_fops = {
> +	.owner =	THIS_MODULE,
> +	.read =		scdrv_read,
> +	.write =	scdrv_write,
> +	.poll =		scdrv_poll,
> +	.open =		scdrv_open,
> +	.release =	scdrv_release,
> +};

the driver would become more readable by having struct file_operations
after the actual function bodies, thus eliminating the need for additional
prototypes.

> +/*
> + * scdrv_wait
> + *
> + * Call this function to wait on one of the queues associated with an
> + * open subchannel.  Avoid races by entering this function with a held
> + * lock that protects the wait queue; don't release the lock until after
> + * we've added ourselves to the queue.
> + */
> +static inline int
> +scdrv_wait(wait_queue_head_t *waitq_head, spinlock_t *waitq_lock,
> +	   unsigned long flags, unsigned long timeout)
> +{
> +	DECLARE_WAITQUEUE(wait, current);
> +	int ret;
> +
> +	add_wait_queue(waitq_head, &wait);
> +	set_current_state(TASK_INTERRUPTIBLE);
> +	spin_unlock_irqrestore(waitq_lock, flags);
> +
> +	if (timeout) {
> +		ret = schedule_timeout(timeout);
> +	} else {
> +		schedule();
> +	}

You're always calling this with a timeout set.  Also I think the code
would be much more readable by opencoding this in the two callers.  That'd
also give you a chance to switch to prepare_wait & co.

> +static int
> +scdrv_open(struct inode *inode, struct file *file)
> +{
> +	struct sysctl_data_s *scd;
> +	struct subch_data_s *sd;
> +	int rv;
> +
> +	/* look up device info for this device file */
> +	scd = container_of(inode->i_cdev, struct sysctl_data_s, scd_cdev);
> +
> +	if (!scd) {
> +		printk("%s: no such device\n", __FUNCTION__);
> +		return -ENODEV;
> +	}

Can't ever be NULL.

> +		len = min((int) count, len);
> +		if (copy_to_user(buf, sd->sd_rb, len))
> +			return -EFAULT;

Don't you have sd->sd_rbs held here?

> +static inline void
> +scdrv_lock_all(struct subch_data_s *sd, unsigned long *flags)
> +{
> +	spin_lock_irqsave(&sd->sd_rlock, *flags);
> +	spin_lock(&sd->sd_wlock);
> +}
> +
> +static inline void
> +scdrv_unlock_all(struct subch_data_s *sd, unsigned long flags)
> +{
> +	spin_unlock(&sd->sd_wlock);
> +	spin_unlock_irqrestore(&sd->sd_rlock, flags);
> +}

It would probably be more readable without these wrappers.

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Andrew Morton <akpm () osdl ! org>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Sun, 01 Aug 2004 00:55:18 +0000
Message-ID: <20040731175518.407425bc.akpm () osdl ! org>
--------------------
Greg Howard <ghoward@sgi.com> wrote:
>
>  Here's a cleaned-up version of altix-system-controller-driver.patch.

Breaks the build for all other architectures:

Is this right?

--- 25/drivers/char/Kconfig~snsc-build-fix	2004-07-31 17:53:52.818565424 -0700
+++ 25-akpm/drivers/char/Kconfig	2004-07-31 17:54:39.658444680 -0700
@@ -426,6 +426,7 @@ config A2232
 
 config SGI_SNSC
 	bool "SGI Altix system controller communication support"
+	depends on CONFIG_IA64_SGI_SN2
 	help
 	  If you have an SGI Altix and you want to enable system
 	  controller communication from user space (you want this!),
_

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Greg Howard <ghoward () sgi ! com>
To: linux-kernel
Subject: Re: [PATCH] Altix system controller communication driver
Date: Mon, 02 Aug 2004 11:46:50 +0000
Message-ID: <Pine.SGI.4.58.0408020645370.8791 () gallifrey ! americas ! sgi ! com>
--------------------
On Sat, 31 Jul 2004, Andrew Morton wrote:

> Breaks the build for all other architectures:
>
> Is this right?
>
> --- 25/drivers/char/Kconfig~snsc-build-fix	2004-07-31 17:53:52.818565424 -0700
> +++ 25-akpm/drivers/char/Kconfig	2004-07-31 17:54:39.658444680 -0700
> @@ -426,6 +426,7 @@ config A2232
>
>  config SGI_SNSC
>  	bool "SGI Altix system controller communication support"
> +	depends on CONFIG_IA64_SGI_SN2
>  	help
>  	  If you have an SGI Altix and you want to enable system
>  	  controller communication from user space (you want this!),
> _
>

No, it's not.  Christoph caught this and had a couple of other
suggestions too.  I'll fix and repost.  Sorry.

Thanks - Greg
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Linux Kernel Mailing List <linux-kernel () vger ! kernel ! org>
To: git-commits-head
Subject: [PATCH] Altix system controller communication driver
Date: Mon, 23 Aug 2004 19:55:46 +0000
Message-ID: <200408232135.i7NLZT29017732 () hera ! kernel ! org>
--------------------
ChangeSet 1.2015, 2004/08/23 12:55:46-07:00, ghoward@sgi.com

	[PATCH] Altix system controller communication driver
	
	drivers/char/Kconfig
	    Make a config option for the SGI Altix system controller
	    communication driver.
	
	drivers/char/Makefile
	    Add an object file target for the SGI Altix system controller
	    communication driver.
	
	drivers/char/snsc.c
	    This file implements a driver that allows an application to
	    communicate with the SGI Altix system controller network. Most of
	    the heavy lifting is done in SAL in order to allow Linux run-time
	    applications to share the system controller link(s) with SAL
	    run-time services.
	
	drivers/char/snsc.h
	    Macros and data types for the Altix system controller driver
	    (drivers/char/snsc.c).
	
	drivers/serial/sn_console.c
	    Modify the SGI Altix console driver to share an interupt with the
	    system controller communication driver.
	
	include/asm-ia64/sn/sn_sal.h
	    Provide an interface to the SAL runtime services that allow the
	    kernel or user applications to send/receive arbitary system
	    controller data.
	
	Signed-off-by: Greg Howard <ghoward@sgi.com>
	Signed-off-by: Andrew Morton <akpm@osdl.org>
	Signed-off-by: Linus Torvalds <torvalds@osdl.org>



 arch/ia64/configs/generic_defconfig |    1 
 arch/ia64/configs/sn2_defconfig     |    1 
 drivers/char/Kconfig                |    8 
 drivers/char/Makefile               |    1 
 drivers/char/snsc.c                 |  456 ++++++++++++++++++++++++++++++++++++
 drivers/char/snsc.h                 |   50 +++
 drivers/serial/sn_console.c         |    3 
 include/asm-ia64/sn/sn_sal.h        |  142 +++++++++++
 8 files changed, 660 insertions(+), 2 deletions(-)


diff -Nru a/arch/ia64/configs/generic_defconfig b/arch/ia64/configs/generic_defconfig
--- a/arch/ia64/configs/generic_defconfig	2004-08-23 14:35:39 -07:00
+++ b/arch/ia64/configs/generic_defconfig	2004-08-23 14:35:39 -07:00
@@ -575,6 +575,7 @@
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
 # CONFIG_STALDRV is not set
+CONFIG_SGI_SNSC=y
 
 #
 # Serial drivers
diff -Nru a/arch/ia64/configs/sn2_defconfig b/arch/ia64/configs/sn2_defconfig
--- a/arch/ia64/configs/sn2_defconfig	2004-08-23 14:35:39 -07:00
+++ b/arch/ia64/configs/sn2_defconfig	2004-08-23 14:35:39 -07:00
@@ -527,6 +527,7 @@
 # CONFIG_SYNCLINKMP is not set
 # CONFIG_N_HDLC is not set
 # CONFIG_STALDRV is not set
+CONFIG_SGI_SNSC=y
 
 #
 # Serial drivers
diff -Nru a/drivers/char/Kconfig b/drivers/char/Kconfig
--- a/drivers/char/Kconfig	2004-08-23 14:35:39 -07:00
+++ b/drivers/char/Kconfig	2004-08-23 14:35:39 -07:00
@@ -424,6 +424,14 @@
 	  will also be built as a module. This has to be loaded before
 	  "ser_a2232". If you want to do this, answer M here.
 
+config SGI_SNSC
+	bool "SGI Altix system controller communication support"
+	depends on (IA64_SGI_SN2 || IA64_GENERIC)
+	help
+	  If you have an SGI Altix and you want to enable system
+	  controller communication from user space (you want this!),
+	  say Y.  Otherwise, say N.
+
 source "drivers/serial/Kconfig"
 
 config UNIX98_PTYS
diff -Nru a/drivers/char/Makefile b/drivers/char/Makefile
--- a/drivers/char/Makefile	2004-08-23 14:35:39 -07:00
+++ b/drivers/char/Makefile	2004-08-23 14:35:39 -07:00
@@ -41,6 +41,7 @@
 obj-$(CONFIG_RIO)		+= rio/ generic_serial.o
 obj-$(CONFIG_HVC_CONSOLE)	+= hvc_console.o hvsi.o
 obj-$(CONFIG_RAW_DRIVER)	+= raw.o
+obj-$(CONFIG_SGI_SNSC)		+= snsc.o
 obj-$(CONFIG_VIOCONS) += viocons.o
 obj-$(CONFIG_VIOTAPE)		+= viotape.o
 obj-$(CONFIG_HVCS)		+= hvcs.o
diff -Nru a/drivers/char/snsc.c b/drivers/char/snsc.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/char/snsc.c	2004-08-23 14:35:39 -07:00
@@ -0,0 +1,456 @@
+/*
+ * SN Platform system controller communication support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+/*
+ * System controller communication driver
+ *
+ * This driver allows a user process to communicate with the system
+ * controller (a.k.a. "IRouter") network in an SGI SN system.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/sched.h>
+#include <linux/device.h>
+#include <linux/poll.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <asm/sn/sn_sal.h>
+#include <asm/sn/nodepda.h>
+#include "snsc.h"
+
+#define SYSCTL_BASENAME	"snsc"
+
+#define SCDRV_BUFSZ	2048
+#define SCDRV_TIMEOUT	1000
+
+static irqreturn_t
+scdrv_interrupt(int irq, void *subch_data, struct pt_regs *regs)
+{
+	struct subch_data_s *sd = subch_data;
+	unsigned long flags;
+	int status;
+
+	spin_lock_irqsave(&sd->sd_rlock, flags);
+	spin_lock(&sd->sd_wlock);
+	status = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);
+
+	if (status > 0) {
+		if (status & SAL_IROUTER_INTR_RECV) {
+			wake_up(&sd->sd_rq);
+		}
+		if (status & SAL_IROUTER_INTR_XMIT) {
+			ia64_sn_irtr_intr_disable
+			    (sd->sd_nasid, sd->sd_subch,
+			     SAL_IROUTER_INTR_XMIT);
+			wake_up(&sd->sd_wq);
+		}
+	}
+	spin_unlock(&sd->sd_wlock);
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+	return IRQ_HANDLED;
+}
+
+/*
+ * scdrv_open
+ *
+ * Reserve a subchannel for system controller communication.
+ */
+
+static int
+scdrv_open(struct inode *inode, struct file *file)
+{
+	struct sysctl_data_s *scd;
+	struct subch_data_s *sd;
+	int rv;
+
+	/* look up device info for this device file */
+	scd = container_of(inode->i_cdev, struct sysctl_data_s, scd_cdev);
+
+	/* allocate memory for subchannel data */
+	sd = kmalloc(sizeof (struct subch_data_s), GFP_KERNEL);
+	if (sd == NULL) {
+		printk("%s: couldn't allocate subchannel data\n",
+		       __FUNCTION__);
+		return -ENOMEM;
+	}
+
+	/* initialize subch_data_s fields */
+	memset(sd, 0, sizeof (struct subch_data_s));
+	sd->sd_nasid = scd->scd_nasid;
+	sd->sd_subch = ia64_sn_irtr_open(scd->scd_nasid);
+
+	if (sd->sd_subch < 0) {
+		kfree(sd);
+		printk("%s: couldn't allocate subchannel\n", __FUNCTION__);
+		return -EBUSY;
+	}
+
+	spin_lock_init(&sd->sd_rlock);
+	spin_lock_init(&sd->sd_wlock);
+	init_waitqueue_head(&sd->sd_rq);
+	init_waitqueue_head(&sd->sd_wq);
+	sema_init(&sd->sd_rbs, 1);
+	sema_init(&sd->sd_wbs, 1);
+
+	file->private_data = sd;
+
+	/* hook this subchannel up to the system controller interrupt */
+	rv = request_irq(SGI_UART_VECTOR, scdrv_interrupt,
+			 SA_SHIRQ | SA_INTERRUPT,
+			 SYSCTL_BASENAME, sd);
+	if (rv) {
+		ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);
+		kfree(sd);
+		printk("%s: irq request failed (%d)\n", __FUNCTION__, rv);
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+/*
+ * scdrv_release
+ *
+ * Release a previously-reserved subchannel.
+ */
+
+static int
+scdrv_release(struct inode *inode, struct file *file)
+{
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+	int rv;
+
+	/* free the interrupt */
+	free_irq(SGI_UART_VECTOR, sd);
+
+	/* ask SAL to close the subchannel */
+	rv = ia64_sn_irtr_close(sd->sd_nasid, sd->sd_subch);
+
+	kfree(sd);
+	return rv;
+}
+
+/*
+ * scdrv_read
+ *
+ * Called to read bytes from the open IRouter pipe.
+ *
+ */
+
+static inline int
+read_status_check(struct subch_data_s *sd, int *len)
+{
+	return ia64_sn_irtr_recv(sd->sd_nasid, sd->sd_subch, sd->sd_rb, len);
+}
+
+static ssize_t
+scdrv_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos)
+{
+	int status;
+	int len;
+	unsigned long flags;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+
+	/* try to get control of the read buffer */
+	if (down_trylock(&sd->sd_rbs)) {
+		/* somebody else has it now;
+		 * if we're non-blocking, then exit...
+		 */
+		if (file->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		/* ...or if we want to block, then do so here */
+		if (down_interruptible(&sd->sd_rbs)) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+	}
+
+	/* anything to read? */
+	len = CHUNKSIZE;
+	spin_lock_irqsave(&sd->sd_rlock, flags);
+	status = read_status_check(sd, &len);
+
+	/* if not, and we're blocking I/O, loop */
+	while (status < 0) {
+		DECLARE_WAITQUEUE(wait, current);
+
+		if (file->f_flags & O_NONBLOCK) {
+			spin_unlock_irqrestore(&sd->sd_rlock, flags);
+			up(&sd->sd_rbs);
+			return -EAGAIN;
+		}
+
+		len = CHUNKSIZE;
+		add_wait_queue(&sd->sd_rq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_unlock_irqrestore(&sd->sd_rlock, flags);
+
+		schedule_timeout(SCDRV_TIMEOUT);
+
+		remove_wait_queue(&sd->sd_rq, &wait);
+		if (signal_pending(current)) {
+			/* wait was interrupted */
+			up(&sd->sd_rbs);
+			return -ERESTARTSYS;
+		}
+
+		spin_lock_irqsave(&sd->sd_rlock, flags);
+		status = read_status_check(sd, &len);
+	}
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+
+	if (len > 0) {
+		/* we read something in the last read_status_check(); copy
+		 * it out to user space
+		 */
+		if (count < len) {
+			pr_debug("%s: only accepting %d of %d bytes\n",
+				 __FUNCTION__, (int) count, len);
+		}
+		len = min((int) count, len);
+		if (copy_to_user(buf, sd->sd_rb, len))
+			len = -EFAULT;
+	}
+
+	/* release the read buffer and wake anyone who might be
+	 * waiting for it
+	 */
+	up(&sd->sd_rbs);
+
+	/* return the number of characters read in */
+	return len;
+}
+
+/*
+ * scdrv_write
+ *
+ * Writes a chunk of an IRouter packet (or other system controller data)
+ * to the system controller.
+ *
+ */
+static inline int
+write_status_check(struct subch_data_s *sd, int count)
+{
+	return ia64_sn_irtr_send(sd->sd_nasid, sd->sd_subch, sd->sd_wb, count);
+}
+
+static ssize_t
+scdrv_write(struct file *file, const char __user *buf,
+	    size_t count, loff_t *f_pos)
+{
+	unsigned long flags;
+	int status;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+
+	/* try to get control of the write buffer */
+	if (down_trylock(&sd->sd_wbs)) {
+		/* somebody else has it now;
+		 * if we're non-blocking, then exit...
+		 */
+		if (file->f_flags & O_NONBLOCK) {
+			return -EAGAIN;
+		}
+		/* ...or if we want to block, then do so here */
+		if (down_interruptible(&sd->sd_wbs)) {
+			/* something went wrong with wait */
+			return -ERESTARTSYS;
+		}
+	}
+
+	count = min((int) count, CHUNKSIZE);
+	if (copy_from_user(sd->sd_wb, buf, count)) {
+		up(&sd->sd_wbs);
+		return -EFAULT;
+	}
+
+	/* try to send the buffer */
+	spin_lock_irqsave(&sd->sd_wlock, flags);
+	status = write_status_check(sd, count);
+
+	/* if we failed, and we want to block, then loop */
+	while (status <= 0) {
+		DECLARE_WAITQUEUE(wait, current);
+
+		if (file->f_flags & O_NONBLOCK) {
+			spin_unlock(&sd->sd_wlock);
+			up(&sd->sd_wbs);
+			return -EAGAIN;
+		}
+
+		add_wait_queue(&sd->sd_wq, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+		spin_unlock_irqrestore(&sd->sd_wlock, flags);
+
+		schedule_timeout(SCDRV_TIMEOUT);
+
+		remove_wait_queue(&sd->sd_wq, &wait);
+		if (signal_pending(current)) {
+			/* wait was interrupted */
+			up(&sd->sd_wbs);
+			return -ERESTARTSYS;
+		}
+
+		spin_lock_irqsave(&sd->sd_wlock, flags);
+		status = write_status_check(sd, count);
+	}
+	spin_unlock_irqrestore(&sd->sd_wlock, flags);
+
+	/* release the write buffer and wake anyone who's waiting for it */
+	up(&sd->sd_wbs);
+
+	/* return the number of characters accepted (should be the complete
+	 * "chunk" as requested)
+	 */
+	if ((status >= 0) && (status < count)) {
+		pr_debug("Didn't accept the full chunk; %d of %d\n",
+			 status, (int) count);
+	}
+	return status;
+}
+
+static unsigned int
+scdrv_poll(struct file *file, struct poll_table_struct *wait)
+{
+	unsigned int mask = 0;
+	int status = 0;
+	struct subch_data_s *sd = (struct subch_data_s *) file->private_data;
+	unsigned long flags;
+
+	poll_wait(file, &sd->sd_rq, wait);
+	poll_wait(file, &sd->sd_wq, wait);
+
+	spin_lock_irqsave(&sd->sd_rlock, flags);
+	spin_lock(&sd->sd_wlock);
+	status = ia64_sn_irtr_intr(sd->sd_nasid, sd->sd_subch);
+	spin_unlock(&sd->sd_wlock);
+	spin_unlock_irqrestore(&sd->sd_rlock, flags);
+
+	if (status > 0) {
+		if (status & SAL_IROUTER_INTR_RECV) {
+			mask |= POLLIN | POLLRDNORM;
+		}
+		if (status & SAL_IROUTER_INTR_XMIT) {
+			mask |= POLLOUT | POLLWRNORM;
+		}
+	}
+
+	return mask;
+}
+
+static struct file_operations scdrv_fops = {
+	.owner =	THIS_MODULE,
+	.read =		scdrv_read,
+	.write =	scdrv_write,
+	.poll =		scdrv_poll,
+	.open =		scdrv_open,
+	.release =	scdrv_release,
+};
+
+/*
+ * scdrv_init
+ *
+ * Called at boot time to initialize the system controller communication
+ * facility.
+ */
+int __init
+scdrv_init(void)
+{
+	geoid_t geoid;
+	cmoduleid_t cmod;
+	int i;
+	char devname[32];
+	char *devnamep;
+	module_t *m;
+	struct sysctl_data_s *scd;
+	void *salbuf;
+	struct class_simple *snsc_class;
+	dev_t first_dev, dev;
+
+	if (alloc_chrdev_region(&first_dev, 0, (MAX_SLABS*nummodules),
+				SYSCTL_BASENAME) < 0) {
+		printk("%s: failed to register SN system controller device\n",
+		       __FUNCTION__);
+		return -ENODEV;
+	}
+	snsc_class = class_simple_create(THIS_MODULE, SYSCTL_BASENAME);
+
+	for (cmod = 0; cmod < nummodules; cmod++) {
+		m = sn_modules[cmod];
+		for (i = 0; i <= MAX_SLABS; i++) {
+
+			if (m->nodes[i] == -1) {
+				/* node is not alive in module */
+				continue;
+			}
+
+			geoid = m->geoid[i];
+			devnamep = devname;
+			format_module_id(devnamep, geo_module(geoid),
+					 MODULE_FORMAT_BRIEF);
+			devnamep = devname + strlen(devname);
+			sprintf(devnamep, "#%d", geo_slab(geoid));
+
+			/* allocate sysctl device data */
+			scd = kmalloc(sizeof (struct sysctl_data_s),
+				      GFP_KERNEL);
+			if (!scd) {
+				printk("%s: failed to allocate device info"
+				       "for %s/%s\n", __FUNCTION__,
+				       SYSCTL_BASENAME, devname);
+				continue;
+			}
+			memset(scd, 0, sizeof (struct sysctl_data_s));
+
+			/* initialize sysctl device data fields */
+			scd->scd_nasid = cnodeid_to_nasid(m->nodes[i]);
+			if (!(salbuf = kmalloc(SCDRV_BUFSZ, GFP_KERNEL))) {
+				printk("%s: failed to allocate driver buffer"
+				       "(%s%s)\n", __FUNCTION__,
+				       SYSCTL_BASENAME, devname);
+				kfree(scd);
+				continue;
+			}
+
+			if (ia64_sn_irtr_init(scd->scd_nasid, salbuf,
+					      SCDRV_BUFSZ) < 0) {
+				printk
+				    ("%s: failed to initialize SAL for"
+				     " system controller communication"
+				     " (%s/%s): outdated PROM?\n",
+				     __FUNCTION__, SYSCTL_BASENAME, devname);
+				kfree(scd);
+				kfree(salbuf);
+				continue;
+			}
+
+			dev = first_dev + m->nodes[i];
+			cdev_init(&scd->scd_cdev, &scdrv_fops);
+			if (cdev_add(&scd->scd_cdev, dev, 1)) {
+				printk("%s: failed to register system"
+				       " controller device (%s%s)\n",
+				       __FUNCTION__, SYSCTL_BASENAME, devname);
+				kfree(scd);
+				kfree(salbuf);
+				continue;
+			}
+
+			class_simple_device_add(snsc_class, dev, NULL,
+						"%s", devname);
+
+			ia64_sn_irtr_intr_enable(scd->scd_nasid,
+						 0 /*ignored */ ,
+						 SAL_IROUTER_INTR_RECV);
+		}
+	}
+	return 0;
+}
+
+module_init(scdrv_init);
diff -Nru a/drivers/char/snsc.h b/drivers/char/snsc.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/char/snsc.h	2004-08-23 14:35:39 -07:00
@@ -0,0 +1,50 @@
+/*
+ * SN Platform system controller communication support
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 Silicon Graphics, Inc. All rights reserved.
+ */
+
+/*
+ * This file contains macros and data types for communication with the
+ * system controllers in SGI SN systems.
+ */
+
+#ifndef _SN_SYSCTL_H_
+#define _SN_SYSCTL_H_
+
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/wait.h>
+#include <linux/kobject.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <asm/sn/types.h>
+#include <asm/semaphore.h>
+
+#define CHUNKSIZE 127
+
+/* This structure is used to track an open subchannel. */
+struct subch_data_s {
+	nasid_t sd_nasid;	/* node on which the subchannel was opened */
+	int sd_subch;		/* subchannel number */
+	spinlock_t sd_rlock;	/* monitor lock for rsv */
+	spinlock_t sd_wlock;	/* monitor lock for wsv */
+	wait_queue_head_t sd_rq;	/* wait queue for readers */
+	wait_queue_head_t sd_wq;	/* wait queue for writers */
+	struct semaphore sd_rbs;	/* semaphore for read buffer */
+	struct semaphore sd_wbs;	/* semaphore for write buffer */
+
+	char sd_rb[CHUNKSIZE];	/* read buffer */
+	char sd_wb[CHUNKSIZE];	/* write buffer */
+};
+
+struct sysctl_data_s {
+	struct cdev scd_cdev;	/* Character device info */
+	nasid_t scd_nasid;	/* Node on which subchannels are opened. */
+};
+
+#endif /* _SN_SYSCTL_H_ */
diff -Nru a/drivers/serial/sn_console.c b/drivers/serial/sn_console.c
--- a/drivers/serial/sn_console.c	2004-08-23 14:35:39 -07:00
+++ b/drivers/serial/sn_console.c	2004-08-23 14:35:39 -07:00
@@ -714,7 +714,8 @@
 static int
 sn_sal_connect_interrupt(struct sn_cons_port *port)
 {
-	if (request_irq(SGI_UART_VECTOR, sn_sal_interrupt, SA_INTERRUPT,
+	if (request_irq(SGI_UART_VECTOR, sn_sal_interrupt,
+			SA_INTERRUPT | SA_SHIRQ,
 			"SAL console driver", port) >= 0) {
 		return SGI_UART_VECTOR;
 	}
diff -Nru a/include/asm-ia64/sn/sn_sal.h b/include/asm-ia64/sn/sn_sal.h
--- a/include/asm-ia64/sn/sn_sal.h	2004-08-23 14:35:39 -07:00
+++ b/include/asm-ia64/sn/sn_sal.h	2004-08-23 14:35:39 -07:00
@@ -8,7 +8,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All rights reserved.
+ * Copyright (c) 2000-2004 Silicon Graphics, Inc.  All rights reserved.
  */
 
 
@@ -60,6 +60,7 @@
 #define  SN_SAL_SYSCTL_FRU_CAPTURE		   0x0200003f
 
 #define  SN_SAL_SYSCTL_IOBRICK_PCI_OP		   0x02000042	// reentrant
+#define	 SN_SAL_IROUTER_OP			   0x02000043
 
 /*
  * Service-specific constants
@@ -86,6 +87,25 @@
 #endif	/* CONFIG_HOTPLUG_PCI_SGI */
 
 /*
+ * IRouter (i.e. generalized system controller) operations
+ */
+#define SAL_IROUTER_OPEN	0	/* open a subchannel */
+#define SAL_IROUTER_CLOSE	1	/* close a subchannel */
+#define SAL_IROUTER_SEND	2	/* send part of an IRouter packet */
+#define SAL_IROUTER_RECV	3	/* receive part of an IRouter packet */
+#define SAL_IROUTER_INTR_STATUS	4	/* check the interrupt status for
+					 * an open subchannel
+					 */
+#define SAL_IROUTER_INTR_ON	5	/* enable an interrupt */
+#define SAL_IROUTER_INTR_OFF	6	/* disable an interrupt */
+#define SAL_IROUTER_INIT	7	/* initialize IRouter driver */
+
+/* IRouter interrupt mask bits */
+#define SAL_IROUTER_INTR_XMIT	SAL_CONSOLE_INTR_XMIT
+#define SAL_IROUTER_INTR_RECV	SAL_CONSOLE_INTR_RECV
+
+
+/*
  * SN_SAL_GET_PARTITION_ADDR return constants
  */
 #define SALRET_MORE_PASSES	1
@@ -702,6 +722,126 @@
 			feature_bits[5],
 			feature_bits[6]);
 	return rv.status;
+}
+
+
+/*
+ * Open a subchannel for sending arbitrary data to the system
+ * controller network via the system controller device associated with
+ * 'nasid'.  Return the subchannel number or a negative error code.
+ */
+static inline int
+ia64_sn_irtr_open(nasid_t nasid)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_OPEN, nasid,
+			   0, 0, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Close system controller subchannel 'subch' previously opened on 'nasid'.
+ */
+static inline int
+ia64_sn_irtr_close(nasid_t nasid, int subch)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_CLOSE,
+			   (u64) nasid, (u64) subch, 0, 0, 0, 0);
+	return (int) rv.status;
+}
+
+/*
+ * Read data from system controller associated with 'nasid' on
+ * subchannel 'subch'.  The buffer to be filled is pointed to by
+ * 'buf', and its capacity is in the integer pointed to by 'len'.  The
+ * referent of 'len' is set to the number of bytes read by the SAL
+ * call.  The return value is either SALRET_OK (for bytes read) or
+ * SALRET_ERROR (for error or "no data available").
+ */
+static inline int
+ia64_sn_irtr_recv(nasid_t nasid, int subch, char *buf, int *len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_RECV,
+			   (u64) nasid, (u64) subch, (u64) buf, (u64) len,
+			   0, 0);
+	return (int) rv.status;
+}
+
+/*
+ * Write data to the system controller network via the system
+ * controller associated with 'nasid' on suchannel 'subch'.  The
+ * buffer to be written out is pointed to by 'buf', and 'len' is the
+ * number of bytes to be written.  The return value is either the
+ * number of bytes written (which could be zero) or a negative error
+ * code.
+ */
+static inline int
+ia64_sn_irtr_send(nasid_t nasid, int subch, char *buf, int len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_SEND,
+			   (u64) nasid, (u64) subch, (u64) buf, (u64) len,
+			   0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Check whether any interrupts are pending for the system controller
+ * associated with 'nasid' and its subchannel 'subch'.  The return
+ * value is a mask of pending interrupts (SAL_IROUTER_INTR_XMIT and/or
+ * SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr(nasid_t nasid, int subch)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_STATUS,
+			   (u64) nasid, (u64) subch, 0, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Enable the interrupt indicated by the intr parameter (either
+ * SAL_IROUTER_INTR_XMIT or SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr_enable(nasid_t nasid, int subch, u64 intr)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_ON,
+			   (u64) nasid, (u64) subch, intr, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Disable the interrupt indicated by the intr parameter (either
+ * SAL_IROUTER_INTR_XMIT or SAL_IROUTER_INTR_RECV).
+ */
+static inline int
+ia64_sn_irtr_intr_disable(nasid_t nasid, int subch, u64 intr)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INTR_OFF,
+			   (u64) nasid, (u64) subch, intr, 0, 0, 0);
+	return (int) rv.v0;
+}
+
+/*
+ * Initialize the SAL components of the system controller
+ * communication driver; specifically pass in a sizable buffer that
+ * can be used for allocation of subchannel queues as new subchannels
+ * are opened.  "buf" points to the buffer, and "len" specifies its
+ * length.
+ */
+static inline int
+ia64_sn_irtr_init(nasid_t nasid, void *buf, int len)
+{
+	struct ia64_sal_retval rv;
+	SAL_CALL_REENTRANT(rv, SN_SAL_IROUTER_OP, SAL_IROUTER_INIT,
+			   (u64) nasid, (u64) buf, (u64) len, 0, 0, 0);
+	return (int) rv.status;
 }
 
 #endif /* _ASM_IA64_SN_SN_SAL_H */
-
To unsubscribe from this list: send the line "unsubscribe bk-commits-head" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Check for signed one-bit bitfields. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Check for signed one-bit bitfields.
Date: Thu, 12 Aug 2004 20:32:28 +0000
Message-ID: <20040812203228.093011422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 13:22:54-04:00 welinder@troll.com 
#   symbol.c:
#     Check for signed one-bit bitfields.
# 
# symbol.c
#   2004/08/12 13:22:39-04:00 welinder@troll.com +10 -1
#   Check for signed one-bit bitfields.
# 
diff -Nru a/symbol.c b/symbol.c
--- a/symbol.c	2004-08-01 23:29:55 -04:00
+++ b/symbol.c	2004-08-12 13:22:39 -04:00
@@ -161,14 +161,23 @@
 {
 	struct symbol *base_type = sym->ctype.base_type;
 	unsigned long bit_size, alignment;
+	int is_signed;
 
 	if (!base_type)
 		return;
 	examine_symbol_type(base_type);
 	bit_size = base_type->bit_size;
 	if (sym->fieldwidth > bit_size) {
-		warn(sym->pos, "impossible field-width for this type");
+		warn(sym->pos, "impossible field-width, %d, for this type",
+		     sym->fieldwidth);
 		sym->fieldwidth = bit_size;
+	}
+
+	is_signed = !(base_type->ctype.modifiers & MOD_UNSIGNED);
+	if (sym->fieldwidth == 1 && is_signed) {
+		// Valid values are either {-1;0} or {0}, depending on integer
+		// representation.  The latter makes for very efficient code...
+		warn(sym->pos, "dubious one-bit signed bitfield");
 	}
 	alignment = base_type->ctype.alignment;
 	if (!sym->ctype.alignment)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Compat file for Cygwin ===

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: [PATCH] Compat file for Cygwin
Date: Fri, 08 Oct 2004 18:15:25 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKCEFEDEAA.mshah () teja ! com>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_0013_01C4AD28.1C047DD0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit


I changed the compat-cygwin.c to use the function (identical_files) from
compat directory since it was using the same one. Here is the patch.

Thanks,

-Mitesh

> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of
> Morten Welinder
> Sent: Saturday, October 02, 2004 7:01 PM
> To: linux-sparse@vger.kernel.org
> Subject: [BK PATCH] Compat file for Solaris.
>
>
>
>
> Linus,
>
> this does the Solaris compatibility in the way you outlined.
>
> Morten
>



------=_NextPart_000_0013_01C4AD28.1C047DD0
Content-Type: text/plain;
	name="diff.txt"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="diff.txt"

Index: Makefile=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /home/cvs/root/sparse-bk/Makefile,v=0A=
retrieving revision 1.4=0A=
diff -u -r1.4 Makefile=0A=
--- Makefile	8 Oct 2004 17:52:25 -0000	1.4=0A=
+++ Makefile	8 Oct 2004 18:10:15 -0000=0A=
@@ -78,7 +78,7 @@=0A=
 	$(LIB_H)=0A=
 compat-solaris.o: compat/id-files-stat.c compat/mmap-blob.c $(LIB_H)=0A=
 compat-mingw.o: $(LIB_H)=0A=
-compat-cygwin.o: $(LIB_H)=0A=
+compat-cygwin.o: compat/id-files-stat.c $(LIB_H)=0A=
 =0A=
 pre-process.h:=0A=
 	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) =
-print-file-name=3Dinclude`\"" > pre-process.h=0A=
Index: compat-cygwin.c=0A=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=
=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=3D=0A=
RCS file: /home/cvs/root/sparse-bk/compat-cygwin.c,v=0A=
retrieving revision 1.2=0A=
diff -u -r1.2 compat-cygwin.c=0A=
--- compat-cygwin.c	27 Sep 2004 17:08:59 -0000	1.2=0A=
+++ compat-cygwin.c	8 Oct 2004 18:10:15 -0000=0A=
@@ -14,6 +14,8 @@=0A=
 =0A=
 #include "lib.h"=0A=
 #include "token.h"=0A=
+=0A=
+#include "compat/id-files-stat.c"=0A=
 	=0A=
 void *blob_alloc(unsigned long size)	=0A=
 {	=0A=
@@ -38,7 +40,3 @@=0A=
 	return strtod(nptr, endptr);	=0A=
 }	=0A=
 	=0A=
-int identical_files(struct stream* s, struct stat *st, const char * =
name) 	=0A=
-{	=0A=
-	return (s->dev =3D=3D st->st_dev && s->ino =3D=3D st->st_ino);	=0A=
-}	=0A=
=0A=

------=_NextPart_000_0013_01C4AD28.1C047DD0--


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Disallow "void" parameters and "void" variables. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Disallow "void" parameters and "void" variables.
Date: Thu, 12 Aug 2004 20:32:18 +0000
Message-ID: <20040812203218.AC5261422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 13:15:04-04:00 welinder@troll.com 
#   parse.c:
#     Disallow "void" parameters and "void" variables.
# 
# parse.c
#   2004/08/12 13:14:44-04:00 welinder@troll.com +8 -3
#   Disallow "void" parameters and "void" variables.
# 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-12 13:08:12 -04:00
+++ b/parse.c	2004-08-12 13:14:44 -04:00
@@ -1119,9 +1119,12 @@
 			break;
 		}
 		token = parameter_declaration(token, &sym);
-		/* Special case: (void) */
-		if (!*list && !sym->ident && sym->ctype.base_type == &void_ctype)
-			break;
+		if (sym->ctype.base_type == &void_ctype) {
+			/* Special case: (void) */
+			if (!*list && !sym->ident)
+				break;
+			warn(token->pos, "void parameter");
+		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
 			break;
@@ -1320,6 +1323,8 @@
 
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
+	} else if (!is_typedef && base_type == &void_ctype) {
+		warn(token->pos, "void declaration");
 	}
 
 	for (;;) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Don't clear MOD_EXPLICITLY_SIGNED in indirect.\ ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Don't clear MOD_EXPLICITLY_SIGNED in indirect.\
Date: Thu, 12 Aug 2004 20:32:35 +0000
Message-ID: <20040812203235.03E4D1422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 13:34:42-04:00 welinder@troll.com 
#   parse.c:
#     Don't clear MOD_EXPLICITLY_SIGNED in indirect.\
#   symbol.c:
#     Add modifier MOD_EXPLICITLY_SIGNED to all versions of "signed".
#     check for integer bitfields that are just "int foo : 42".
#   symbol.h:
#     Define MOD_EXPLICITLY_SIGNED.
#     This will be used to distinguish "int" and "signed int".
#   show-parse.c:
#     Show MOD_EXPLICITLY_SIGNED as "[explicitly-signed]".
# 
# parse.c
#   2004/08/12 13:33:52-04:00 welinder@troll.com +1 -1
#   Don't clear MOD_EXPLICITLY_SIGNED in indirect.\
# 
# symbol.c
#   2004/08/12 13:30:54-04:00 welinder@troll.com +9 -3
#   Add modifier MOD_EXPLICITLY_SIGNED to all versions of "signed".
#   check for integer bitfields that are just "int foo : 42".
# 
# symbol.h
#   2004/08/12 13:30:07-04:00 welinder@troll.com +1 -0
#   Define MOD_EXPLICITLY_SIGNED.
#   This will be used to distinguish "int" and "signed int".
# 
# show-parse.c
#   2004/08/12 13:29:27-04:00 welinder@troll.com +1 -1
#   Show MOD_EXPLICITLY_SIGNED as "[explicitly-signed]".
# 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-12 13:26:45 -04:00
+++ b/parse.c	2004-08-12 13:33:52 -04:00
@@ -68,7 +68,7 @@
 	struct symbol *sym = alloc_symbol(pos, type);
 
 	sym->ctype.base_type = ctype->base_type;
-	sym->ctype.modifiers = ctype->modifiers & ~MOD_STORAGE;
+	sym->ctype.modifiers = ctype->modifiers & ~(MOD_STORAGE | MOD_EXPLICITLY_SIGNED);
 
 	ctype->base_type = sym;
 	ctype->modifiers &= MOD_STORAGE;
diff -Nru a/show-parse.c b/show-parse.c
--- a/show-parse.c	2004-08-02 00:10:24 -04:00
+++ b/show-parse.c	2004-08-12 13:29:27 -04:00
@@ -78,7 +78,7 @@
 		"[typeof]", "[attribute]", "inline", "[addressable]",
 		"[nocast]", "[noderef]", "[accessed]", "[toplevel]",
 		"[label]", "[assigned]", "[type]", "[safe]",
-		"[usertype]", "[force]",
+		"[usertype]", "[force]", "[explicitly-signed]",
 		NULL
 	};
 	ptr = names;
diff -Nru a/symbol.c b/symbol.c
--- a/symbol.c	2004-08-12 13:22:39 -04:00
+++ b/symbol.c	2004-08-12 13:30:54 -04:00
@@ -179,6 +179,12 @@
 		// representation.  The latter makes for very efficient code...
 		warn(sym->pos, "dubious one-bit signed bitfield");
 	}
+	if (base_type->type != SYM_ENUM &&
+	    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) && is_signed) {
+		// The sign of bitfields is unspecified by default.
+		warn (sym->pos, "dubious bitfield without explicit `signed' or `unsigned'");
+	}
+
 	alignment = base_type->ctype.alignment;
 	if (!sym->ctype.alignment)
 		sym->ctype.alignment = alignment;
@@ -397,9 +403,9 @@
 	{ "long",	NULL,		MOD_LONG },
 	{ "float",	&fp_type,	0 },
 	{ "double",	&fp_type,	MOD_LONG },
-	{ "signed",	NULL,		MOD_SIGNED },
-	{ "__signed",	NULL,		MOD_SIGNED },
-	{ "__signed__",	NULL,		MOD_SIGNED },
+	{ "signed",	NULL,		MOD_SIGNED | MOD_EXPLICITLY_SIGNED },
+	{ "__signed",	NULL,		MOD_SIGNED | MOD_EXPLICITLY_SIGNED },
+	{ "__signed__",	NULL,		MOD_SIGNED | MOD_EXPLICITLY_SIGNED },
 	{ "unsigned",	NULL,		MOD_UNSIGNED },
 	{ "__label__",	&label_type,	MOD_LABEL | MOD_UNSIGNED },
 
diff -Nru a/symbol.h b/symbol.h
--- a/symbol.h	2004-08-04 13:00:16 -04:00
+++ b/symbol.h	2004-08-12 13:30:07 -04:00
@@ -143,6 +143,7 @@
 
 #define MOD_USERTYPE	0x10000000
 #define MOD_FORCE	0x20000000
+#define MOD_EXPLICITLY_SIGNED	0x40000000
 
 /* Basic types */
 extern struct symbol	void_type,
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Don't complain over undefined preprocessor symbols that start ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Don't complain over undefined preprocessor symbols that start
Date: Thu, 12 Aug 2004 20:32:53 +0000
Message-ID: <20040812203253.86E111422D4F () darter ! rentec ! com>
--------------------

(This one is not a no-brainer.)

# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 14:46:08-04:00 welinder@troll.com 
#   expand.c:
#     Don't complain over undefined preprocessor symbols that start
#     with an underscore.
#     This helps quiet a gazillion errors with _cplusplus and others
#     used by solaris' system headers.
#     This change may or may not be approapriate on a glibc system.
# 
# expand.c
#   2004/08/12 14:44:37-04:00 welinder@troll.com +3 -1
#   Don't complain over undefined preprocessor symbols that start
#   with an underscore.
#   This helps quiet a gazillion errors with _cplusplus and others
#   used by solaris' system headers.
#   This change may or may not be approapriate on a glibc system.
# 
diff -Nru a/expand.c b/expand.c
--- a/expand.c	2004-08-12 12:46:29 -04:00
+++ b/expand.c	2004-08-12 14:44:37 -04:00
@@ -41,7 +41,9 @@
 	 * The preprocessor can cause unknown symbols to be generated
 	 */
 	if (!sym) {
-		warn(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
+		const char *ident = show_ident(expr->symbol_name);
+		if (ident[0] != '_')
+			warn(expr->pos, "undefined preprocessor identifier '%s'", ident);
 		expr->type = EXPR_VALUE;
 		expr->value = 0;
 		return UNSAFE;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Generate correct =?koi8-r?Q?=22?=push=?koi8-r?Q?=22=20?=instruction. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] Generate correct =?koi8-r?Q?=22?=push=?koi8-r?Q?=22=20?=instruction.
Date: Fri, 30 Jul 2004 15:14:09 +0000
Message-ID: <E1BqZ5F-000EwX-00.adobriyan-mail-ru () f16 ! mail ! ru>
--------------------
Pay attention to size of function arguments when pushing them to stack.

Generate "pushb" for char, "pushw" for short, ...

diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	2004-07-28 12:27:28 +00:00
+++ b/compile-i386.c	2004-07-28 13:03:35 +00:00
@@ -1840,8 +1840,7 @@
 		struct storage *new = x86_expression(arg);
 		int size = arg->ctype->bit_size;
 
-		/* FIXME: pay attention to 'size' */
-		insn("pushl", new, NULL,
+		insn(opbits("push", size), new, NULL,
 		     !framesize ? "begin function call" : NULL);
 
 		framesize += size >> 3;

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Handle __noreturn__ as noreturn (==ignore). ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Handle __noreturn__ as noreturn (==ignore).
Date: Thu, 12 Aug 2004 20:32:24 +0000
Message-ID: <20040812203224.49A621422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 13:20:04-04:00 welinder@troll.com 
#   parse.c:
#     Handle __noreturn__ as noreturn (==ignore).
# 
# parse.c
#   2004/08/12 13:19:37-04:00 welinder@troll.com +2 -1
#   Handle __noreturn__ as noreturn (==ignore).
# 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-12 13:14:44 -04:00
+++ b/parse.c	2004-08-12 13:19:37 -04:00
@@ -301,7 +301,8 @@
 	if (match_string_ident(attribute, "const") ||
 	    match_string_ident(attribute, "__const__"))
 		return NULL;
-	if (match_string_ident(attribute, "noreturn"))
+	if (match_string_ident(attribute, "noreturn") ||
+	    match_string_ident(attribute, "__noreturn__"))
 		return NULL;
 	if (match_string_ident(attribute, "regparm"))
 		return NULL;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Linearize initializer ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 10:47:46 +0000
Message-ID: <20041103104746.GA22484 () 64m ! dyndns ! org>
--------------------
Hi Linus,

Here is a tentative patch to add linearize the initializer.

While I am learning the new initializer tree. I think the
current way of initializing does not handle the bit field
member correctly. I can't tell from the initializer
tree that a member is a bit field. Do I miss some thing?

Anyway, here is the patch works for non bit field.

Chris

Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-11-03 01:32:56.000000000 -0500
+++ sparse-be/linearize.c	2004-11-03 05:41:50.000000000 -0500
@@ -23,11 +23,12 @@
 pseudo_t linearize_expression(struct entrypoint *ep, struct expression *expr);
 
 static void add_setcc(struct entrypoint *ep, struct expression *expr, pseudo_t val);
-static pseudo_t add_binary_op(struct entrypoint *ep, struct expression *expr, int op, pseudo_t left, pseudo_t right);
+static pseudo_t add_binary_op(struct entrypoint *ep, struct symbol *ctype, int op, pseudo_t left, pseudo_t right);
 static pseudo_t add_setval(struct entrypoint *ep, struct symbol *ctype, struct expression *val);
 static pseudo_t add_const_value(struct entrypoint *ep, struct position pos, struct symbol *ctype, int val);
 static pseudo_t add_load(struct entrypoint *ep, struct expression *expr, pseudo_t addr);
 
+pseudo_t linearize_initializer(struct entrypoint *ep, pseudo_t baseaddr, struct expression *initializer);
 
 struct pseudo void_pseudo = {};
 
@@ -386,6 +387,18 @@
 	}
 }
 
+static void add_store(struct entrypoint *ep, struct expression *expr, pseudo_t addr, pseudo_t value)
+{
+	struct basic_block *bb = ep->active;
+
+	if (bb_reachable(bb)) {
+		struct instruction *store = alloc_instruction(OP_STORE, expr->ctype);
+		store->target = value;
+		store->src = addr;
+		add_one_insn(ep, store);
+	}
+}
+
 static void add_branch(struct entrypoint *ep, struct expression *expr, pseudo_t cond, struct basic_block *bb_true, struct basic_block *bb_false)
 {
 	struct basic_block *bb = ep->active;
@@ -428,8 +441,6 @@
 
 static pseudo_t linearize_store_gen(struct entrypoint *ep, pseudo_t value, struct expression *expr, pseudo_t addr)
 {
-	struct instruction *store = alloc_instruction(OP_STORE, expr->ctype);
-
 	if (expr->type == EXPR_BITFIELD) {
 		unsigned long mask = ((1<<expr->nrbits)-1) << expr->bitpos;
 		pseudo_t shifted, andmask, ormask, orig, orig_mask, value_mask, newval;
@@ -438,35 +449,33 @@
 		if (expr->bitpos) {
 			pseudo_t shift;
 			shift = add_const_value(ep, expr->pos, &uint_ctype, expr->bitpos);
-			shifted = add_binary_op(ep, expr, OP_SHL, value, shift);
+			shifted = add_binary_op(ep, expr->ctype, OP_SHL, value, shift);
 			add_deathnote(ep, shift);
 		}
 		orig = add_load(ep, expr, addr);
 		andmask = add_const_value(ep, expr->pos, &uint_ctype, ~mask);
-		orig_mask = add_binary_op(ep, expr, OP_AND, orig, andmask);
+		orig_mask = add_binary_op(ep, expr->ctype, OP_AND, orig, andmask);
 		add_deathnote(ep, orig);
 		add_deathnote(ep, andmask);
 		ormask = add_const_value(ep, expr->pos, &uint_ctype, mask);
-		value_mask = add_binary_op(ep, expr, OP_AND, shifted, ormask);
+		value_mask = add_binary_op(ep, expr->ctype, OP_AND, shifted, ormask);
 		add_deathnote(ep, ormask);
 		if (shifted != value)
 			add_deathnote(ep, shifted);
-		newval = add_binary_op(ep, expr, OP_OR, orig_mask, value_mask);
+		newval = add_binary_op(ep, expr->ctype, OP_OR, orig_mask, value_mask);
 		add_deathnote(ep, orig_mask);
 		add_deathnote(ep, value_mask);
 		value = newval;
 	}
 
-	store->target = value;
-	store->src = addr;
-	add_one_insn(ep, store);
+	add_store(ep, expr, addr, value);
 	add_deathnote(ep, addr);
 	return value;
 }
 
-static pseudo_t add_binary_op(struct entrypoint *ep, struct expression *expr, int op, pseudo_t left, pseudo_t right)
+static pseudo_t add_binary_op(struct entrypoint *ep, struct symbol *ctype, int op, pseudo_t left, pseudo_t right)
 {
-	struct instruction *insn = alloc_instruction(op, expr->ctype);
+	struct instruction *insn = alloc_instruction(op, ctype);
 	pseudo_t target = alloc_pseudo(insn);
 	insn->target = target;
 	insn->src1 = left;
@@ -514,11 +523,11 @@
 		pseudo_t mask;
 		if (expr->bitpos) {
 			pseudo_t shift = add_const_value(ep, expr->pos, &uint_ctype, expr->bitpos);
-			new = add_binary_op(ep, expr, OP_SHR, new, shift);
+			new = add_binary_op(ep, expr->ctype, OP_SHR, new, shift);
 			add_deathnote(ep, shift);
 		}
 		mask = add_const_value(ep, expr->pos, &uint_ctype, (1<<expr->nrbits)-1);
-		new = add_binary_op(ep, expr, OP_AND, new, mask);
+		new = add_binary_op(ep, expr->ctype, OP_AND, new, mask);
 		add_deathnote(ep, mask);
 		return new;
 	}
@@ -544,7 +553,7 @@
 
 	old = linearize_load_gen(ep, expr->unop, addr);
 	one = add_const_value(ep, expr->pos, expr->ctype, 1);
-	new = add_binary_op(ep, expr, op, old, one);
+	new = add_binary_op(ep, expr->ctype, op, old, one);
 	linearize_store_gen(ep, new, expr->unop, addr);
 	if (postop) {
 		add_deathnote(ep, new);
@@ -589,7 +598,7 @@
 		return pre;
 	case '!': {
 		pseudo_t zero = add_const_value(ep, expr->pos, expr->ctype, 0);
-		return add_binary_op(ep, expr, OP_SET_EQ, pre, zero);
+		return add_binary_op(ep, expr->ctype, OP_SET_EQ, pre, zero);
 	}
 	case '~':
 		return add_uniop(ep, expr, OP_NOT, pre);
@@ -697,7 +706,7 @@
 
 	src1 = linearize_expression(ep, expr->left);
 	src2 = linearize_expression(ep, expr->right);
-	dst = add_binary_op(ep, expr, opcode[expr->op], src1, src2);
+	dst = add_binary_op(ep, expr->ctype, opcode[expr->op], src1, src2);
 	add_deathnote(ep, src1);
 	add_deathnote(ep, src2);
 	return dst;
@@ -716,7 +725,7 @@
 	cond = linearize_expression(ep, expr->conditional);
 
 	add_setcc(ep, expr, cond);
-	res = add_binary_op(ep, expr, OP_SEL, true, false);
+	res = add_binary_op(ep, expr->ctype, OP_SEL, true, false);
 	add_deathnote(ep, true);
 	add_deathnote(ep, false);
 	add_deathnote(ep, cond);
@@ -783,7 +792,7 @@
 
 	pseudo_t src1 = linearize_expression(ep, expr->left);
 	pseudo_t src2 = linearize_expression(ep, expr->right);
-	pseudo_t dst = add_binary_op(ep, expr, cmpop[expr->op], src1, src2);
+	pseudo_t dst = add_binary_op(ep, expr->ctype, cmpop[expr->op], src1, src2);
 	add_deathnote(ep, src1);
 	add_deathnote(ep, src2);
 	return dst;
@@ -868,17 +877,38 @@
 	return result;
 }
 
-pseudo_t linearize_position(struct entrypoint *ep, struct expression *pos)
+pseudo_t linearize_position(struct entrypoint *ep, pseudo_t baseaddr, struct expression *pos)
 {
-	return linearize_expression(ep, pos->init_expr);
+	struct expression *init_expr = pos->init_expr;
+	pseudo_t offset = add_const_value(ep, pos->pos, &uint_ctype, pos->init_offset);
+	pseudo_t addr = add_binary_op(ep, baseaddr->def->type, OP_ADD, baseaddr, offset);
+	pseudo_t value = linearize_expression(ep, init_expr);
+	add_store(ep, init_expr, addr, value);
+	add_deathnote(ep, addr);
+	add_deathnote(ep, value);
+	return VOID;
 }
 
-pseudo_t linearize_initializer(struct entrypoint *ep, struct expression *initializer)
+pseudo_t linearize_initializer(struct entrypoint *ep, pseudo_t baseaddr, struct expression *initializer)
 {
-	struct expression *expr;
-	FOR_EACH_PTR(initializer->expr_list, expr) {
-		linearize_expression(ep, expr);
-	} END_FOR_EACH_PTR(expr);
+	switch (initializer->type) {
+	case EXPR_INITIALIZER: {
+		struct expression *expr;
+		FOR_EACH_PTR(initializer->expr_list, expr) {
+			linearize_initializer(ep, baseaddr, expr);
+		} END_FOR_EACH_PTR(expr);
+		break;
+	}
+	case EXPR_POS:
+		linearize_position(ep, baseaddr, initializer);
+		break;
+	default: {
+		pseudo_t value = linearize_expression(ep, initializer);
+		add_store(ep, initializer, baseaddr, value);
+		add_deathnote(ep, value);
+	}
+	}
+
 	return VOID;
 }
 
@@ -941,11 +971,9 @@
 		return linearize_slice(ep, expr);
 
 	case EXPR_INITIALIZER:
-		return linearize_initializer(ep, expr);
-
 	case EXPR_POS:
-		return linearize_position(ep, expr);
-
+		warning(expr->pos, "unexpected initializer expression (%d %d)", expr->type, expr->op);
+		return VOID;
 	default: 
 		warning(expr->pos, "unknown expression (%d %d)", expr->type, expr->op);
 		return VOID;
@@ -955,21 +983,14 @@
 
 static void linearize_one_symbol(struct entrypoint *ep, struct symbol *sym)
 {
-	pseudo_t value, address;
-	struct instruction *store;
+	pseudo_t address;
 
 	if (!sym->initializer)
 		return;
 	
-	value = linearize_expression(ep, sym->initializer);
 	address = add_setval(ep, sym, NULL);
-
-	store = alloc_instruction(OP_STORE, sym);
-	store->target = value;
-	store->src = address;
-	add_one_insn(ep, store);
+	linearize_initializer(ep, address, sym->initializer);
 	add_deathnote(ep, address);
-	add_deathnote(ep, value);
 }
 
 static pseudo_t linearize_compound_statement(struct entrypoint *ep, struct statement *stmt)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 15:26:34 +0000
Message-ID: <Pine.LNX.4.58.0411030721140.2187 () ppc970 ! osdl ! org>
--------------------


On Wed, 3 Nov 2004, Christopher Li wrote:
> 
> While I am learning the new initializer tree. I think the
> current way of initializing does not handle the bit field
> member correctly. I can't tell from the initializer
> tree that a member is a bit field. Do I miss some thing?

Hmm.. "expr->ctype" should have the type of the individual assignment (and
thus the bitfield), but maybe I'm wrong.

So check that first, but if I'm full of sh*t, we probably need to make the
offset be a bit-offset in the EXPR_POS thing, and add a size field too.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 16:10:33 +0000
Message-ID: <20041103161033.GB22484 () 64m ! dyndns ! org>
--------------------
I find out the bit_offset of the SYM_FIELD is always zero.

Here is the test case I used:

struct a{
        int n[4];
        int b1:3;
        int b2:2;
};
struct b{
        int n[3];
        struct a a;
};
void foo(void)
{
        int b[] = { [4] = 5 };
        struct b c = { .n = {1,2}, .a.b1 = 9, .a.b2 = 13};
        int *a;
        c.a.b2 = 14;
}

My ast.py shows:
...
    ['syms->SYM_NODE',
     'name: c',
     ['ctype.base->SYM_STRUCT'],
     ['initializer->EXPR_INITIALIZER',
      ['EXPR_INITIALIZER',
       ['EXPR_VALUE', ['ctype->SYM_BASETYPE', 'int'], '1'],
       ['EXPR_POS',
        ['ctype->SYM_BASETYPE', 'int'],
        'init_offset:4',
        'init_nr:1',
        ['init_expr->EXPR_VALUE', ['ctype->SYM_BASETYPE', 'int'], '2']]],
      ['EXPR_POS',
       ['ctype->SYM_NODE',
        'name: b1',
        ['ctype.base->SYM_BITFIELD',
         'bit_offset: 0',
         'bit_size: 3',
         'fieldwidth: 3',
         ['ctype.base->SYM_BASETYPE', 'int']]],
       'init_offset:28',
       'init_nr:1',
       ['init_expr->EXPR_VALUE', ['ctype->SYM_NODE', 'name: b1'], '1']],
      ['EXPR_POS',
       ['ctype->SYM_NODE',
        'name: b2',
        ['ctype.base->SYM_BITFIELD',
         'bit_offset: 0',   <===============================
         'bit_size: 2',
         'fieldwidth: 2',
         ['ctype.base->SYM_BASETYPE', 'int']]],
       'init_offset:28',
       'init_nr:1',
       ['init_expr->EXPR_VALUE', ['ctype->SYM_NODE', 'name: b2'], '1']]]],
...

Chris

On Wed, Nov 03, 2004 at 10:21:53AM -0800, Linus Torvalds wrote:
> 
> 
> On Wed, 3 Nov 2004, Linus Torvalds wrote:
> > 
> > There's also the issue of assigning one bitfield to another one of the 
> > same size, but with a different shift. Right now there won't be any casts, 
> > and thus the initializer linearizer will see the type of the _source_ 
> > bitfield rather than the type of the destination.
> 
> Ok, fixed. When doing this, I also noticed that the structuer member 
> placement had gotten confused by the semantic change in bitfield bit_size.
> 
> I think the whole "fieldwidth" part of a symbol is now redundant, except
> for the fact that we also use "bit_size" as a flag to test whether we have
> evaluated the type yet (so if we were to skip fieldwidth and just
> initialize bit_size when parsing the thing, we'd break that logic).  Oh,
> well..
> 
> I guess we might replace "fieldwidth" with a single-bit "examined" field
> to take on that task instead.
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 17:15:31 +0000
Message-ID: <Pine.LNX.4.58.0411030852250.2187 () ppc970 ! osdl ! org>
--------------------


On Wed, 3 Nov 2004, Linus Torvalds wrote:
> 
> Hmm.. "expr->ctype" should have the type of the individual assignment (and
> thus the bitfield), but maybe I'm wrong.

Ok, I'm right in theory, but wrong in practice.

What happened is that expr->ctype _does_ have the type of the assignment, 
but for some silly reasons we had totally _lost_ the bitfield-ness of the 
assignment long before.

Why? First off, bitfield symbols ended up evaluating as having the size of
the base type. Which is wrong - they do end up evaluating to that size (or
bigger) when used as part of an _expression_, but the symbol itself has 
it's true size. 

That's fixed by just making "examine_bitfield_type()" use the right size 
for initialization of bit_size.

Secondly, even with that fixed, in "type_difference()", all integer types
are considered to be exactly equal, so then when we do the assignment type
casting in "compatible_assignment_types()", we would ignore the fact that 
the types weren't the same at all - we'd just look at the base types in 
the difference, and decide that they're all the same. Oops.

That's fixed by just moving type_difference() down a bit (to under the
integer/fp size checks) in the assignment compatibility check function.

With those two things fixed, the expression type _does_ end up being the 
right type, I think. That said, I'm pretty sure we still handle symbol 
expressions wrong - we should "degenerate" a bitfield type to the integer 
type on _any_ use as a lvalue (right now we only degenerate when we see it 
as part of an expression, ie the expression "bitfield + 1" degenerates it, 
but just "bitfield" will stay as a bitfield).

If we did the degenerate properly, we could also dispense with the 
"type_difference()" problem - type_difference would never see enum's, 
because they would all have degenerated properly. 

Basically, certain types "degenerate" when they convert from
lvalue->rvalue (pretty much any use apart from assignment and
"typeof"/"sizeof"):  bitfields and enums degenerate into their base types,
and char/short degenerate into "int".

Al added to the cc, because he might have input on the conversion. We 
right now do it slightly haphazardously: we have "degenerate()" which just 
degenerates fn/arrays into pointers, we have "evaluate_arguments()", which 
has the magic "..." case degenerate thing (which seems to leave a bitfield 
of a bigger-than-int size non-converted), and we have integer_promotion() 
which does it all, but only triggers on unops/binops and thus doesn't 
trigger on things like function call arguments etc.

Looks like at least "evaluate_arguments()" should be fixed to use 
integer_promotion(). Al?

		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 17:34:09 +0000
Message-ID: <Pine.LNX.4.58.0411030927200.2187 () ppc970 ! osdl ! org>
--------------------


On Wed, 3 Nov 2004, Linus Torvalds wrote:
> 
> Looks like at least "evaluate_arguments()" should be fixed to use 
> integer_promotion(). Al?

There's also the issue of assigning one bitfield to another one of the 
same size, but with a different shift. Right now there won't be any casts, 
and thus the initializer linearizer will see the type of the _source_ 
bitfield rather than the type of the destination.

I would suggest that all bitfield usage would be through a cast, and that
way we could consider the shifting and masking to be an attribute of the
_casting_, not of the access itself. That simplifies thinking about the
accesses a _lot_ (as it is, symbol accesses are generally the most complex
part of the tree at linearization time: they need to worry about
bitfields, about load/store to memory, about the address etc etc).

If we make "bitfields" be really nothing more than casts to the underlying
(regular) symbol, we suddenly never ever have to worry about things like
bitfields as part of a register vs memory etc - they'll just be regular
accesses followed by a cast that is just a shift/mask operation.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 18:21:53 +0000
Message-ID: <Pine.LNX.4.58.0411031019190.2187 () ppc970 ! osdl ! org>
--------------------


On Wed, 3 Nov 2004, Linus Torvalds wrote:
> 
> There's also the issue of assigning one bitfield to another one of the 
> same size, but with a different shift. Right now there won't be any casts, 
> and thus the initializer linearizer will see the type of the _source_ 
> bitfield rather than the type of the destination.

Ok, fixed. When doing this, I also noticed that the structuer member 
placement had gotten confused by the semantic change in bitfield bit_size.

I think the whole "fieldwidth" part of a symbol is now redundant, except
for the fact that we also use "bit_size" as a flag to test whether we have
evaluated the type yet (so if we were to skip fieldwidth and just
initialize bit_size when parsing the thing, we'd break that logic).  Oh,
well..

I guess we might replace "fieldwidth" with a single-bit "examined" field
to take on that task instead.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 19:46:31 +0000
Message-ID: <Pine.LNX.4.58.0411031142160.2187 () ppc970 ! osdl ! org>
--------------------


On Wed, 3 Nov 2004, Christopher Li wrote:
>
> I find out the bit_offset of the SYM_FIELD is always zero.

I think I fixed that with the 

	ChangeSet@1.910, 2004-11-03 10:15:31-08:00, torvalds@ppc970.osdl.org
	  Fix up structure bitfield placement.
	  
	  The change in bitfield symbol bit_size means that structure
	  placement needs to get the size of the base type by walking
	  it explicitly.

which is out there now.

But it's only there on the "node", not on the bitfield. Do you care? I can 
certainly fix it up to be on both.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Linearize initializer
Date: Wed, 03 Nov 2004 20:07:53 +0000
Message-ID: <Pine.LNX.4.58.0411031153240.2187 () ppc970 ! osdl ! org>
--------------------


On Wed, 3 Nov 2004, Linus Torvalds wrote:
> 
> But it's only there on the "node", not on the bitfield. Do you care? I can 
> certainly fix it up to be on both.

Done. Thinking some more about it, I definitely agree with you that the 
SYM_BITFIELD node needs this too, since we are supposed to be able to peel 
off the SYM_NODE information and still have a valid type.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Linux/Solaris split.  Keep it minimal for now. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Linux/Solaris split.  Keep it minimal for now.
Date: Thu, 12 Aug 2004 20:32:57 +0000
Message-ID: <20040812203257.401B91422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 15:00:29-04:00 welinder@troll.com 
#   lib.c:
#     Linux/Solaris split.  Keep it minimal for now.
# 
# lib.c
#   2004/08/12 15:00:04-04:00 welinder@troll.com +26 -5
#   Linux/Solaris split.  Keep it minimal for now.
# 
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-08-12 14:39:28 -04:00
+++ b/lib.c	2004-08-12 15:00:04 -04:00
@@ -670,8 +670,33 @@
 
 void create_builtin_stream(void)
 {
+#if defined(__linux__)
 	add_pre_buffer("#define __linux__ 1\n");
-	add_pre_buffer("#define linux linux\n");
+	add_pre_buffer("#define __linux 1\n");
+	add_pre_buffer("#define linux 1\n");
+
+	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
+	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
+	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
+	add_pre_buffer("#define __builtin_va_end(arg)\n");	
+#elif defined(__sun__)
+	add_pre_buffer("#define __sun__ 1\n");
+	add_pre_buffer("#define __sun 1\n");
+	add_pre_buffer("#define sun 1\n");
+	add_pre_buffer("#define __svr4__ 1\n");
+	add_pre_buffer("#define SVR4 1\n");
+	// The system definition (either 0 or 0L) is just not useful.
+	// Luckily, it is conditionally defined.
+	add_pre_buffer("#define NULL ((void *)0)\n");
+	// gcc specs define the following on solaris:
+	add_pre_buffer("#define _REENTRANT\n");
+	add_pre_buffer("#define _SOLARIS_THREADS\n");
+	// I'm just guessing here:
+	add_pre_buffer("#define __builtin_va_alist (*(void *)0)\n");
+	add_pre_buffer("#define __builtin_va_arg_incr(x) ((x) + 1)\n");
+#else
+#warning "System not recognized; hope for the best"
+#endif
 	add_pre_buffer("#define unix 1\n");
 	add_pre_buffer("#define __unix 1\n");
 	add_pre_buffer("#define __unix__ 1\n");
@@ -686,10 +711,6 @@
 	// it is "long unsigned int".  In either case we can probably
 	// get away with this:
 	add_pre_buffer("#define __SIZE_TYPE__ long unsigned int\n");
-	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
-	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
-	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
-	add_pre_buffer("#define __builtin_va_end(arg)\n");	
 }
 
 #ifdef __sun__
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Move bitfield parsing into struct/union parsing where it belongs. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Move bitfield parsing into struct/union parsing where it belongs.
Date: Thu, 12 Aug 2004 20:32:31 +0000
Message-ID: <20040812203231.6877B1422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 13:27:32-04:00 welinder@troll.com 
#   parse.c:
#     Move bitfield parsing into struct/union parsing where it belongs.
#     Sanity check bitfield widths.
# 
# parse.c
#   2004/08/12 13:26:45-04:00 welinder@troll.com +27 -11
#   Move bitfield parsing into struct/union parsing where it belongs.
#   Sanity check bitfield widths.
# 
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-12 13:19:37 -04:00
+++ b/parse.c	2004-08-12 13:26:45 -04:00
@@ -626,16 +626,6 @@
 			ctype = &array->ctype;
 			continue;
 		}
-		if (token->special == ':') {
-			if (is_int_type (ctype->base_type)) {
-				struct symbol *bitfield = indirect(token->pos, ctype, SYM_BITFIELD);
-				struct expression *expr;
-				token = conditional_expression(token->next, &expr);
-				bitfield->fieldwidth = get_expression_value(expr);
-			} else
-				error(token->pos, "Invalid bitfield specifier for type %s.", show_typename (ctype->base_type));
-			break;
-		}
 		break;
 	}
 	if (p) {
@@ -692,8 +682,34 @@
 			decl->ctype = ctype;
 			token = declarator(token, &decl, &ident);
 			if (match_op(token, ':')) {
+				struct ctype *ctype = &decl->ctype;
 				struct expression *expr;
-				token = parse_expression(token->next, &expr);
+				struct symbol *bitfield;
+				long long width;
+
+				if (is_int_type (ctype->base_type)) {
+					bitfield = indirect(token->pos, ctype, SYM_BITFIELD);
+					token = conditional_expression(token->next, &expr);
+					width = get_expression_value(expr);
+					bitfield->fieldwidth = width;
+					if (width < 0) {
+						warn(token->pos, "invalid negative bitfield width, %lld.", width);
+						bitfield->fieldwidth = 8;
+					} else if (decl->ident && width == 0) {
+						warn(token->pos, "invalid named zero-width bitfield `%s'",
+						     show_ident (decl->ident));
+						bitfield->fieldwidth = 8;
+					} else if (width != bitfield->fieldwidth) {
+						// Overflow.
+						unsigned int stupid_gcc = -1;
+						bitfield->fieldwidth = stupid_gcc;
+						warn(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
+					}
+				} else {
+					warn(token->pos, "invalid bitfield specifier for type %s.", show_typename (ctype->base_type));
+					// Parse this to recover gracefully.
+					token = conditional_expression(token->next, &expr);
+				}
 			}
 			add_symbol(list, decl);
 			if (!match_op(token, ','))
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Print instruction's suffix in a human-readable form. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] Print instruction's suffix in a human-readable form.
Date: Fri, 30 Jul 2004 15:10:34 +0000
Message-ID: <E1BqZ1m-0001vj-00.adobriyan-mail-ru () f27 ! mail ! ru>
--------------------
{'b', 'w', 'l', 'q'} instead of {ascii 8, ascii 16, ' ', '@'}

diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	2004-07-24 01:49:38 +00:00
+++ b/compile-i386.c	2004-07-28 12:27:28 +00:00
@@ -992,7 +992,7 @@
 	default: assert(0); break;
 	}
 
-	sprintf(opbits_str, "%s%c", insn, bits);
+	sprintf(opbits_str, "%s%c", insn, c);
 
 	return opbits_str;
 }

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: Does the Sparse work under cygwin? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] Re: Does the Sparse work under cygwin?
Date: Thu, 09 Sep 2004 15:29:17 +0000
Message-ID: <20040909152917.GA29383 () 64m ! dyndns ! org>
--------------------
Can you please try this patch and see if it works for you?

I do not have cygwin around so I did not test this patch on cygwin
at all.

Chris

Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/lib.h	2004-09-09 11:21:20.000000000 -0400
@@ -410,4 +410,11 @@
 #define REPLACE_CURRENT_PTR(ptr, new_ptr)						\
 	do { *THIS_ADDRESS(ptr) = (new_ptr); } while (0)
 
+#define __CYGWIN__
+#ifdef __CYGWIN__
+#define ZEROED_MMAP zeroed_mmap
+#else
+#define ZEROED_MMAP mmap
+#endif
+
 #endif
Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/lib.c	2004-09-09 11:23:05.000000000 -0400
@@ -67,6 +67,18 @@
 	return retval;
 }
 
+#ifdef __CYGWIN__
+
+static inline void* zeroed_mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)
+{
+	void *pages = mmap(start, length, prot, flags, fd, offset);
+	if (pages)
+		memset(pages, length, 0);
+	return pages;
+}
+
+#endif
+ 
 /*
  * Simple allocator for data that doesn't get partially free'd.
  * The tokenizer and parser allocate a _lot_ of small data structures
@@ -83,7 +95,7 @@
 };
 
 #define CHUNK 32768
-#define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+#define blob_alloc(size) ZEROED_MMAP(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
 #define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
 
 struct allocator_struct {


On Thu, Sep 09, 2004 at 10:47:22AM -0700, Mitesh shah wrote:
> > -----Original Message-----
> > From: linux-sparse-owner@vger.kernel.org
> > [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Christopher Li
> > Sent: Wednesday, September 08, 2004 12:15 PM
> > To: Mitesh shah
> > Cc: Linux-Sparse
> > Subject: Re: Does the Sparse work under cygwin?
> >
> >
> > I used to run sparse in cygwin from time to time.
> > I eventually lost interest in using sparse under cygwin.
> >
> > There is another pit fall to watch out is that, in cygwin
> > mmap anonymous page is broken. It did not reset page to zero.
> 
> 
> I am hitting segmentation fault in struct_declaration_list for somewhat
> larger files. I tried to debug it but looks like there is a memory
> corruption for the symbol list. I am trying to find out if it is related
> to this mmap issue. Did you solve the mmap issue on cygwin? I replaced
> the allocate with malloc and it seems to work.
> 
> Thanks,
> 
> -Mitesh
> 
> 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: [PATCH] Re: Does the Sparse work under cygwin?
Date: Thu, 09 Sep 2004 23:40:36 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKCEODDDAA.mshah () teja ! com>
--------------------

At the first it did not work and crashed at the same place but I see
that last two arguments of the memset should be swapped. i.e.
memset(pages,  0, length);

I changed that and it worked.

Thanks for the patch

-Mitesh


> -----Original Message-----
> From: linux-sparse-owner@vger.kernel.org
> [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of Christopher Li
> Sent: Thursday, September 09, 2004 8:29 AM
> To: Mitesh shah
> Cc: Linux-Sparse
> Subject: [PATCH] Re: Does the Sparse work under cygwin?
>
>
> Can you please try this patch and see if it works for you?
>
> I do not have cygwin around so I did not test this patch on cygwin
> at all.
>
> Chris
>
> Index: sparse-be/lib.h
> ===================================================================
> --- sparse-be.orig/lib.h	2004-09-06 10:53:43.000000000 -0400
> +++ sparse-be/lib.h	2004-09-09 11:21:20.000000000 -0400
> @@ -410,4 +410,11 @@
>  #define REPLACE_CURRENT_PTR(ptr, new_ptr)
> 			\
>  	do { *THIS_ADDRESS(ptr) = (new_ptr); } while (0)
>
> +#define __CYGWIN__
> +#ifdef __CYGWIN__
> +#define ZEROED_MMAP zeroed_mmap
> +#else
> +#define ZEROED_MMAP mmap
> +#endif
> +
>  #endif
> Index: sparse-be/lib.c
> ===================================================================
> --- sparse-be.orig/lib.c	2004-09-06 10:53:43.000000000 -0400
> +++ sparse-be/lib.c	2004-09-09 11:23:05.000000000 -0400
> @@ -67,6 +67,18 @@
>  	return retval;
>  }
>
> +#ifdef __CYGWIN__
> +
> +static inline void* zeroed_mmap(void *start, size_t length,
> int prot, int flags, int fd, off_t offset)
> +{
> +	void *pages = mmap(start, length, prot, flags, fd, offset);
> +	if (pages)
> +		memset(pages, length, 0);
> +	return pages;
> +}
> +
> +#endif
> +
>  /*
>   * Simple allocator for data that doesn't get partially free'd.
>   * The tokenizer and parser allocate a _lot_ of small data structures
> @@ -83,7 +95,7 @@
>  };
>
>  #define CHUNK 32768
> -#define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095,
> PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
> +#define blob_alloc(size) ZEROED_MMAP(NULL, ((size)+4095) &
> ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
>  #define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
>
>  struct allocator_struct {
>
>
> On Thu, Sep 09, 2004 at 10:47:22AM -0700, Mitesh shah wrote:
> > > -----Original Message-----
> > > From: linux-sparse-owner@vger.kernel.org
> > > [mailto:linux-sparse-owner@vger.kernel.org]On Behalf Of
> Christopher Li
> > > Sent: Wednesday, September 08, 2004 12:15 PM
> > > To: Mitesh shah
> > > Cc: Linux-Sparse
> > > Subject: Re: Does the Sparse work under cygwin?
> > >
> > >
> > > I used to run sparse in cygwin from time to time.
> > > I eventually lost interest in using sparse under cygwin.
> > >
> > > There is another pit fall to watch out is that, in cygwin
> > > mmap anonymous page is broken. It did not reset page to zero.
> >
> >
> > I am hitting segmentation fault in struct_declaration_list
> for somewhat
> > larger files. I tried to debug it but looks like there is a memory
> > corruption for the symbol list. I am trying to find out if
> it is related
> > to this mmap issue. Did you solve the mmap issue on cygwin?
> I replaced
> > the allocate with malloc and it seems to work.
> >
> > Thanks,
> >
> > -Mitesh
> >
> >
> -
> To unsubscribe from this list: send the line "unsubscribe
> linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Does the Sparse work under cygwin?
Date: Mon, 13 Sep 2004 19:40:48 +0000
Message-ID: <20040913194048.GA3295 () 64m ! dyndns ! org>
--------------------
On Mon, Sep 13, 2004 at 03:46:57PM -0700, Linus Torvalds wrote:
> 
> 
> On Mon, 13 Sep 2004, Mitesh shah wrote:
> In particular, I do detest #ifdef code inside code, or using upper-case
> macros where a simple wrapper function might do.
> 
> For example, it might just make sense to have a "compat.c" file that 
> gathers compatibility-functions. Make that "blob_alloc()" a real function 
> in that file, and then different systems could just have different 
> versions of that (and a different one for debugging, for example).

Do you prefer different system share the same compat.c file or have
each system a compat-xxx.c by its own?


Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Does the Sparse work under cygwin?
Date: Mon, 13 Sep 2004 19:43:38 +0000
Message-ID: <20040913194338.GB3295 () 64m ! dyndns ! org>
--------------------
On Mon, Sep 13, 2004 at 06:50:56PM -0400, Morten Welinder wrote:
> 
> For mmap, you would need to say something like
> 
>   #ifdef __CYGWIN__
>   #include <sys/mmap.h> // Or whatever it is
>   #undef mmap
>   #define mmap zeroed_mmap
>   // Prototype
>   #endif
> 
> in the header file.  This way we can keep the portability issues
> pretty local.

Only mmap anonymous pages get zeroed pages.  If you want to mmap a
regular file then clear out the pages will be disaster.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: [PATCH] Re: Does the Sparse work under cygwin?
Date: Mon, 13 Sep 2004 22:34:54 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKGEPDDDAA.mshah () teja ! com>
--------------------

I have attached the modified patch to make it work on cygwin. Two
modifications to your patch. (1) added conditional definitions of
strtold  (2) swapped the last two parameters of memset and removed
__CYGWIN__ define from lib.h file.

Linus,

I am not sure if it is ok to submit patches to solve OS dependent
issues, otherwise I will keep the patch applied in my local copy.

-Mitesh


--------------------
Index: sparse-local/expression.c
diff -u sparse-local/expression.c:1.1.1.1
sparse-local/expression.c:1.1.1.1.2.1
--- sparse-local/expression.c:1.1.1.1   Sun Aug  1 16:00:43 2004
+++ sparse-local/expression.c   Mon Sep 13 15:20:29 2004
@@ -204,7 +204,7 @@
                        show_token(token));
        return;
 Float:
-       expr->fvalue = strtold(str, &end);
+       expr->fvalue = C99_STRTOLD(str, &end);
        if (str == end)
                goto Enoint;

Index: sparse-local/lib.c
diff -u sparse-local/lib.c:1.1.1.1 sparse-local/lib.c:1.1.1.1.2.1
--- sparse-local/lib.c:1.1.1.1  Mon Sep  6 16:00:49 2004
+++ sparse-local/lib.c  Mon Sep 13 15:20:29 2004
@@ -67,6 +67,18 @@
        return retval;
 }

+#ifdef __CYGWIN__
+
+static inline void* zeroed_mmap(void *start, size_t length, int prot,
int flags
, int fd, off_t offset)
+{
+       void *pages = mmap(start, length, prot, flags, fd, offset);
+       if (pages)
+               memset(pages, 0, length);
+       return pages;
+}
+
+#endif
+
 /*
  * Simple allocator for data that doesn't get partially free'd.
  * The tokenizer and parser allocate a _lot_ of small data structures
@@ -83,7 +95,7 @@
 };

 #define CHUNK 32768
-#define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ |
PROT_WRI
TE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
+#define blob_alloc(size) ZEROED_MMAP(NULL, ((size)+4095) & ~4095,
PROT_READ | P
ROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
 #define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)

 struct allocator_struct {
Index: sparse-local/lib.h
diff -u sparse-local/lib.h:1.1.1.1 sparse-local/lib.h:1.1.1.1.2.1
--- sparse-local/lib.h:1.1.1.1  Mon Sep  6 16:00:49 2004
+++ sparse-local/lib.h  Mon Sep 13 15:20:29 2004
@@ -410,4 +410,12 @@
 #define REPLACE_CURRENT_PTR(ptr, new_ptr)
\
        do { *THIS_ADDRESS(ptr) = (new_ptr); } while (0)

+#ifdef __CYGWIN__
+#define ZEROED_MMAP zeroed_mmap
+#define C99_STRTOLD strtod
+#else
+#define ZEROED_MMAP mmap
+#define C99_STRTOLD strtold
+#endif
+
 #endif


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: RE: [PATCH] Re: Does the Sparse work under cygwin?
Date: Mon, 13 Sep 2004 22:46:57 +0000
Message-ID: <Pine.LNX.4.58.0409131540500.2378 () ppc970 ! osdl ! org>
--------------------


On Mon, 13 Sep 2004, Mitesh shah wrote:
> 
> I am not sure if it is ok to submit patches to solve OS dependent
> issues, otherwise I will keep the patch applied in my local copy.

I think it's ok to solve problems like this, but I'd like to see them get 
a bit more abstraction.

In particular, I do detest #ifdef code inside code, or using upper-case
macros where a simple wrapper function might do.

For example, it might just make sense to have a "compat.c" file that 
gathers compatibility-functions. Make that "blob_alloc()" a real function 
in that file, and then different systems could just have different 
versions of that (and a different one for debugging, for example).

(bloc_free() to match, of course).

Similarly, the "strtold()" function could just be in compat.c too: instead 
of using a macro to define it to something else, just have a nice wrapper 
for it and call it something descriptive..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [PATCH] Re: Does the Sparse work under cygwin?
Date: Mon, 13 Sep 2004 22:50:56 +0000
Message-ID: <200409132250.i8DMouh14192 () troll ! rentec ! com>
--------------------

I would prefer that you leave callers alone and just have lib.[ch]
(conditionally) define strtold.  Or maybe we need port.[ch] for that.

For mmap, you would need to say something like

  #ifdef __CYGWIN__
  #include <sys/mmap.h> // Or whatever it is
  #undef mmap
  #define mmap zeroed_mmap
  // Prototype
  #endif

in the header file.  This way we can keep the portability issues
pretty local.

Morten

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Re: Does the Sparse work under cygwin?
Date: Mon, 13 Sep 2004 23:05:55 +0000
Message-ID: <Pine.LNX.4.58.0409131603330.2378 () ppc970 ! osdl ! org>
--------------------


On Mon, 13 Sep 2004, Christopher Li wrote:
> 
> Do you prefer different system share the same compat.c file or have
> each system a compat-xxx.c by its own?

I actually think having a compat-xxx.h and compat-xxx.c for each system 
would be wonderful. Have something that just sets it up in the Makefile 
directly (either using symlinks or even a "-include compat-xxx.h" flag).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Re: sparse howto? ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: [PATCH] Re: sparse howto?
Date: Sat, 12 Jun 2004 17:33:27 +0000
Message-ID: <20040612103327.36de75c0.rddunlap () osdl ! org>
--------------------
On Sat, 12 Jun 2004 06:44:34 -0500 Josh Boyer wrote:

| > Does that help?  What other questions do you have?
| > (but I probably can't answer any more)
| 
| Yes, that is exactly what I was looking for.  Thanks!  I don't have any
| other questions at the moment, but I am sure I'll come up with some
| later :).
| 
| Maybe something like this could be put in the FAQ file for sparse.  Then
| the list wouldn't have to suffer newbies such as myself ;).

Linus, anyone else-

Any comments/additions for this quickie sparse howto?
I put it in the README instead of the FAQ since the FAQ is
entitled "FAQ - Why sparse?" (and not HOWTO sparse).


If not, please add it....
--



Add Quick HOWTO for building and using sparse.

Signed-off-by: Randy Dunlap <rddunlap@osdl.org>

diffstat:=
 README |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+)


diff -Naurp ./README~howto ./README
--- ./README~howto	2004-01-30 10:29:14.000000000 -0800
+++ ./README	2004-06-12 10:26:25.000000000 -0700
@@ -82,3 +82,25 @@ preprocessing, parsing and type evaluati
 results.  These clients were done to verify and debug the library, and
 also as trivial examples of what you can do with the parse tree once it
 is formed, so that users can see how the tree is organized. 
+
+
+Quick sparse HOWTO
+======================================================================
+
+in kernel tree:  make help
+says:
+  make C=1   [targets] Check all c source with checker tool
+
+Build/install sparse:
+
+"checker tool" is built as "check" but then installed as "sparse".
+
+a.  unpack the tarball or export the bk tree
+b.  cd path/to/sparse
+c.  make
+d.  make install     # default location is in user's $HOME/bin
+
+...then do your target build, e.g.,
+
+make allmodconfig     # or defconfig or whatever
+make C=1 all >build.out 2>&1     # to capture all messages
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Resend: minor fix for switch -I handler ===

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: [PATCH] Resend: minor fix for switch -I handler
Date: Wed, 22 Sep 2004 17:58:50 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKMEBJDEAA.mshah () teja ! com>
--------------------

Include paths are not being parsed correctly. Also, the error message
from test-parsing was not referring to the correct filename when there
are more than one arguments. Here is the patch.

Thanks,

-Mitesh

------------------------------------------------------------------------
-


Index: lib.c
===================================================================
RCS file: /home/cvs/root/sparse-bk/lib.c,v
retrieving revision 1.2
diff -u -r1.2 lib.c
--- lib.c       22 Sep 2004 17:35:41 -0000      1.2
+++ lib.c       22 Sep 2004 17:54:55 -0000
@@ -627,8 +627,8 @@
 char **handle_switch_I(char *arg, char **next)
 {
        // FIXME: What about "-I-"?
-       if (!strcmp (arg, "I") && *next) {
-               add_pre_buffer("#add_include \"%s/\"\n", next);
+       if (!strcmp (arg, "I") && **(next+1)) {
+               add_pre_buffer("#add_include \"%s/\"\n", *(next+1));
                return next + 1; // "-I foo"
        } else {
                add_pre_buffer("#add_include \"%s/\"\n", arg + 1);
Index: test-parsing.c
===================================================================
RCS file: /home/cvs/root/sparse-bk/test-parsing.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 test-parsing.c
--- test-parsing.c      1 Sep 2004 23:00:27 -0000       1.1.1.1
+++ test-parsing.c      22 Sep 2004 17:54:55 -0000
@@ -56,7 +56,7 @@

        fd = open(filename, O_RDONLY);
        if (fd < 0)
-               die("No such file: %s", argv[1]);
+               die("No such file: %s", filename);

        // Tokenize the input stream
        token = tokenize(filename, fd, NULL, includepath);


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Resend: minor fix for switch -I handler
Date: Wed, 22 Sep 2004 18:20:55 +0000
Message-ID: <Pine.LNX.4.58.0409221104440.25656 () ppc970 ! osdl ! org>
--------------------


On Wed, 22 Sep 2004, Mitesh shah wrote:
> 
> Include paths are not being parsed correctly.

Hmm.. Your improvement seems to be only partial. In particular, it looks 
like it would SIGSEGV if "-I" is the last argument.

I did an alternate version that should work and has a proper error message 
instead.

> Also, the error message from test-parsing was not referring to the
> correct filename when there are more than one arguments.

Fair enough..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Simplify mnemonic generation for =?koi8-r?Q?=22?=mov*=?koi8-r?Q?=22=20?=instructions. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: [PATCH] Simplify mnemonic generation for =?koi8-r?Q?=22?=mov*=?koi8-r?Q?=22=20?=instructions.
Date: Fri, 30 Jul 2004 15:12:56 +0000
Message-ID: <E1BqZ44-000JGL-00.adobriyan-mail-ru () f30 ! mail ! ru>
--------------------
We already have a function that adds correct {b,w,l,q} suffix.

diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	2004-07-28 13:03:35 +00:00
+++ b/compile-i386.c	2004-07-28 13:45:00 +00:00
@@ -1018,31 +1018,15 @@
 		return;
 	}
 
-	switch (bits) {
-	case 8:
+	if ((bits == 8) || (bits == 16)) {
 		if (is_dest)
-					opname = "movb";
-		else {
-			if (is_signed)	opname = "movsxb";
-			else		opname = "movzxb";
-		}
-		break;
-	case 16:
-		if (is_dest)
-					opname = "movw";
-		else {
-			if (is_signed)	opname = "movsxw";
-			else		opname = "movzxw";
-		}
-		break;
-
-	case 32:			opname = "movl";	break;
-	case 64:			opname = "movq";	break;
-
-	default:			assert(0);		break;
-	}
+			opname = "mov";
+		else
+			opname = is_signed ? "movsx" : "movzx";
+	} else
+		opname = "mov";
 
-	insn(opname, src, dest, comment);
+	insn(opbits(opname, bits), src, dest, comment);
 }
 
 static struct storage *emit_compare(struct expression *expr)

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Under __sun__, implement a strtold. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Under __sun__, implement a strtold.
Date: Thu, 12 Aug 2004 20:32:39 +0000
Message-ID: <20040812203239.4E6A21422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 13:59:07-04:00 welinder@troll.com 
#   lib.c, lib.h:
#     Under __sun__, implement a strtold.
# 
# lib.c
#   2004/08/12 13:58:53-04:00 welinder@troll.com +32 -0
#   Under __sun__, implement a strtold.
# 
# lib.h
#   2004/08/12 13:58:40-04:00 welinder@troll.com +4 -0
#   Under __sun__, implement a strtold.
# 
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-08-12 13:00:29 -04:00
+++ b/lib.c	2004-08-12 13:58:53 -04:00
@@ -683,3 +683,35 @@
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
 	add_pre_buffer("#define __builtin_va_end(arg)\n");	
 }
+
+#ifdef __sun__
+#include <floatingpoint.h>
+#include <limits.h>
+#include <errno.h>
+
+long double
+strtold (char const *str, char **end)
+{
+	long double res;
+	decimal_record dr;
+	enum decimal_string_form form;
+	decimal_mode dm;
+	fp_exception_field_type excp;
+	char *echar;
+
+	string_to_decimal ((char **)&str, INT_MAX, 0,
+			   &dr, &form, &echar);
+	if (end) *end = (char *)str;
+
+	if (form == invalid_form) {
+		errno = EINVAL;
+		return 0.0;
+	}
+
+	dm.rd = fp_nearest;
+	decimal_to_quadruple (&res, &dm, &dr, &excp);
+        if (excp & ((1 << fp_overflow) | (1 << fp_underflow)))
+                errno = ERANGE;
+	return res;
+}
+#endif
diff -Nru a/lib.h b/lib.h
--- a/lib.h	2004-06-07 02:14:33 -04:00
+++ b/lib.h	2004-08-12 13:58:40 -04:00
@@ -133,6 +133,10 @@
 
 extern void create_builtin_stream(void);
 
+#ifdef __sun__
+extern long double strtold (char const *str, char **end);
+#endif
+
 static inline int symbol_list_size(struct symbol_list* list)
 {
 	return ptr_list_size((struct ptr_list *)(list));
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Use __SIZE_TYPE__ ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Use __SIZE_TYPE__
Date: Thu, 12 Aug 2004 20:32:46 +0000
Message-ID: <20040812203246.7471B1422D4F () darter ! rentec ! com>
--------------------


# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 14:40:25-04:00 welinder@troll.com 
#   check.c:
#     Use __SIZE_TYPE__
#     Define __builtin_alloca.
#   lib.c:
#     Pre-define __SIZE_TYPE__
# 
# check.c
#   2004/08/12 14:39:41-04:00 welinder@troll.com +3 -2
#   Use __SIZE_TYPE__
#   Define __builtin_alloca.
# 
# lib.c
#   2004/08/12 14:39:28-04:00 welinder@troll.com +5 -0
#   Pre-define __SIZE_TYPE__
# 
diff -Nru a/check.c b/check.c
--- a/check.c	2004-07-27 17:52:32 -04:00
+++ b/check.c	2004-08-12 14:39:41 -04:00
@@ -49,11 +49,12 @@
 
 	create_builtin_stream();
 	add_pre_buffer("#define __CHECKER__ 1\n");
-	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, unsigned long);\n");
+	add_pre_buffer("extern void *__builtin_memcpy(void *, const void *, __SIZE_TYPE__);\n");
 	add_pre_buffer("extern void *__builtin_return_address(int);\n");
-	add_pre_buffer("extern void *__builtin_memset(void *, int, unsigned long);\n");	
+	add_pre_buffer("extern void *__builtin_memset(void *, int, __SIZE_TYPE__);\n");	
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
+	add_pre_buffer("extern void *__builtin_alloca(__SIZE_TYPE__);\n");
 
 	args = argv;
 	for (;;) {
diff -Nru a/lib.c b/lib.c
--- a/lib.c	2004-08-12 14:14:51 -04:00
+++ b/lib.c	2004-08-12 14:39:28 -04:00
@@ -681,6 +681,11 @@
 	add_pre_buffer("#define __func__ \"function\"\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
+	// gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
+	// solaris/sparc that is really "unsigned int" and for linux/x86_64
+	// it is "long unsigned int".  In either case we can probably
+	// get away with this:
+	add_pre_buffer("#define __SIZE_TYPE__ long unsigned int\n");
 	add_pre_buffer("#define __builtin_stdarg_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_start(a,b) ((a) = (__builtin_va_list)(&(b)))\n");
 	add_pre_buffer("#define __builtin_va_arg(arg,type)  ((type)0)\n");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] Wrapper to run check and gcc in series. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: [PATCH] Wrapper to run check and gcc in series.
Date: Thu, 12 Aug 2004 20:31:01 +0000
Message-ID: <20040812203101.C0C6C1422D4F () darter ! rentec ! com>
--------------------

http://sparse-mw.bkbits.net:8080/sparse is operational.

You could in principle pull from there and nothing too bad would
happen, but I suspect that there are a few changesets that you do
not want.  Therefore, a patch flood...  Most of the patches are
very local in nature.

These were generated with the command

    perl -e 'for $i (709 ... 725) { my $cmd = "bk -v rset -hr1.$i | bk gnupatch -T"; print "$cmd\n"; system ("$cmd >patch-$i"); }'

If that's not the way to do it, well, let me know.  I didn't see a
simple way of pulling a specific changeset from a repository.

(Oh, and lots of keyboard macros and scripts were involved here.  Any
email screwup is likely to be impressive...)

Morten




# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/08/12 12:40:32-04:00 welinder@troll.com 
#   Wrapper to run check and gcc in series.
# 
# cgcc
#   2004/08/12 12:40:31-04:00 welinder@troll.com +22 -0
# 
# cgcc
#   2004/08/12 12:40:31-04:00 welinder@troll.com +0 -0
#   BitKeeper file /scratch/welinder/sparse/cgcc
# 
diff -Nru a/cgcc b/cgcc
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/cgcc	2004-08-12 12:40:31 -04:00
@@ -0,0 +1,22 @@
+#!/usr/bin/perl -w
+# -----------------------------------------------------------------------------
+
+my $cc = $ENV{'REAL_CC'} || 'cc';
+my $check = $ENV{'CHECK'} || 'check';
+
+# Look for a .c file.  We don't want to run the checker on .o or .so files
+# in the link run.  (This simplistic check knows nothing about options
+# with arguments, but it seems to do the job.)
+my $seen_a_c_file = 0;
+foreach (@ARGV) {
+    if (/^[^-].*\.c/) {
+	$seen_a_c_file = 1;
+	last;
+    }
+}
+
+if ($seen_a_c_file) {
+    system ($check, @ARGV);
+}
+
+exec ($cc, @ARGV);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [PATCH] Wrapper to run check and gcc in series.
Date: Thu, 12 Aug 2004 20:54:11 +0000
Message-ID: <411BD8F3.8090103 () pobox ! com>
--------------------
Morten Welinder wrote:
> http://sparse-mw.bkbits.net:8080/sparse is operational.

Look in the kernel tree for the "bk-make-sum" script in the 
Documentation/BK-usage directory.  Run it like this:

$ cd /repos/sparse.morten
$ bk push		# verify everything is at bkbits.net
$ bk-make-sum ../sparse.vanilla
$ vi /tmp/linus.txt	# edit the 'bk pull' URL
$    # email linus.txt to linus and linux-sparse

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] Wrapper to run check and gcc in series.
Date: Fri, 13 Aug 2004 04:38:14 +0000
Message-ID: <Pine.LNX.4.58.0408122104120.1839 () ppc970 ! osdl ! org>
--------------------


On Thu, 12 Aug 2004, Morten Welinder wrote:
> 
> These were generated with the command
> 
>     perl -e 'for $i (709 ... 725) { my $cmd = "bk -v rset -hr1.$i | bk gnupatch -T"; print "$cmd\n"; system ("$cmd >patch-$i"); }'
> 
> If that's not the way to do it, well, let me know.  I didn't see a
> simple way of pulling a specific changeset from a repository.

There isn't - this is pretty good.

However, one thing I'd prefer to make it much more palatable to me:

 - number your patches by making the subject line be "[PATCH n/m] xxxx",
   and have a 10-second delay in between sending them out. That way they
   tend to arrive to me in order, and even if they don't, I can easily 
   save them in the right order both visually and by sorting by inbox by 
   date (which I usually don't, since too many people have their dates 
   screwed up ;)

 - if you can make the body of the email a bit more readable by stripping 
   out the BK-induced stuff (ie the "#" and non-comment stuff). So instead 
   of

	# This is a BitKeeper generated diff -Nru style patch.
	#
	# ChangeSet
	#   2004/08/12 13:20:04-04:00 welinder@troll.com 
	#   parse.c:
	#     Handle __noreturn__ as noreturn (==ignore).
	# 
	# parse.c
	#   2004/08/12 13:19:37-04:00 welinder@troll.com +2 -1
	#   Handle __noreturn__ as noreturn (==ignore).
	# 

   just a simple

	Handle __noreturn__ as noreturn (==ignore).

   as the body would be preferred..

That way all my patch-applying scripts will work.

Oh, and one more thing: check that they apply to current BK. I suspect 
some of your patches clash with Al Viro's..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add __restrict__ symbol ===

From: Jeff Muizelaar <jeff () infidigm ! net>
To: linux-sparse
Subject: [PATCH] add __restrict__ symbol
Date: Fri, 26 Nov 2004 19:40:05 +0000
Message-ID: <20041126194005.GB10481 () debian>
--------------------
Adds the __restrict__ variant of restrict. Pretty straight forward.

-Jeff


diff -urp sparse-bk/symbol.c sparse-restrict/symbol.c
--- sparse-bk/symbol.c	2004-11-17 19:00:42 -0500
+++ sparse-restrict/symbol.c	2004-11-26 14:24:35 -0500
@@ -602,6 +602,7 @@ struct sym_init {
 	/* Ignored for now.. */
 	{ "restrict",	NULL,		0 },
 	{ "__restrict",	NULL,		0 },
+	{ "__restrict__", NULL,		0 },
 
 	{ NULL,		NULL,		0 }
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Muizelaar <jeff () infidigm ! net>
To: linux-sparse
Subject: [PATCH] add __restrict__ symbol
Date: Mon, 06 Dec 2004 00:19:11 +0000
Message-ID: <20041206001910.GA22797 () debian>
--------------------
Adds the __restrict__ variant of restrict. Pretty straight forward.

-Jeff

diff -u sparse-bk/symbol.c sparse-restrict-new/symbol.c
--- sparse-bk/symbol.c	2004-12-02 19:00:46 -0500
+++ sparse-restrict-new/symbol.c	2004-12-05 19:14:49 -0500
@@ -603,6 +603,7 @@
 	/* Ignored for now.. */
 	{ "restrict",	NULL,		0 },
 	{ "__restrict",	NULL,		0 },
+	{ "__restrict__", NULL,		0 },
 
 	{ NULL,		NULL,		0 }
 };
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] add define __STDC__ ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] add define __STDC__
Date: Fri, 05 Nov 2004 06:20:03 +0000
Message-ID: <20041105062003.GA28850 () 64m ! dyndns ! org>
--------------------
Define __GNUC__ but not __STDC__ will upset cdefs.h:

/usr/include/sys/cdefs.h:31:3: warning: "You need a ISO C conforming compiler to use the glibc headers"

Chris

Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-11-03 01:32:56.000000000 -0500
+++ sparse-be/lib.c	2004-11-05 01:13:31.000000000 -0500
@@ -768,6 +768,7 @@
 void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __GNUC__ 2\n");
+	add_pre_buffer("#define __STDC__ 1\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: [PATCH] add define __STDC__
Date: Fri, 05 Nov 2004 14:22:35 +0000
Message-ID: <20041105142235.126D21422D4F () darter ! rentec ! com>
--------------------

This causes problems on Solaris which is why I made cgcc handle it.

I suggest that lib.c issue...

    add_pre_buffer("#ifndef __STDC__\n");
    add_pre_buffer("#define __STDC__ 1\n");
    add_pre_buffer("#endif\n");

...so cgcc's definition is not overruled.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] add define __STDC__
Date: Fri, 05 Nov 2004 16:07:46 +0000
Message-ID: <Pine.LNX.4.58.0411050804300.2187 () ppc970 ! osdl ! org>
--------------------


On Fri, 5 Nov 2004, Morten Welinder wrote:
> 
> I suggest that lib.c issue...
> 
>     add_pre_buffer("#ifndef __STDC__\n");
>     add_pre_buffer("#define __STDC__ 1\n");
>     add_pre_buffer("#endif\n");
> 
> ...so cgcc's definition is not overruled.

Actually, we should probably add a 

	#weak_define xxxx yyyy

which is similar to a regular define, but says: don't complain if somebody
has already defined it or will re-define it.

A lot of the sparse internal #defines should probably be of that type.

(On that same issue - I think we currently do the wrong thing for 
re-definitions. We complain, but then we keep the old one. We should 
probably pick up the new one. At least that's what gcc does, and it seems 
sane.)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] add define __STDC__
Date: Fri, 05 Nov 2004 16:19:09 +0000
Message-ID: <20041105161909.GD29422 () 64m ! dyndns ! org>
--------------------
> Actually, we should probably add a 
> 
> 	#weak_define xxxx yyyy
> 
> which is similar to a regular define, but says: don't complain if somebody
> has already defined it or will re-define it.
> 
> A lot of the sparse internal #defines should probably be of that type.
> 
> (On that same issue - I think we currently do the wrong thing for 
> re-definitions. We complain, but then we keep the old one. We should 
> probably pick up the new one. At least that's what gcc does, and it seems 
> sane.)

Weak define it is.

The weak define is implement in the previous patch I send out.
I feel that there is more macro want to go weak_define as well.
So I keep it separate.


Chris


Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-11-03 01:32:56.000000000 -0500
+++ sparse-be/lib.c	2004-11-05 11:12:49.000000000 -0500
@@ -768,6 +768,7 @@
 void create_builtin_stream(void)
 {
 	add_pre_buffer("#define __GNUC__ 2\n");
+	add_pre_buffer("#weak_define __STDC__ 1\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
 	add_pre_buffer("#define __extension__\n");
 	add_pre_buffer("#define __pragma__\n");
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] clean up usage of list internal ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] clean up usage of list internal
Date: Fri, 05 Nov 2004 06:25:33 +0000
Message-ID: <20041105062533.GB28850 () 64m ! dyndns ! org>
--------------------
Minor cleanup. There is a remote chance that list contain only
one item. So second might be an uninitialized pointer.

Chris

Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-11-04 18:11:16.000000000 -0500
+++ sparse-be/linearize.c	2004-11-05 01:04:45.000000000 -0500
@@ -1421,15 +1421,13 @@
 	struct basic_block *bb;
 
 	FOR_EACH_PTR(ep->bbs, bb) {
-		struct instruction *first, *second;
-		struct ptr_list *list;
+		struct instruction *first, *second, *insn;
 
-		/* FIXME! This knows too much about list internals */
-		list = (struct ptr_list *)bb->insns;
-		if (!list)
-			continue;
-		first = list->list[0];
-		second = list->list[1];
+		PREPARE_PTR_LIST(bb->insns, insn);
+		first = insn;
+		NEXT_PTR_LIST(insn);
+		second = insn;
+		FINISH_PTR_LIST(insn);
 
 		if (!first || !second)
 			continue;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] clean up usage of list internal
Date: Fri, 05 Nov 2004 16:00:10 +0000
Message-ID: <20041105160010.GA29422 () 64m ! dyndns ! org>
--------------------
On Fri, Nov 05, 2004 at 08:15:21AM -0800, Linus Torvalds wrote:
> 
> 
> On Fri, 5 Nov 2004, Christopher Li wrote:
> >
> > Minor cleanup. There is a remote chance that list contain only
> > one item. So second might be an uninitialized pointer.
> 
> I wanted to do a
> 
> 	int linearize_ptr_list(struct ptr_list *, void *, int);

I implement that in a the next patch I am going to send, with an
start offset. But if you want to handle a bb has more than one
phi node in the front. You can't use the linearize_ptr_list.


I revisit it. And modify the patch as follows. Please let me know
if you still want to using linearize_ptr_list.

Chris

Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-11-05 01:07:57.000000000 -0500
+++ sparse-be/linearize.c	2004-11-05 10:53:40.000000000 -0500
@@ -1422,17 +1422,11 @@
 
 	FOR_EACH_PTR(ep->bbs, bb) {
 		struct instruction *first, *second;
-		struct ptr_list *list;
 
-		/* FIXME! This knows too much about list internals */
-		list = (struct ptr_list *)bb->insns;
-		if (!list)
-			continue;
-		first = list->list[0];
-		second = list->list[1];
-
-		if (!first || !second)
+		if (instruction_list_size(bb->insns) != 2)
 			continue;
+		first = first_instruction(bb->insns);
+		second = last_instruction(bb->insns);
 		if (first->opcode != OP_PHI)
 			continue;
 		if (second->opcode != OP_BR)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] clean up usage of list internal
Date: Fri, 05 Nov 2004 16:15:21 +0000
Message-ID: <Pine.LNX.4.58.0411050811330.2187 () ppc970 ! osdl ! org>
--------------------


On Fri, 5 Nov 2004, Christopher Li wrote:
>
> Minor cleanup. There is a remote chance that list contain only
> one item. So second might be an uninitialized pointer.

I wanted to do a

	int linearize_ptr_list(struct ptr_list *, void *, int);

which just takes a pointer list, and an array and length, and linearizes 
the pointer list into the array.

Then that first/second thing would become

	struct instruction *insns[2];

	if (linearize_ptr_list(bb->insns, insns, 2) < 2)
		continue;

and you have the first instruction in "insns[0]" and the second one in 
"insns[1]".

But I was lazy. 

Using PREPARE_... NEXT_... FINISH_.. is about as ugly as the current code, 
and this is a general issue.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] clean up usage of list internal
Date: Fri, 05 Nov 2004 19:51:29 +0000
Message-ID: <Pine.LNX.4.58.0411051143390.2223 () ppc970 ! osdl ! org>
--------------------


On Fri, 5 Nov 2004, Christopher Li wrote:
> 
> I implement that in a the next patch I am going to send, with an
> start offset. But if you want to handle a bb has more than one
> phi node in the front. You can't use the linearize_ptr_list.

That simplification only really cared about the trivial case of a 
conditional jump that directly depends on a phi-node, so no other case 
really mattered for it.

I _would_ like to do the symbols->pseudo conversion, but I haven't decided
how to do it most cleanly. Some of it should really be done at the first
pass generating the linear thing, otherwise we'll just have to rewrite the
"generate address and load/store from it", but that thing is also
complicated by those bitfield assignments which are just really nasty.

I'm more and more wanting to try to get rid of bitfields as early as
humanly possible, preferably at the tree evaluation phase (so that the
expansion phase sees all the bitmask and shift constants and can merge
them). That's a rather big upheaval..

I did the "linearise_ptr_list()" thing already, btw (it's more 
efficiently done by just doing a bunch of pointers at a time, rather than 
with a regular FOR_EACH_PTR() kind of one-at-a-time loop). I didn't see 
any reason for a start offset, but maybe there is..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] linearize bitfield initializer ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] linearize bitfield initializer
Date: Thu, 04 Nov 2004 21:22:45 +0000
Message-ID: <20041104212245.GA26985 () 64m ! dyndns ! org>
--------------------
Hi Linus,

Here is the simple patch to linearize bit field initializer.
It don't try to optimized it.  Ideally the bit field
initializer can be combined. It don't have to use and/or mask.

I am a lazy baster. 

Chris


Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-11-03 10:21:43.000000000 -0500
+++ sparse-be/linearize.c	2004-11-04 16:19:25.000000000 -0500
@@ -441,28 +441,30 @@
 
 static pseudo_t linearize_store_gen(struct entrypoint *ep, pseudo_t value, struct expression *expr, pseudo_t addr)
 {
-	if (expr->type == EXPR_BITFIELD) {
-		unsigned long mask = ((1<<expr->nrbits)-1) << expr->bitpos;
+	struct symbol *ctype = expr->ctype;
+
+	if(is_bitfield_type(ctype)) {
+		unsigned long mask = ((1<<ctype->bit_size)-1) << ctype->bit_offset;
 		pseudo_t shifted, andmask, ormask, orig, orig_mask, value_mask, newval;
 
 		shifted = value;
-		if (expr->bitpos) {
+		if (ctype->bit_offset) {
 			pseudo_t shift;
-			shift = add_const_value(ep, expr->pos, &uint_ctype, expr->bitpos);
-			shifted = add_binary_op(ep, expr->ctype, OP_SHL, value, shift);
+			shift = add_const_value(ep, expr->pos, &uint_ctype, ctype->bit_offset);
+			shifted = add_binary_op(ep, ctype, OP_SHL, value, shift);
 			add_deathnote(ep, shift);
 		}
 		orig = add_load(ep, expr, addr);
 		andmask = add_const_value(ep, expr->pos, &uint_ctype, ~mask);
-		orig_mask = add_binary_op(ep, expr->ctype, OP_AND, orig, andmask);
+		orig_mask = add_binary_op(ep, ctype, OP_AND, orig, andmask);
 		add_deathnote(ep, orig);
 		add_deathnote(ep, andmask);
 		ormask = add_const_value(ep, expr->pos, &uint_ctype, mask);
-		value_mask = add_binary_op(ep, expr->ctype, OP_AND, shifted, ormask);
+		value_mask = add_binary_op(ep, ctype, OP_AND, shifted, ormask);
 		add_deathnote(ep, ormask);
 		if (shifted != value)
 			add_deathnote(ep, shifted);
-		newval = add_binary_op(ep, expr->ctype, OP_OR, orig_mask, value_mask);
+		newval = add_binary_op(ep, ctype, OP_OR, orig_mask, value_mask);
 		add_deathnote(ep, orig_mask);
 		add_deathnote(ep, value_mask);
 		value = newval;
@@ -883,7 +885,7 @@
 	pseudo_t offset = add_const_value(ep, pos->pos, &uint_ctype, pos->init_offset);
 	pseudo_t addr = add_binary_op(ep, baseaddr->def->type, OP_ADD, baseaddr, offset);
 	pseudo_t value = linearize_expression(ep, init_expr);
-	add_store(ep, init_expr, addr, value);
+	linearize_store_gen(ep, value, init_expr, addr);
 	add_deathnote(ep, addr);
 	add_deathnote(ep, value);
 	return VOID;
@@ -904,7 +906,7 @@
 		break;
 	default: {
 		pseudo_t value = linearize_expression(ep, initializer);
-		add_store(ep, initializer, baseaddr, value);
+		linearize_store_gen(ep, value, initializer, baseaddr);
 		add_deathnote(ep, value);
 	}
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] minor fix for -I handler ===

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: [PATCH] minor fix for -I handler
Date: Tue, 14 Sep 2004 01:14:28 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKEEPGDDAA.mshah () teja ! com>
--------------------
Include paths are not being parsed correctly. Also, the error message
from test-parsing was not referring to the correct filename when there
are more than one arguments. Here is the patch.


$ ctk diff -u
Index: lib.c
===================================================================
RCS file: /home/cvs/root/sparse-local/lib.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 lib.c
--- lib.c       6 Sep 2004 23:00:49 -0000       1.1.1.1
+++ lib.c       14 Sep 2004 01:02:27 -0000
@@ -593,8 +593,8 @@
 char **handle_switch_I(char *arg, char **next)
 {
        // FIXME: What about "-I-"?
-       if (!strcmp (arg, "I") && *next) {
-               add_pre_buffer("#add_include \"%s/\"\n", next);
+       if (!strcmp (arg, "I") && **(next+1)) {
+               add_pre_buffer("#add_include \"%s/\"\n", *(next+1));
                return next + 1; // "-I foo"
        } else {
                add_pre_buffer("#add_include \"%s/\"\n", arg + 1);
Index: test-parsing.c
===================================================================
RCS file: /home/cvs/root/sparse-local/test-parsing.c,v
retrieving revision 1.1.1.1
diff -u -r1.1.1.1 test-parsing.c
--- test-parsing.c      1 Sep 2004 23:00:27 -0000       1.1.1.1
+++ test-parsing.c      14 Sep 2004 01:02:27 -0000
@@ -56,7 +56,7 @@

        fd = open(filename, O_RDONLY);
        if (fd < 0)
-               die("No such file: %s", argv[1]);
+               die("No such file: %s", filename);

        // Tokenize the input stream
        token = tokenize(filename, fd, NULL, includepath);


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] minor fix for ansi C declear ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] minor fix for ansi C declear
Date: Thu, 09 Sep 2004 14:52:43 +0000
Message-ID: <20040909145243.GA28750 () 64m ! dyndns ! org>
--------------------
Just a one liner. Notice this when I parse sparse itself.

Chris

Index: sparse-be/pre-process.c
===================================================================
--- sparse-be.orig/pre-process.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/pre-process.c	2004-09-09 10:49:29.000000000 -0400
@@ -1376,7 +1376,7 @@
 }
 
 
-void init_preprocessor()
+void init_preprocessor(void)
 {
 	int i;
 	int stream = init_stream("preprocessor", -1, includepath);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] minor optimization on packing bb ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] minor optimization on packing bb
Date: Wed, 08 Sep 2004 17:19:47 +0000
Message-ID: <20040908171947.GA13186 () 64m ! dyndns ! org>
--------------------
This is a very minor optimization. When the target block
is the entry. we don't need to count the parents of target block.
Because we already know the entry block has at least 2 parents already,
one is the entry point, one is the current bb which try to jump to
the entry block.

Chris

Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/linearize.c	2004-09-08 13:12:51.000000000 -0400
@@ -1129,11 +1129,9 @@
 			continue;
 
 		target = jmp->bb_true ? jmp->bb_true : jmp->bb_false;
-		if (target == bb)
+		if (target == bb || target == ep->entry)
 			continue;
 		parents = bb_list_size(target->parents);
-		if (target == ep->entry)
-			parents++;
 		if (parents != 1 && jmp != first_instruction(bb->insns))
 			continue;
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [PATCH] minor optimization on packing bb
Date: Thu, 09 Sep 2004 02:09:05 +0000
Message-ID: <20040909020905.GA23894 () 64m ! dyndns ! org>
--------------------
Oh yes you are right. Silly me.

A test case for this:

void foo(void)
{
        int c;
entry: goto b;

b:
        if (c)
                goto d;
        else
                goto b;

d: 	goto entry;
}

Chris

On Wed, Sep 08, 2004 at 09:57:12PM -0700, Linus Torvalds wrote:
> 
> 
> On Wed, 8 Sep 2004, Christopher Li wrote:
> >
> > This is a very minor optimization. When the target block
> > is the entry. we don't need to count the parents of target block.
> > Because we already know the entry block has at least 2 parents already,
> > one is the entry point, one is the current bb which try to jump to
> > the entry block.
> 
> No no.
> 
> It's true that we don't strictly need to count the parents, but a block 
> with two parents can be _ok_. You missed the part where it says
> 
> 	if (parents != 1 && jmp != first_instruction(bb->insns))
> 			    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> 
> ie we shouldn't continue just because the target is "ep->entry", because 
> if the first instruction of the source is an unconditional jump, we can 
> just merge it into the target anyway.
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] minor optimization on packing bb
Date: Thu, 09 Sep 2004 04:57:12 +0000
Message-ID: <Pine.LNX.4.58.0409082154570.5912 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Sep 2004, Christopher Li wrote:
>
> This is a very minor optimization. When the target block
> is the entry. we don't need to count the parents of target block.
> Because we already know the entry block has at least 2 parents already,
> one is the entry point, one is the current bb which try to jump to
> the entry block.

No no.

It's true that we don't strictly need to count the parents, but a block 
with two parents can be _ok_. You missed the part where it says

	if (parents != 1 && jmp != first_instruction(bb->insns))
			    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

ie we shouldn't continue just because the target is "ep->entry", because 
if the first instruction of the source is an unconditional jump, we can 
just merge it into the target anyway.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] patch for os related differences ===

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: [PATCH] patch for os related differences
Date: Wed, 22 Sep 2004 21:02:27 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKEEBLDEAA.mshah () teja ! com>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_0005_01C4A0AC.CAE87EB0
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: 7bit


As discussed earlier, I have created separate .h and .c files for
different OS. In this patch you will find following changes.

New Files:
---------------
compat-linux.c and compat-linux.h
declaration and definition of blob_alloc and blob_free, nothing changed,
moved functions from lib.c

compat-cygwin.c and compat-cygwin.h
blob_alloc changed to set the memory to 0 after the allocation, strtold
is defined as a wrapper to strtod.

compat-mingw.c and compat-mingw.h
No mmap/munmap support under mingw, so changed the allocation to malloc
and deallocation to free. strtold is defined as a wrapper to strtod.

Changes in the existing files:
------------------------------------

Makefile is changed to have OS variable and by default its value is
"linux"

tokenize.c
In function init_stream, I have added the extra comparison for the
filenames in addition to device and inode. Under mingw, inode is always
0 and name comparison is sufficient enough to distinguish between the
files (There is no hard links)

Thanks,

-Mitesh

------=_NextPart_000_0005_01C4A0AC.CAE87EB0
Content-Type: application/octet-stream;
	name="t"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="t"

Index: sparse-bk/Makefile=0A=
diff -u sparse-bk/Makefile:1.1.1.1 sparse-bk/Makefile:1.1.1.1.8.1=0A=
--- sparse-bk/Makefile:1.1.1.1	Mon Sep 13 16:00:30 2004=0A=
+++ sparse-bk/Makefile	Wed Sep 22 13:17:30 2004=0A=
@@ -1,5 +1,6 @@=0A=
+OS=3Dlinux=0A=
 CC=3Dgcc=0A=
-CFLAGS=3D-O -g -Wall -Wwrite-strings=0A=
+CFLAGS=3D-O -g -Wall -Wwrite-strings -include compat-$(OS).h=0A=
 LDFLAGS=3D-g=0A=
 AR=3Dar=0A=
 =0A=
@@ -10,7 +11,8 @@=0A=
 	  linearize.h bitmap.h ident-list.h=0A=
 =0A=
 LIB_OBJS=3D target.o parse.o tokenize.o pre-process.o symbol.o lib.o =
scope.o \=0A=
-	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o=0A=
+	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \=0A=
+	  compat-$(OS).o=0A=
 =0A=
 LIB_FILE=3D sparse.a=0A=
 LIBS=3D$(LIB_FILE)=0A=
Index: sparse-bk/compat-cygwin.c=0A=
diff -u /dev/null sparse-bk/compat-cygwin.c:1.1.2.1=0A=
--- /dev/null	Wed Sep 22 13:54:22 2004=0A=
+++ sparse-bk/compat-cygwin.c	Wed Sep 22 13:17:30 2004=0A=
@@ -0,0 +1,38 @@=0A=
+=0A=
+/*=0A=
+ * Cygwin Compatibility functions=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+=0A=
+#include <sys/mman.h>=0A=
+#include <stdlib.h>=0A=
+#include <string.h>=0A=
+=0A=
+#include "compat-cygwin.h"=0A=
+=0A=
+void *blob_alloc (size_t size)=0A=
+{=0A=
+	void *ptr;=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	ptr =3D mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | =
MAP_ANONYMOUS, -1, 0);=0A=
+	if (ptr =3D=3D MAP_FAILED)=0A=
+		ptr =3D NULL;=0A=
+	else=0A=
+		memset(ptr, 0, size);=0A=
+	return ptr;=0A=
+}=0A=
+=0A=
+void blob_free (void *addr, size_t size)=0A=
+{=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	munmap(addr, size);=0A=
+}=0A=
+=0A=
+long double strtold(const char *nptr, char **endptr) =0A=
+{=0A=
+	return strtod(nptr, endptr);=0A=
+}=0A=
Index: sparse-bk/compat-cygwin.h=0A=
diff -u /dev/null sparse-bk/compat-cygwin.h:1.1.2.1=0A=
--- /dev/null	Wed Sep 22 13:54:22 2004=0A=
+++ sparse-bk/compat-cygwin.h	Wed Sep 22 13:17:30 2004=0A=
@@ -0,0 +1,19 @@=0A=
+#ifndef  COMPAT_CYGWIN_H=0A=
+#define  COMAPT_CYGWIN_H=0A=
+=0A=
+#include <stddef.h>=0A=
+=0A=
+=0A=
+/*=0A=
+ * Cygwin Compatibility declarations and defines =0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+void *blob_alloc (size_t size);=0A=
+void blob_free (void *addr, size_t size);=0A=
+long double strtold(const char *nptr, char **endptr);=0A=
+=0A=
+#endif // COMPAT_CYGWIN_H=0A=
Index: sparse-bk/compat-linux.c=0A=
diff -u /dev/null sparse-bk/compat-linux.c:1.1.2.1=0A=
--- /dev/null	Wed Sep 22 13:54:22 2004=0A=
+++ sparse-bk/compat-linux.c	Wed Sep 22 13:17:30 2004=0A=
@@ -0,0 +1,26 @@=0A=
+/*=0A=
+ * Linux Compatibility functions=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+#include <sys/mman.h>=0A=
+#include "compat-linux.h"=0A=
+=0A=
+void *blob_alloc (size_t size)=0A=
+{=0A=
+	void *ptr;=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	ptr =3D mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | =
MAP_ANONYMOUS, -1, 0);=0A=
+	if (ptr =3D=3D MAP_FAILED)=0A=
+		ptr =3D NULL;=0A=
+	return ptr;=0A=
+}=0A=
+=0A=
+void blob_free (void *addr, size_t size)=0A=
+{=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	munmap(addr, size);=0A=
+}=0A=
Index: sparse-bk/compat-linux.h=0A=
diff -u /dev/null sparse-bk/compat-linux.h:1.1.2.2=0A=
--- /dev/null	Wed Sep 22 13:54:22 2004=0A=
+++ sparse-bk/compat-linux.h	Wed Sep 22 13:25:23 2004=0A=
@@ -0,0 +1,20 @@=0A=
+#ifndef  COMPAT_LINUX_H=0A=
+#define  COMAPT_LINUX_H=0A=
+=0A=
+=0A=
+/*=0A=
+ * Linux Compatibility declarations and defines=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+#include <stddef.h>=0A=
+=0A=
+=0A=
+=0A=
+void *blob_alloc (size_t size);=0A=
+void blob_free (void *addr, size_t size);=0A=
+=0A=
+#endif // COMPAT_LINUX_H=0A=
Index: sparse-bk/compat-mingw.c=0A=
diff -u /dev/null sparse-bk/compat-mingw.c:1.1.2.1=0A=
--- /dev/null	Wed Sep 22 13:54:22 2004=0A=
+++ sparse-bk/compat-mingw.c	Wed Sep 22 13:17:30 2004=0A=
@@ -0,0 +1,33 @@=0A=
+=0A=
+/*=0A=
+ * Mingw Compatibility functions=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+=0A=
+#include <stdlib.h>=0A=
+#include <string.h>=0A=
+=0A=
+#include "compat-mingw.h"=0A=
+=0A=
+void *blob_alloc (size_t size)=0A=
+{=0A=
+	void *ptr;=0A=
+	ptr =3D malloc(size);=0A=
+	if (ptr !=3D NULL)=0A=
+		memset(ptr, 0, size);=0A=
+	return ptr;=0A=
+}=0A=
+=0A=
+void blob_free (void *addr, size_t size)=0A=
+{=0A=
+	free(addr);=0A=
+}=0A=
+=0A=
+long double strtold(const char *nptr, char **endptr) =0A=
+{=0A=
+	return strtod(nptr, endptr);=0A=
+}=0A=
Index: sparse-bk/compat-mingw.h=0A=
diff -u /dev/null sparse-bk/compat-mingw.h:1.1.2.1=0A=
--- /dev/null	Wed Sep 22 13:54:22 2004=0A=
+++ sparse-bk/compat-mingw.h	Wed Sep 22 13:17:30 2004=0A=
@@ -0,0 +1,19 @@=0A=
+#ifndef  COMPAT_MINGW_H=0A=
+#define  COMAPT_MINGW_H=0A=
+=0A=
+#include <stddef.h>=0A=
+=0A=
+=0A=
+/*=0A=
+ * Mingw Compatibility declarations and defines =0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+void *blob_alloc (size_t size);=0A=
+void blob_free (void *addr, size_t size);=0A=
+long double strtold(const char *nptr, char **endptr);=0A=
+=0A=
+#endif // COMPAT_MINGW_H=0A=
Index: sparse-bk/lib.c=0A=
diff -u sparse-bk/lib.c:1.2 sparse-bk/lib.c:1.2.2.1=0A=
--- sparse-bk/lib.c:1.2	Wed Sep 22 10:35:41 2004=0A=
+++ sparse-bk/lib.c	Wed Sep 22 13:17:30 2004=0A=
@@ -14,7 +14,6 @@=0A=
 #include <stdlib.h>=0A=
 #include <string.h>=0A=
 =0A=
-#include <sys/mman.h>=0A=
 #include <sys/types.h>=0A=
 #include <sys/stat.h>=0A=
 =0A=
@@ -83,22 +82,6 @@=0A=
 };=0A=
 =0A=
 #define CHUNK 32768=0A=
-=0A=
-static void *blob_alloc (size_t size)=0A=
-{=0A=
-	void *ptr;=0A=
-	size =3D (size + 4095) & ~4095;=0A=
-	ptr =3D mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | =
MAP_ANONYMOUS, -1, 0);=0A=
-	if (ptr =3D=3D MAP_FAILED)=0A=
-		ptr =3D NULL;=0A=
-	return ptr;=0A=
-}=0A=
-=0A=
-static void blob_free (void *addr, size_t size)=0A=
-{=0A=
-	size =3D (size + 4095) & ~4095;=0A=
-	munmap(addr, size);=0A=
-}=0A=
 =0A=
 struct allocator_struct {=0A=
 	const char *name;=0A=
Index: sparse-bk/tokenize.c=0A=
diff -u sparse-bk/tokenize.c:1.1.1.1 sparse-bk/tokenize.c:1.1.1.1.8.1=0A=
--- sparse-bk/tokenize.c:1.1.1.1	Mon Sep 13 16:00:30 2004=0A=
+++ sparse-bk/tokenize.c	Wed Sep 22 13:17:30 2004=0A=
@@ -171,6 +171,7 @@=0A=
 		for (i =3D 0; i < stream; i++) {=0A=
 			struct stream *s =3D input_streams + i;=0A=
 			if (s->dev =3D=3D st.st_dev && s->ino =3D=3D st.st_ino &&=0A=
+			    !strcmp(s->name, name) &&=0A=
 			    s->constant =3D=3D CONSTANT_FILE_YES &&=0A=
 			    lookup_symbol(s->protect, NS_MACRO))=0A=
 				return -1;=0A=

------=_NextPart_000_0005_01C4A0AC.CAE87EB0--


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] patch for os related differences
Date: Wed, 22 Sep 2004 21:46:24 +0000
Message-ID: <Pine.LNX.4.58.0409221436300.25656 () ppc970 ! osdl ! org>
--------------------


On Wed, 22 Sep 2004, Mitesh shah wrote:
> 
> tokenize.c
> In function init_stream, I have added the extra comparison for the
> filenames in addition to device and inode. Under mingw, inode is always
> 0 and name comparison is sufficient enough to distinguish between the
> files (There is no hard links)

Hmm. That extra comparison is wrong on posixy platforms, since it will 
mean that we will tokenize streams only because we happened to hit them 
through two different pathnames (one might be relative, another absolute: 
it doesn't even need symlinks or hardlinks).

So I think that part should also be abstracted out some way. Even om mingw 
you might have some more complex rules (_fullname() or something, to get 
the full pathname comparison).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: [PATCH] patch for os related differences
Date: Wed, 22 Sep 2004 23:14:24 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKIEBMDEAA.mshah () teja ! com>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_000A_01C4A0BF.39B88C10
Content-Type: text/plain;
	charset="us-ascii"
Content-Transfer-Encoding: 7bit



> Hmm. That extra comparison is wrong on posixy platforms,
> since it will mean that we will tokenize streams only because we
happened
> to hit them  through two different pathnames (one might be relative,
> another absolute:  it doesn't even need symlinks or hardlinks).
>
> So I think that part should also be abstracted out some way.
> Even om mingw you might have some more complex rules (_fullname() or
> something, to get  the full pathname comparison).
>
> 		Linus

Ok, I have moved the file inode comparison in an os dependent function
called identical_files(). Currently, for mingw, I am using windows API
to identify the files uniquely, which is somewhat heavy because I have
to open both the files simultaneously to compare the indices, will
replace it to a lighter version later if I find out how to do that.

The new diffs are attached.

-Mitesh



------=_NextPart_000_000A_01C4A0BF.39B88C10
Content-Type: text/plain;
	name="diff.txt"
Content-Transfer-Encoding: quoted-printable
Content-Disposition: attachment;
	filename="diff.txt"

Index: sparse-bk/Makefile=0A=
diff -u sparse-bk/Makefile:1.1.1.1 sparse-bk/Makefile:1.1.1.1.8.1=0A=
--- sparse-bk/Makefile:1.1.1.1	Mon Sep 13 16:00:30 2004=0A=
+++ sparse-bk/Makefile	Wed Sep 22 13:17:30 2004=0A=
@@ -1,5 +1,6 @@=0A=
+OS=3Dlinux=0A=
 CC=3Dgcc=0A=
-CFLAGS=3D-O -g -Wall -Wwrite-strings=0A=
+CFLAGS=3D-O -g -Wall -Wwrite-strings -include compat-$(OS).h=0A=
 LDFLAGS=3D-g=0A=
 AR=3Dar=0A=
 =0A=
@@ -10,7 +11,8 @@=0A=
 	  linearize.h bitmap.h ident-list.h=0A=
 =0A=
 LIB_OBJS=3D target.o parse.o tokenize.o pre-process.o symbol.o lib.o =
scope.o \=0A=
-	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o=0A=
+	  expression.o show-parse.o evaluate.o expand.o inline.o linearize.o \=0A=
+	  compat-$(OS).o=0A=
 =0A=
 LIB_FILE=3D sparse.a=0A=
 LIBS=3D$(LIB_FILE)=0A=
Index: sparse-bk/compat-cygwin.c=0A=
diff -u /dev/null sparse-bk/compat-cygwin.c:1.1.2.2=0A=
--- /dev/null	Wed Sep 22 16:05:25 2004=0A=
+++ sparse-bk/compat-cygwin.c	Wed Sep 22 16:01:58 2004=0A=
@@ -0,0 +1,43 @@=0A=
+=0A=
+/*=0A=
+ * Cygwin Compatibility functions=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+=0A=
+#include <sys/mman.h>=0A=
+#include <stdlib.h>=0A=
+#include <string.h>=0A=
+=0A=
+#include "compat-cygwin.h"=0A=
+=0A=
+void *blob_alloc (size_t size)=0A=
+{=0A=
+	void *ptr;=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	ptr =3D mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | =
MAP_ANONYMOUS, -1, 0);=0A=
+	if (ptr =3D=3D MAP_FAILED)=0A=
+		ptr =3D NULL;=0A=
+	else=0A=
+		memset(ptr, 0, size);=0A=
+	return ptr;=0A=
+}=0A=
+=0A=
+void blob_free (void *addr, size_t size)=0A=
+{=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	munmap(addr, size);=0A=
+}=0A=
+=0A=
+long double strtold(const char *nptr, char **endptr) =0A=
+{=0A=
+	return strtod(nptr, endptr);=0A=
+}=0A=
+=0A=
+int identical_files(struct stream* s, struct stat *st, const char * =
name) =0A=
+{=0A=
+	return (s->dev =3D=3D st->st_dev && s->ino =3D=3D st->st_ino);=0A=
+}=0A=
Index: sparse-bk/compat-cygwin.h=0A=
diff -u /dev/null sparse-bk/compat-cygwin.h:1.1.2.2=0A=
--- /dev/null	Wed Sep 22 16:05:25 2004=0A=
+++ sparse-bk/compat-cygwin.h	Wed Sep 22 16:01:58 2004=0A=
@@ -0,0 +1,23 @@=0A=
+#ifndef  COMPAT_CYGWIN_H=0A=
+#define  COMAPT_CYGWIN_H=0A=
+=0A=
+#include <stddef.h>=0A=
+#include <sys/stat.h>=0A=
+=0A=
+#include "token.h"=0A=
+=0A=
+=0A=
+/*=0A=
+ * Cygwin Compatibility declarations and defines =0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+void *blob_alloc (size_t size);=0A=
+void blob_free (void *addr, size_t size);=0A=
+long double strtold(const char *nptr, char **endptr);=0A=
+int identical_files(struct stream* s, struct stat *st, const char * =
name);=0A=
+=0A=
+#endif // COMPAT_CYGWIN_H=0A=
Index: sparse-bk/compat-linux.c=0A=
diff -u /dev/null sparse-bk/compat-linux.c:1.1.2.2=0A=
--- /dev/null	Wed Sep 22 16:05:25 2004=0A=
+++ sparse-bk/compat-linux.c	Wed Sep 22 16:01:58 2004=0A=
@@ -0,0 +1,32 @@=0A=
+/*=0A=
+ * Linux Compatibility functions=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+#include <sys/mman.h>=0A=
+=0A=
+#include "compat-linux.h"=0A=
+=0A=
+void *blob_alloc (size_t size)=0A=
+{=0A=
+	void *ptr;=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	ptr =3D mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | =
MAP_ANONYMOUS, -1, 0);=0A=
+	if (ptr =3D=3D MAP_FAILED)=0A=
+		ptr =3D NULL;=0A=
+	return ptr;=0A=
+}=0A=
+=0A=
+void blob_free (void *addr, size_t size)=0A=
+{=0A=
+	size =3D (size + 4095) & ~4095;=0A=
+	munmap(addr, size);=0A=
+}=0A=
+=0A=
+int identical_files(struct stream* s, struct stat *st, const char * =
name) =0A=
+{=0A=
+	return (s->dev =3D=3D st->st_dev && s->ino =3D=3D st->st_ino);=0A=
+}=0A=
Index: sparse-bk/compat-linux.h=0A=
diff -u /dev/null sparse-bk/compat-linux.h:1.1.2.3=0A=
--- /dev/null	Wed Sep 22 16:05:25 2004=0A=
+++ sparse-bk/compat-linux.h	Wed Sep 22 16:01:58 2004=0A=
@@ -0,0 +1,22 @@=0A=
+#ifndef  COMPAT_LINUX_H=0A=
+#define  COMAPT_LINUX_H=0A=
+=0A=
+=0A=
+/*=0A=
+ * Linux Compatibility declarations and defines=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+#include <stddef.h>=0A=
+#include <sys/stat.h>=0A=
+#include "token.h"=0A=
+=0A=
+=0A=
+void *blob_alloc (size_t size);=0A=
+void blob_free (void *addr, size_t size);=0A=
+int identical_files(struct stream* s, struct stat *st, const char * =
name);=0A=
+=0A=
+#endif // COMPAT_LINUX_H=0A=
Index: sparse-bk/compat-mingw.c=0A=
diff -u /dev/null sparse-bk/compat-mingw.c:1.1.2.2=0A=
--- /dev/null	Wed Sep 22 16:05:25 2004=0A=
+++ sparse-bk/compat-mingw.c	Wed Sep 22 16:01:58 2004=0A=
@@ -0,0 +1,61 @@=0A=
+=0A=
+/*=0A=
+ * Mingw Compatibility functions=0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+=0A=
+#include <stdarg.h>=0A=
+#include <windef.h>=0A=
+#include <winbase.h>=0A=
+#include <stdlib.h>=0A=
+#include <string.h>=0A=
+=0A=
+#include "compat-mingw.h"=0A=
+=0A=
+void *blob_alloc (size_t size)=0A=
+{=0A=
+	void *ptr;=0A=
+	ptr =3D malloc(size);=0A=
+	if (ptr !=3D NULL)=0A=
+		memset(ptr, 0, size);=0A=
+	return ptr;=0A=
+}=0A=
+=0A=
+void blob_free (void *addr, size_t size)=0A=
+{=0A=
+	free(addr);=0A=
+}=0A=
+=0A=
+long double strtold(const char *nptr, char **endptr) =0A=
+{=0A=
+	return strtod(nptr, endptr);=0A=
+}=0A=
+=0A=
+int identical_files(struct stream* s, struct stat *st, const char * =
name) =0A=
+{=0A=
+	HANDLE file1 =
=3DCreateFile(s->name,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FIL=
E_ATTRIBUTE_NORMAL,NULL);=0A=
+	if(file1=3D=3DINVALID_HANDLE_VALUE) =0A=
+		return 0;=0A=
+	HANDLE =
file2=3DCreateFile(name,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,F=
ILE_ATTRIBUTE_NORMAL,NULL);=0A=
+	if(file2=3D=3DINVALID_HANDLE_VALUE) {=0A=
+		CloseHandle(file1);=0A=
+		return 0;=0A=
+	}=0A=
+	BY_HANDLE_FILE_INFORMATION info1;=0A=
+	BY_HANDLE_FILE_INFORMATION info2;=0A=
+	int same=3D0;=0A=
+	if(GetFileInformationByHandle(file1,&info1) && =
GetFileInformationByHandle(file2,&info2)){=0A=
+		if(info1.nFileIndexLow=3D=3Dinfo2.nFileIndexLow &&=0A=
+		   info1.nFileIndexHigh=3D=3Dinfo2.nFileIndexHigh &&=0A=
+		   info1.dwVolumeSerialNumber=3D=3Dinfo2.dwVolumeSerialNumber) =0A=
+			same=3D1;=0A=
+	}=0A=
+	CloseHandle(file1);=0A=
+	CloseHandle(file2);=0A=
+	return same;=0A=
+}=0A=
+=0A=
Index: sparse-bk/compat-mingw.h=0A=
diff -u /dev/null sparse-bk/compat-mingw.h:1.1.2.2=0A=
--- /dev/null	Wed Sep 22 16:05:25 2004=0A=
+++ sparse-bk/compat-mingw.h	Wed Sep 22 16:01:58 2004=0A=
@@ -0,0 +1,23 @@=0A=
+#ifndef  COMPAT_MINGW_H=0A=
+#define  COMAPT_MINGW_H=0A=
+=0A=
+#include <stddef.h>=0A=
+#include <sys/stat.h>=0A=
+=0A=
+#include "token.h"=0A=
+=0A=
+=0A=
+/*=0A=
+ * Mingw Compatibility declarations and defines =0A=
+ *=0A=
+ *=0A=
+ *  Licensed under the Open Software License version 1.1=0A=
+ */=0A=
+=0A=
+=0A=
+void *blob_alloc (size_t size);=0A=
+void blob_free (void *addr, size_t size);=0A=
+long double strtold(const char *nptr, char **endptr);=0A=
+int identical_files(struct stream* s, struct stat *st, const char * =
name);=0A=
+=0A=
+#endif // COMPAT_MINGW_H=0A=
Index: sparse-bk/lib.c=0A=
diff -u sparse-bk/lib.c:1.2 sparse-bk/lib.c:1.2.2.1=0A=
--- sparse-bk/lib.c:1.2	Wed Sep 22 10:35:41 2004=0A=
+++ sparse-bk/lib.c	Wed Sep 22 13:17:30 2004=0A=
@@ -14,7 +14,6 @@=0A=
 #include <stdlib.h>=0A=
 #include <string.h>=0A=
 =0A=
-#include <sys/mman.h>=0A=
 #include <sys/types.h>=0A=
 #include <sys/stat.h>=0A=
 =0A=
@@ -83,22 +82,6 @@=0A=
 };=0A=
 =0A=
 #define CHUNK 32768=0A=
-=0A=
-static void *blob_alloc (size_t size)=0A=
-{=0A=
-	void *ptr;=0A=
-	size =3D (size + 4095) & ~4095;=0A=
-	ptr =3D mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | =
MAP_ANONYMOUS, -1, 0);=0A=
-	if (ptr =3D=3D MAP_FAILED)=0A=
-		ptr =3D NULL;=0A=
-	return ptr;=0A=
-}=0A=
-=0A=
-static void blob_free (void *addr, size_t size)=0A=
-{=0A=
-	size =3D (size + 4095) & ~4095;=0A=
-	munmap(addr, size);=0A=
-}=0A=
 =0A=
 struct allocator_struct {=0A=
 	const char *name;=0A=
Index: sparse-bk/tokenize.c=0A=
diff -u sparse-bk/tokenize.c:1.1.1.1 sparse-bk/tokenize.c:1.1.1.1.8.2=0A=
--- sparse-bk/tokenize.c:1.1.1.1	Mon Sep 13 16:00:30 2004=0A=
+++ sparse-bk/tokenize.c	Wed Sep 22 16:01:58 2004=0A=
@@ -170,7 +170,7 @@=0A=
 =0A=
 		for (i =3D 0; i < stream; i++) {=0A=
 			struct stream *s =3D input_streams + i;=0A=
-			if (s->dev =3D=3D st.st_dev && s->ino =3D=3D st.st_ino &&=0A=
+			if (identical_files(s,&st,name) &&=0A=
 			    s->constant =3D=3D CONSTANT_FILE_YES &&=0A=
 			    lookup_symbol(s->protect, NS_MACRO))=0A=
 				return -1;=0A=
cvs server: cannot find module `sparse-bk/compat-mingw.o' - ignored=0A=

------=_NextPart_000_000A_01C4A0BF.39B88C10--


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: RE: [PATCH] patch for os related differences
Date: Sat, 25 Sep 2004 19:15:23 +0000
Message-ID: <Pine.LNX.4.58.0409251209200.2317 () ppc970 ! osdl ! org>
--------------------


On Wed, 22 Sep 2004, Mitesh shah wrote:
> 
> Ok, I have moved the file inode comparison in an os dependent function
> called identical_files(). Currently, for mingw, I am using windows API
> to identify the files uniquely, which is somewhat heavy because I have
> to open both the files simultaneously to compare the indices, will
> replace it to a lighter version later if I find out how to do that.

Ok, I redid this somewhat, but tried to apply your cygwin/mingw code to my 
slightly changed scheme of things.

The main change is really that I just used one single compat.h header to 
avoid duplication. Yeah, having a separate header for separate systems 
might be nice some day, but at least for now it wasn't really required, 
so..

Can you verify that cygwin/mingw actually work after my butchery, and 
maybe send fixup patches?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Mitesh shah" <mshah () teja ! com>
To: linux-sparse
Subject: RE: [PATCH] patch for os related differences
Date: Sun, 26 Sep 2004 17:20:18 +0000
Message-ID: <ODEAJDBCBIHDNKCDBNFKMECHDEAA.mshah () teja ! com>
--------------------


>
> Ok, I redid this somewhat, but tried to apply your  cygwin/mingw code
to my  slightly changed scheme of things.
>
> The main change is really that I just used one single  compat.h header
to  avoid duplication. Yeah, having a separate header for  separate
systems  might be nice some day, but at least for now it wasn't really
required,  so..
>
> Can you verify that cygwin/mingw actually work after my butchery, and
> maybe send fixup patches?
>
> 		Linus
>

mingw works fine, cygwin needs the sys/stat.h for stat structure
definition.

Thanks,

-Mitesh

-----------------------------------------
diff -u -w sparse-bk-orig/compat-cygwin.c sparse-bk/compat-cygwin.c
--- sparse-bk-orig/compat-cygwin.c      2004-09-25
16:00:55.000000000 -0700
+++ sparse-bk/compat-cygwin.c   2004-09-26 10:17:56.919577600 -0700
@@ -10,6 +10,7 @@
 #include <sys/mman.h>
 #include <stdlib.h>
 #include <string.h>
+#include <sys/stat.h>

 #include "lib.h"
 #include "token.h"


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] rename "warn" to "warning" ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] rename "warn" to "warning"
Date: Wed, 08 Sep 2004 18:20:14 +0000
Message-ID: <20040908182014.GA13546 () 64m ! dyndns ! org>
--------------------
This is another invasive patch. It rename all the "warn" to "warning".
The reason is that "warn" is taken in glibc. /usr/include/err.h

/* Print "program: ", FORMAT, ": ", the standard error string for errno,
   and a newline, on stderr.  */
extern void warn (__const char *__format, ...)
     __THROW __attribute__ ((__format__ (__printf__, 1, 2)));

If you try to load sparse as a dynamic library, warn will link to
the glibc one. Sparse give a segment fault on warning.

I know I have to try it.

Chris 

Index: sparse-be/compile-i386.c
===================================================================
--- sparse-be.orig/compile-i386.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/compile-i386.c	2004-09-08 14:09:43.000000000 -0400
@@ -1371,11 +1371,11 @@
 			opname = "mul";
 		break;
 	case SPECIAL_LOGICAL_AND:
-		warn(expr->pos, "bogus bitwise and for logical op (should use '2*setne + and' or something)");
+		warning(expr->pos, "bogus bitwise and for logical op (should use '2*setne + and' or something)");
 		opname = "and";
 		break;
 	case SPECIAL_LOGICAL_OR:
-		warn(expr->pos, "bogus bitwise or for logical op (should use 'or + setne' or something)");
+		warning(expr->pos, "bogus bitwise or for logical op (should use 'or + setne' or something)");
 		opname = "or";
 		break;
 	default:
@@ -2061,7 +2061,7 @@
 	char s[64];
 
 	if (!expr->ctype) {
-		warn(expr->pos, "\tcall with no type!");
+		warning(expr->pos, "\tcall with no type!");
 		return NULL;
 	}
 
@@ -2355,7 +2355,7 @@
 	case EXPR_DEREF:
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warn(expr->pos, "invalid expression after evaluation");
+		warning(expr->pos, "invalid expression after evaluation");
 		return NULL;
 	case EXPR_CAST:
 		return emit_cast_expr(expr);
@@ -2380,19 +2380,19 @@
 	// None of these should exist as direct expressions: they are only
 	// valid as sub-expressions of initializers.
 	case EXPR_POS:
-		warn(expr->pos, "unable to show plain initializer position expression");
+		warning(expr->pos, "unable to show plain initializer position expression");
 		return NULL;
 	case EXPR_IDENTIFIER:
-		warn(expr->pos, "unable to show identifier expression");
+		warning(expr->pos, "unable to show identifier expression");
 		return NULL;
 	case EXPR_INDEX:
-		warn(expr->pos, "unable to show index expression");
+		warning(expr->pos, "unable to show index expression");
 		return NULL;
 	case EXPR_TYPE:
-		warn(expr->pos, "unable to show type expression");
+		warning(expr->pos, "unable to show type expression");
 		return NULL;
 	case EXPR_FVALUE:
-		warn(expr->pos, "floating point support is not implemented");
+		warning(expr->pos, "floating point support is not implemented");
 		return NULL;
 	}
 	return NULL;
Index: sparse-be/evaluate.c
===================================================================
--- sparse-be.orig/evaluate.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/evaluate.c	2004-09-08 14:09:43.000000000 -0400
@@ -40,17 +40,17 @@
 			expr->ctype = &int_ctype;
 			return &int_ctype;
 		}
-		warn(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
+		warning(expr->pos, "undefined identifier '%s'", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
 	examine_symbol_type(sym);
 	if ((sym->ctype.context ^ current_context) & (sym->ctype.contextmask & current_contextmask))
-		warn(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
+		warning(expr->pos, "Using symbol '%s' in wrong context", show_ident(expr->symbol_name));
 
 	base_type = sym->ctype.base_type;
 	if (!base_type) {
-		warn(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
+		warning(expr->pos, "identifier '%s' has no type", show_ident(expr->symbol_name));
 		return NULL;
 	}
 
@@ -215,7 +215,7 @@
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warn(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
+	warning(expr->pos, "incompatible types for operation (%s)", show_special(expr->op));
 	switch (expr->type) {
 	case EXPR_BINOP:
 	case EXPR_COMPARE:
@@ -387,7 +387,7 @@
 
 	ctype = degenerate(ptr);
 	if (!ctype->ctype.base_type) {
-		warn(expr->pos, "missing type information");
+		warning(expr->pos, "missing type information");
 		return NULL;
 	}
 
@@ -582,7 +582,7 @@
 	if (expr->type != EXPR_VALUE || expr->value)
 		return 0;
 	if (!is_ptr_type(expr->ctype))
-		warn(expr->pos, "Using plain integer as NULL pointer");
+		warning(expr->pos, "Using plain integer as NULL pointer");
 	return 1;
 }
 
@@ -623,7 +623,7 @@
 	if (typediff) {
 		ctype = common_ptr_type(l, r);
 		if (!ctype) {
-			warn(expr->pos, "subtraction of different types can't work (%s)", typediff);
+			warning(expr->pos, "subtraction of different types can't work (%s)", typediff);
 			return NULL;
 		}
 	}
@@ -633,7 +633,7 @@
 	if (ctype->type == SYM_NODE)
 		ctype = ctype->ctype.base_type;
 	if (ctype->type != SYM_PTR && ctype->type != SYM_ARRAY) {
-		warn(expr->pos, "subtraction of functions? Share your drugs");
+		warning(expr->pos, "subtraction of functions? Share your drugs");
 		return NULL;
 	}
 	ctype = ctype->ctype.base_type;
@@ -682,12 +682,12 @@
 		return NULL;
 
 	if (expr->type == EXPR_ASSIGNMENT)
-		warn(expr->pos, "assignment expression in conditional");
+		warning(expr->pos, "assignment expression in conditional");
 
 	ctype = evaluate_expression(expr);
 	if (ctype) {
 		if (is_safe_type(ctype))
-			warn(expr->pos, "testing a 'safe expression'");
+			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
 			struct expression *comp;
 			/*
@@ -801,7 +801,7 @@
 		goto OK;
 
 	if (is_safe_type(ltype) || is_safe_type(rtype))
-		warn(expr->pos, "testing a 'safe expression'");
+		warning(expr->pos, "testing a 'safe expression'");
 
 	/* Pointer types? */
 	if (is_ptr_type(ltype) || is_ptr_type(rtype)) {
@@ -892,7 +892,7 @@
 	ctype = compatible_restricted_binop('?', &expr->left, &expr->right);
 	if (ctype)
 		goto out;
-	warn(expr->pos, "incompatible types in conditional expression (%s)", typediff);
+	warning(expr->pos, "incompatible types in conditional expression (%s)", typediff);
 	return NULL;
 
 out:
@@ -963,7 +963,7 @@
 		}
 	}
 
-	warn(expr->pos, "incorrect type in %s (%s)", where, typediff);
+	warning(expr->pos, "incorrect type in %s (%s)", where, typediff);
 	info(expr->pos, "   expected %s", show_typename(target));
 	info(expr->pos, "   got %s", show_typename(source));
 	*rp = cast_to(*rp, target);
@@ -1057,7 +1057,7 @@
 static void evaluate_assign_to(struct expression *left, struct symbol *type)
 {
 	if (type->ctype.modifiers & MOD_CONST)
-		warn(left->pos, "assignment to const expression");
+		warning(left->pos, "assignment to const expression");
 	if (type->type == SYM_NODE)
 		type->ctype.modifiers |= MOD_ASSIGNED;
 }
@@ -1069,7 +1069,7 @@
 	struct symbol *ltype, *rtype;
 
 	if (!lvalue_expression(left)) {
-		warn(expr->pos, "not an lvalue");
+		warning(expr->pos, "not an lvalue");
 		return NULL;
 	}
 
@@ -1154,7 +1154,7 @@
 	access_symbol(sym);
 	sym->ctype.modifiers |= MOD_ADDRESSABLE;
 	if (sym->ctype.modifiers & MOD_REGISTER) {
-		warn(expr->pos, "taking address of 'register' variable '%s'", show_ident(sym->ident));
+		warning(expr->pos, "taking address of 'register' variable '%s'", show_ident(sym->ident));
 		sym->ctype.modifiers &= ~MOD_REGISTER;
 	}
 	if (sym->type == SYM_NODE) {
@@ -1239,7 +1239,7 @@
 		}
 	case SYM_FN:
 		if (expr->op != '*' || expr->type != EXPR_PREOP) {
-			warn(expr->pos, "strange non-value function or array");
+			warning(expr->pos, "strange non-value function or array");
 			return NULL;
 		}
 		*expr = *expr->unop;
@@ -1257,7 +1257,7 @@
 	struct symbol *ctype;
 
 	if (op->op != '*' || op->type != EXPR_PREOP) {
-		warn(expr->pos, "not addressable");
+		warning(expr->pos, "not addressable");
 		return NULL;
 	}
 	ctype = op->ctype;
@@ -1296,7 +1296,7 @@
 
 	switch (ctype->type) {
 	default:
-		warn(expr->pos, "cannot derefence this type");
+		warning(expr->pos, "cannot derefence this type");
 		return NULL;
 	case SYM_PTR:
 		merge_type(node, ctype);
@@ -1318,7 +1318,7 @@
 
 	case SYM_ARRAY:
 		if (!lvalue_expression(op)) {
-			warn(op->pos, "non-lvalue array??");
+			warning(op->pos, "non-lvalue array??");
 			return NULL;
 		}
 
@@ -1350,11 +1350,11 @@
 	struct symbol *ctype = op->ctype;
 
 	if (!lvalue_expression(expr->unop)) {
-		warn(expr->pos, "need lvalue expression for ++/--");
+		warning(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
 	if (is_restricted_type(ctype) && restricted_unop(expr->op, ctype)) {
-		warn(expr->pos, "bad operation on restricted");
+		warning(expr->pos, "bad operation on restricted");
 		return NULL;
 	}
 
@@ -1415,7 +1415,7 @@
 
 	case '!':
 		if (is_safe_type(ctype))
-			warn(expr->pos, "testing a 'safe expression'");
+			warning(expr->pos, "testing a 'safe expression'");
 		if (is_float_type(ctype)) {
 			struct expression *arg = expr->unop;
 			expr->type = EXPR_BINOP;
@@ -1510,7 +1510,7 @@
 	if (!evaluate_expression(deref))
 		return NULL;
 	if (!ident) {
-		warn(expr->pos, "bad member name");
+		warning(expr->pos, "bad member name");
 		return NULL;
 	}
 
@@ -1523,7 +1523,7 @@
 		mod |= ctype->ctype.modifiers;
 	}
 	if (!ctype || (ctype->type != SYM_STRUCT && ctype->type != SYM_UNION)) {
-		warn(expr->pos, "expected structure or union");
+		warning(expr->pos, "expected structure or union");
 		return NULL;
 	}
 	offset = 0;
@@ -1536,7 +1536,7 @@
 			name = ctype->ident->name;
 			namelen = ctype->ident->len;
 		}
-		warn(expr->pos, "no member '%s' in %s %.*s",
+		warning(expr->pos, "no member '%s' in %s %.*s",
 			show_ident(ident), type, namelen, name);
 		return NULL;
 	}
@@ -1641,10 +1641,10 @@
 				size = bits_in_int;
 		}
 		if (is_bitfield_type(what->ctype))
-			warn(expr->pos, "sizeof applied to bitfield type");
+			warning(expr->pos, "sizeof applied to bitfield type");
 	}
 	if (size & 7)
-		warn(expr->pos, "cannot size expression");
+		warning(expr->pos, "cannot size expression");
 	expr->type = EXPR_VALUE;
 	expr->value = size >> 3;
 	expr->ctype = size_t_ctype;
@@ -1661,7 +1661,7 @@
 			return NULL;
 	}
 	if (is_bitfield_type(type))
-		warn(expr->pos, "alignof applied to bitfield type");
+		warning(expr->pos, "alignof applied to bitfield type");
 	examine_symbol_type(type);
 	expr->type = EXPR_VALUE;
 	expr->value = type->ctype.alignment;
@@ -1693,7 +1693,7 @@
 			return 0;
 
 		if (context_clash(f, ctype))
-			warn(expr->pos, "argument %d used in wrong context", i);
+			warning(expr->pos, "argument %d used in wrong context", i);
 
 		ctype = degenerate(expr);
 
@@ -1749,7 +1749,7 @@
 static int evaluate_scalar_initializer(struct symbol *ctype, struct expression *expr, unsigned long offset)
 {
 	if (offset || expression_list_size(expr->expr_list) != 1) {
-		warn(expr->pos, "unexpected compound initializer");
+		warning(expr->pos, "unexpected compound initializer");
 		return 0;
 	}
 	return evaluate_array_initializer(ctype, expr, 0);
@@ -1772,7 +1772,7 @@
 			RESET_PTR_LIST(sym);
 			for (;;) {
 				if (!sym) {
-					warn(entry->pos, "unknown named initializer '%s'", show_ident(ident));
+					warning(entry->pos, "unknown named initializer '%s'", show_ident(ident));
 					return 0;
 				}
 				if (sym->ident == ident)
@@ -1783,7 +1783,7 @@
 		}
 
 		if (!sym) {
-			warn(expr->pos, "too many initializers for struct/union");
+			warning(expr->pos, "too many initializers for struct/union");
 			return 0;
 		}
 
@@ -1954,10 +1954,10 @@
 			goto out;
 	}
 	if (type == SYM_ARRAY || type == SYM_UNION || type == SYM_STRUCT)
-		warn(expr->pos, "cast to non-scalar");
+		warning(expr->pos, "cast to non-scalar");
 
 	if (!target->ctype) {
-		warn(expr->pos, "cast from unknown type");
+		warning(expr->pos, "cast from unknown type");
 		goto out;
 	}
 
@@ -1965,10 +1965,10 @@
 	if (type == SYM_NODE)
 		type = target->ctype->ctype.base_type->type;
 	if (type == SYM_ARRAY || type == SYM_UNION || type == SYM_STRUCT)
-		warn(expr->pos, "cast from non-scalar");
+		warning(expr->pos, "cast from non-scalar");
 
 	if (!get_as(ctype) && get_as(target->ctype) > 0)
-		warn(expr->pos, "cast removes address space of expression");
+		warning(expr->pos, "cast removes address space of expression");
 
 	if (!(ctype->ctype.modifiers & MOD_FORCE)) {
 		struct symbol *t1 = ctype, *t2 = target->ctype;
@@ -1978,9 +1978,9 @@
 			t2 = t2->ctype.base_type;
 		if (t1 != t2) {
 			if (t1->type == SYM_RESTRICT)
-				warn(expr->pos, "cast to restricted type");
+				warning(expr->pos, "cast to restricted type");
 			if (t2->type == SYM_RESTRICT)
-				warn(expr->pos, "cast from restricted type");
+				warning(expr->pos, "cast from restricted type");
 		}
 	}
 
@@ -2052,15 +2052,15 @@
 	if (!evaluate_arguments(sym, ctype, arglist))
 		return NULL;
 	if (ctype->type != SYM_FN) {
-		warn(expr->pos, "not a function %s", show_ident(sym->ident));
+		warning(expr->pos, "not a function %s", show_ident(sym->ident));
 		return NULL;
 	}
 	args = expression_list_size(expr->args);
 	fnargs = symbol_list_size(ctype->arguments);
 	if (args < fnargs)
-		warn(expr->pos, "not enough arguments for function %s", show_ident(sym->ident));
+		warning(expr->pos, "not enough arguments for function %s", show_ident(sym->ident));
 	if (args > fnargs && !ctype->variadic)
-		warn(expr->pos, "too many arguments for function %s", show_ident(sym->ident));
+		warning(expr->pos, "too many arguments for function %s", show_ident(sym->ident));
 	if (sym->type == SYM_NODE) {
 		if (evaluate_symbol_call(expr))
 			return expr->ctype;
@@ -2079,7 +2079,7 @@
 	switch (expr->type) {
 	case EXPR_VALUE:
 	case EXPR_FVALUE:
-		warn(expr->pos, "value expression without a type");
+		warning(expr->pos, "value expression without a type");
 		return NULL;
 	case EXPR_STRING:
 		return evaluate_string(expr);
@@ -2129,7 +2129,7 @@
 	case EXPR_CALL:
 		return evaluate_call(expr);
 	case EXPR_BITFIELD:
-		warn(expr->pos, "bitfield generated by parser");
+		warning(expr->pos, "bitfield generated by parser");
 		return NULL;
 	case EXPR_SELECT:
 	case EXPR_CONDITIONAL:
@@ -2160,10 +2160,10 @@
 	case EXPR_IDENTIFIER:
 	case EXPR_INDEX:
 	case EXPR_POS:
-		warn(expr->pos, "internal front-end error: initializer in expression");
+		warning(expr->pos, "internal front-end error: initializer in expression");
 		return NULL;
 	case EXPR_SLICE:
-		warn(expr->pos, "internal front-end error: SLICE re-evaluated");
+		warning(expr->pos, "internal front-end error: SLICE re-evaluated");
 		return NULL;
 	}
 	return NULL;
@@ -2178,7 +2178,7 @@
 		evaluate_symbol(next);
 		typediff = type_difference(sym, next, 0, 0);
 		if (typediff) {
-			warn(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
+			warning(sym->pos, "symbol '%s' redeclared with different type (originally declared at %s:%d) - %s",
 				show_ident(sym->ident),
 				input_streams[next->pos.stream].name, next->pos.line, typediff);
 			return;
@@ -2244,12 +2244,12 @@
 	fntype = current_fn->ctype.base_type;
 	if (!fntype || fntype == &void_ctype) {
 		if (expr && ctype != &void_ctype)
-			warn(expr->pos, "return expression in %s function", fntype?"void":"typeless");
+			warning(expr->pos, "return expression in %s function", fntype?"void":"typeless");
 		return NULL;
 	}
 
 	if (!expr) {
-		warn(stmt->pos, "return with no return value");
+		warning(stmt->pos, "return with no return value");
 		return NULL;
 	}
 	if (!ctype)
Index: sparse-be/expand.c
===================================================================
--- sparse-be.orig/expand.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/expand.c	2004-09-08 14:09:43.000000000 -0400
@@ -42,7 +42,7 @@
 	 * The preprocessor can cause unknown symbols to be generated
 	 */
 	if (!sym) {
-		warn(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
+		warning(expr->pos, "undefined preprocessor identifier '%s'", show_ident(expr->symbol_name));
 		expr->type = EXPR_VALUE;
 		expr->value = 0;
 		return UNSAFE;
@@ -120,7 +120,7 @@
 static int check_shift_count(struct expression *expr, struct symbol *ctype, unsigned int count)
 {
 	if (count >= ctype->bit_size) {
-		warn(expr->pos, "shift too big for type (%x)", ctype->ctype.modifiers);
+		warning(expr->pos, "shift too big for type (%x)", ctype->ctype.modifiers);
 		count &= ctype->bit_size-1;
 	}
 	return count;
@@ -233,10 +233,10 @@
 	expr->type = EXPR_VALUE;
 	return 1;
 Div:
-	warn(expr->pos, "division by zero");
+	warning(expr->pos, "division by zero");
 	return 0;
 Overflow:
-	warn(expr->pos, "constant integer operation overflow");
+	warning(expr->pos, "constant integer operation overflow");
 	return 0;
 }
 
@@ -315,7 +315,7 @@
 	expr->fvalue = res;
 	return 1;
 Div:
-	warn(expr->pos, "division by zero");
+	warning(expr->pos, "division by zero");
 	return 0;
 }
 
@@ -511,7 +511,7 @@
 	 * test for me to get the type evaluation right..
 	 */
 	if (expr->ctype->ctype.modifiers & MOD_NODEREF)
-		warn(unop->pos, "dereference of noderef expression");
+		warning(unop->pos, "dereference of noderef expression");
 
 	if (unop->type == EXPR_SYMBOL) {
 		struct symbol *sym = unop->symbol;
@@ -565,7 +565,7 @@
 	return 1;
 
 Overflow:
-	warn(expr->pos, "constant integer operation overflow");
+	warning(expr->pos, "constant integer operation overflow");
 	return 0;
 }
 
@@ -739,7 +739,7 @@
 		return expand_call(expr);
 
 	case EXPR_DEREF:
-		warn(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
+		warning(expr->pos, "we should not have an EXPR_DEREF left at expansion time");
 		return UNSAFE;
 
 	case EXPR_BITFIELD:
@@ -772,7 +772,7 @@
 
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warn(expr->pos, "internal front-end error: sizeof in expansion?");
+		warning(expr->pos, "internal front-end error: sizeof in expansion?");
 		return UNSAFE;
 	}
 	return SIDE_EFFECTS;
@@ -783,7 +783,7 @@
 	if (expr) {
 		expand_expression(expr);
 		if (expr->type != EXPR_VALUE)
-			warn(expr->pos, "Expected constant expression in %s", where);
+			warning(expr->pos, "Expected constant expression in %s", where);
 	}
 }
 
@@ -919,12 +919,12 @@
 		return 0;
 	ctype = evaluate_expression(expr);
 	if (!ctype) {
-		warn(expr->pos, "bad constant expression type");
+		warning(expr->pos, "bad constant expression type");
 		return 0;
 	}
 	expand_expression(expr);
 	if (expr->type != EXPR_VALUE) {
-		warn(expr->pos, "bad constant expression");
+		warning(expr->pos, "bad constant expression");
 		return 0;
 	}
 
Index: sparse-be/expression.c
===================================================================
--- sparse-be.orig/expression.c	2004-08-22 20:11:14.000000000 -0400
+++ sparse-be/expression.c	2004-09-08 14:09:43.000000000 -0400
@@ -75,7 +75,7 @@
 		} while (token_type(next) == TOKEN_STRING);
 
 		if (totlen > MAX_STRING) {
-			warn(token->pos, "trying to concatenate %d-character string (%d bytes max)", totlen, MAX_STRING);
+			warning(token->pos, "trying to concatenate %d-character string (%d bytes max)", totlen, MAX_STRING);
 			totlen = MAX_STRING;
 		}
 
@@ -179,18 +179,18 @@
 	if (!(value & (1ULL << bits)))
 		goto got_it;
 	if (!try_unsigned)
-		warn(expr->pos, "decimal constant %s is too big for long long",
+		warning(expr->pos, "decimal constant %s is too big for long long",
 			show_token(token));
 	modifiers |= MOD_UNSIGNED;
 got_it:
 	if (do_warn)
-		warn(expr->pos, "constant %s is so big it is%s%s%s",
+		warning(expr->pos, "constant %s is so big it is%s%s%s",
 			show_token(token),
 			(modifiers & MOD_UNSIGNED) ? " unsigned":"",
 			(modifiers & MOD_LONG) ? " long":"",
 			(modifiers & MOD_LONGLONG) ? " long":"");
 	if (do_warn & 2)
-		warn(expr->pos,
+		warning(expr->pos,
 			"decimal constant %s is between LONG_MAX and ULONG_MAX."
 			" For C99 that means long long, C90 compilers are very "
 			"likely to produce unsigned long (and a warning) here",
@@ -258,7 +258,7 @@
 		 *	if (typeof(a) == int) ..
 		 */
 		if (sym && sym->namespace == NS_TYPEDEF) {
-			warn(token->pos, "typename in expression");
+			warning(token->pos, "typename in expression");
 			sym = NULL;
 		}
 		expr->symbol_name = token->ident;
@@ -359,7 +359,7 @@
 			deref->deref = expr;
 			token = token->next;
 			if (token_type(token) != TOKEN_IDENT) {
-				warn(token->pos, "Expected member name");
+				warning(token->pos, "Expected member name");
 				break;
 			}
 			deref->member = token->ident;
@@ -435,7 +435,7 @@
 
 			next = cast_expression(token->next, &unop);
 			if (!unop) {
-				warn(token->pos, "Syntax error in unary expression");
+				warning(token->pos, "Syntax error in unary expression");
 				return next;
 			}
 			unary = alloc_expression(token->pos, EXPR_PREOP);
@@ -522,7 +522,7 @@
 			top = alloc_expression(next->pos, type);	\
 			next = inner(next->next, &right);		\
 			if (!right) {					\
-				warn(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
+				warning(next->pos, "No right hand side of '%s'-expression", show_special(op));	\
 				break;					\
 			}						\
 			top->op = op;					\
Index: sparse-be/inline.c
===================================================================
--- sparse-be.orig/inline.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/inline.c	2004-09-08 14:09:44.000000000 -0400
@@ -37,7 +37,7 @@
 	if (sym->ctype.modifiers & (MOD_STATIC | MOD_EXTERN | MOD_TOPLEVEL | MOD_INLINE))
 		return sym;
 	if (!sym->replace) {
-		warn(pos, "unreplaced symbol '%s'", show_ident(sym->ident));
+		warning(pos, "unreplaced symbol '%s'", show_ident(sym->ident));
 		return sym;
 	}
 	return sym->replace;
@@ -220,7 +220,7 @@
 	}
 
 	default:
-		warn(expr->pos, "trying to copy expression type %d", expr->type);
+		warning(expr->pos, "trying to copy expression type %d", expr->type);
 	}
 	return expr;
 }
@@ -235,7 +235,7 @@
 {
 	struct symbol *r = sym->replace;
 	if (!r) {
-		warn(sym->pos, "symbol '%s' not replaced?", show_ident(sym->ident));
+		warning(sym->pos, "symbol '%s' not replaced?", show_ident(sym->ident));
 		return;
 	}
 	r->replace = NULL;
@@ -351,7 +351,7 @@
 		break;
 	}
 	default:
-		warn(stmt->pos, "trying to copy statement type %d", stmt->type);
+		warning(stmt->pos, "trying to copy statement type %d", stmt->type);
 		break;
 	}
 	return stmt;
@@ -419,7 +419,7 @@
 	struct expression *arg;
 
 	if (!fn->inline_stmt) {
-		warn(fn->pos, "marked inline, but without a definition");
+		warning(fn->pos, "marked inline, but without a definition");
 		return 0;
 	}
 	if (fn->expanding)
Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/lib.c	2004-09-08 14:09:44.000000000 -0400
@@ -40,8 +40,8 @@
 		static struct token bad_token;
 		if (token != &bad_token) {
 			bad_token.next = token;
-			warn(token->pos, "Expected %s %s", show_special(op), where);
-			warn(token->pos, "got %s", show_token(token));
+			warning(token->pos, "Expected %s %s", show_special(op), where);
+			warning(token->pos, "got %s", show_token(token));
 		}
 		if (op == ';')
 			return skip_to(token, op);
@@ -496,7 +496,7 @@
 	va_end(args);
 }
 
-void warn(struct position pos, const char * fmt, ...)
+void warning(struct position pos, const char * fmt, ...)
 {
 	static int warnings = 0;
 	va_list args;
Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/lib.h	2004-09-08 14:09:44.000000000 -0400
@@ -43,7 +43,7 @@
 struct token *skip_to(struct token *, int);
 struct token *expect(struct token *, int, const char *);
 extern void info(struct position, const char *, ...);
-extern void warn(struct position, const char *, ...);
+extern void warning(struct position, const char *, ...);
 extern void error(struct position, const char *, ...);
 
 #define __DECLARE_ALLOCATOR(type, x)		\
Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-09-08 14:09:08.000000000 -0400
+++ sparse-be/linearize.c	2004-09-08 14:09:44.000000000 -0400
@@ -272,7 +272,7 @@
 static void bind_label(struct symbol *label, struct basic_block *bb, struct position pos)
 {
 	if (label->bb_target)
-		warn(pos, "label '%s' already bound", show_ident(label->ident));
+		warning(pos, "label '%s' already bound", show_ident(label->ident));
 	label->bb_target = bb;
 }
 
@@ -370,7 +370,7 @@
 		return linearize_expression(ep, expr->unop);
 	if (expr->type == EXPR_BITFIELD)
 		return linearize_expression(ep, expr->address);
-	warn(expr->pos, "generating address of non-lvalue");
+	warning(expr->pos, "generating address of non-lvalue");
 	return VOID;
 }
 
@@ -452,7 +452,7 @@
 		return add_binary_op(ep, expr, OP_AND, new, mask);
 	}
 
-	warn(expr->pos, "loading unknown expression");
+	warning(expr->pos, "loading unknown expression");
 	return new;		
 }
 
@@ -570,7 +570,7 @@
 	pseudo_t retval;
 
 	if (!expr->ctype) {
-		warn(expr->pos, "call with no type!");
+		warning(expr->pos, "call with no type!");
 		return VOID;
 	}
 
@@ -829,7 +829,7 @@
 		return linearize_slice(ep, expr);
 
 	default: 
-		warn(expr->pos, "unknown expression (%d %d)", expr->type, expr->op);
+		warning(expr->pos, "unknown expression (%d %d)", expr->type, expr->op);
 		return VOID;
 	}
 	return VOID;
Index: sparse-be/obfuscate.c
===================================================================
--- sparse-be.orig/obfuscate.c	2004-09-05 22:59:28.000000000 -0400
+++ sparse-be/obfuscate.c	2004-09-08 14:09:44.000000000 -0400
@@ -29,11 +29,11 @@
 	const char *name = show_ident(sym->ident);
 
 	if (size <= 0) {
-		warn(sym->pos, "emitting insized symbol");
+		warning(sym->pos, "emitting insized symbol");
 		size = 8;
 	}
 	if (size & 7)
-		warn(sym->pos, "emitting symbol of size %d bits\n", size);
+		warning(sym->pos, "emitting symbol of size %d bits\n", size);
 	size = (size+7) >> 3;
 	if (alignment < 1)
 		alignment = 1;
@@ -67,7 +67,7 @@
 
 	evaluate_symbol(sym);
 	if (sym->type != SYM_NODE) {
-		warn(sym->pos, "I really want to emit nodes, not pure types!");
+		warning(sym->pos, "I really want to emit nodes, not pure types!");
 		return;
 	}
 
@@ -87,7 +87,7 @@
 		emit_fn(sym);
 		return;
 	default:
-		warn(sym->pos, "what kind of strange node do you want me to emit again?");
+		warning(sym->pos, "what kind of strange node do you want me to emit again?");
 		return;
 	}
 }
Index: sparse-be/parse.c
===================================================================
--- sparse-be.orig/parse.c	2004-09-08 13:09:30.000000000 -0400
+++ sparse-be/parse.c	2004-09-08 14:09:44.000000000 -0400
@@ -134,7 +134,7 @@
 
 	// private struct/union/enum type
 	if (!match_op(token, '{')) {
-		warn(token->pos, "expected declaration");
+		warning(token->pos, "expected declaration");
 		ctype->base_type = &bad_type;
 		return token;
 	}
@@ -193,7 +193,7 @@
 	struct symbol *sym;
 
 	if (!match_op(token, '(')) {
-		warn(token->pos, "expected '(' after typeof");
+		warning(token->pos, "expected '(' after typeof");
 		return token;
 	}
 	if (lookup_type(token->next)) {
@@ -368,7 +368,7 @@
 			token = parens_expression(token, &attribute_expr, "in attribute");
 		error = handle_attribute(ctype, attribute_name, attribute_expr);
 		if (error)
-			warn(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
+			warning(token->pos, "attribute '%s': %s", show_ident(attribute_name), error);
 		if (!match_op(token, ','))
 			break;
 		token = token->next;
@@ -440,29 +440,29 @@
 		}
 		dup = (mod & old) | (extra & old) | (extra & mod);
 		if (dup)
-			warn(pos, "Just how %sdo you want this type to be?",
+			warning(pos, "Just how %sdo you want this type to be?",
 				modifier_string(dup));
 
 		conflict = !(~mod & ~old & (MOD_LONG | MOD_SHORT));
 		if (conflict)
-			warn(pos, "You cannot have both long and short modifiers.");
+			warning(pos, "You cannot have both long and short modifiers.");
 
 		conflict = !(~mod & ~old & (MOD_SIGNED | MOD_UNSIGNED));
 		if (conflict)
-			warn(pos, "You cannot have both signed and unsigned modifiers.");
+			warning(pos, "You cannot have both signed and unsigned modifiers.");
 
 		// Only one storage modifier allowed, except that "inline" doesn't count.
 		conflict = (mod | old) & (MOD_STORAGE & ~MOD_INLINE);
 		conflict &= (conflict - 1);
 		if (conflict)
-			warn(pos, "multiple storage classes");
+			warning(pos, "multiple storage classes");
 
 		ctype->modifiers = old | mod | extra;
 	}
 
 	/* Context mask and value */
 	if ((ctype->context ^ thistype->context) & (ctype->contextmask & thistype->contextmask)) {
-		warn(pos, "inconsistent attribute types");
+		warning(pos, "inconsistent attribute types");
 		thistype->context = 0;
 		thistype->contextmask = 0;
 	}
@@ -471,7 +471,7 @@
 
 	/* Alignment */
 	if (thistype->alignment & (thistype->alignment-1)) {
-		warn(pos, "I don't like non-power-of-2 alignments");
+		warning(pos, "I don't like non-power-of-2 alignments");
 		thistype->alignment = 0;
 	}
 	if (thistype->alignment > ctype->alignment)
@@ -506,7 +506,7 @@
 
 	wrong = mod & banned;
 	if (wrong)
-		warn(*pos, "modifier %sis invalid in this context",
+		warning(*pos, "modifier %sis invalid in this context",
 		     modifier_string (wrong));
 }
 
@@ -588,7 +588,7 @@
 		struct symbol *type;
 		ctype->modifiers &= ~(MOD_BITWISE | MOD_SPECIFIER);
 		if (!is_int_type(ctype->base_type)) {
-			warn(token->pos, "invalid modifier");
+			warning(token->pos, "invalid modifier");
 			return token;
 		}
 		type = alloc_symbol(token->pos, SYM_BASETYPE);
@@ -724,7 +724,7 @@
 	long long width;
 
 	if (!is_int_type(ctype->base_type)) {
-		warn(token->pos, "invalid bitfield specifier for type %s.",
+		warning(token->pos, "invalid bitfield specifier for type %s.",
 			show_typename(ctype->base_type));
 		// Parse this to recover gracefully.
 		return conditional_expression(token->next, &expr);
@@ -736,31 +736,31 @@
 	bitfield->fieldwidth = width;
 
 	if (width < 0) {
-		warn(token->pos, "invalid negative bitfield width, %lld.", width);
+		warning(token->pos, "invalid negative bitfield width, %lld.", width);
 		bitfield->fieldwidth = 8;
 	} else if (decl->ident && width == 0) {
-		warn(token->pos, "invalid named zero-width bitfield `%s'",
+		warning(token->pos, "invalid named zero-width bitfield `%s'",
 		     show_ident(decl->ident));
 		bitfield->fieldwidth = 8;
 	} else if (width != bitfield->fieldwidth) {
 		// Overflow.
 		unsigned int stupid_gcc = -1;
 		bitfield->fieldwidth = stupid_gcc;
-		warn(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
+		warning(token->pos, "truncating large bitfield from %lld to %d bits", width, bitfield->fieldwidth);
 	} else if (decl->ident) {
 		struct symbol *base_type = bitfield->ctype.base_type;
 		int is_signed = !(base_type->ctype.modifiers & MOD_UNSIGNED);
 		if (bitfield->fieldwidth == 1 && is_signed) {
 			// Valid values are either {-1;0} or {0}, depending on integer
 			// representation.  The latter makes for very efficient code...
-			warn(token->pos, "dubious one-bit signed bitfield");
+			warning(token->pos, "dubious one-bit signed bitfield");
 		}
 		if (Wdefault_bitfield_sign &&
 		    base_type->type != SYM_ENUM &&
 		    !(base_type->ctype.modifiers & MOD_EXPLICITLY_SIGNED) &&
 		    is_signed) {
 			// The sign of bitfields is unspecified by default.
-			warn (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
+			warning (token->pos, "dubious bitfield without explicit `signed' or `unsigned'");
 		}
 	}
 	return token;
@@ -787,7 +787,7 @@
 			token = token->next;
 		}
 		if (!match_op(token, ';')) {
-			warn(token->pos, "expected ; at end of declaration");
+			warning(token->pos, "expected ; at end of declaration");
 			break;
 		}
 		token = token->next;
@@ -1003,7 +1003,7 @@
 static void end_switch(struct statement *stmt)
 {
 	if (!stmt->switch_case->symbol_list)
-		warn(stmt->pos, "switch with no cases");
+		warning(stmt->pos, "switch with no cases");
 	end_symbol_scope();
 }
 
@@ -1013,7 +1013,7 @@
 	struct symbol *sym;
 
 	if (!target) {
-		warn(stmt->pos, "not in switch scope");
+		warning(stmt->pos, "not in switch scope");
 		return;
 	}
 	sym = alloc_symbol(stmt->pos, SYM_NODE);
@@ -1096,7 +1096,7 @@
 	if (token_type(token) == TOKEN_IDENT && token->ident == &while_ident)
 		token = token->next;
 	else
-		warn(token->pos, "expected 'while' after 'do'");
+		warning(token->pos, "expected 'while' after 'do'");
 	token = parens_expression(token, &expr, "after 'do-while'");
 
 	stmt->iterator_post_condition = expr;
@@ -1131,7 +1131,7 @@
 			stmt->type = STMT_GOTO;
 			stmt->goto_label = target;
 			if (!target)
-				warn(stmt->pos, "break/continue not in iterator scope");
+				warning(stmt->pos, "break/continue not in iterator scope");
 			return expect(token->next, ';', "at end of statement");
 		}
 		if (token->ident == &default_ident) {
@@ -1175,7 +1175,7 @@
 				stmt->goto_label = label_symbol(token);
 				token = token->next;
 			} else {
-				warn(token->pos, "Expected identifier or goto expression");
+				warning(token->pos, "Expected identifier or goto expression");
 			}
 			return expect(token, ';', "at end of statement");
 		}
@@ -1224,7 +1224,7 @@
 		// No warning for "void oink ();"
 		// Bug or feature: warns for "void oink () __attribute__ ((noreturn));"
 		if (!match_op(token->next, ';'))
-			warn(token->pos, "non-ANSI function declaration");
+			warning(token->pos, "non-ANSI function declaration");
 		return token;
 	}
 
@@ -1233,7 +1233,7 @@
 
 		if (match_op(token, SPECIAL_ELLIPSIS)) {
 			if (!*list)
-				warn(token->pos, "variadic functions must have one named argument");
+				warning(token->pos, "variadic functions must have one named argument");
 			fn->variadic = 1;
 			token = token->next;
 			break;
@@ -1245,7 +1245,7 @@
 			/* Special case: (void) */
 			if (!*list && !sym->ident)
 				break;
-			warn(token->pos, "void parameter");
+			warning(token->pos, "void parameter");
 		}
 		add_symbol(list, sym);
 		if (!match_op(token, ','))
@@ -1284,7 +1284,7 @@
 	if (to) {
 		idx_to = get_expression_value(to);
 		if (idx_to < idx_from || idx_from < 0)
-			warn(from->pos, "nonsense array initializer index range");
+			warning(from->pos, "nonsense array initializer index range");
 	}
 	expr->idx_from = idx_from;
 	expr->idx_to = idx_to;
@@ -1339,7 +1339,7 @@
 static void declare_argument(struct symbol *sym, struct symbol *fn)
 {
 	if (!sym->ident) {
-		warn(sym->pos, "no identifier for function argument");
+		warning(sym->pos, "no identifier for function argument");
 		return;
 	}
 	bind_symbol(sym, sym->ident, NS_SYMBOL);
@@ -1364,7 +1364,7 @@
 
 	if (decl->ctype.modifiers & MOD_EXTERN) {
 		if (!(decl->ctype.modifiers & MOD_INLINE))
-			warn(decl->pos, "function with external linkage has definition");
+			warning(decl->pos, "function with external linkage has definition");
 	}
 	if (!(decl->ctype.modifiers & MOD_STATIC))
 		decl->ctype.modifiers |= MOD_EXTERN;
@@ -1385,7 +1385,7 @@
 	function_symbol_list = NULL;
 	if (function_computed_goto_list) {
 		if (!function_computed_target_list)
-			warn(decl->pos, "function has computed goto but no targets?");
+			warning(decl->pos, "function has computed goto but no targets?");
 		else {
 			struct statement *stmt;
 			FOR_EACH_PTR(function_computed_goto_list, stmt) {
@@ -1417,7 +1417,7 @@
 			if (type->ident == arg->ident)
 				goto match;
 		} END_FOR_EACH_PTR(type);
-		warn(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
+		warning(arg->pos, "missing type declaration for parameter '%s'", show_ident(arg->ident));
 		continue;
 match:
 		type->used = 1;
@@ -1429,7 +1429,7 @@
 
 	FOR_EACH_PTR(argtypes, arg) {
 		if (!arg->used)
-			warn(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
+			warning(arg->pos, "nonsensical parameter declaration '%s'", show_ident(arg->ident));
 	} END_FOR_EACH_PTR(arg);
 
 }
@@ -1439,7 +1439,7 @@
 {
 	struct symbol_list *args = NULL;
 
-	warn(token->pos, "non-ANSI function declaration");
+	warning(token->pos, "non-ANSI function declaration");
 	do {
 		token = external_declaration(token, &args);
 	} while (lookup_type(token));
@@ -1447,7 +1447,7 @@
 	apply_k_r_types(args, decl);
 
 	if (!match_op(token, '{')) {
-		warn(token->pos, "expected function body");
+		warning(token->pos, "expected function body");
 		return token;
 	}
 	return parse_function_body(token, decl, list);
@@ -1513,7 +1513,7 @@
 		if (!(decl->ctype.modifiers & MOD_STATIC))
 			decl->ctype.modifiers |= MOD_EXTERN;
 	} else if (!is_typedef && base_type == &void_ctype && !(decl->ctype.modifiers & MOD_EXTERN)) {
-		warn(token->pos, "void declaration");
+		warning(token->pos, "void declaration");
 	}
 
 	for (;;) {
@@ -1528,7 +1528,7 @@
 		}
 		if (!is_typedef && match_op(token, '=')) {
 			if (decl->ctype.modifiers & MOD_EXTERN) {
-				warn(decl->pos, "symbol with external linkage has initializer");
+				warning(decl->pos, "symbol with external linkage has initializer");
 				decl->ctype.modifiers &= ~MOD_EXTERN;
 			}
 			token = initializer(&decl->initializer, token->next);
@@ -1552,7 +1552,7 @@
 		token = declaration_specifiers(token, &decl->ctype, 1);
 		token = declarator(token, &decl, &ident);
 		if (!ident) {
-			warn(token->pos, "expected identifier name in type definition");
+			warning(token->pos, "expected identifier name in type definition");
 			return token;
 		}
 
Index: sparse-be/pre-process.c
===================================================================
--- sparse-be.orig/pre-process.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/pre-process.c	2004-09-08 14:09:45.000000000 -0400
@@ -98,7 +98,7 @@
 	char *string[] = { "0", "1" };
 	int defined = 0;
 	if (token_type(token) != TOKEN_IDENT)
-		warn(token->pos, "operator \"defined\" requires an identifier");
+		warning(token->pos, "operator \"defined\" requires an identifier");
 	else if (lookup_symbol(token->ident, NS_MACRO))
 		defined = 1;
 	token_type(token) = TOKEN_NUMBER;
@@ -237,7 +237,7 @@
 	return 1;
 
 Efew:
-	warn(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
+	warning(what->pos, "macro \"%s\" requires %d arguments, but only %d given",
 		show_token(what), wanted, count);
 	goto out;
 Emany:
@@ -247,11 +247,11 @@
 	}
 	if (eof_token(next))
 		goto Eclosing;
-	warn(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
+	warning(what->pos, "macro \"%s\" passed %d arguments, but takes just %d",
 		show_token(what), count, wanted);
 	goto out;
 Eclosing:
-	warn(what->pos, "unterminated argument list invoking macro \"%s\"",
+	warning(what->pos, "unterminated argument list invoking macro \"%s\"",
 		show_token(what));
 out:
 	what->next = next->next;
@@ -400,7 +400,7 @@
 	default:
 		;
 	}
-	warn(left->pos, "'##' failed: concatenation is not a valid token");
+	warning(left->pos, "'##' failed: concatenation is not a valid token");
 	return 0;
 }
 
@@ -581,7 +581,7 @@
 	}
 	*ptr = 0;
 	if (endop && !match_op(token, endop))
-		warn(start->pos, "expected '>' at end of filename");
+		warning(start->pos, "expected '>' at end of filename");
 	return buffer;
 }
 
@@ -843,20 +843,20 @@
 
 
 Emissing:
-	warn(arg->pos, "parameter name missing");
+	warning(arg->pos, "parameter name missing");
 	return NULL;
 Ebadstuff:
-	warn(arg->pos, "\"%s\" may not appear in macro parameter list",
+	warning(arg->pos, "\"%s\" may not appear in macro parameter list",
 		show_token(arg));
 	return NULL;
 Enotclosed:
-	warn(arg->pos, "missing ')' in macro parameter list");
+	warning(arg->pos, "missing ')' in macro parameter list");
 	return NULL;
 Eva_args:
-	warn(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro");
+	warning(arg->pos, "__VA_ARGS__ can only appear in the expansion of a C99 variadic macro");
 	return NULL;
 Eargs:
-	warn(arg->pos, "too many arguments in macro definition");
+	warning(arg->pos, "too many arguments in macro definition");
 	return NULL;
 }
 
@@ -950,14 +950,14 @@
 	return expansion;
 
 Equote:
-	warn(token->pos, "'#' is not followed by a macro parameter");
+	warning(token->pos, "'#' is not followed by a macro parameter");
 	return NULL;
 
 Econcat:
-	warn(token->pos, "'##' cannot appear at the ends of macro expansion");
+	warning(token->pos, "'##' cannot appear at the ends of macro expansion");
 	return NULL;
 Earg:
-	warn(token->pos, "too many instances of argument in body");
+	warning(token->pos, "too many instances of argument in body");
 	return NULL;
 }
 
@@ -969,7 +969,7 @@
 	struct ident *name;
 
 	if (token_type(left) != TOKEN_IDENT) {
-		warn(token->pos, "expected identifier to 'define'");
+		warning(token->pos, "expected identifier to 'define'");
 		return 0;
 	}
 	if (false_nesting)
@@ -997,7 +997,7 @@
 	if (sym) {
 		if (token_list_different(sym->expansion, expansion) || 
 		    token_list_different(sym->arglist, arglist)) {
-			warn(left->pos, "preprocessor token %.*s redefined",
+			warning(left->pos, "preprocessor token %.*s redefined",
 					name->len, name->name);
 			info(sym->pos, "this was the original definition");
 		}
@@ -1017,7 +1017,7 @@
 	struct symbol **sym;
 
 	if (token_type(left) != TOKEN_IDENT) {
-		warn(token->pos, "expected identifier to 'undef'");
+		warning(token->pos, "expected identifier to 'undef'");
 		return 0;
 	}
 	if (false_nesting)
@@ -1058,7 +1058,7 @@
 	if (token_type(token) == TOKEN_IDENT)
 		return lookup_symbol(token->ident, NS_MACRO) != NULL;
 
-	warn(token->pos, "expected identifier for #if[n]def");
+	warning(token->pos, "expected identifier for #if[n]def");
 	return 0;
 }
 
@@ -1125,7 +1125,7 @@
 		case 3:
 			state = 0;
 			if (!match_op(p, ')'))
-				warn(p->pos, "missing ')' after \"defined\"");
+				warning(p->pos, "missing ')' after \"defined\"");
 			*list = p->next;
 			continue;
 		}
@@ -1134,7 +1134,7 @@
 
 	p = constant_expression(*where, &expr);
 	if (!eof_token(p))
-		warn(p->pos, "garbage at end: %s", show_token_sequence(p));
+		warning(p->pos, "garbage at end: %s", show_token_sequence(p));
 	value = get_expression_value(expr);
 	return value != 0;
 }
@@ -1160,12 +1160,12 @@
 		MARK_STREAM_NONCONST(token->pos);
 
 	if (stream->nesting > if_nesting) {
-		warn(token->pos, "unmatched #elif");
+		warning(token->pos, "unmatched #elif");
 		return 1;
 	}
 
 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warn(token->pos, "#elif after #else");
+		warning(token->pos, "#elif after #else");
 
 	if (false_nesting) {
 		/* If this whole if-thing is if'ed out, an elif cannot help */
@@ -1189,12 +1189,12 @@
 		MARK_STREAM_NONCONST(token->pos);
 
 	if (stream->nesting > if_nesting) {
-		warn(token->pos, "unmatched #else");
+		warning(token->pos, "unmatched #else");
 		return 1;
 	}
 
 	if (elif_ignore[if_nesting-1] & ELIF_SEEN_ELSE)
-		warn(token->pos, "#else after #else");
+		warning(token->pos, "#else after #else");
 	else
 		elif_ignore[if_nesting-1] |= ELIF_SEEN_ELSE;
 
@@ -1218,7 +1218,7 @@
 		stream->constant = CONSTANT_FILE_MAYBE;
 
 	if (stream->nesting > if_nesting)
-		warn(token->pos, "unmatched #endif");
+		warning(token->pos, "unmatched #endif");
 	else if (false_nesting)
 		false_nesting--;
 	else
@@ -1239,7 +1239,7 @@
 		int len = strlen(val);
 
 		if (ptr + whitespace + len >= buffer + sizeof(buffer)) {
-			warn(token->pos, "too long token expansion");
+			warning(token->pos, "too long token expansion");
 			break;
 		}
 
@@ -1260,7 +1260,7 @@
 		return 1;
 	if (stream->constant == CONSTANT_FILE_MAYBE)
 		MARK_STREAM_NONCONST(token->pos);
-	warn(token->pos, "%s", show_token_sequence(token->next));
+	warning(token->pos, "%s", show_token_sequence(token->next));
 	return 1;
 }
 
@@ -1270,7 +1270,7 @@
 		return 1;
 	if (stream->constant == CONSTANT_FILE_MAYBE)
 		MARK_STREAM_NONCONST(token->pos);
-	warn(token->pos, "%s", show_token_sequence(token->next));
+	warning(token->pos, "%s", show_token_sequence(token->next));
 	return 1;
 }
 
@@ -1335,7 +1335,7 @@
 		if (eof_token(token))
 			return 1;
 		if (token_type(token) != TOKEN_STRING) {
-			warn(token->pos, "expected path string");
+			warning(token->pos, "expected path string");
 			return 1;
 		}
 		add_path_entry(token, token->string->data);
@@ -1428,7 +1428,7 @@
 			return;
 	}
 
-	warn(token->pos, "unrecognized preprocessor line '%s'", show_token_sequence(token));
+	warning(token->pos, "unrecognized preprocessor line '%s'", show_token_sequence(token));
 }
 
 static void preprocessor_line(struct stream *stream, struct token **line)
@@ -1464,7 +1464,7 @@
 		switch (token_type(next)) {
 		case TOKEN_STREAMEND:
 			if (stream->nesting < if_nesting + 1) {
-				warn(unmatched_if->pos, "unterminated preprocessor conditional");
+				warning(unmatched_if->pos, "unterminated preprocessor conditional");
 				// Pretend to see a series of #endifs
 				MARK_STREAM_NONCONST(next->pos);
 				do {
Index: sparse-be/show-parse.c
===================================================================
--- sparse-be.orig/show-parse.c	2004-09-08 13:09:30.000000000 -0400
+++ sparse-be/show-parse.c	2004-09-08 14:09:45.000000000 -0400
@@ -586,7 +586,7 @@
 	int framesize;
 
 	if (!expr->ctype) {
-		warn(expr->pos, "\tcall with no type!");
+		warning(expr->pos, "\tcall with no type!");
 		return 0;
 	}
 
@@ -994,7 +994,7 @@
 	case EXPR_DEREF:
 	case EXPR_SIZEOF:
 	case EXPR_ALIGNOF:
-		warn(expr->pos, "invalid expression after evaluation");
+		warning(expr->pos, "invalid expression after evaluation");
 		return 0;
 	case EXPR_CAST:
 		return show_cast_expr(expr);
@@ -1021,16 +1021,16 @@
 	// None of these should exist as direct expressions: they are only
 	// valid as sub-expressions of initializers.
 	case EXPR_POS:
-		warn(expr->pos, "unable to show plain initializer position expression");
+		warning(expr->pos, "unable to show plain initializer position expression");
 		return 0;
 	case EXPR_IDENTIFIER:
-		warn(expr->pos, "unable to show identifier expression");
+		warning(expr->pos, "unable to show identifier expression");
 		return 0;
 	case EXPR_INDEX:
-		warn(expr->pos, "unable to show index expression");
+		warning(expr->pos, "unable to show index expression");
 		return 0;
 	case EXPR_TYPE:
-		warn(expr->pos, "unable to show type expression");
+		warning(expr->pos, "unable to show type expression");
 		return 0;
 	}
 	return 0;
Index: sparse-be/symbol.c
===================================================================
--- sparse-be.orig/symbol.c	2004-09-08 13:09:30.000000000 -0400
+++ sparse-be/symbol.c	2004-09-08 14:09:46.000000000 -0400
@@ -123,7 +123,7 @@
 		sym->offset = (bit_size - bit_offset) >> 3;
 		sym->bit_offset = bit_offset;
 		info->bit_size = bit_size + width;
-		// warn (sym->pos, "bitfield: offset=%d:%d  size=:%d", sym->offset, sym->bit_offset, width);
+		// warning (sym->pos, "bitfield: offset=%d:%d  size=:%d", sym->offset, sym->bit_offset, width);
 
 		return;
 	}
@@ -135,7 +135,7 @@
 	sym->offset = bit_size >> 3;
 
 	info->bit_size = bit_size + sym->bit_size;
-	// warn (sym->pos, "regular: offset=%d", sym->offset);
+	// warning (sym->pos, "regular: offset=%d", sym->offset);
 }
 
 static void examine_struct_union_type(struct symbol *sym, int advance)
@@ -182,7 +182,7 @@
 	examine_symbol_type(base_type);
 	bit_size = base_type->bit_size;
 	if (sym->fieldwidth > bit_size) {
-		warn(sym->pos, "impossible field-width, %d, for this type",
+		warning(sym->pos, "impossible field-width, %d, for this type",
 		     sym->fieldwidth);
 		sym->fieldwidth = bit_size;
 	}
@@ -257,7 +257,7 @@
 	case SYM_TYPEOF: {
 		struct symbol *base = evaluate_expression(sym->initializer);
 		if (is_bitfield_type (base))
-			warn(base->pos, "typeof applied to bitfield type");
+			warning(base->pos, "typeof applied to bitfield type");
 		if (base) {
 			if (base->type == SYM_NODE)
 				base = base->ctype.base_type;
@@ -266,10 +266,10 @@
 		}
 		break;
 	case SYM_PREPROCESSOR:
-		warn(sym->pos, "ctype on preprocessor command? (%s)", show_ident(sym->ident));
+		warning(sym->pos, "ctype on preprocessor command? (%s)", show_ident(sym->ident));
 		return NULL;
 	case SYM_UNINITIALIZED:
-		warn(sym->pos, "ctype on uninitialized symbol %p", sym);
+		warning(sym->pos, "ctype on uninitialized symbol %p", sym);
 		return NULL;
 	}
 	default:
@@ -332,7 +332,7 @@
 {
 	struct scope *scope;
 	if (sym->id_list) {
-		warn(sym->pos, "internal error: symbol type already bound");
+		warning(sym->pos, "internal error: symbol type already bound");
 		return;
 	}
 	sym->namespace = ns;
Index: sparse-be/tokenize.c
===================================================================
--- sparse-be.orig/tokenize.c	2004-09-06 10:53:43.000000000 -0400
+++ sparse-be/tokenize.c	2004-09-08 14:09:47.000000000 -0400
@@ -240,7 +240,7 @@
 	} else {
 		if (c == '\n') {
 			if (complain)
-				warn(stream->pos, "non-ASCII data stream");
+				warning(stream->pos, "non-ASCII data stream");
 			spliced = 1;
 			goto restart;
 		}
@@ -252,7 +252,7 @@
 out:
 	stream->offset = offset;
 	if (complain)
-		warn(stream->pos, "non-ASCII data stream");
+		warning(stream->pos, "non-ASCII data stream");
 
 	return c;
 
@@ -262,11 +262,11 @@
 		goto out;
 	}
 	if (stream->pos.pos)
-		warn(stream->pos, "no newline at end of file");
+		warning(stream->pos, "no newline at end of file");
 	else if (had_cr)
-		warn(stream->pos, "non-ASCII data stream");
+		warning(stream->pos, "non-ASCII data stream");
 	else if (spliced)
-		warn(stream->pos, "backslash-newline at end of file");
+		warning(stream->pos, "backslash-newline at end of file");
 	return EOF;
 }
 
@@ -433,7 +433,7 @@
 	value = first;
 
 	if (first == '\n')
-		warn(stream->pos, "Newline in string or character constant");
+		warning(stream->pos, "Newline in string or character constant");
 
 	if (first == '\\' && next != EOF) {
 		value = next;
@@ -471,7 +471,7 @@
 			case '"':
 				break;
 			case '\n':
-				warn(stream->pos, "Newline in string or character constant");
+				warning(stream->pos, "Newline in string or character constant");
 				break;
 			case '0'...'7': {
 				int nr = 2;
@@ -500,7 +500,7 @@
 			}
 			/* Fallthrough */
 			default:
-				warn(stream->pos, "Unknown escape '%c'", value);
+				warning(stream->pos, "Unknown escape '%c'", value);
 			}
 		}
 		/* Mark it as escaped */
@@ -517,7 +517,7 @@
 
 	next = escapechar(next, '\'', stream, &value);
 	if (value == '\'' || next != '\'') {
-		warn(stream->pos, "Bad character constant");
+		warning(stream->pos, "Bad character constant");
 		drop_token(stream);
 		return next;
 	}
@@ -543,7 +543,7 @@
 		if (val == '"')
 			break;
 		if (next == EOF) {
-			warn(stream->pos, "End of file in middle of string");
+			warning(stream->pos, "End of file in middle of string");
 			return next;
 		}
 		if (len < MAX_STRING)
@@ -552,7 +552,7 @@
 	}
 
 	if (len > MAX_STRING) {
-		warn(stream->pos, "string too long (%d bytes, %d bytes max)", len, MAX_STRING);
+		warning(stream->pos, "string too long (%d bytes, %d bytes max)", len, MAX_STRING);
 		len = MAX_STRING;
 	}
 
@@ -595,7 +595,7 @@
 	for (;;) {
 		int curr = next;
 		if (curr == EOF) {
-			warn(stream->pos, "End of file in the middle of a comment");
+			warning(stream->pos, "End of file in the middle of a comment");
 			return curr;
 		}
 		next = nextchar(stream);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] resend: trivial ansi-c declear ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] resend: trivial ansi-c declear
Date: Mon, 13 Sep 2004 19:46:26 +0000
Message-ID: <20040913194626.GA3712 () 64m ! dyndns ! org>
--------------------
Here is resend of the trivial patch. Catch by
checking sparse itself.

Chris

Index: sparse-be/pre-process.c
===================================================================
--- sparse-be.orig/pre-process.c	2004-09-13 15:27:20.000000000 -0400
+++ sparse-be/pre-process.c	2004-09-13 15:44:13.000000000 -0400
@@ -1378,7 +1378,7 @@
 }
 
 
-void init_preprocessor()
+void init_preprocessor(void)
 {
 	int i;
 	int stream = init_stream("preprocessor", -1, includepath);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] typos in README + obfuscate ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: [PATCH] typos in README + obfuscate
Date: Mon, 04 Oct 2004 00:24:51 +0000
Message-ID: <20041003172451.465a19b5.rddunlap () osdl ! org>
--------------------

Fix typos in sparse README and obfuscate.c.

diffstat:=
 README      |    2 +-
 obfuscate.c |    2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff -Naurp ./README~check_addns ./README
--- ./README~check_addns	2004-01-30 10:29:14.000000000 -0800
+++ ./README	2004-10-01 17:42:36.239683600 -0700
@@ -58,7 +58,7 @@ This means that a user of the library wi
 	init_symbols();
 
 	// Tokenize the input stream
-	token = tokenize(filename, fd, NULL);
+	token = tokenize(filename, fd, NULL, includepath);
 
 	// Pre-process the stream
 	token = preprocess(token);
diff -Naurp ./obfuscate.c~check_addns ./obfuscate.c
--- ./obfuscate.c~check_addns	2004-09-22 16:00:28.000000000 -0700
+++ ./obfuscate.c	2004-10-03 16:24:03.283568856 -0700
@@ -29,7 +29,7 @@ static void emit_blob(struct symbol *sym
 	const char *name = show_ident(sym->ident);
 
 	if (size <= 0) {
-		warning(sym->pos, "emitting insized symbol");
+		warning(sym->pos, "emitting unsized symbol");
 		size = 8;
 	}
 	if (size & 7)


--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH] weak_define ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [PATCH] weak_define
Date: Fri, 05 Nov 2004 16:16:32 +0000
Message-ID: <20041105161632.GC29422 () 64m ! dyndns ! org>
--------------------
It implement the weak_define that don't complain if the stuff
has already define.

Chris

Index: sparse-be/pre-process.c
===================================================================
--- sparse-be.orig/pre-process.c	2004-10-09 12:54:53.000000000 -0400
+++ sparse-be/pre-process.c	2004-11-05 11:11:21.000000000 -0500
@@ -960,7 +960,7 @@
 	return NULL;
 }
 
-static int handle_define(struct stream *stream, struct token **line, struct token *token)
+static int do_handle_define(struct stream *stream, struct token **line, struct token *token, int weakdef)
 {
 	struct token *arglist, *expansion;
 	struct token *left = token->next;
@@ -994,6 +994,8 @@
 
 	sym = lookup_symbol(name, NS_MACRO);
 	if (sym) {
+		if (weakdef)
+			return 1;
 		if (token_list_different(sym->expansion, expansion) || 
 		    token_list_different(sym->arglist, arglist)) {
 			warning(left->pos, "preprocessor token %.*s redefined",
@@ -1010,6 +1012,15 @@
 	return 1;
 }
 
+static int handle_weak_define(struct stream *stream, struct token **line, struct token *token)
+{
+	return do_handle_define(stream, line, token, 1);
+}
+
+static int handle_define(struct stream *stream, struct token **line, struct token *token)
+{
+	return do_handle_define(stream, line, token, 0);
+}
 static int handle_undef(struct stream *stream, struct token **line, struct token *token)
 {
 	struct token *left = token->next;
@@ -1398,6 +1409,7 @@
 		{ "if",		handle_if },
 		{ "elif",	handle_elif },
 		{ "warning",	handle_warning },
+		{ "weak_define",handle_weak_define },
 		{ "error",	handle_error },
 		{ "include",	handle_include },
 		{ "include_next",handle_include_next },
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH] weak_define
Date: Fri, 05 Nov 2004 19:55:25 +0000
Message-ID: <Pine.LNX.4.58.0411051153300.2223 () ppc970 ! osdl ! org>
--------------------


On Fri, 5 Nov 2004, Christopher Li wrote:
>
> It implement the weak_define that don't complain if the stuff
> has already define.

Heh. I already pushed my version out a few hours ago ;)

The current tree has linearize_ptr_list() and weak defines, and uses them 
both.. (And I made re-defining work properly, warnings or not - non-weak 
overrides weak, and later over-rides earleir)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH]: Fix 3 warnings in compile-i386.c ===

From: Rui Saraiva <rmps () joel ! ist ! utl ! pt>
To: linux-sparse
Subject: [PATCH]: Fix 3 warnings in compile-i386.c
Date: Wed, 10 Nov 2004 22:24:15 +0000
Message-ID: <Pine.LNX.4.58.0411102218540.7088 () joel ! ist ! utl ! pt>
--------------------

This patch fix this 3 warnings (gcc 3.3.4) in values not handled in
switch():

compile-i386.c: In function `x86_statement':
compile-i386.c:2040: warning: enumeration value `STMT_INTERNAL' not handled in switch
compile-i386.c: In function `x86_expression':
compile-i386.c:2378: warning: enumeration value `EXPR_PTRSIZEOF' not handled in switch
compile-i386.c:2378: warning: enumeration value `EXPR_SLICE' not handled in switch


Regards,
  Rui Saraiva


--- compile-i386.c.orig	2004-11-10 22:15:18.000000000 +0000
+++ compile-i386.c	2004-11-10 22:17:45.000000000 +0000
@@ -2037,6 +2037,9 @@ static struct storage *x86_statement(str
 	case STMT_ASM:
 		printf("\tasm( .... )\n");
 		break;
+
+	case STMT_INTERNAL:
+		break;
 	}
 	return NULL;
 }
@@ -2375,6 +2378,9 @@ static struct storage *x86_expression(st
 	case EXPR_FVALUE:
 		warning(expr->pos, "floating point support is not implemented");
 		return NULL;
+	case EXPR_PTRSIZEOF:
+	case EXPR_SLICE:
+		break;
 	}
 	return NULL;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [PATCH]: Fix 3 warnings in compile-i386.c
Date: Wed, 10 Nov 2004 22:42:11 +0000
Message-ID: <Pine.LNX.4.58.0411101440390.2301 () ppc970 ! osdl ! org>
--------------------


On Wed, 10 Nov 2004, Rui Saraiva wrote:
> 
> This patch fix this 3 warnings (gcc 3.3.4) in values not handled in
> switch():

I'd actually rather have the warnings than a compile that "succeeds", but 
doesn't actually handle the cases correctly.

The STMT_INTERNAL might not matter (it's perfectly valid to throw it 
away), but at the very least it should complain about EXPR_PTRSIZEOF (such 
an expression should not exist any more by the time the tree has been 
expanded). And EXPR_SLICE really needs actual code.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [PATCH][RFC] cross compile sparse checking ===

From: Josh Boyer <jwboyer () charter ! net>
To: linux-sparse
Subject: [PATCH][RFC] cross compile sparse checking
Date: Tue, 20 Jul 2004 16:35:53 +0000
Message-ID: <1090341351.313.13.camel () c68 ! 115 ! 86 ! 108 ! roc ! mn ! charter ! com>
--------------------
Hi,

Below is a patch to allow sparse to use the correct internal includes
when it is going to be used in cross compiling.  Example useage is:

make CROSS_CHECK=powerpc-linux-

which would use the cross compilers internal include files.  Comments?

josh

diff -Naur sparse-bk/Makefile sparse-bk.jwb/Makefile
--- sparse-bk/Makefile	2004-06-30 18:00:22.000000000 -0500
+++ sparse-bk.jwb/Makefile	2004-07-20 10:57:48.000000000 -0500
@@ -1,3 +1,4 @@
+CROSS_CHECK=
 CC=gcc
 CFLAGS=-O -g -Wall
 LDFLAGS=-g
@@ -63,7 +64,7 @@
 tokenize.o: $(LIB_H)
 
 pre-process.h:
-	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h
+	echo "#define GCC_INTERNAL_INCLUDE \"`$(CROSS_CHECK)$(CC) -print-file-name=include`\"" > pre-process.h
 
 clean:
 	rm -f *.[oasi] core core.[0-9]* $(PROGRAMS) pre-process.h

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: [PATCH][RFC] cross compile sparse checking
Date: Tue, 20 Jul 2004 17:13:40 +0000
Message-ID: <40FD52C4.7020603 () numba-tu ! com>
--------------------
Josh Boyer wrote:

>diff -Naur sparse-bk/Makefile sparse-bk.jwb/Makefile
>--- sparse-bk/Makefile	2004-06-30 18:00:22.000000000 -0500
>+++ sparse-bk.jwb/Makefile	2004-07-20 10:57:48.000000000 -0500
>@@ -1,3 +1,4 @@
>+CROSS_CHECK=
> CC=gcc
> CFLAGS=-O -g -Wall
> LDFLAGS=-g
>@@ -63,7 +64,7 @@
> tokenize.o: $(LIB_H)
> 
> pre-process.h:
>-	echo "#define GCC_INTERNAL_INCLUDE \"`$(CC) -print-file-name=include`\"" > pre-process.h
>+	echo "#define GCC_INTERNAL_INCLUDE \"`$(CROSS_CHECK)$(CC) -print-file-name=include`\"" > pre-process.h
>  
>
Isn't it more custom to have a CROSS_CC and make it default to CC?  I 
think that would be nicer.

Tommy


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jwboyer () charter ! net>
To: linux-sparse
Subject: Re: [PATCH][RFC] cross compile sparse checking
Date: Tue, 20 Jul 2004 17:34:10 +0000
Message-ID: <1090344850.363.6.camel () c68 ! 115 ! 86 ! 108 ! roc ! mn ! charter ! com>
--------------------
On Tue, 2004-07-20 at 12:13, Tommy Thorn wrote:
> Isn't it more custom to have a CROSS_CC and make it default to CC?  I 
> think that would be nicer.

CROSS_CC is usually used for compiling a binary for another arch.  I
don't want to actually compile sparse for another arch, I just want to
make it use the internal headers from my cross compiler when I do build
a binary for another arch.

In other words CROSS_CHECK=powerpc-linux- makes the equivalent of
powerpc-linux-sparse, not a ppc sparse binary.

That's the intention anyway :).

josh


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jwboyer () charter ! net>
To: linux-sparse
Subject: Re: [PATCH][RFC] cross compile sparse checking
Date: Thu, 22 Jul 2004 21:31:56 +0000
Message-ID: <1090531916.2578.1.camel () c68 ! 115 ! 86 ! 108 ! roc ! mn ! charter ! com>
--------------------
On Tue, 2004-07-20 at 12:34, Josh Boyer wrote:
> On Tue, 2004-07-20 at 12:13, Tommy Thorn wrote:
> > Isn't it more custom to have a CROSS_CC and make it default to CC?  I 
> > think that would be nicer.
> 
> CROSS_CC is usually used for compiling a binary for another arch.  I
> don't want to actually compile sparse for another arch, I just want to
> make it use the internal headers from my cross compiler when I do build
> a binary for another arch.
> 
> In other words CROSS_CHECK=powerpc-linux- makes the equivalent of
> powerpc-linux-sparse, not a ppc sparse binary.
> 
> That's the intention anyway :).

I figure most people are at OLS, but are there anymore comments on this
patch?  Is it wanted, ugly, unnecessary?  

thx,
josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [PATCH][RFC] cross compile sparse checking
Date: Fri, 23 Jul 2004 17:29:58 +0000
Message-ID: <20040723193044.GA7017 () mars ! ravnborg ! org>
--------------------
On Thu, Jul 22, 2004 at 04:31:56PM -0500, Josh Boyer wrote:
> On Tue, 2004-07-20 at 12:34, Josh Boyer wrote:
> > On Tue, 2004-07-20 at 12:13, Tommy Thorn wrote:
> > > Isn't it more custom to have a CROSS_CC and make it default to CC?  I 
> > > think that would be nicer.
> > 
> > CROSS_CC is usually used for compiling a binary for another arch.  I
> > don't want to actually compile sparse for another arch, I just want to
> > make it use the internal headers from my cross compiler when I do build
> > a binary for another arch.
> > 
> > In other words CROSS_CHECK=powerpc-linux- makes the equivalent of
> > powerpc-linux-sparse, not a ppc sparse binary.
> > 
> > That's the intention anyway :).
> 
> I figure most people are at OLS, but are there anymore comments on this
> patch?  Is it wanted, ugly, unnecessary?  

The latter...
You just use:
sparse -I `gcc-platform -print-file-name=include`

That should do the trick - it's what m68k uses in the kernel.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [bk][sparse] generalize linearize_statement ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [bk][sparse] generalize linearize_statement
Date: Mon, 24 May 2004 20:09:45 +0000
Message-ID: <20040524200945.GA15389 () havoc ! gtf ! org>
--------------------


NOTE:  This also does a 'bk ignore test-linearize'

Please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 linearize.c      |   13 ++++++++-----
 linearize.h      |    3 ++-
 test-linearize.c |    5 ++++-
 3 files changed, 14 insertions(+), 7 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (04/05/24 1.529)
   Generalize linearize_symbol()
   
   Allow it to be used by multiple callers.

diff -Nru a/linearize.c b/linearize.c
--- a/linearize.c	2004-05-24 16:08:06 -04:00
+++ b/linearize.c	2004-05-24 16:08:06 -04:00
@@ -213,7 +213,7 @@
 	printf("\n");
 }
 
-static void show_entry(struct entrypoint *ep)
+void show_entry(struct entrypoint *ep)
 {
 	struct symbol *sym;
 	struct basic_block *bb;
@@ -1033,15 +1033,16 @@
 	}
 }
 
-void linearize_symbol(struct symbol *sym)
+struct entrypoint *linearize_symbol(struct symbol *sym)
 {
 	struct symbol *base_type;
+	struct entrypoint *ret_ep = NULL;
 
 	if (!sym)
-		return;
+		return NULL;
 	base_type = sym->ctype.base_type;
 	if (!base_type)
-		return;
+		return NULL;
 	if (base_type->type == SYM_FN) {
 		if (base_type->stmt) {
 			struct entrypoint *ep = alloc_entrypoint();
@@ -1062,7 +1063,9 @@
 				add_one_insn(ep, pos, insn);
 			}
 			pack_basic_blocks(&ep->bbs);
-			show_entry(ep);
+			ret_ep = ep;
 		}
 	}
+
+	return ret_ep;
 }
diff -Nru a/linearize.h b/linearize.h
--- a/linearize.h	2004-05-24 16:08:06 -04:00
+++ b/linearize.h	2004-05-24 16:08:06 -04:00
@@ -192,7 +192,8 @@
 	struct basic_block *active;
 };
 
-void linearize_symbol(struct symbol *sym);
+struct entrypoint *linearize_symbol(struct symbol *sym);
+void show_entry(struct entrypoint *ep);
 
 #endif /* LINEARIZE_H */
 
diff -Nru a/test-linearize.c b/test-linearize.c
--- a/test-linearize.c	2004-05-24 16:08:06 -04:00
+++ b/test-linearize.c	2004-05-24 16:08:06 -04:00
@@ -23,10 +23,13 @@
 
 static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
 {
+	struct entrypoint *ep;
+
 	check_duplicates(sym);
 	evaluate_symbol(sym);
 	expand_symbol(sym);
-	linearize_symbol(sym);
+	ep = linearize_symbol(sym);
+	show_entry(ep);
 }
 
 int main(int argc, char **argv)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [discuss] Re: Warning ===

From: Sander Vesik <Sander.Vesik () Sun ! COM>
To: openoffice-discuss
Subject: Re: [discuss] Re: Warning
Date: Thu, 11 Dec 2003 02:10:29 +0000
Message-ID: <3FD7D215.2040907 () sun ! com>
--------------------
G. Roderick Singleton wrote:
> Sander Vesik wrote:
> 
>> Daniel Carrera wrote:
>>
>>> Warning:  This page is unnecessarily graphic.
>>>
>>
>> oh crap, this sneaked through the list?
>>
> 
> Human error or software?
> 

neither. i don't think this was moderated through (so sent by 
subscriber), and as it doesn't have attachments the software
wouldn't bother with it.


================================================================================


################################################################################

=== Thread: [discuss] Warning ===

From: Sander Vesik <Sander.Vesik () Sun ! COM>
To: openoffice-discuss
Subject: Re: [discuss] Warning
Date: Thu, 11 Dec 2003 14:39:14 +0000
Message-ID: <3FD88192.8030401 () sun ! com>
--------------------
MBaumli@mvl.kmmfg.com wrote:
> 
> Christian
>  
> You are a little harsh on Louis.  That's pretty harsh words coming from a 
> conservative such as myself.  Louis should be entitled to one mistake.  I 
> must assume that he is as I was/still am, young and dumb and full of fecal 
> matter.  He has been warned, if he screws up again,  we should then talk 
> to one of the OOo or Sun guys about getting him kicked off of the list. 
> Although, since they already know about this, and have responded,  I doubt 
> that Louis will attempt to provide such links again. 
> 

Sorry, I'm confused - how does Louis fit into the picture other than 
(more or less) the only person who can unsubscribe people?

> Now about viewing the link.  I seen the email first thing this morning, 
> and passed it up.  It looked supspicious, so I didn't open it.  I figure 
> anyone with common sense would be able to pick this up. I don't want to 
> hear any more griping about this. The link wasn't deceptive or devious, 
> just bad humored.
> 
> 
> Sincerely
> 
> Michael Baumli
> Kawasaki Motors Manufacturing 
> 28147 Business HWY 71
> Maryville MO 64468
> 



================================================================================

From: MBaumli () mvl ! kmmfg ! com
To: openoffice-discuss
Subject: Re: [discuss] Warning
Date: Thu, 11 Dec 2003 14:53:51 +0000
Message-ID: <OF52129718.97A97FCB-ON86256DF9.0051B47D-86256DF9.0051BB43 () mvl ! kmmfg ! com>
--------------------
--=_alternative 0051BB4086256DF9_=
Content-Type: text/plain; charset="US-ASCII"

Sorry, miss read the message, and  got the people mixed up.  I should have 
said Audrey.  Too sick, too tired, too early.  The Flu is a wonderful 
thing.

Sincerely

Michael Baumli
Kawasaki Motors Manufacturing 
28147 Business HWY 71
Maryville MO 64468


"This e-mail address is to be used for business purposes only.  Do not 
send any e-mail messages to this address that do not have a specific 
business purpose.  Thank you."




Sander Vesik <Sander.Vesik@Sun.COM>
2003/12/11 08:39
Please respond to discuss
 
        To:     discuss@openoffice.org
        cc: 
        Subject:        Re: [discuss] Warning


MBaumli@mvl.kmmfg.com wrote:
> 
> Christian
> 
> You are a little harsh on Louis.  That's pretty harsh words coming from 
a 
> conservative such as myself.  Louis should be entitled to one mistake. I 

> must assume that he is as I was/still am, young and dumb and full of 
fecal 
> matter.  He has been warned, if he screws up again,  we should then talk 

> to one of the OOo or Sun guys about getting him kicked off of the list. 
> Although, since they already know about this, and have responded,  I 
doubt 
> that Louis will attempt to provide such links again. 
> 

Sorry, I'm confused - how does Louis fit into the picture other than 
(more or less) the only person who can unsubscribe people?

> Now about viewing the link.  I seen the email first thing this morning, 
> and passed it up.  It looked supspicious, so I didn't open it.  I figure 

> anyone with common sense would be able to pick this up. I don't want to 
> hear any more griping about this. The link wasn't deceptive or devious, 
> just bad humored.
> 
> 
> Sincerely
> 
> Michael Baumli
> Kawasaki Motors Manufacturing 
> 28147 Business HWY 71
> Maryville MO 64468
> 



---------------------------------------------------------------------
To unsubscribe, e-mail: discuss-unsubscribe@openoffice.org
For additional commands, e-mail: discuss-help@openoffice.org



--=_alternative 0051BB4086256DF9_=--

================================================================================

From: Sander Vesik <Sander.Vesik () Sun ! COM>
To: openoffice-discuss
Subject: Re: [discuss] Warning
Date: Thu, 11 Dec 2003 15:52:43 +0000
Message-ID: <3FD892CB.7060801 () sun ! com>
--------------------
MBaumli@mvl.kmmfg.com wrote:
> Sorry, miss read the message, and  got the people mixed up.  I should have 
> said Audrey.  Too sick, too tired, too early.  The Flu is a wonderful 
> thing.
> 

Don't worry, its ok, it happens every now and then. Get well soon 8-)

> Sincerely
> 
> Michael Baumli
> Kawasaki Motors Manufacturing 
> 28147 Business HWY 71
> Maryville MO 64468
> 


================================================================================


################################################################################

=== Thread: [discuss] warning ===

From: Sander Vesik <Sander.Vesik () Sun ! COM>
To: openoffice-discuss
Subject: Re: [discuss] warning
Date: Mon, 21 Jun 2004 13:05:01 +0000
Message-ID: <40D6DCFD.7050303 () sun ! com>
--------------------
toralf@procaptura.com wrote:
> you earn money
> 

yes, but why do we need to be warned about that? ;-)

PS. yes, i know the initial one had virus payload

-- 

	Sander

Daniel Carrera: I think I'll stick to simple things like
the 5-dimensional gravity paper I'm reading.

================================================================================


################################################################################

=== Thread: [gtkmm] simple question ===

From: Carl Nygard <cjnygard () fast ! net>
To: gtkmm
Subject: [gtkmm] simple question
Date: Sat, 24 Jul 2004 00:34:23 +0000
Message-ID: <1090629263.26131.213.camel () traveler>
--------------------


I know I'm going to feel like a dope, but how can I find out the size of
a widget.  Gtk::Frame specifically?  I can only find a method for
Gtk::Window.  I'm trying to set Paned widgets position relative to the
parent's size, so I don't want to use the absolute coords but rather
fractions of parent size and compute.

Regards,
Carl

_______________________________________________
gtkmm-list mailing list
gtkmm-list@gnome.org
http://mail.gnome.org/mailman/listinfo/gtkmm-list
================================================================================

From: Hamar Gabor <hg307 () hszk ! bme ! hu>
To: gtkmm
Subject: Re: [gtkmm] simple question
Date: Sat, 24 Jul 2004 11:27:13 +0000
Message-ID: <20040724112713.GA439 () tragacs>
--------------------
On Fri, Jul 23, 2004 at 08:34:23PM -0400, Carl Nygard wrote:
> 
> 
> I know I'm going to feel like a dope, but how can I find out the size of
> a widget.  Gtk::Frame specifically?  I can only find a method for
> Gtk::Window.  I'm trying to set Paned widgets position relative to the
> parent's size, so I don't want to use the absolute coords but rather
> fractions of parent size and compute.
You can use these functions:
Gtk::Widget::get_width()
Gtk::Widget::get_height()
_______________________________________________
gtkmm-list mailing list
gtkmm-list@gnome.org
http://mail.gnome.org/mailman/listinfo/gtkmm-list
================================================================================


################################################################################

=== Thread: [j-nsp] simple question ===

From: =?iso-8859-1?q?snort=20bsd?= <snortbsd () yahoo ! com ! au>
To: juniper-nsp
Subject: [j-nsp] simple question
Date: Thu, 12 Aug 2004 22:35:21 +0000
Message-ID: <20040812223521.65682.qmail () web42004 ! mail ! yahoo ! com>
--------------------
hi all:

what is "system routes" in JUNOS?

thanks


Find local movie times and trailers on Yahoo! Movies.
http://au.movies.yahoo.com
_______________________________________________
juniper-nsp mailing list juniper-nsp@puck.nether.net
http://puck.nether.net/mailman/listinfo/juniper-nsp
================================================================================


################################################################################

=== Thread: [j-nsp] warning ===

From: Nicolas Fevrier <nicolas.fevrier () free ! fr>
To: juniper-nsp
Subject: Re: [j-nsp] warning
Date: Thu, 19 Feb 2004 20:30:22 +0000
Message-ID: <40351CDE.20403 () free ! fr>
--------------------
All,

this w32.netsky.B worm is getting annoying...  ;)
http://securityresponse.symantec.com/avcenter/venc/data/w32.netsky.b@mm.removal.tool.html
 
Cheers,

Nicolas.

>something is going wrong
>  
>
>------------------------------------------------------------------------
>
>_______________________________________________
>juniper-nsp mailing list juniper-nsp@puck.nether.net
>http://puck.nether.net/mailman/listinfo/juniper-nsp
>  
>




================================================================================


################################################################################

=== Thread: [patch][sparse] mention list and bk repo ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [patch][sparse] mention list and bk repo
Date: Sat, 29 May 2004 18:29:49 +0000
Message-ID: <40B8D69D.2050101 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------030109040803050000020303
Content-Type: text/plain; charset=ISO-8859-1; format=flowed
Content-Transfer-Encoding: 7bit


--------------030109040803050000020303
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== FAQ 1.3 vs edited =====
--- 1.3/FAQ	2003-04-02 14:22:53 -05:00
+++ edited/FAQ	2004-05-29 14:28:50 -04:00
@@ -84,3 +84,12 @@
     typed) constructs. Maybe somebody else who is working on projects
     where pre-ANSI C makes sense might be more inclined to care about
     ancient C.  It's open source, after all. Go wild.
+
+
+Q.  What other sparse resources are available?
+
+A.  Mailing list:  linux-sparse@vger.kernel.org
+    (email majordomo@vger.kernel.org to subscribe)
+
+    BitKeeper repository:  bk://sparse.bkbits.net/sparse
+

--------------030109040803050000020303--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [sparse PATCH] while loops ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse PATCH] while loops
Date: Tue, 17 Feb 2004 07:19:33 +0000
Message-ID: <20040217071933.GA31155 () 64m ! dyndns ! org>
--------------------
This patch fix a minor bug that loop_bottom symbol was not chained
to the basic blocks. You can see a "jz .L(nil)" in the while loop
test output. I let it use the iterator break instead.

I also notice that the while loop generate two same basic blocks
for pre statement and post statement. Is there any reason not to
reuse the same block?

Chris


Index: sparse-hack/linearize.c
===================================================================
--- sparse-hack.orig/linearize.c	2004-02-16 23:19:19.000000000 -0800
+++ sparse-hack/linearize.c	2004-02-17 00:56:39.000000000 -0800
@@ -247,13 +247,13 @@
 		if (pre_condition) {
 			if (pre_condition->type == EXPR_VALUE) {
 				if (!pre_condition->value) {
-					loop_bottom = alloc_symbol(stmt->pos, SYM_LABEL);
+					loop_bottom = stmt->iterator_break;
 					bb->next = loop_bottom;
 					bb = new_basic_block(bbs, loop_bottom);
 				}
 			} else {
 				struct statement *pre_cond = alloc_statement(stmt->pos, STMT_CONDFALSE);
-				loop_bottom = alloc_symbol(stmt->pos, SYM_LABEL);
+				loop_bottom = stmt->iterator_break;
 				pre_cond->bb_conditional = pre_condition;
 				pre_cond->bb_target = loop_bottom;
 				add_statement(&bb->stmts, pre_cond);
@@ -290,7 +290,7 @@
 			}
 		}
 
-		if (stmt->iterator_break->used) {
+		if (stmt->iterator_break->used || loop_bottom) {
 			struct basic_block *brk = new_basic_block(bbs, stmt->iterator_break);
 			bb->next = stmt->iterator_break;
 			bb = brk;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse be] PATCH: (take II) condition branch simplify ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 10:21:05 +0000
Message-ID: <20040414102105.GA9335 () 64m ! dyndns ! org>
--------------------
I has been two weeks since I submit the last one.

Here is the update version of the patch.

On Thu, Apr 01, 2004 at 11:36:51PM -0800, Linus Torvalds wrote:
> So I'd rather have a bit more complicated iterator flattening, if it means 
> that the iterator flattening does the right thing every time.
> 

I try to make it. Then I realize that the code will pretty much like
what it is right now. In stead I write some pass to stitch the basic
block. It does two things. If it is an empty block with goto,
it transfer the out going edge directly to the target.
If the only parent ends with goto, it combine with parent.

There is also the dead code elimination. So I remove the previous
entry point hack for while loops. There is no need for that.
The end result is that it generate very compact basic blocks,
often better than the current one.

The pass can be reuse for other back end pass.

> Ok. I definitely agree that it was a mistake to have separate instructions 
> for true/false. I tried to keep the size of "struct instruction" down to a 
> minimum, and you just made it grow by another pointer. Probably worth it.

I can make it the same by reuse the target pseudo.

> I'm ok with your changes, apart from the picky naming thing ("bound").

I fix that already.  I also did:
- add some lib functions to delete a point from the ptr_list while
  iterating.
- Ignore the label which is not used.
- some minor bug fix in the previous patch.

Know problem:
- it doesn't deal with phi correctly, I need to redo the phi base
  on Tommy's suggestion.

Any comment is welcome.

Chris

Index: sparse-be/linearize.h
===================================================================
--- sparse-be.orig/linearize.h	2004-03-31 23:50:22.000000000 -0800
+++ sparse-be/linearize.h	2004-04-14 01:41:53.000000000 -0700
@@ -20,11 +20,32 @@
 
 #define VOID (to_pseudo(0))
 
+struct multijmp {
+	struct basic_block *target;
+	int begin, end;
+};
+
+struct phi {
+	struct basic_block *source;
+	pseudo_t pseudo;
+};
+
 struct instruction {
 	struct symbol *type;
 	int opcode;
 	pseudo_t target;
 	union {
+		struct /* branch */ {
+			pseudo_t cond;
+			struct basic_block *bb_true, *bb_false;
+		};
+		struct /* switch */ {
+			pseudo_t switch_cond;
+			struct multijmp_list *multijmp_list;	/* switch */
+		};
+		struct /* phi_node */ {
+			struct phi_list *phi_list;
+		};
 		struct /* unops */ {
 			struct symbol *orig_type;	/* casts */
 			pseudo_t src;
@@ -42,18 +63,56 @@
 
 enum opcode {
 	OP_BADOP,
-	OP_CONDTRUE,
-	OP_CONDFALSE,
-	OP_SETVAL,
-	OP_MULTIVALUE,
-	OP_MULTIJUMP,
+	/* Terminator */
+	OP_RET,
+	OP_BR,
+	OP_SWITCH,
+	OP_INVOKE,
+	OP_UNWIND,
+	
+	/* Binary */
+	OP_ADD,
+	OP_SUB,
+	OP_MUL,
+	OP_DIV,
+	OP_REM,
+	OP_SHL,
+	OP_SHR,
+	
+	/* Logical */
+	OP_AND,
+	OP_OR,
+	OP_XOR,
+
+	/* Binary comparison */
+	OP_SET_EQ,
+	OP_SET_NE,
+	OP_SET_LE,
+	OP_SET_GE,
+	OP_SET_LT,
+	OP_SET_GT,
+	
+	/* Memory */
+	OP_MALLOC,
+	OP_FREE,
+	OP_ALLOCA,
 	OP_LOAD,
 	OP_STORE,
+	OP_SETVAL,
+	OP_GET_ELEMENT_PTR,
+
+	/* Other */
+	OP_PHI,
+	OP_CAST,
+	OP_CALL,
+	OP_VANEXT,
+	OP_VAARG,
+
+	/* The old op code */
+	OP_MULTIJUMP,
 	OP_MOVE,
 	OP_ARGUMENT,
-	OP_CALL,
 	OP_INDCALL,
-	OP_CAST,
 	OP_UNOP = 0x200,
 	OP_LASTUNOP = 0x3ff,
 	OP_BINOP = 0x400,
@@ -68,17 +127,19 @@
  * track (at build time) whether the basic block has been branched
  * out of yet. 
  */
-#define BB_HASBRANCH	0x00000001
-
-#define EP_HASLABEL	0x00000001
+#define BB_REACHABLE	0x00000001
 
 struct basic_block {
 	unsigned long flags;		/* BB status flags */
-	struct symbol *this;		/* Points to the symbol that owns "this" basic block - NULL if unreachable */
+	struct basic_block_list *parents; /* sources */
 	struct instruction_list *insns;	/* Linear list of instructions */
-	struct symbol *next;		/* Points to the symbol that describes the fallthrough */
 };
 
+static inline int is_branch_goto(struct instruction *br)
+{
+	return br && br->opcode==OP_BR && (!br->bb_true || !br->bb_false);
+}
+
 static inline void add_bb(struct basic_block_list **list, struct basic_block *bb)
 {
 	add_ptr_list((struct ptr_list **)list, bb);
@@ -89,8 +150,31 @@
 	add_ptr_list((struct ptr_list **)list, insn);
 }
 
+static inline void add_multijmp(struct multijmp_list **list, struct multijmp *multijmp)
+{
+	add_ptr_list((struct ptr_list **)list, multijmp);
+}
+
+static inline void add_phi(struct phi_list **list, struct phi *phi)
+{
+	add_ptr_list((struct ptr_list **)list, phi);
+}
+
+static inline int bb_terminated(struct basic_block *bb)
+{
+	struct instruction *insn;
+	if (!bb)
+		return 0;
+	insn = last_instruction(bb->insns);
+	return insn && insn->opcode >= OP_RET && insn->opcode <= OP_UNWIND;
+}
+
+static inline int bb_reachable(struct basic_block *bb)
+{
+	return bb && (bb->parents || (bb->flags & BB_REACHABLE));
+}
+
 struct entrypoint {
-	unsigned long flags;		/* entry point status flags */
 	struct symbol *name;
 	struct symbol_list *syms;
 	struct basic_block_list *bbs;
Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-03-31 23:50:22.000000000 -0800
+++ sparse-be/linearize.c	2004-04-14 01:59:00.000000000 -0700
@@ -7,6 +7,7 @@
  * subroutine calls. That's all "local" behaviour.
  *
  * Copyright (C) 2004 Linus Torvalds
+ * Copyright (C) 2004 Christopher Li
  */
 
 #include <string.h>
@@ -39,6 +40,23 @@
 	return __alloc_basic_block(0);
 }
 
+static struct multijmp* alloc_multijmp(struct basic_block *target, int begin, int end)
+{
+	struct multijmp *multijmp = __alloc_multijmp(0);
+	multijmp->target = target;
+	multijmp->begin = begin;
+	multijmp->end = end;
+	return multijmp;
+}
+
+static struct phi* alloc_phi(struct basic_block *source, pseudo_t pseudo)
+{
+	struct phi *phi = __alloc_phi(0);
+	phi->source = source;
+	phi->pseudo = pseudo;
+	return phi;
+}
+
 static void show_instruction(struct instruction *insn)
 {
 	int op = insn->opcode;
@@ -47,11 +65,14 @@
 	case OP_BADOP:
 		printf("\tAIEEE! (%d %d)\n", insn->target.nr, insn->src.nr);
 		break;
-	case OP_CONDTRUE: case OP_CONDFALSE:
-		printf("\t%s %%r%d,%p\n",
-			op == OP_CONDTRUE ? "jne" : "jz",
-			insn->target.nr, insn->address->bb_target);
+	case OP_BR:
+		if (insn->bb_true && insn->bb_false) {
+			printf("\tbr\t%%r%d, .L%p, .L%p\n", insn->cond.nr, insn->bb_true, insn->bb_false);
+			break;
+		}
+		printf("\tbr\t.L%p\n", insn->bb_true ? insn->bb_true : insn->bb_false);
 		break;
+
 	case OP_SETVAL: {
 		struct expression *expr = insn->val;
 		switch (expr->type) {
@@ -72,21 +93,38 @@
 		}
 		break;
 	}
-	case OP_MULTIVALUE:
-		printf("\tswitch %%r%d\n", insn->target.nr);
+	case OP_SWITCH: {
+		struct multijmp *jmp;
+		printf("\tswitch %%r%d", insn->target.nr);
+		FOR_EACH_PTR(insn->multijmp_list, jmp) {
+			if (jmp->begin == jmp->end)
+				printf(", %d -> .L%p", jmp->begin, jmp->target);
+			else if (jmp->begin < jmp->end)
+				printf(", %d ... %d -> .L%p", jmp->begin, jmp->end, jmp->target);
+			else
+				printf(", default -> .L%p\n", jmp->target);
+		} END_FOR_EACH_PTR;
+		printf("\n");
 		break;
-	case OP_MULTIJUMP:
-		printf("\tcase %d ... %d -> %p\n", insn->begin, insn->end, insn->type);
+	}
+	
+	case OP_PHI: {
+		struct phi *phi;
+		char *s = " ";
+		printf("\t%%r%d <- phi", insn->target.nr);
+		FOR_EACH_PTR(insn->phi_list, phi) {
+			printf("%s(%%r%d, .L%p)", s, phi->pseudo.nr, phi->source);
+			s = ", ";
+		} END_FOR_EACH_PTR;
+		printf("\n");
 		break;
+	}	
 	case OP_LOAD:
 		printf("\tload %%r%d <- [%%r%d]\n", insn->target.nr, insn->src.nr);
 		break;
 	case OP_STORE:
 		printf("\tstore %%r%d -> [%%r%d]\n", insn->target.nr, insn->src.nr);
 		break;
-	case OP_MOVE:
-		printf("\t%%r%d <- %%r%d\n", insn->target.nr, insn->src.nr);
-		break;
 	case OP_ARGUMENT:
 		printf("\tpush %%r%d\n", insn->src.nr);
 		break;
@@ -120,24 +158,19 @@
 static void show_bb(struct basic_block *bb)
 {
 	struct instruction *insn;
-	struct symbol *owner = bb->this;
 
-	printf("bb: %p%s\n", bb, owner ? "" : " UNREACHABLE!!");
-	if (owner) {
+	printf("bb: %p\n", bb);
+	if (bb->parents) {
 		struct basic_block *from;
-		FOR_EACH_PTR(owner->bb_parents, from) {
+		FOR_EACH_PTR(bb->parents, from) {
 			printf("  **from %p**\n", from);
 		} END_FOR_EACH_PTR;
 	}
 	FOR_EACH_PTR(bb->insns, insn) {
 		show_instruction(insn);
 	} END_FOR_EACH_PTR;
-
-	if (bb->next) {
-		printf("\tgoto\t\t.L%p\n", bb->next->bb_target);
-	} else {
+	if (!bb_terminated(bb))
 		printf("\tEND\n");
-	}
 	printf("\n");
 }
 
@@ -161,90 +194,67 @@
 	printf("\n");
 }
 
-#define bb_reachable(bb) ((bb)->this != NULL)
-#define ep_haslabel(ep) ((ep)->flags & EP_HASLABEL)
-
-static struct basic_block * new_basic_block(struct entrypoint *ep, struct symbol *owner)
+static void bind_label(struct symbol *label, struct basic_block *bb, struct position pos)
 {
-	struct basic_block *bb;
-
-	if (!owner) {
-		static struct basic_block unreachable;
-		return &unreachable;
-	}
-		
-	bb = alloc_basic_block();
-	add_bb(&ep->bbs, bb);
-	bb->this = owner;
-	if (owner->bb_target)
-		warn(owner->pos, "Symbol already has a basic block %p", owner->bb_target);
-	owner->bb_target = bb;
-	return bb;
+	if (label->bb_target)
+		warn(pos, "label already bound\n");
+	label->bb_target = bb;
 }
 
-static void add_goto(struct basic_block *bb, struct symbol *sym)
+static struct basic_block * get_bound_block(struct entrypoint *ep, struct symbol *label)
 {
-	if (bb_reachable(bb)) {
-		bb->next = sym;
-		add_bb(&sym->bb_parents, bb);
-	}
-}
-
-static void add_label(struct entrypoint *ep, struct symbol *sym)
-{
-	struct basic_block *new_bb = new_basic_block(ep, sym);
-	struct basic_block *bb = ep->active;
+	struct basic_block *bb = label->bb_target;
 
-	add_goto(bb, sym);
-	ep->active = new_bb;
+	if (!bb) {
+		label->bb_target = bb = alloc_basic_block();
+		bb->flags |= BB_REACHABLE;
+	}
+	return bb;
 }
 
-/*
- * Add a anonymous label, return the symbol for it..
- *
- * If we already have a label for the top of the active
- * context, we can just re-use it.
- */
-static struct symbol *create_label(struct entrypoint *ep, struct position pos)
+static void add_goto(struct entrypoint *ep, struct basic_block *dst)
 {
-	struct basic_block *bb = ep->active;
-	struct symbol *label = bb->this;
-
-	if (!bb_reachable(bb) || !ptr_list_empty(bb->insns)) {
-		label = alloc_symbol(pos, SYM_LABEL);
-		add_label(ep, label);
+	struct basic_block *src = ep->active;
+	if (bb_reachable(src)) {
+		struct instruction *br = alloc_instruction(OP_BR, NULL);
+		br->bb_true = dst;
+		add_bb(&dst->parents, src);
+		add_instruction(&src->insns, br);
+		ep->active = NULL;
 	}
-	return label;
 }
 
 static void add_one_insn(struct entrypoint *ep, struct position pos, struct instruction *insn)
 {
 	struct basic_block *bb = ep->active;    
 
-	if (bb_reachable(bb)) {
-		if (bb->flags & BB_HASBRANCH) {
-			add_label(ep, alloc_symbol(pos, SYM_LABEL));
-			bb = ep->active;
-		}
+	if (bb_reachable(bb))
 		add_instruction(&bb->insns, insn);
-	}
 }
 
-static void set_unreachable(struct entrypoint *ep)
+static void set_activeblock(struct entrypoint *ep, struct basic_block *bb)
 {
-	ep->active = new_basic_block(ep, NULL);
+	if (!bb_terminated(ep->active))
+		add_goto(ep, bb);
+
+	ep->active = bb;
+	if (bb_reachable(bb))
+		add_bb(&ep->bbs, bb);
 }
 
-static void add_branch(struct entrypoint *ep, int opcode, struct expression *cond, struct symbol *target)
+static void add_branch(struct entrypoint *ep, struct expression *expr, pseudo_t cond, struct basic_block *bb_true, struct basic_block *bb_false)
 {
 	struct basic_block *bb = ep->active;
+	struct instruction *br;
 
 	if (bb_reachable(bb)) {
-		struct instruction *jump = alloc_instruction(opcode, target);
-		jump->address = target;
-		bb->flags |= BB_HASBRANCH;
-		add_instruction(&bb->insns, jump);
-		add_bb(&target->bb_parents, bb);
+       		br = alloc_instruction(OP_BR, expr->ctype);
+		br->cond = cond;
+		br->bb_true = bb_true;
+		br->bb_false = bb_false;
+		add_bb(&bb_true->parents, bb);
+		add_bb(&bb_false->parents, bb);
+		add_one_insn(ep, expr->pos, br);
 	}
 }
 
@@ -442,44 +452,93 @@
 	return result;
 }
 
-static void cond_branch(struct entrypoint *ep, int op, struct symbol *ctype, pseudo_t pseudo, struct symbol *target)
+static pseudo_t linearize_logical_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false);
+
+pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false);
+
+static pseudo_t linearize_logical(struct entrypoint *ep, struct expression *expr)
 {
+	pseudo_t src1, src2, target;
+	struct basic_block *bb_true = alloc_basic_block();
+	struct basic_block *bb_false = alloc_basic_block();
+	struct basic_block *merge = alloc_basic_block();
+	struct basic_block *first = bb_true;
+	struct basic_block *second = bb_false;
 	struct instruction *insn;
-	struct basic_block *bb = ep->active;
 
-	insn = alloc_instruction(op, ctype);
-	insn->address = target;
-	bb->flags |= BB_HASBRANCH;
-	add_instruction(&bb->insns, insn);
-	add_bb(&target->bb_parents, bb);
-}
+	if (expr->op == SPECIAL_LOGICAL_OR) {
+		first = bb_false;
+		second = bb_true;
+	}
 
-static void copy_pseudo(struct entrypoint *ep, struct expression *expr, pseudo_t old, pseudo_t new)
-{
-	struct instruction *insn = alloc_instruction(OP_MOVE, expr->ctype);
-	insn->target = new;
-	insn->src = old;
-	add_one_insn(ep, expr->pos, insn);
+	linearize_cond_branch(ep, expr->left, bb_true, bb_false);
+
+	set_activeblock(ep, first);
+	src1 = linearize_expression(ep, expr->right);
+	add_goto(ep, merge);
+
+	set_activeblock(ep, second);
+       	insn = alloc_instruction(OP_SETVAL, expr->ctype);
+	insn->target = src2 = alloc_pseudo();
+	insn->val = alloc_const_expression(expr->pos, expr->op == SPECIAL_LOGICAL_OR);
+	add_one_insn(ep, expr->pos,insn);
+
+	set_activeblock(ep, merge);
+
+	if (bb_reachable(bb_true) && bb_reachable(bb_false)) {
+		struct instruction *phi_node = alloc_instruction(OP_PHI, expr->ctype);
+		add_phi(&phi_node->phi_list, alloc_phi(first, src1));
+		add_phi(&phi_node->phi_list, alloc_phi(second, src2));
+		phi_node->target = target = alloc_pseudo();
+		add_one_insn(ep, expr->pos, phi_node);
+		set_activeblock(ep, alloc_basic_block());
+		return target;
+	}
+
+	return bb_reachable(first) ? src1 : src2;
 }
 
-static pseudo_t linearize_logical(struct entrypoint *ep, struct expression *expr)
+pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false)
 {
-	pseudo_t src1, src2, result;
-	struct symbol *label;
-	int op = (expr->op == SPECIAL_LOGICAL_OR) ? OP_CONDTRUE : OP_CONDFALSE;
+	if (!expr || !bb_reachable(ep->active))
+		return VOID;
 
-	src1 = linearize_expression(ep, expr->left);
-	result = alloc_pseudo();
-	copy_pseudo(ep, expr, src1, result);
+	switch (expr->type) {
+
+	case EXPR_STRING:
+	case EXPR_VALUE:
+		add_goto(ep, expr->value ? bb_true : bb_false);
+		return VOID;
+		
+	case EXPR_LOGICAL:
+		linearize_logical_branch(ep, expr, bb_true, bb_false);
+		return VOID;
 
-	/* Conditional jump */
-	label = alloc_symbol(expr->pos, SYM_LABEL);
-	cond_branch(ep, op, expr->ctype, src1, label);
+	case EXPR_PREOP:
+		if (expr->op == '!')
+			return linearize_cond_branch(ep, expr->unop, bb_false, bb_true);
+		/* fall through */
+	default: {
+		pseudo_t cond = linearize_expression(ep, expr);
+		add_branch(ep, expr, cond, bb_true, bb_false);
 
-	src2 = linearize_expression(ep, expr->right);
-	copy_pseudo(ep, expr, src2, result);
-	add_label(ep, label);
-	return result;
+		return VOID;
+	}
+	}
+	return VOID;
+}
+
+static pseudo_t linearize_logical_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false)
+{
+	struct basic_block *next = alloc_basic_block();
+
+	if (expr->op == SPECIAL_LOGICAL_OR)
+		linearize_cond_branch(ep, expr->left, bb_true, next);
+	else
+		linearize_cond_branch(ep, expr->left, next, bb_false);
+	set_activeblock(ep, next);
+	linearize_cond_branch(ep, expr->right, bb_true, bb_false);
+	return VOID;
 }
 
 pseudo_t linearize_cast(struct entrypoint *ep, struct expression *expr)
@@ -570,26 +629,30 @@
 
 	case STMT_RETURN: {
 		pseudo_t pseudo = linearize_expression(ep, stmt->expression);
-		set_unreachable(ep);
 		return pseudo;
 	}
 
 	case STMT_CASE: {
-		add_label(ep, stmt->case_label);
+		struct basic_block *bb = get_bound_block(ep, stmt->case_label);
+		set_activeblock(ep, bb);
 		linearize_statement(ep, stmt->case_statement);
 		break;
 	}
 
 	case STMT_LABEL: {
-		add_label(ep, stmt->label_identifier);
-		ep->flags |= EP_HASLABEL;
-		linearize_statement(ep, stmt->label_statement);
+		struct symbol *label = stmt->label_identifier;
+		struct basic_block *bb;
+
+		if (label->used) {
+			bb = get_bound_block(ep, stmt->label_identifier);
+			set_activeblock(ep, bb);
+			linearize_statement(ep, stmt->label_statement);
+		}
 		break;
 	}
 
 	case STMT_GOTO: {
-		add_goto(ep->active, stmt->goto_label);
-		set_unreachable(ep);
+		add_goto(ep, get_bound_block(ep, stmt->goto_label));
 		break;
 	}
 
@@ -608,99 +671,66 @@
 	 * switch the arms around appropriately..
 	 */
 	case STMT_IF: {
-		struct symbol *target;
-		struct basic_block *if_block;
-		struct expression *cond = stmt->if_conditional;
-
-		if (cond->type == EXPR_VALUE) {
-			struct statement *always = stmt->if_true;
-			struct statement *never = stmt->if_false;
-
-			if (!cond->value) {
-				never = always;
-				always = stmt->if_false;
-			}
-			if (always)
-				linearize_statement(ep, always);
-			if (never) {
-				struct basic_block *bb = ep->active;
-				set_unreachable(ep);
-				linearize_statement(ep, never);
-
-				/*
-				 * If the "never case" is reachable some other
-				 * way, we need to merge the old always case
-				 * with the fallthrough of the never case.
-				 */
-				if (bb_reachable(ep->active)) {
-					add_goto(bb, create_label(ep, never->pos));
-					break;
-				}
-
-				/* Otherwise we just continue with the old always case.. */
-				ep->active = bb;
-			}
-			break;
-		}
-			
+		struct basic_block *bb_true, *bb_false, *endif;
+ 		struct expression *cond = stmt->if_conditional;
 
-		target = alloc_symbol(stmt->pos, SYM_LABEL);
-		add_branch(ep, OP_CONDFALSE, cond, target);
+		bb_true = alloc_basic_block();
+		bb_false = endif = alloc_basic_block();
 
-		linearize_statement(ep, stmt->if_true);
+ 		linearize_cond_branch(ep, cond, bb_true, bb_false);
 
-		if_block = ep->active;
-		add_label(ep, target);
-		
-		if (stmt->if_false) {
-			struct symbol *else_target = alloc_symbol(stmt->pos, SYM_LABEL);
-			add_goto(if_block, else_target);
-			linearize_statement(ep, stmt->if_false);
-			add_label(ep, else_target);
+		set_activeblock(ep, bb_true);
+ 		linearize_statement(ep, stmt->if_true);
+ 
+ 		if (stmt->if_false) {
+			endif = alloc_basic_block();
+			add_goto(ep, endif);
+			set_activeblock(ep, bb_false);
+ 			linearize_statement(ep, stmt->if_false);
 		}
+		set_activeblock(ep, endif);
 		break;
 	}
 
 	case STMT_SWITCH: {
-		int default_seen;
 		struct symbol *sym;
-		struct instruction *switch_value;
+		struct instruction *switch_ins;
+		struct basic_block *switch_end = alloc_basic_block();
 		pseudo_t pseudo;
 
-		/* Create the "head node" */
-		if (!bb_reachable(ep->active))
-			break;
-
 		pseudo = linearize_expression(ep, stmt->switch_expression);
-		switch_value = alloc_instruction(OP_MULTIVALUE, NULL);
-		switch_value->target = pseudo;
-		add_one_insn(ep, stmt->pos, switch_value);
+		switch_ins = alloc_instruction(OP_SWITCH, NULL);
+		switch_ins->target = pseudo;
+		add_one_insn(ep, stmt->pos, switch_ins);
 
-		/* Create all the sub-jumps */
-		default_seen = 0;
 		FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
 			struct statement *case_stmt = sym->stmt;
-			struct instruction *sw_bb = alloc_instruction(OP_MULTIJUMP, sym);
-			if (!case_stmt->case_expression)
-				default_seen = 1;
-			if (case_stmt->case_expression)
-				sw_bb->begin = case_stmt->case_expression->value;
-			if (case_stmt->case_to)
-				sw_bb->end = case_stmt->case_to->value;
-			add_one_insn(ep, stmt->pos, sw_bb);
-			add_bb(&sym->bb_parents, ep->active);
+			struct basic_block *bb_case = get_bound_block(ep, sym);
+			struct multijmp *jmp;
+			int begin, end;
+			if (!case_stmt->case_expression) {
+			      jmp = alloc_multijmp(bb_case, 1, 0);
+			} else {
+				if (case_stmt->case_expression)
+					begin = end = case_stmt->case_expression->value;
+				if (case_stmt->case_to)
+					end = case_stmt->case_to->value;
+				if (begin > end)
+					jmp = alloc_multijmp(bb_case, end, begin);
+				else
+					jmp = alloc_multijmp(bb_case, begin, end);
+
+			}
+			add_multijmp(&switch_ins->multijmp_list, jmp);
+			add_bb(&bb_case->parents, ep->active);
 		} END_FOR_EACH_PTR;
 
-		/* Default fall-through case */
-		if (!default_seen)
-			add_goto(ep->active, stmt->switch_break);
-		set_unreachable(ep);
+		bind_label(stmt->switch_break, switch_end, stmt->pos);
 
 		/* And linearize the actual statement */
 		linearize_statement(ep, stmt->switch_statement);
+		set_activeblock(ep, switch_end);
 
-		/* ..then tie it all together at the end.. */
-		add_label(ep, stmt->switch_break);
 		break;
 	}
 
@@ -710,70 +740,44 @@
 		struct statement  *statement = stmt->iterator_statement;
 		struct statement  *post_statement = stmt->iterator_post_statement;
 		struct expression *post_condition = stmt->iterator_post_condition;
-		struct symbol *loop_top = NULL, *loop_bottom = NULL;
-		struct entrypoint *oldep = NULL;
-
-		if (!bb_reachable(ep->active)) {
-			oldep = ep;
-			ep = alloc_entrypoint();
-			ep->active = oldep->active;
-		}
+		struct basic_block *loop_top, *loop_body, *loop_continue, *loop_end;
 
 		concat_symbol_list(stmt->iterator_syms, &ep->syms);
 		linearize_statement(ep, pre_statement);
-		if (pre_condition && bb_reachable(ep->active)) {
-			if (pre_condition->type == EXPR_VALUE) {
-				if (!pre_condition->value) {
-					loop_bottom = alloc_symbol(stmt->pos, SYM_LABEL);
-					add_goto(ep->active, loop_bottom);
-					set_unreachable(ep);
-				}
-			} else {
-				loop_bottom = alloc_symbol(stmt->pos, SYM_LABEL);
-				add_branch(ep, OP_CONDFALSE, pre_condition, loop_bottom);
-			}
-		}
 
-		if (!post_condition || post_condition->type != EXPR_VALUE || post_condition->value)
-			loop_top = create_label(ep, stmt->pos);
+ 		loop_body = loop_top = alloc_basic_block();
+ 		loop_continue = alloc_basic_block();
+ 		loop_end = alloc_basic_block();
+ 
+		if (!post_statement && (pre_condition == post_condition)) {
+			/*
+			 * If it is a while loop, optimize away the post_condition.
+			 */
+			post_condition = NULL;
+			loop_body = loop_continue;
+			loop_continue = loop_top;
+			loop_top->flags |= BB_REACHABLE;
+			set_activeblock(ep, loop_top);
+		}
 
-		linearize_statement(ep, statement);
+		loop_top->flags |= BB_REACHABLE;
+		if (pre_condition) 
+ 			linearize_cond_branch(ep, pre_condition, loop_body, loop_end);
 
-		if (stmt->iterator_continue->used)
-			add_label(ep, stmt->iterator_continue);
+		bind_label(stmt->iterator_continue, loop_continue, stmt->pos);
+		bind_label(stmt->iterator_break, loop_end, stmt->pos);
 
-		linearize_statement(ep, post_statement);
+		set_activeblock(ep, loop_body);
+		linearize_statement(ep, statement);
+		add_goto(ep, loop_continue);
 
-		if (!post_condition) {
-			add_goto(ep->active, loop_top);
-			set_unreachable(ep);
-		} else {
-			if (post_condition->type == EXPR_VALUE) {
-				if (post_condition->value) {
-					add_goto(ep->active, loop_top);
-					set_unreachable(ep);
-				}
-			} else
-				add_branch(ep, OP_CONDTRUE, post_condition, loop_top);
+		if (post_condition) {
+			set_activeblock(ep, loop_continue);
+			linearize_statement(ep, post_statement);
+ 			linearize_cond_branch(ep, post_condition, loop_top, loop_end);
 		}
 
-		if (stmt->iterator_break->used)
-			add_label(ep, stmt->iterator_break);
-		if (loop_bottom)
-			add_label(ep, loop_bottom);
-
-		/*
-		 * If we started out unreachable, maybe the inside
-		 * of the loop is still reachable?
-		 */
-		if (oldep) {
-			if (ep_haslabel(ep)) {
-				concat_basic_block_list(ep->bbs, &oldep->bbs);
-				concat_symbol_list(ep->syms, &oldep->syms);
-				oldep->active = ep->active;
-			}
-			ep = oldep;
-		}
+		set_activeblock(ep, loop_end);
 		break;
 	}
 
@@ -783,6 +787,102 @@
 	return VOID;
 }
 
+void mark_bb_reachable(struct basic_block *bb)
+{
+	struct basic_block *child;
+	struct terminator_iterator term;
+	struct basic_block_list *bbstack = NULL;
+
+	if (!bb || bb->flags & BB_REACHABLE)
+		return;
+
+	add_bb(&bbstack, bb);
+	while (bbstack) {
+		bb = delete_last_basic_block(&bbstack);
+		if (bb->flags & BB_REACHABLE)
+			continue;
+		bb->flags |= BB_REACHABLE;
+		init_terminator_iterator(last_instruction(bb->insns), &term);
+		while ((child=next_terminator_bb(&term))) {
+			if (!(child->flags & BB_REACHABLE))
+				add_bb(&bbstack, child);
+		}
+	}
+}
+
+void remove_unreachable_bbs(struct basic_block_list **bblist)
+{
+	struct basic_block *bb, *child;
+	struct list_iterator iterator;
+	struct terminator_iterator term;
+
+	init_iterator((struct ptr_list **) bblist, &iterator, 0);
+	while((bb=next_basic_block(&iterator)))
+		bb->flags &= ~BB_REACHABLE;
+
+	init_iterator((struct ptr_list **) bblist, &iterator, 0);
+	mark_bb_reachable(next_basic_block(&iterator));
+	while((bb=next_basic_block(&iterator))) {
+		if (bb->flags & BB_REACHABLE)
+			continue;
+		init_terminator_iterator(last_instruction(bb->insns), &term);
+		while ((child=next_terminator_bb(&term)))
+			replace_basic_block_list(&child->parents, bb, NULL);
+		delete_iterator(&iterator);
+	}
+}
+
+void pack_basic_blocks(struct basic_block_list **bblist)
+{
+	struct basic_block *child, *bb, *parent;
+	struct list_iterator iterator;
+	struct terminator_iterator term;
+	struct instruction *jmp;
+
+	remove_unreachable_bbs(bblist);
+	init_bb_iterator(bblist, &iterator, 0);
+	while((bb=next_basic_block(&iterator))) {
+		if (is_branch_goto(jmp=first_instruction(bb->insns))) {
+			/*
+			 * This is an empty goto block. Transfer the parents' terminator
+			 * to target directly.
+			 */
+			struct list_iterator it_parents;
+			struct basic_block *target;
+
+			target = jmp->bb_true ? jmp->bb_true : jmp->bb_false;
+			replace_basic_block_list(&target->parents, bb, NULL);
+			init_bb_iterator(&bb->parents, &it_parents, 0);
+			while((parent=next_basic_block(&it_parents))) {
+				init_terminator_iterator(last_instruction(parent->insns), &term);
+				while ((child=next_terminator_bb(&term))) {
+					if (child == bb) {
+						replace_terminator_bb(&term, target);
+						add_bb(&target->parents, parent);
+					}
+				}
+			}
+			delete_iterator(&iterator);
+			continue;
+		}
+		
+		if (bb_list_size(bb->parents)!=1)
+		       continue;
+		parent = first_basic_block(bb->parents);
+		if (parent!=bb && is_branch_goto(last_instruction(parent->insns))) {
+			/*
+			 * Combine this block with the parent.
+			 */
+			delete_last_instruction(&parent->insns);
+			concat_instruction_list(bb->insns, &parent->insns);
+			init_terminator_iterator(last_instruction(bb->insns), &term);
+			while ((child=next_terminator_bb(&term)))
+				replace_basic_block_list(&child->parents, bb, parent);
+			delete_iterator(&iterator);
+		}
+	}
+}
+
 void linearize_symbol(struct symbol *sym)
 {
 	struct symbol *base_type;
@@ -795,11 +895,14 @@
 	if (base_type->type == SYM_FN) {
 		if (base_type->stmt) {
 			struct entrypoint *ep = alloc_entrypoint();
+			struct basic_block *bb = alloc_basic_block();
 
 			ep->name = sym;
-			ep->active = new_basic_block(ep, sym);
+			bb->flags |= BB_REACHABLE;
+			set_activeblock(ep, bb);
 			concat_symbol_list(base_type->arguments, &ep->syms);
 			linearize_statement(ep, base_type->stmt);
+			pack_basic_blocks(&ep->bbs);
 			show_entry(ep);
 		}
 	}
Index: sparse-be/symbol.h
===================================================================
--- sparse-be.orig/symbol.h	2004-03-31 23:50:22.000000000 -0800
+++ sparse-be/symbol.h	2004-04-14 01:41:53.000000000 -0700
@@ -95,7 +95,6 @@
 		struct symbol_list *symbol_list;
 		struct expression *initializer;
 		struct basic_block *bb_target;	/* label */
-		struct basic_block_list *bb_parents; /* sources */
 		long long value;		/* Initial value */
 	};
 	void *aux;				/* Auxiliary info, eg. backend information */
Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-04-01 01:37:44.000000000 -0800
+++ sparse-be/lib.h	2004-04-14 01:50:31.000000000 -0700
@@ -32,6 +32,8 @@
 struct basic_block_list;
 struct entrypoint;
 struct instruction;
+struct instruction_list;
+struct multijmp;
 
 struct token *skip_to(struct token *, int);
 struct token *expect(struct token *, int, const char *);
@@ -55,6 +57,8 @@
 DECLARE_ALLOCATOR(basic_block);
 DECLARE_ALLOCATOR(entrypoint);
 DECLARE_ALLOCATOR(instruction);
+DECLARE_ALLOCATOR(multijmp);
+DECLARE_ALLOCATOR(phi);
 
 
 #define LIST_NODE_NR (29)
@@ -66,12 +70,46 @@
 	void *list[LIST_NODE_NR];
 };
 
+struct list_iterator {
+	struct ptr_list **head;
+	struct ptr_list *active;
+	int index;
+	unsigned int flags;
+};
+
+enum iterator_br_state {
+	BR_INIT,
+	BR_TRUE,
+	BR_FALSE,
+	BR_END,
+};
+
+struct terminator_iterator {
+	struct instruction *terminator;
+	union {
+		struct list_iterator multijmp;
+		int branch;
+	};
+};
+
+#define ITERATOR_BACKWARDS 1
+#define ITERATOR_CURRENT 2
+
 #define ITERATE_FIRST 1
 #define ITERATE_LAST 2
 
 #define ptr_list_empty(x) ((x) == NULL)
 
 void iterate(struct ptr_list *,void (*callback)(void *, void *, int), void*);
+void init_iterator(struct ptr_list **head, struct list_iterator *iterator, int flags);
+void * next_iterator(struct list_iterator *iterator);
+void delete_iterator(struct list_iterator *iterator);
+void init_terminator_iterator(struct instruction* terminator, struct terminator_iterator *iterator);
+struct basic_block* next_terminator_bb(struct terminator_iterator *iterator);
+void replace_terminator_bb(struct terminator_iterator *iterator, struct basic_block* bb);
+void * delete_ptr_list_last(struct ptr_list **head);
+int replace_ptr_list(struct ptr_list **head, void *old_ptr, void *new_ptr);
+
 extern void add_ptr_list(struct ptr_list **, void *);
 extern void concat_ptr_list(struct ptr_list *a, struct ptr_list **b);
 extern void free_ptr_list(struct ptr_list **);
@@ -90,6 +128,73 @@
 #define symbol_list_size(list) ptr_list_size((struct ptr_list *)(list))
 #define statement_list_size(list) ptr_list_size((struct ptr_list *)(list))
 #define expression_list_size(list) ptr_list_size((struct ptr_list *)(list))
+#define instruction_list_size(list) ptr_list_size((struct ptr_list *)(list))
+#define bb_list_size(list) ptr_list_size((struct ptr_list *)(list))
+
+
+#define init_multijmp_iterator(list, iterator, flags) init_iterator((struct ptr_list **)(list), (iterator), (flags))
+
+#define next_basic_block(iterator) (struct basic_block*) next_iterator(iterator)
+#define next_multijmp(iterator) (struct multijmp*) next_iterator(iterator)
+
+void * next_iterator(struct list_iterator *iterator);
+
+static inline void init_bb_iterator(struct basic_block_list **head, struct list_iterator *iterator, int flags)
+{
+	init_iterator((struct ptr_list **)head, iterator, flags);
+}
+
+static inline struct instruction * delete_last_instruction(struct instruction_list **head)
+{
+	return delete_ptr_list_last((struct ptr_list **)head);
+}
+
+static inline struct basic_block * delete_last_basic_block(struct basic_block_list **head)
+{
+	return delete_ptr_list_last((struct ptr_list **)head);
+}
+
+
+static inline void *first_ptr_list(struct ptr_list *list)
+{
+	if (!list)
+		return NULL;
+	return list->list[0];
+}
+
+static inline void *last_ptr_list(struct ptr_list *list)
+{
+
+	if (!list)
+		return NULL;
+	list = list->prev;
+	return list->list[list->nr-1];
+}
+
+static inline void * current_iterator(struct list_iterator *iterator)
+{
+	struct ptr_list *list = iterator->active;
+	return list ? list->list[iterator->index] : NULL;
+}
+
+static inline struct basic_block *first_basic_block(struct basic_block_list *head)
+{
+	return last_ptr_list((struct ptr_list *)head);
+}
+static inline struct instruction *last_instruction(struct instruction_list *head)
+{
+	return last_ptr_list((struct ptr_list *)head);
+}
+
+static inline struct instruction *first_instruction(struct instruction_list *head)
+{
+	return first_ptr_list((struct ptr_list *)head);
+}
+
+static inline int replace_basic_block_list(struct basic_block_list **head, struct basic_block *from, struct basic_block *to)
+{
+	return replace_ptr_list((struct ptr_list **)head, (void*)from, (void*)to);
+}
 
 static inline void concat_symbol_list(struct symbol_list *from, struct symbol_list **to)
 {
@@ -101,6 +206,11 @@
 	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
 }
 
+static inline void concat_instruction_list(struct instruction_list *from, struct instruction_list **to)
+{
+	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
+}
+
 static inline void add_symbol(struct symbol_list **list, struct symbol *sym)
 {
 	add_ptr_list((struct ptr_list **)list, sym);
Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-03-16 01:17:24.000000000 -0800
+++ sparse-be/lib.c	2004-04-14 01:50:56.000000000 -0700
@@ -159,6 +159,8 @@
 struct allocator_struct basic_block_allocator = { "basic_block", NULL, __alignof__(struct basic_block), CHUNK };
 struct allocator_struct entrypoint_allocator = { "entrypoint", NULL, __alignof__(struct entrypoint), CHUNK };
 struct allocator_struct instruction_allocator = { "instruction", NULL, __alignof__(struct instruction), CHUNK };
+struct allocator_struct multijmp_allocator = { "multijmp", NULL, __alignof__(struct multijmp), CHUNK };
+struct allocator_struct phi_allocator = { "phi", NULL, __alignof__(struct phi), CHUNK };
 
 #define __ALLOCATOR(type, size, x)				\
 	type *__alloc_##x(int extra)				\
@@ -180,6 +182,8 @@
 ALLOCATOR(scope); __ALLOCATOR(void, 0, bytes);
 ALLOCATOR(basic_block); ALLOCATOR(entrypoint);
 ALLOCATOR(instruction);
+ALLOCATOR(multijmp);
+ALLOCATOR(phi);
 
 int ptr_list_size(struct ptr_list *head)
 {
@@ -242,6 +246,206 @@
 	last->nr = nr;
 }
 
+void init_iterator(struct ptr_list **head, struct list_iterator *iterator, int flags)
+{
+	iterator->head = head;
+	iterator->index = 0;
+	iterator->active = NULL;
+	iterator->flags = flags;
+}
+
+void * next_iterator(struct list_iterator *iterator)
+{
+	struct ptr_list *list = iterator->active;
+	int index;
+
+	if (!list) {
+		if (*iterator->head==NULL)
+			return NULL;
+
+		list = *iterator->head;
+		iterator->index = 0;
+		if (!(iterator->flags & ITERATOR_BACKWARDS)) {
+			iterator->active = list;
+			return list->list[0];
+		}
+	}
+
+	if (iterator->flags & ITERATOR_BACKWARDS) {
+		index = iterator->index -1;
+		if (index < 0) {
+			if (list->prev == *iterator->head)
+				return NULL;
+			list = iterator->active = list->prev;
+			index = list->nr -1;
+		}
+	} else {
+		index = iterator->index + 1;
+		if (index >= list->nr) {
+			if (list->next == *iterator->head)
+				return NULL;
+			list = iterator->active = list->next;
+			index = 0;
+		}
+	}
+	iterator->index = index;
+	return list->list[index];
+}
+
+void replace_iterator(struct list_iterator *iterator, void* ptr)
+{
+	struct ptr_list *list = iterator->active;
+	if (list)
+		list->list[iterator->index] = ptr;
+}
+
+void delete_iterator(struct list_iterator *iterator)
+{
+	struct ptr_list *list = iterator->active;
+	int movsize = list->nr - iterator->index - 1;
+	void ** curptr = list->list+iterator->index;
+
+	if (movsize>0)
+		memmove(curptr, curptr+1, movsize*sizeof curptr);
+
+	list->nr --;
+	if (iterator->flags & ITERATOR_BACKWARDS) {
+		if (iterator->index + 1 >= list->nr) {
+			iterator->active = (list->next == *iterator->head) ? NULL : list->next;
+			iterator->index = 0;
+		}
+	} else {
+		if (--iterator->index <0) {
+			iterator->active = (list->prev == *iterator->head) ? NULL : list->prev;
+			iterator->index = list->prev->nr;
+		}
+	}
+	if (list->nr <=0) {
+		list->prev->next = list->next;
+		list->next->prev = list->prev;
+		if (list == *iterator->head)
+			*iterator->head = (list->next == *iterator->head) ? NULL : list->next;
+		free(list);
+	}
+}
+
+void init_terminator_iterator(struct instruction* terminator, struct terminator_iterator *iterator)
+{
+	iterator->terminator = terminator;
+	if (!terminator)
+		return;
+
+	switch (terminator->opcode) {
+	case OP_BR:
+		iterator->branch = BR_INIT;
+		break;
+	case OP_SWITCH:
+		init_multijmp_iterator(&terminator->multijmp_list, &iterator->multijmp, 0);
+		break;
+	}
+}
+
+struct basic_block* next_terminator_bb(struct terminator_iterator *iterator)
+{
+	struct instruction *terminator = iterator->terminator;
+
+	if (!terminator)
+		return NULL;
+	switch (terminator->opcode) {
+	case OP_BR:
+		switch(iterator->branch) {
+		case BR_INIT:
+			if (terminator->bb_true) {
+				iterator->branch = BR_TRUE;
+				return terminator->bb_true;
+			}
+		case BR_TRUE:
+			if (terminator->bb_false) {
+				iterator->branch = BR_FALSE;
+				return terminator->bb_false;
+			}
+		default:
+			iterator->branch = BR_END;
+			return NULL;
+		}
+		break;
+	case OP_SWITCH: {
+		struct multijmp *jmp = next_multijmp(&iterator->multijmp);
+		return jmp ? jmp->target : NULL;
+	}
+	}
+	return NULL;
+}
+
+void replace_terminator_bb(struct terminator_iterator *iterator, struct basic_block* bb)
+{
+	struct instruction *terminator = iterator->terminator;
+	if (!terminator)
+		return;
+
+	switch (terminator->opcode) {
+	case OP_BR:
+		switch(iterator->branch) {
+		case BR_TRUE:
+			if (terminator->bb_true) {
+				terminator->bb_true = bb;
+				return;
+			}
+		case BR_FALSE:
+			if (terminator->bb_false) {
+				terminator->bb_false = bb;
+				return;
+			}
+		}
+		break;
+
+	case OP_SWITCH: {
+		struct multijmp *jmp = (struct multijmp*) current_iterator(&iterator->multijmp);
+		if (jmp)
+		       jmp->target = bb;
+	}
+	}
+}
+
+
+
+int replace_ptr_list(struct ptr_list **head, void *old_ptr, void *new_ptr)
+{
+	int count = 0;
+	struct list_iterator iterator;
+	void *ptr;
+
+	init_iterator(head, &iterator, 0);
+	while ((ptr=next_iterator(&iterator))) {
+		if (ptr==old_ptr) {
+			if (new_ptr)
+				replace_iterator(&iterator, new_ptr);
+			else
+				delete_iterator(&iterator);
+			count ++;
+		}
+	}
+	return count;
+}
+
+void * delete_ptr_list_last(struct ptr_list **head)
+{
+	void *ptr = NULL;
+	struct ptr_list *last;
+
+	if (!*head)
+		return NULL;
+	last = (*head)->prev;
+	if (last->nr)
+		ptr = last->list[--last->nr];
+	if (last->nr <=0) {
+		if (last == *head)
+			*head = NULL;
+		free(last);
+	}
+	return ptr;
+}
+
 void concat_ptr_list(struct ptr_list *a, struct ptr_list **b)
 {
 	void *entry;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 13:17:24 +0000
Message-ID: <20040414131724.GA10565 () 64m ! dyndns ! org>
--------------------
I was referring to the fact that when the pack_basic_block move
the block around, it did not deal with the phi instruction. In other
word, phi can contain the wrong basic block number.

On Wed, Apr 14, 2004 at 12:14:19PM -0700, tommy@numba-tu.com wrote:
> 
> All I did was point out that the "classic" SSA phi() nodes are different:
> They have an argument corresponding to each incoming edge, such that a
> multiple var definition reaching this block will be merged with a phi
> node.  Obviously, after register allocation it will turn into moves or
> nothing.

What it has right now is pretty  close. It is a list of pairs, which contain
incoming block and the register.

> 
> There's a common variant on the scheme which is a little nicer: spilt the
> phi node into two kinds: the incoming (~ classic) part, and the outgoing
> part.  Eg. instead of
> 
>   B1: ....                        B2: ....
>       i.7 = x.8 / 2                   i.9 = x.5 + 1024
>       goto B3                         goto B3
> 
>   B3: i.10 = phi(i.7, i.9)
>       ....
> 
> you'd now have
> 
>   B1: ....                        B2: ....
>       i.7 = x.8 / 2                   i.9 = x.5 + 1024
>       i.10 = ihp(i.7)                 i.10 = ihp(i.9)
>       goto B3                         goto B3
> 
>   B3: i.10 = phi()
>       ....
> 
> Pros: Closer to what ends up being generated and less work to do when
> adding and deleting incoming edges.
> Cons: More work to do for finding to sources of a merged var def.

I will give it more though. But it is low on my list right now.

Right now it only generate phi for things like:

a = b || c;

I am not going after the memory variable yet.


Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 13:30:47 +0000
Message-ID: <20040414133047.GB10565 () 64m ! dyndns ! org>
--------------------
On Wed, Apr 14, 2004 at 12:43:33PM -0700, Linus Torvalds wrote:
> 
> 
> On Wed, 14 Apr 2004, Christopher Li wrote:
> 
> Fair enough.
> 
> Patch looks good, no real complaints. The lib.c knowledge about
> instruction opcodes and the terminator thing looks a bit ugly (it's not
> exactly a generic list library routine any more), but I can't complain. We

I agree. I am think some thing like a lib-backend.c to contain all these.
The back end pass will use it a lot. Also the pack_basic_blocks and
friends should really belong to something like "pass-XXX.c".

We will going to have more pass functions.

> could add generic "flag" support to the list entry things by just always
> using the two low bits of a pointer, or something like that, but maybe
> it's not worth it.

Then we have to mask out the lowest two bits to use the pointer? I am not
sure it is worth while.

> 
> The notion of having the lists be lists of "tagged pointers" ratehr than
> just normal pointers (and thus require some alignment of them, but we get
> that alignment requirement for other cases anyway) would potentially be
> nice for other things too, though, even if the tag ends up being just two
> or three bits. But until such a use is actually evident, maybe the current
> special case op knowledge is better.

You mean the terminator_iterator? That prove the abstraction that iterator
the out going edge without knowing what op code it is. So I think it is
OK to have the op code knowledge. It is a mistake left it at lib.c , I
should move it out.

> 
> I'll look at it some more, but my first reaction is to just apply it.  
> It's bound to be better than what is there now.

Thank you.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 15:49:04 +0000
Message-ID: <20040414154904.GC10565 () 64m ! dyndns ! org>
--------------------
On Wed, Apr 14, 2004 at 03:07:20PM -0700, Linus Torvalds wrote:
> 
> 
> On Wed, 14 Apr 2004, Christopher Li wrote:
> 
> Note that _users_ would never have to mask out the low bits, since they 
> never access those things directly anyway - only the macros in lib.h would 
> ever know about the tags, and the only change would really be the:
> 
> 	do {							\
> 		ptr = (__typeof__(ptr)) (__list->list[__i]);	\
> 
> line becoming something like
> 
> 	do {							\
> 		unsigned long TAG = __list->list[__i];		\
> 		ptr = (__typeof__(ptr)) (~3UL & TAG);		\
> 		TAG &= 3;					\
> 
> and then you could use the FOR_EACH_PTR() macros as-is, except your list 
> traversal would also always see the "TAG" thing while traversing it.

I see. The iterator stuff I add need to deal with that as well.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: tommy () numba-tu ! com
To: linux-sparse
Subject: Re: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 19:14:19 +0000
Message-ID: <24347.65.113.40.130.1081970059.squirrel () numba-tu ! com>
--------------------
> Know problem:
> - it doesn't deal with phi correctly, I need to redo the phi base
>   on Tommy's suggestion.

All I did was point out that the "classic" SSA phi() nodes are different:
They have an argument corresponding to each incoming edge, such that a
multiple var definition reaching this block will be merged with a phi
node.  Obviously, after register allocation it will turn into moves or
nothing.

There's a common variant on the scheme which is a little nicer: spilt the
phi node into two kinds: the incoming (~ classic) part, and the outgoing
part.  Eg. instead of

  B1: ....                        B2: ....
      i.7 = x.8 / 2                   i.9 = x.5 + 1024
      goto B3                         goto B3

  B3: i.10 = phi(i.7, i.9)
      ....

you'd now have

  B1: ....                        B2: ....
      i.7 = x.8 / 2                   i.9 = x.5 + 1024
      i.10 = ihp(i.7)                 i.10 = ihp(i.9)
      goto B3                         goto B3

  B3: i.10 = phi()
      ....

Pros: Closer to what ends up being generated and less work to do when
adding and deleting incoming edges.
Cons: More work to do for finding to sources of a merged var def.

Just my 0,02 euro

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 19:43:33 +0000
Message-ID: <Pine.LNX.4.58.0404141236320.12398 () ppc970 ! osdl ! org>
--------------------


On Wed, 14 Apr 2004, Christopher Li wrote:
> 
> I try to make it. Then I realize that the code will pretty much like
> what it is right now. In stead I write some pass to stitch the basic
> block. It does two things. If it is an empty block with goto,
> it transfer the out going edge directly to the target.
> If the only parent ends with goto, it combine with parent.

Fair enough.

Patch looks good, no real complaints. The lib.c knowledge about
instruction opcodes and the terminator thing looks a bit ugly (it's not
exactly a generic list library routine any more), but I can't complain. We
could add generic "flag" support to the list entry things by just always
using the two low bits of a pointer, or something like that, but maybe
it's not worth it.

The notion of having the lists be lists of "tagged pointers" ratehr than
just normal pointers (and thus require some alignment of them, but we get
that alignment requirement for other cases anyway) would potentially be
nice for other things too, though, even if the tag ends up being just two
or three bits. But until such a use is actually evident, maybe the current
special case op knowledge is better.

I'll look at it some more, but my first reaction is to just apply it.  
It's bound to be better than what is there now.

	Thanks,
			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: (take II) condition branch simplify
Date: Wed, 14 Apr 2004 22:07:20 +0000
Message-ID: <Pine.LNX.4.58.0404141457340.12398 () ppc970 ! osdl ! org>
--------------------


On Wed, 14 Apr 2004, Christopher Li wrote:
> 
> > could add generic "flag" support to the list entry things by just always
> > using the two low bits of a pointer, or something like that, but maybe
> > it's not worth it.
> 
> Then we have to mask out the lowest two bits to use the pointer? I am not
> sure it is worth while.

Note that _users_ would never have to mask out the low bits, since they 
never access those things directly anyway - only the macros in lib.h would 
ever know about the tags, and the only change would really be the:

	do {							\
		ptr = (__typeof__(ptr)) (__list->list[__i]);	\

line becoming something like

	do {							\
		unsigned long TAG = __list->list[__i];		\
		ptr = (__typeof__(ptr)) (~3UL & TAG);		\
		TAG &= 3;					\

and then you could use the FOR_EACH_PTR() macros as-is, except your list 
traversal would also always see the "TAG" thing while traversing it.

So if you want to mix different pointers on a list, you could do just

	FOR_EACH_PTR(list, ptr) {
		switch (TAG) {
		case PTR_PHI:
			/* ptr is pointer to a phi node */
			phi = (struct phi_node) ptr;
			...
			break;
		case PTR_SYM:
			/* ptr is pointer to a symbol */
			sym = (struct symbol *) ptr;
			...
		}
	} END_FOR_EACH_PTR;

Yeah, I'm not claiming it makes any sense. I'm just claiming that it
wouldn't necessarily be all that hard to do even without having to change
any existing users if we ever want to do something like this ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html

.

================================================================================


################################################################################

=== Thread: [sparse be] PATCH: bug fix and bitfield ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 09:22:02 +0000
Message-ID: <20040422092202.GA2021 () 64m ! dyndns ! org>
--------------------
Hi Linus,

This patch includes:

- Bug fix for linearizion. Most the sparse source source
  can be feed to linearize without crash.
  One exception is the compile-i386.c, which contain
  type error due to sparse don't understand the assert
  macro yet.

- bit field was added to pass the test.

Thanks

Chris
 
Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-04-19 16:37:36.000000000 -0700
+++ sparse-be/linearize.c	2004-04-22 00:59:10.000000000 -0700
@@ -22,6 +22,14 @@
 pseudo_t linearize_statement(struct entrypoint *ep, struct statement *stmt);
 pseudo_t linearize_expression(struct entrypoint *ep, struct expression *expr);
 
+static pseudo_t add_binary_op(struct entrypoint *ep, struct expression *expr, int op, pseudo_t left, pseudo_t right);
+static pseudo_t add_setval(struct entrypoint *ep, struct symbol *ctype, struct expression *val);
+static pseudo_t add_const_value(struct entrypoint *ep, struct position pos, struct symbol *ctype, int val);
+static pseudo_t add_load(struct entrypoint *ep, struct expression *expr, pseudo_t addr);
+
+
+struct pseudo void_pseudo = {};
+
 static struct instruction *alloc_instruction(int opcode, struct symbol *type)
 {
 	struct instruction * insn = __alloc_instruction(0);
@@ -66,7 +74,10 @@
 		printf("\tAIEEE! (%d %d)\n", insn->target->nr, insn->src->nr);
 		break;
 	case OP_RET:
-		printf("\tret %%r%d\n", insn->src->nr);
+		if (insn->type)
+			printf("\tret %%r%d\n", insn->src->nr);
+		else
+			printf("\tret\n");
 		break;
 	case OP_BR:
 		if (insn->bb_true && insn->bb_false) {
@@ -312,6 +323,21 @@
 static void linearize_store_gen(struct entrypoint *ep, pseudo_t value, struct expression *expr, pseudo_t addr)
 {
 	struct instruction *store = alloc_instruction(OP_STORE, expr->ctype);
+
+	if (expr->type == EXPR_BITFIELD) {
+		unsigned long mask = ((1<<expr->nrbits)-1) << expr->bitpos;
+		pseudo_t andmask, ormask, shift, orig;
+		if (expr->bitpos) {
+			shift = add_const_value(ep, expr->pos, &uint_ctype, expr->bitpos);
+			value = add_binary_op(ep, expr, OP_SHL, value, shift);
+		}
+		orig = add_load(ep, expr, addr);
+		andmask = add_const_value(ep, expr->pos, &uint_ctype, ~mask);
+		value = add_binary_op(ep, expr, OP_AND, orig, andmask);
+		ormask = add_const_value(ep, expr->pos, &uint_ctype, mask);
+		value = add_binary_op(ep, expr, OP_OR, orig, ormask);
+	}
+
 	store->target = value;
 	store->src = addr;
 	add_one_insn(ep, expr->pos, store);
@@ -338,7 +364,13 @@
 	return target;
 }
 
-static pseudo_t linearize_load_gen(struct entrypoint *ep, struct expression *expr, pseudo_t addr)
+static pseudo_t add_const_value(struct entrypoint *ep, struct position pos, struct symbol *ctype, int val)
+{
+	struct expression *expr = alloc_const_expression(pos, val);
+	return add_setval(ep, ctype, expr);
+}
+
+static pseudo_t add_load(struct entrypoint *ep, struct expression *expr, pseudo_t addr)
 {
 	pseudo_t new = alloc_pseudo();
 	struct instruction *insn = alloc_instruction(OP_LOAD, expr->ctype);
@@ -346,11 +378,26 @@
 	insn->target = new;
 	insn->src = addr;
 	add_one_insn(ep, expr->pos, insn);
+	return new;
+}
+
+static pseudo_t linearize_load_gen(struct entrypoint *ep, struct expression *expr, pseudo_t addr)
+{
+	pseudo_t new = add_load(ep, expr, addr);
 	if (expr->type == EXPR_PREOP)
 		return new;
 
-	/* bitfield load */
-	/* FIXME! Add shift and mask!!! */
+	if (expr->type == EXPR_BITFIELD) {
+		pseudo_t mask;
+		if (expr->bitpos) {
+			pseudo_t shift = add_const_value(ep, expr->pos, &uint_ctype, expr->bitpos);
+			new = add_binary_op(ep, expr, OP_SHR, new, shift);
+		}
+		mask = add_const_value(ep, expr->pos, &uint_ctype, (1<<expr->nrbits)-1);
+		return add_binary_op(ep, expr, OP_AND, new, mask);
+	}
+
+	warn(expr->pos, "loading unknown expression");
 	return new;		
 }
 
@@ -367,7 +414,7 @@
 	int op = expr->op == SPECIAL_INCREMENT ? OP_ADD : OP_SUB;
 
 	old = linearize_load_gen(ep, expr->unop, addr);
-	one = add_setval(ep, expr->ctype, alloc_const_expression(expr->pos, 1));
+	one = add_const_value(ep, expr->pos, expr->ctype, 1);
 	new = add_binary_op(ep, expr, op, old, one);
 	linearize_store_gen(ep, new, expr->unop, addr);
 	return postop ? old : new;
@@ -390,8 +437,7 @@
 	case '+':
 		return pre;
 	case '!': {
-		struct expression * zeroval = alloc_const_expression(expr->pos, 0);
-		pseudo_t zero = add_setval(ep, expr->ctype, zeroval);
+		pseudo_t zero = add_const_value(ep, expr->pos, expr->ctype, 0);
 		return add_binary_op(ep, expr, OP_SET_EQ, pre, zero);
 	}
 	case '~':
@@ -441,7 +487,7 @@
 			[SPECIAL_OR_ASSIGN  - SPECIAL_BASE] = OP_OR,
 			[SPECIAL_XOR_ASSIGN - SPECIAL_BASE] = OP_XOR 
 		};
-		pseudo_t left = linearize_load_gen(ep, expr->left, address);
+		pseudo_t left = linearize_load_gen(ep, target, address);
 		value = add_binary_op(ep, expr, opcode[expr->op - SPECIAL_BASE], left, value);
 	}
 	linearize_store_gen(ep, value, target, address);
@@ -509,19 +555,24 @@
 	struct basic_block *bb_false = alloc_basic_block();
 	struct basic_block *merge = alloc_basic_block();
 
-	linearize_cond_branch(ep, cond, bb_true, bb_false);
+	if (expr_true) {
+		linearize_cond_branch(ep, cond, bb_true, bb_false);
 
-	set_activeblock(ep, bb_true);
-	src1 = linearize_expression(ep, expr_true);
-	bb_true = ep->active;
-	add_goto(ep, merge); 
+		set_activeblock(ep, bb_true);
+		src1 = linearize_expression(ep, expr_true);
+		bb_true = ep->active;
+		add_goto(ep, merge); 
+	} else {
+		src1 = linearize_expression(ep, cond);
+		add_branch(ep, expr, src1, merge, bb_false);
+	}
 
 	set_activeblock(ep, bb_false);
 	src2 = linearize_expression(ep, expr_false);
 	bb_false = ep->active;
 	set_activeblock(ep, merge);
 
-	if (bb_reachable(bb_true) && bb_reachable(bb_false)) {
+	if (src1 != VOID && src2 != VOID) {
 		struct instruction *phi_node = alloc_instruction(OP_PHI, expr->ctype);
 		add_phi(&phi_node->phi_list, alloc_phi(bb_true, src1));
 		add_phi(&phi_node->phi_list, alloc_phi(bb_false, src2));
@@ -531,7 +582,7 @@
 		return target;
 	}
 
-	return bb_reachable(bb_true) ? src1 : src2;
+	return src1 != VOID ? src1 : src2;
 }
 
 static pseudo_t linearize_logical(struct entrypoint *ep, struct expression *expr)
@@ -617,6 +668,8 @@
 	struct instruction *insn;
 
 	src = linearize_expression(ep, expr->cast_expression);
+	if (src == VOID)
+		return VOID;
 	insn = alloc_instruction(OP_CAST, expr->ctype);
 	result = alloc_pseudo();
 	insn->target = result;
@@ -670,15 +723,14 @@
 
 	case EXPR_CAST:
 		return linearize_cast(ep, expr);
+	
+	case EXPR_BITFIELD:
+		return linearize_access(ep, expr);
 
-	default: {
-		struct instruction *bad = alloc_instruction(OP_BADOP, expr->ctype);
-		bad->target->nr = expr->type;
-		bad->src->nr = expr->op;
-		add_one_insn(ep, expr->pos, bad);
+	default: 
+		die("Unknown expression (%d %d)", expr->type, expr->op);
 		return VOID;
 	}
-	}
 	return VOID;
 }
 
@@ -700,7 +752,7 @@
 
 	case STMT_RETURN: {
 		struct expression *expr = stmt->expression;
-		struct instruction *ret = alloc_instruction(OP_RET, expr->ctype);
+		struct instruction *ret = alloc_instruction(OP_RET, expr ? expr->ctype : NULL);
 		ret->src = linearize_expression(ep, expr);
 		add_one_insn(ep, stmt->pos, ret);
 		ep->active = NULL;
@@ -972,6 +1024,15 @@
 			set_activeblock(ep, bb);
 			concat_symbol_list(base_type->arguments, &ep->syms);
 			linearize_statement(ep, base_type->stmt);
+			if (bb_reachable(ep->active) && !bb_terminated(ep->active)) {
+				struct symbol *ret_type = base_type->ctype.base_type;
+				struct instruction *insn = alloc_instruction(OP_RET, NULL);
+				struct position pos = base_type->stmt->pos;
+
+				if (ret_type && ret_type != &void_ctype)
+					warn(pos, "control reaches end of non-void function\n");
+				add_one_insn(ep, pos, insn);
+			}
 			pack_basic_blocks(&ep->bbs);
 			show_entry(ep);
 		}
Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-04-21 03:45:48.000000000 -0700
+++ sparse-be/lib.c	2004-04-22 01:10:52.000000000 -0700
@@ -433,15 +433,17 @@
 void * delete_ptr_list_last(struct ptr_list **head)
 {
 	void *ptr = NULL;
-	struct ptr_list *last;
+	struct ptr_list *last, *first = *head;
 
-	if (!*head)
+	if (!first)
 		return NULL;
-	last = (*head)->prev;
+	last = first->prev;
 	if (last->nr)
 		ptr = last->list[--last->nr];
 	if (last->nr <=0) {
-		if (last == *head)
+		first->prev = last->prev;
+		last->prev->next = first;
+		if (last == first)
 			*head = NULL;
 		free(last);
 	}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 12:47:40 +0000
Message-ID: <20040422124740.GA12443 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 22, 2004 at 11:27:26AM -0700, Linus Torvalds wrote:
> 
> 
> On Thu, 22 Apr 2004, Christopher Li wrote:
> > 
> > - Bug fix for linearizion. Most the sparse source source
> >   can be feed to linearize without crash.
> 
> Applied.
> 
> Btw, it may not crash, but it still does some seriously wrong things about
> inline functions. The "return" part should get turned into a "store to
> return symbol + goto return-point", not a "ret" instruction.

Your return as different meaning than mine. The current code is not
ready to handle the inline expand yet.

> 	static inline int fn(int val)
> 	{
> 		return val;
> 	}
> 
> 	int testfn(int val)
> 	{
> 		return 1 + fn(val);
> 	}
> 
> never does the "1+" part.

I see what is going on there.
Here is the output of the AST tree. There are return inside the return.
The inner return set the basic block to terminated. So the add instruction
is skipped due to active block is unreachable.  I can fix it.

BTW, if you accept the python API module, I am all for that.
It is just a quiet module sit in a sub directory, it don't need to touch any
thing in sparse source. (Well, expect s/warn/warning/g because warn is a glibc function.)

$ python ast.py t-inline.c 
['SYM_NODE',
 'name: testfn',
 ['ctype.base->SYM_FN',
  ['ctype.base->SYM_BASETYPE'],
  ['args', ['args->SYM_NODE', 'name: val', ['ctype.base->SYM_BASETYPE']]],
  ['stmt->STMT_COMPOUND',
   ['syms'],
   ['stmts',
    ['stmts->STMT_RETURN',
     ['expression->EXPR_BINOP',
      'op: +',
      ['left->EXPR_VALUE', '1'],
      ['right->EXPR_STATEMENT',
       ['statement->STMT_COMPOUND',
        ['syms',
         ['syms->SYM_NODE', 'name: val', ['ctype.base->SYM_BASETYPE']]],
        ['stmts',
         ['stmts->STMT_RETURN',
          ['expression->EXPR_PREOP',
           'op: *',
           ['unop->EXPR_SYMBOL',
            ['symbol->SYM_NODE',
             'name: val',
             ['ctype.base->SYM_BASETYPE']]]]]]]]]]]]]]

> 
> I'll try to take a look too, but if you beat me to it, I'll be all the 
> more happy ;)

Maybe tonight.

> 
> (Btw, if you change the type of "testfn()" above to "void", it will cause
> a SIGSEGV in show_instruction).

I see similar things before. I guess you need to see a big warning on type not compatible.
That is due to the function call has ctype to NULL. I am still not sure when does it use
NULL instead of &void_ctype.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 14:32:08 +0000
Message-ID: <20040422143208.GB12443 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 22, 2004 at 02:42:46PM -0700, Linus Torvalds wrote:
> 
> 
> On Thu, 22 Apr 2004, Christopher Li wrote:
> > > 
> > > Btw, it may not crash, but it still does some seriously wrong things about
> > > inline functions. The "return" part should get turned into a "store to
> > > return symbol + goto return-point", not a "ret" instruction.
> > 
> > Your return as different meaning than mine. The current code is not
> > ready to handle the inline expand yet.
> 
> I think it should be pretty close. We actually _have_ a "return symbol"  
> associated with a expression statement, and that's how inlining is done:  
> as far as the back-end is concerned, an inlined function ends up being
> nothing but a fairly complex expression statement. We even copy the return
> symbol when we do the inlining operation.
> 
> It's just that when we do the linearization, we never _use_ that symbol. 
> 
> It should be just another label as far as linearization is concerned: we 
> should emit the label (if it is used) when linearizing an expression of 
> type EXPR_STATMENT, and we should make "return" be just a "copy the 
> expression to the return symbol, and goto the bb associated with the 
> symbol". That should do it for us. 

I am fine with that. We need to allocate phi_node for the return register.
But when the outside function end, how does it find out which bb is the
finial return bb? In other words, when you see a return statement, how
do you know it is from the inline function or not?

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 17:40:16 +0000
Message-ID: <20040422174016.GC12443 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 22, 2004 at 04:29:18PM -0700, Linus Torvalds wrote:
> 
> 
> On Thu, 22 Apr 2004, Christopher Li wrote:
> > 
> > I am fine with that. We need to allocate phi_node for the return register.
> > But when the outside function end, how does it find out which bb is the
> > finial return bb? In other words, when you see a return statement, how
> > do you know it is from the inline function or not?
> 
> You don't care. A return _always_ just does the "move to return phi node, 
> and goto return symbol".
> 
> The "return symbol" is the magic, and the parser has already generated it 
> for us. We just need to have one place generate it:
> 
>  - linearize_statement(), case "STMT_COMPOUND" needs to create a label 
>    at the _end_ (aftre doing the linearization of all the other stuff) if 
>    "stmt->ret" is non-NULL and "stmt->ret->used" is true.

Ha, the stmt->ret is what I am looking for. The used flag is not working
correctly right now. Copy symbol seems lost the used flag. There are something
wrong there.

> 
> and then we need to have the final "ret" instruction in just one place:
> 
>  - linearize_symbol() needs to generate the final "ret" instruction if the 
>    end is reachable (which it _will_ be if linearize_statement() added the 
>    label above.
> 
> In fact, the second part we already do, I think.

Yes, I add that a while ago. Because return fold into gotos. I can't
really tell if the non-void function reach end of function without
return now.

> 
> So I literally think the only need is to add the label in STMT_COMPOUND 
> linearization, and to make STMT_RETURN add the phi node and the goto.

yes, pretty much.

Chris

Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-04-22 15:02:58.000000000 -0700
+++ sparse-be/linearize.c	2004-04-22 18:50:45.000000000 -0700
@@ -74,7 +74,7 @@
 		printf("\tAIEEE! (%d %d)\n", insn->target->nr, insn->src->nr);
 		break;
 	case OP_RET:
-		if (insn->type)
+		if (insn->type && insn->type != &void_ctype)
 			printf("\tret %%r%d\n", insn->src->nr);
 		else
 			printf("\tret\n");
@@ -752,10 +752,20 @@
 
 	case STMT_RETURN: {
 		struct expression *expr = stmt->expression;
-		struct instruction *ret = alloc_instruction(OP_RET, expr ? expr->ctype : NULL);
-		ret->src = linearize_expression(ep, expr);
-		add_one_insn(ep, stmt->pos, ret);
-		ep->active = NULL;
+		struct basic_block *bb_return = stmt->ret_target->bb_target;
+		struct basic_block *active;
+		pseudo_t src = linearize_expression(ep, expr);
+		active = ep->active;
+		add_goto(ep, bb_return);
+		if (src != &void_pseudo) {
+			struct instruction *phi_node = first_instruction(bb_return->insns);
+			if (!phi_node) {
+				phi_node = alloc_instruction(OP_PHI, expr->ctype);
+				phi_node->target = alloc_pseudo();
+				add_instruction(&bb_return->insns, phi_node);
+			}
+			add_phi(&phi_node->phi_list, alloc_phi(active, src));
+		}
 		return VOID;
 	}
 
@@ -786,10 +796,28 @@
 	case STMT_COMPOUND: {
 		pseudo_t pseudo;
 		struct statement *s;
+		struct symbol *ret = stmt->ret;
 		concat_symbol_list(stmt->syms, &ep->syms);
+		if (ret)
+			ret->bb_target = alloc_basic_block();
 		FOR_EACH_PTR(stmt->stmts, s) {
 			pseudo = linearize_statement(ep, s);
 		} END_FOR_EACH_PTR;
+		if (ret) {
+			struct basic_block *bb = ret->bb_target;
+			struct instruction *phi = first_instruction(bb->insns);
+
+			if (!phi)
+				return pseudo;
+
+			set_activeblock(ep, bb);
+			if (phi_list_size(phi->phi_list)==1) {
+				pseudo = first_phi(phi->phi_list)->pseudo;
+				delete_last_instruction(&bb->insns);
+				return pseudo;
+			}
+			return phi->target;
+		}
 		return pseudo;
 	}
 
@@ -1018,19 +1046,19 @@
 		if (base_type->stmt) {
 			struct entrypoint *ep = alloc_entrypoint();
 			struct basic_block *bb = alloc_basic_block();
+			pseudo_t result;
 
 			ep->name = sym;
 			bb->flags |= BB_REACHABLE;
 			set_activeblock(ep, bb);
 			concat_symbol_list(base_type->arguments, &ep->syms);
-			linearize_statement(ep, base_type->stmt);
+			result = linearize_statement(ep, base_type->stmt);
 			if (bb_reachable(ep->active) && !bb_terminated(ep->active)) {
 				struct symbol *ret_type = base_type->ctype.base_type;
-				struct instruction *insn = alloc_instruction(OP_RET, NULL);
+				struct instruction *insn = alloc_instruction(OP_RET, ret_type);
 				struct position pos = base_type->stmt->pos;
-
-				if (ret_type && ret_type != &void_ctype)
-					warn(pos, "control reaches end of non-void function\n");
+				
+				insn->src = result;
 				add_one_insn(ep, pos, insn);
 			}
 			pack_basic_blocks(&ep->bbs);
Index: sparse-be/linearize.h
===================================================================
--- sparse-be.orig/linearize.h	2004-04-22 15:03:26.000000000 -0700
+++ sparse-be/linearize.h	2004-04-22 17:54:06.000000000 -0700
@@ -13,7 +13,9 @@
 
 typedef struct pseudo *pseudo_t;
 
-#define VOID NULL
+extern struct pseudo void_pseudo;
+
+#define VOID (&void_pseudo)
 
 struct multijmp {
 	struct basic_block *target;
Index: sparse-be/symbol.h
===================================================================
--- sparse-be.orig/symbol.h	2004-04-17 01:43:06.000000000 -0700
+++ sparse-be/symbol.h	2004-04-22 18:48:12.000000000 -0700
@@ -94,10 +94,12 @@
 		struct statement *stmt;
 		struct symbol_list *symbol_list;
 		struct expression *initializer;
-		struct basic_block *bb_target;	/* label */
 		long long value;		/* Initial value */
 	};
-	void *aux;				/* Auxiliary info, eg. backend information */
+	union /* backend */ {
+		struct basic_block *bb_target;	/* label */
+		void *aux;			/* Auxiliary info, eg. backend information */
+	};
 };
 
 /* Modifiers */
Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-04-19 14:25:36.000000000 -0700
+++ sparse-be/lib.h	2004-04-22 17:42:52.000000000 -0700
@@ -36,6 +36,8 @@
 struct instruction_list;
 struct multijmp;
 struct multijmp_list;
+struct phi;
+struct phi_list;
 
 struct token *skip_to(struct token *, int);
 struct token *expect(struct token *, int, const char *);
@@ -149,6 +151,11 @@
 	return ptr_list_size((struct ptr_list *)(list));
 }
 
+static inline int phi_list_size(struct phi_list* list)
+{
+	return ptr_list_size((struct ptr_list *)(list));
+}
+
 static inline int bb_list_size(struct basic_block_list* list)
 {
 	return ptr_list_size((struct ptr_list *)(list));
@@ -225,6 +232,11 @@
 	return first_ptr_list((struct ptr_list *)head);
 }
 
+static inline struct phi *first_phi(struct phi_list *head)
+{
+	return first_ptr_list((struct ptr_list *)head);
+}
+
 static inline int replace_basic_block_list(struct basic_block_list **head, struct basic_block *from, struct basic_block *to)
 {
 	return replace_ptr_list((struct ptr_list **)head, (void*)from, (void*)to);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 18:27:26 +0000
Message-ID: <Pine.LNX.4.58.0404221116270.19703 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Apr 2004, Christopher Li wrote:
> 
> - Bug fix for linearizion. Most the sparse source source
>   can be feed to linearize without crash.

Applied.

Btw, it may not crash, but it still does some seriously wrong things about
inline functions. The "return" part should get turned into a "store to
return symbol + goto return-point", not a "ret" instruction.

I used to do it right at some point in "show-parse.c": it had a

	struct expression *expr = stmt->ret_value;
	struct symbol *target = stmt->ret_target;

	if (expr && expr->ctype) {
		..
	}

	printf("\tgoto .L%p\n", target);

along with SYM_FN expansion doing the _real_ "ret" instruction. But I 
broke it at some point, and the brokenness was percolated back to the 
linearization pass.

It's easy to test for

	static inline int fn(int val)
	{
		return val;
	}

	int testfn(int val)
	{
		return 1 + fn(val);
	}

never does the "1+" part.

I'll try to take a look too, but if you beat me to it, I'll be all the 
more happy ;)

(Btw, if you change the type of "testfn()" above to "void", it will cause
a SIGSEGV in show_instruction).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 21:42:46 +0000
Message-ID: <Pine.LNX.4.58.0404221432280.19703 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Apr 2004, Christopher Li wrote:
> > 
> > Btw, it may not crash, but it still does some seriously wrong things about
> > inline functions. The "return" part should get turned into a "store to
> > return symbol + goto return-point", not a "ret" instruction.
> 
> Your return as different meaning than mine. The current code is not
> ready to handle the inline expand yet.

I think it should be pretty close. We actually _have_ a "return symbol"  
associated with a expression statement, and that's how inlining is done:  
as far as the back-end is concerned, an inlined function ends up being
nothing but a fairly complex expression statement. We even copy the return
symbol when we do the inlining operation.

It's just that when we do the linearization, we never _use_ that symbol. 

It should be just another label as far as linearization is concerned: we 
should emit the label (if it is used) when linearizing an expression of 
type EXPR_STATMENT, and we should make "return" be just a "copy the 
expression to the return symbol, and goto the bb associated with the 
symbol". That should do it for us. 

I think.

I know I had this "almost working" at one point - where each real function
just had one return point, and any returns in the middle always did the
same thing:  they assigned the return value to the return symbol, and they
jumped to a single exit point. 

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Thu, 22 Apr 2004 23:29:18 +0000
Message-ID: <Pine.LNX.4.58.0404221616400.19703 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Apr 2004, Christopher Li wrote:
> 
> I am fine with that. We need to allocate phi_node for the return register.
> But when the outside function end, how does it find out which bb is the
> finial return bb? In other words, when you see a return statement, how
> do you know it is from the inline function or not?

You don't care. A return _always_ just does the "move to return phi node, 
and goto return symbol".

The "return symbol" is the magic, and the parser has already generated it 
for us. We just need to have one place generate it:

 - linearize_statement(), case "STMT_COMPOUND" needs to create a label 
   at the _end_ (aftre doing the linearization of all the other stuff) if 
   "stmt->ret" is non-NULL and "stmt->ret->used" is true.

and then we need to have the final "ret" instruction in just one place:

 - linearize_symbol() needs to generate the final "ret" instruction if the 
   end is reachable (which it _will_ be if linearize_statement() added the 
   label above.

In fact, the second part we already do, I think.

So I literally think the only need is to add the label in STMT_COMPOUND 
linearization, and to make STMT_RETURN add the phi node and the goto.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Fri, 23 Apr 2004 05:03:05 +0000
Message-ID: <Pine.LNX.4.58.0404222157150.19703 () ppc970 ! osdl ! org>
--------------------


On Thu, 22 Apr 2004, Christopher Li wrote:
> > 
> >  - linearize_statement(), case "STMT_COMPOUND" needs to create a label 
> >    at the _end_ (aftre doing the linearization of all the other stuff) if 
> >    "stmt->ret" is non-NULL and "stmt->ret->used" is true.
> 
> Ha, the stmt->ret is what I am looking for. The used flag is not working
> correctly right now. Copy symbol seems lost the used flag. There are something
> wrong there.

Ahh, yes, you're right. We should probably just copy the "used" flag, 
since usage will be same in the inlined copy as it was in the original 
function.

Alternatively, I think your bb cleanup phase will just remove any 
unnecessary basic blocks anyway, so even not using it won't really hurt 
much.

> > So I literally think the only need is to add the label in STMT_COMPOUND 
> > linearization, and to make STMT_RETURN add the phi node and the goto.
> 
> yes, pretty much.

Looks good, passes the trivial test, applied.

Thanks,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: bug fix and bitfield
Date: Fri, 23 Apr 2004 09:13:28 +0000
Message-ID: <20040423091328.GA14355 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 22, 2004 at 10:03:05PM -0700, Linus Torvalds wrote:
> 
> 
> On Thu, 22 Apr 2004, Christopher Li wrote:
> > > 
> > >  - linearize_statement(), case "STMT_COMPOUND" needs to create a label 
> > >    at the _end_ (aftre doing the linearization of all the other stuff) if 
> > >    "stmt->ret" is non-NULL and "stmt->ret->used" is true.
> > 
> > Ha, the stmt->ret is what I am looking for. The used flag is not working
> > correctly right now. Copy symbol seems lost the used flag. There are something
> > wrong there.
> 
> Ahh, yes, you're right. We should probably just copy the "used" flag, 
> since usage will be same in the inlined copy as it was in the original 
> function.

I try that before, then the used flag is set even there is no returns.

> 
> Alternatively, I think your bb cleanup phase will just remove any 
> unnecessary basic blocks anyway, so even not using it won't really hurt 
> much.

Right now the unnecessary bb is not insert to ep in the first place.
Unreachable bb is skipped. Plus I need to remove the one entry phi node,
so empty phi node also means it is never used.

I think I can change it back to only inline function use this. The non-inline
function keep the original op_ret then we can still have the "reach end of
non-void function" warning.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [sparse be] PATCH: more op code ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 09:48:07 +0000
Message-ID: <20040415094807.GA2069 () 64m ! dyndns ! org>
--------------------
Hi Linus,

This is another small step. It add binary op, compare op and ret.
The classic recursive Fibonacci numbers function should
be working.
 
Thanks,

Chris


Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-04-14 02:05:16.000000000 -0700
+++ sparse-be/linearize.c	2004-04-15 10:57:46.000000000 -0700
@@ -65,6 +65,9 @@
 	case OP_BADOP:
 		printf("\tAIEEE! (%d %d)\n", insn->target.nr, insn->src.nr);
 		break;
+	case OP_RET:
+		printf("\tret %%r%d\n", insn->src.nr);
+		break;
 	case OP_BR:
 		if (insn->bb_true && insn->bb_false) {
 			printf("\tbr\t%%r%d, .L%p, .L%p\n", insn->cond.nr, insn->bb_true, insn->bb_false);
@@ -95,7 +98,7 @@
 	}
 	case OP_SWITCH: {
 		struct multijmp *jmp;
-		printf("\tswitch %%r%d", insn->target.nr);
+		printf("\tswitch %%r%d", insn->cond.nr);
 		FOR_EACH_PTR(insn->multijmp_list, jmp) {
 			if (jmp->begin == jmp->end)
 				printf(", %d -> .L%p", jmp->begin, jmp->target);
@@ -140,16 +143,40 @@
 			insn->orig_type->bit_size, insn->type->bit_size, 
 			insn->src.nr);
 		break;
+	case OP_BINARY ... OP_BINARY_END:
+	case OP_LOGICAL ... OP_LOGICAL_END: {
+		static const char *opname[] = {
+			[OP_ADD - OP_BINARY] = "add", [OP_SUB - OP_BINARY] = "sub",
+			[OP_MUL - OP_BINARY] = "mul", [OP_DIV - OP_BINARY] = "div",
+			[OP_MOD - OP_BINARY] = "mod", [OP_AND - OP_BINARY] = "and",
+			[OP_OR  - OP_BINARY] = "or",  [OP_XOR - OP_BINARY] = "xor"
+		};
+		printf("\t%%r%d <- %s  %%r%d, %%r%d\n",
+			insn->target.nr,
+			opname[op - OP_BINARY], insn->src1.nr, insn->src2.nr);
+		break;
+	}
+
+	case OP_BINCMP ... OP_BINCMP_END: {
+		static const char *opname[] = {
+			[OP_SET_EQ - OP_BINCMP] = "seteq",
+			[OP_SET_NE - OP_BINCMP] = "setne",
+			[OP_SET_LE - OP_BINCMP] = "setle",
+			[OP_SET_GE - OP_BINCMP] = "setge",
+			[OP_SET_LT - OP_BINCMP] = "setlt",
+			[OP_SET_GT - OP_BINCMP] = "setgt",
+		};
+		printf("\t%%r%d <- %s  %%r%d, %%r%d\n",
+			insn->target.nr,
+			opname[op - OP_BINCMP], insn->src1.nr, insn->src2.nr);
+		break;
+	}
+
 	case OP_UNOP ... OP_LASTUNOP:
 		printf("\t%%r%d <- %s %%r%d\n",
 			insn->target.nr,
 			show_special(op - OP_UNOP), insn->src.nr);
 		break;
-	case OP_BINOP ... OP_LASTBINOP:
-		printf("\t%%r%d <- %%r%d %s %%r%d\n",
-			insn->target.nr,
-			insn->src1.nr, show_special(op - OP_UNOP), insn->src2.nr);
-		break;
 	default:
 		printf("\top %d ???\n", op);
 	}
@@ -440,11 +467,18 @@
 {
 	pseudo_t src1, src2, result;
 	struct instruction *insn;
+	static const int opcode[] = {
+		['+'] = OP_ADD, ['-'] = OP_SUB,
+		['*'] = OP_MUL, ['/'] = OP_DIV,
+		['%'] = OP_MOD, ['&'] = OP_AND,
+		['|'] = OP_OR,  ['^'] = OP_XOR,
+	};
 
 	src1 = linearize_expression(ep, expr->left);
 	src2 = linearize_expression(ep, expr->right);
 	result = alloc_pseudo();
-	insn = alloc_instruction(OP_BINOP + expr->op, expr->ctype);
+
+	insn = alloc_instruction(opcode[expr->op], expr->ctype);
 	insn->target = result;
 	insn->src1 = src1;
 	insn->src2 = src2;
@@ -498,8 +532,29 @@
 	return bb_reachable(first) ? src1 : src2;
 }
 
+static pseudo_t linearize_compare(struct entrypoint *ep, struct expression *expr)
+{
+	static const int cmpop[] = {
+		['>'] = OP_SET_GT, ['<'] = OP_SET_LT,
+		[SPECIAL_EQUAL] = OP_SET_EQ,
+		[SPECIAL_NOTEQUAL] = OP_SET_NE,
+		[SPECIAL_GTE] = OP_SET_GE,
+		[SPECIAL_LTE] = OP_SET_LE,
+	};
+	struct instruction *insn = alloc_instruction(cmpop[expr->op], expr->ctype);
+	pseudo_t target;
+	insn->src1 = linearize_expression(ep, expr->left);
+	insn->src2 = linearize_expression(ep, expr->right);
+	insn->target = target = alloc_pseudo();
+	add_one_insn(ep, expr->pos, insn);
+	return target;
+}
+
+
 pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false)
 {
+	pseudo_t cond;
+
 	if (!expr || !bb_reachable(ep->active))
 		return VOID;
 
@@ -514,12 +569,17 @@
 		linearize_logical_branch(ep, expr, bb_true, bb_false);
 		return VOID;
 
+	case EXPR_COMPARE:
+		cond = linearize_compare(ep, expr);
+		add_branch(ep, expr, cond, bb_true, bb_false);
+		break;
+		
 	case EXPR_PREOP:
 		if (expr->op == '!')
 			return linearize_cond_branch(ep, expr->unop, bb_false, bb_true);
 		/* fall through */
 	default: {
-		pseudo_t cond = linearize_expression(ep, expr);
+		cond = linearize_expression(ep, expr);
 		add_branch(ep, expr, cond, bb_true, bb_false);
 
 		return VOID;
@@ -528,6 +588,8 @@
 	return VOID;
 }
 
+
+	
 static pseudo_t linearize_logical_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false)
 {
 	struct basic_block *next = alloc_basic_block();
@@ -583,6 +645,9 @@
 	case EXPR_LOGICAL:
 		return linearize_logical(ep, expr);
 
+	case EXPR_COMPARE:
+		return  linearize_compare(ep, expr);
+
 	case EXPR_COMMA: {
 		linearize_expression(ep, expr->left);
 		return linearize_expression(ep, expr->right);
@@ -628,8 +693,12 @@
 		break;
 
 	case STMT_RETURN: {
-		pseudo_t pseudo = linearize_expression(ep, stmt->expression);
-		return pseudo;
+		struct expression *expr = stmt->expression;
+		struct instruction *ret = alloc_instruction(OP_RET, expr->ctype);
+		ret->src = linearize_expression(ep, expr);
+		add_one_insn(ep, stmt->pos, ret);
+		ep->active = NULL;
+		return VOID;
 	}
 
 	case STMT_CASE: {
@@ -700,7 +769,7 @@
 
 		pseudo = linearize_expression(ep, stmt->switch_expression);
 		switch_ins = alloc_instruction(OP_SWITCH, NULL);
-		switch_ins->target = pseudo;
+		switch_ins->cond = pseudo;
 		add_one_insn(ep, stmt->pos, switch_ins);
 
 		FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
Index: sparse-be/linearize.h
===================================================================
--- sparse-be.orig/linearize.h	2004-04-14 01:41:53.000000000 -0700
+++ sparse-be/linearize.h	2004-04-15 02:01:50.000000000 -0700
@@ -33,14 +33,15 @@
 struct instruction {
 	struct symbol *type;
 	int opcode;
-	pseudo_t target;
+	union {
+		pseudo_t target;
+		pseudo_t cond;		/* for branch and switch */
+	};
 	union {
 		struct /* branch */ {
-			pseudo_t cond;
 			struct basic_block *bb_true, *bb_false;
 		};
 		struct /* switch */ {
-			pseudo_t switch_cond;
 			struct multijmp_list *multijmp_list;	/* switch */
 		};
 		struct /* phi_node */ {
@@ -64,33 +65,41 @@
 enum opcode {
 	OP_BADOP,
 	/* Terminator */
-	OP_RET,
+	OP_TERMINATOR,
+	OP_RET = OP_TERMINATOR,
 	OP_BR,
 	OP_SWITCH,
 	OP_INVOKE,
 	OP_UNWIND,
+	OP_TERMINATOR_END = OP_UNWIND,
 	
 	/* Binary */
-	OP_ADD,
+	OP_BINARY,
+	OP_ADD = OP_BINARY,
 	OP_SUB,
 	OP_MUL,
 	OP_DIV,
-	OP_REM,
+	OP_MOD,
 	OP_SHL,
 	OP_SHR,
+	OP_BINARY_END = OP_SHR,
 	
 	/* Logical */
-	OP_AND,
+	OP_LOGICAL,
+	OP_AND = OP_LOGICAL,
 	OP_OR,
 	OP_XOR,
+	OP_LOGICAL_END = OP_XOR,
 
 	/* Binary comparison */
-	OP_SET_EQ,
+	OP_BINCMP,
+	OP_SET_EQ = OP_BINCMP,
 	OP_SET_NE,
 	OP_SET_LE,
 	OP_SET_GE,
 	OP_SET_LT,
 	OP_SET_GT,
+	OP_BINCMP_END = OP_SET_GT,
 	
 	/* Memory */
 	OP_MALLOC,
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 12:34:14 +0000
Message-ID: <20040415123414.GA12428 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 15, 2004 at 11:52:35AM -0700, Linus Torvalds wrote:
> Ok, applied.

Thanks.

> 
> One question: what do you think about signedness on the compare ops? When 
> we make the conversion from "expr->ops" to "instr->ops", my reaction is 
> that we should probably also take the sign into account, and have 
> OP_SET_LEU/OP_SET_GEU/OP_SET_LTU/OP_SET_GTU for the unsigned versions.
> 
> At that point any code downstream should hopefully no longer care about 
> any other details about the C types than the actual size of the type, 
> which makes sense to me. Comments?

I want the instruction cover all the possible type, and the C type is store in
the instruction.

As my understanding, there are two major step on the down stream. One is the MIR
(middle level of representation) which is target independent. Most of the
compiler optimization stuff is done at this level. e.g. alias analyze, common
expression eliminate and so on.

Then it emit to the LIR which is pretty much one to one mapping to machine
assemble code. Some machine specify optimization is done at this level.
e.g. "lea eax, [eax + ebx + offset]" to perform two add at one time.

What we have after lionization is the MIR. For most of the stuff done in this
level, they need to know about the C type any way. Only the LIR really care
about signedness. I don't see a need for adding more OP code for different type
in MIR. Keeping the MIR instruction set small is good.
 
> 
> (And yes, I realize that it still leaves the issue of floating point ops
> up in the air, and yes, if we go this way we should probably do OP_FP_ADD,
> OP_FP_MUL etc at this stage too in addition to having FP comparison ops. 
> I've ignored all FP issues so far).

FP is already under covered already. Cost nothing to have they in MIR.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 12:42:57 +0000
Message-ID: <20040415124257.GB12428 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 15, 2004 at 04:50:35PM -0400, Jeff Garzik wrote:
> Linus Torvalds wrote:
> >One question: what do you think about signedness on the compare ops? When 
> >we make the conversion from "expr->ops" to "instr->ops", my reaction is 
> >that we should probably also take the sign into account, and have 
> >OP_SET_LEU/OP_SET_GEU/OP_SET_LTU/OP_SET_GTU for the unsigned versions.
> 
> >At that point any code downstream should hopefully no longer care about 
> >any other details about the C types than the actual size of the type, 
> >which makes sense to me. Comments?
> 
> After having to worry about signedness in my silly backend, that would 
> certainly be nice.
> 
> The IL of some compilers looks like
> 
> 	addi.32
> 	subi.16
> 
> etc. where the size is an attribute of the op.  It's probably a tossup 
> where signedness is more useful as an attribute or an op, though I lean 
> towards separate ops.

That is one level lower than what I am worry about right now. It is not
there yet.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 14:30:31 +0000
Message-ID: <20040415143031.GB15616 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 15, 2004 at 03:44:50PM -0700, tommy@numba-tu.com wrote:
> Awesome progress Chris.
> 
> Something else: I'm a little uncertain about the way parameters to
> function calls are represented, eg. the "push".  It seems they aren't
> explicitly linked to the call site and the order of them is important. 
> While it matches stack based ABI well, it's kind of awkward for register
> passing ABI.   It seems like a hard problem to find a model that works
> well for both ABIs (and a mixed ABI).

Oh yes, it is one my plan. The call instruction should have a list of the
arguments. That is it. Other things like a?b:c , +=, ++ is still not working
yet. Stay tuned.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 18:52:35 +0000
Message-ID: <Pine.LNX.4.58.0404151145260.12398 () ppc970 ! osdl ! org>
--------------------


On Thu, 15 Apr 2004, Christopher Li wrote:
> 
> This is another small step. It add binary op, compare op and ret.
> The classic recursive Fibonacci numbers function should
> be working.

Ok, applied.

One question: what do you think about signedness on the compare ops? When 
we make the conversion from "expr->ops" to "instr->ops", my reaction is 
that we should probably also take the sign into account, and have 
OP_SET_LEU/OP_SET_GEU/OP_SET_LTU/OP_SET_GTU for the unsigned versions.

At that point any code downstream should hopefully no longer care about 
any other details about the C types than the actual size of the type, 
which makes sense to me. Comments?

(And yes, I realize that it still leaves the issue of floating point ops
up in the air, and yes, if we go this way we should probably do OP_FP_ADD,
OP_FP_MUL etc at this stage too in addition to having FP comparison ops. 
I've ignored all FP issues so far).

What do you think?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 20:50:35 +0000
Message-ID: <407EF59B.50006 () pobox ! com>
--------------------
Linus Torvalds wrote:
> One question: what do you think about signedness on the compare ops? When 
> we make the conversion from "expr->ops" to "instr->ops", my reaction is 
> that we should probably also take the sign into account, and have 
> OP_SET_LEU/OP_SET_GEU/OP_SET_LTU/OP_SET_GTU for the unsigned versions.

> At that point any code downstream should hopefully no longer care about 
> any other details about the C types than the actual size of the type, 
> which makes sense to me. Comments?

After having to worry about signedness in my silly backend, that would 
certainly be nice.

The IL of some compilers looks like

	addi.32
	subi.16

etc. where the size is an attribute of the op.  It's probably a tossup 
where signedness is more useful as an attribute or an op, though I lean 
towards separate ops.


> (And yes, I realize that it still leaves the issue of floating point ops
> up in the air, and yes, if we go this way we should probably do OP_FP_ADD,
> OP_FP_MUL etc at this stage too in addition to having FP comparison ops. 
> I've ignored all FP issues so far).

Yeah...

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 21:03:28 +0000
Message-ID: <Pine.LNX.4.58.0404151356000.12398 () ppc970 ! osdl ! org>
--------------------


On Thu, 15 Apr 2004, Jeff Garzik wrote:
> 
> > At that point any code downstream should hopefully no longer care about 
> > any other details about the C types than the actual size of the type, 
> > which makes sense to me. Comments?
> 
> After having to worry about signedness in my silly backend, that would 
> certainly be nice.

My real argument is that it will allow simplification of the data 
structures later on, where we can just drop the entire C type system, and 
instead adopt more of a "machine type" system. I seriously doubt the 
back-end wants to worry about "pointer to a structure", when it can just 
consider it to be "integer of size X" instead.

So at that point we'd _have_ to do the operation signedness expansion.  
This point where we do some op-translation _anyway_ seems like a good
place to do it.

		Linus


================================================================================

From: hpa () zytor ! com (H !  Peter Anvin)
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 21:09:38 +0000
Message-ID: <c5mtmi$vrq$1 () terminus ! zytor ! com>
--------------------
Followup to:  <Pine.LNX.4.58.0404151356000.12398@ppc970.osdl.org>
By author:    Linus Torvalds <torvalds@osdl.org>
In newsgroup: linux.dev.sparse
> 
> On Thu, 15 Apr 2004, Jeff Garzik wrote:
> > 
> > > At that point any code downstream should hopefully no longer care about 
> > > any other details about the C types than the actual size of the type, 
> > > which makes sense to me. Comments?
> > 
> > After having to worry about signedness in my silly backend, that would 
> > certainly be nice.
> 
> My real argument is that it will allow simplification of the data 
> structures later on, where we can just drop the entire C type system, and 
> instead adopt more of a "machine type" system. I seriously doubt the 
> back-end wants to worry about "pointer to a structure", when it can just 
> consider it to be "integer of size X" instead.
> 
> So at that point we'd _have_ to do the operation signedness expansion.  
> This point where we do some op-translation _anyway_ seems like a good
> place to do it.
> 

Do consider, though, that for some targets (e.g. x86) signedness is a
property of the consumer of the comparison, and for some it's a
property of the comparison itself (e.g. any predicated architecture.)

	-hpa
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 21:19:03 +0000
Message-ID: <407EFC47.5080004 () pobox ! com>
--------------------
Linus Torvalds wrote:
> 
> On Thu, 15 Apr 2004, Jeff Garzik wrote:
> 
>>>At that point any code downstream should hopefully no longer care about 
>>>any other details about the C types than the actual size of the type, 
>>>which makes sense to me. Comments?
>>
>>After having to worry about signedness in my silly backend, that would 
>>certainly be nice.
> 
> 
> My real argument is that it will allow simplification of the data 
> structures later on, where we can just drop the entire C type system, and 
> instead adopt more of a "machine type" system. I seriously doubt the 
> back-end wants to worry about "pointer to a structure", when it can just 
> consider it to be "integer of size X" instead.
> 
> So at that point we'd _have_ to do the operation signedness expansion.  
> This point where we do some op-translation _anyway_ seems like a good
> place to do it.


Thinking a bit more about it...  for high/mid-level stuff I like dealing 
exclusively with C types, and doing optimization at that level as much 
as possible.

When the compiler is ready to dive into a lower level, you have a 
C->machine type translation phase.  Some C types pass straight through 
with no modification; others (like u64 on 32-bit) have much more 
complicated translation.

As much as I dislike C++, my brain continues to think that we want some 
OOP-ish data-type-based dispatch to do this high->low translation, where 
the backend declares a set of operations for each C type.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 21:19:43 +0000
Message-ID: <407EFC6F.2030608 () pobox ! com>
--------------------
Christopher Li wrote:
> On Thu, Apr 15, 2004 at 04:50:35PM -0400, Jeff Garzik wrote:
> 
>>Linus Torvalds wrote:
>>
>>>One question: what do you think about signedness on the compare ops? When 
>>>we make the conversion from "expr->ops" to "instr->ops", my reaction is 
>>>that we should probably also take the sign into account, and have 
>>>OP_SET_LEU/OP_SET_GEU/OP_SET_LTU/OP_SET_GTU for the unsigned versions.
>>
>>>At that point any code downstream should hopefully no longer care about 
>>>any other details about the C types than the actual size of the type, 
>>>which makes sense to me. Comments?
>>
>>After having to worry about signedness in my silly backend, that would 
>>certainly be nice.
>>
>>The IL of some compilers looks like
>>
>>	addi.32
>>	subi.16
>>
>>etc. where the size is an attribute of the op.  It's probably a tossup 
>>where signedness is more useful as an attribute or an op, though I lean 
>>towards separate ops.
> 
> 
> That is one level lower than what I am worry about right now. It is not
> there yet.


Yeah, for higher level optimizations, you're probably right.

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 21:36:03 +0000
Message-ID: <407F0043.5050400 () pobox ! com>
--------------------
Christopher Li wrote:
> On Thu, Apr 15, 2004 at 05:19:43PM -0400, Jeff Garzik wrote:
> 
>>Christopher Li wrote:
>>
>>>That is one level lower than what I am worry about right now. It is not
>>>there yet.
>>
>>
>>Yeah, for higher level optimizations, you're probably right.
> 
> 
> You really want to have do as much higher level optimizations as you can before
> you goto machine dependent level.


I agree, though it doesn't _have_ to be that way.

As long as you don't _lose_ information from the high level, you can 
comfortably do optimizations at low level.  That is a bit problem with 
gcc's RTL -- you "free fall" from high level to low level, and lose tons 
of useful info in the process.  IBM's compiler does a lot of high level 
optimizations working exclusively from the lowest level.

But yes, performing optimizations at the C level is very desireable, as 
it is a lot more simple there.  I like putting the bulk of the 
optimizations at a higher level to keep the backend more simple.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: tommy () numba-tu ! com
To: linux-sparse
Subject: Re: [sparse be] PATCH: more op code
Date: Thu, 15 Apr 2004 22:44:50 +0000
Message-ID: <14709.65.113.40.130.1082069090.squirrel () numba-tu ! com>
--------------------
Awesome progress Chris.

> As my understanding, there are two major step on the down stream. One is
> the MIR
> (middle level of representation) which is target independent. Most of the
> compiler optimization stuff is done at this level. e.g. alias analyze,
> common expression eliminate and so on.

MIR is target independent, yes, but many optimization will probably depend
on the target.

Also, C99-style alias assumptions depends on C types, so we'd need to
handle that somehow.

> I don't see a need for adding more OP code for different
> type in MIR. Keeping the MIR instruction set small is good.

Amen!

Something else: I'm a little uncertain about the way parameters to
function calls are represented, eg. the "push".  It seems they aren't
explicitly linked to the call site and the order of them is important. 
While it matches stack based ABI well, it's kind of awkward for register
passing ABI.   It seems like a hard problem to find a model that works
well for both ABIs (and a mixed ABI).

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse be] PATCH: remove dead while loop ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse be] PATCH: remove dead while loop
Date: Mon, 29 Mar 2004 02:09:06 +0000
Message-ID: <20040329020906.GA6554 () 64m ! dyndns ! org>
--------------------
Hi Linus,

Here is a patch that improve the dead code eliminate for the
while loop inside if (0) case.The idea is that have a decoy
entrypoint for those while loops. On copy the basic block back
only if there is C level label was found inside the block.

It is tempting that left the dead code elimination and constant
propagation to the some back end pass.

Chris

Index: sparse-be/linearize.h
===================================================================
--- sparse-be.orig/linearize.h	2004-03-16 01:17:24.000000000 -0800
+++ sparse-be/linearize.h	2004-03-29 01:43:31.000000000 -0800
@@ -70,6 +70,8 @@
  */
 #define BB_HASBRANCH	0x00000001
 
+#define EP_HASLABEL	0x00000001
+
 struct basic_block {
 	unsigned long flags;		/* BB status flags */
 	struct symbol *this;		/* Points to the symbol that owns "this" basic block - NULL if unreachable */
@@ -88,6 +90,7 @@
 }
 
 struct entrypoint {
+	unsigned long flags;		/* entry point status flags */
 	struct symbol *name;
 	struct symbol_list *syms;
 	struct basic_block_list *bbs;
Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-03-28 05:30:32.000000000 -0800
+++ sparse-be/linearize.c	2004-03-29 01:49:57.000000000 -0800
@@ -162,6 +162,7 @@
 }
 
 #define bb_reachable(bb) ((bb)->this != NULL)
+#define ep_haslabel(ep) ((ep)->flags & EP_HASLABEL)
 
 static struct basic_block * new_basic_block(struct entrypoint *ep, struct symbol *owner)
 {
@@ -573,6 +574,7 @@
 
 	case STMT_LABEL: {
 		add_label(ep, stmt->label_identifier);
+		ep->flags |= EP_HASLABEL;
 		linearize_statement(ep, stmt->label_statement);
 		break;
 	}
@@ -701,6 +703,14 @@
 		struct statement  *post_statement = stmt->iterator_post_statement;
 		struct expression *post_condition = stmt->iterator_post_condition;
 		struct symbol *loop_top = NULL, *loop_bottom = NULL;
+		struct entrypoint *oldep = NULL;
+
+		if (!bb_reachable(ep->active)) {
+			oldep = ep;
+			ep = alloc_entrypoint();
+			ep->active = oldep->active;
+			ep->syms = oldep->syms;
+		}
 
 		concat_symbol_list(stmt->iterator_syms, &ep->syms);
 		linearize_statement(ep, pre_statement);
@@ -739,6 +749,11 @@
 			add_label(ep, stmt->iterator_break);
 		if (loop_bottom)
 			add_label(ep, loop_bottom);
+
+		if (oldep && ep_haslabel(ep)) {
+			concat_basic_block_list(ep->bbs, &oldep->bbs);
+			oldep->active = ep->active;
+		}
 		break;
 	}
 
Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-03-24 01:56:59.000000000 -0800
+++ sparse-be/lib.h	2004-03-29 01:43:31.000000000 -0800
@@ -29,6 +29,7 @@
 struct expression;
 struct expression_list;
 struct basic_block;
+struct basic_block_list;
 struct entrypoint;
 struct instruction;
 
@@ -95,6 +96,11 @@
 	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
 }
 
+static inline void concat_basic_block_list(struct basic_block_list *from, struct basic_block_list **to)
+{
+	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
+}
+
 static inline void add_symbol(struct symbol_list **list, struct symbol *sym)
 {
 	add_ptr_list((struct ptr_list **)list, sym);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Mon, 29 Mar 2004 10:59:59 +0000
Message-ID: <20040329105959.GA7069 () 64m ! dyndns ! org>
--------------------
On Mon, Mar 29, 2004 at 08:09:18AM -0800, Linus Torvalds wrote:
> 
> 
> Ok, I see what you're doing, although I would have assumed that this could 
> be done by simply looking at the "bb_readable()" flag on any of the parts 
> of the loop, without having to allocate a new EP.


But the while loop contain a "loop_top" label make the body basic
block reachable, then every one inside the loop is reachable.

If the loop_top start with unreachable, then find a C label in the middle
of loop body. The loop_top part will be come reachable and you have to
go back to regenerate those instructions.

Did I miss something?


> 
> In other words, I would think that it should be possible to actually get
> the "perfect"  translation for this:
> 
> 		goto inside;
> 		while (x) {
> 			x++;
> 	inside:
> 		goto outside;
> 			x++;
> 		}
> 	outside:

This patch will make it almost perfect translation.
It miss the ep->syms as you point out.


> 
> without having any "loop-global" flags, by just using the regular "is this
> part of the loop reachable" logic.

I still don't see how to handle the back edge of the loop that way.
Do it count as reachable? It can't decide until the whole body
of loop is scanned. 

> 
> Does it get too complicated that way?
> 
> Is insufficient, since at the very least you'd want to also concatenate 
> the symbols for the new entry-point, no?

You are absolutely right.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Mon, 29 Mar 2004 16:09:18 +0000
Message-ID: <Pine.LNX.4.58.0403290759421.1096 () ppc970 ! osdl ! org>
--------------------


On Sun, 28 Mar 2004, Christopher Li wrote:
>
> Here is a patch that improve the dead code eliminate for the while loop
> inside if (0) case.The idea is that have a decoy entrypoint for those
> while loops. On copy the basic block back only if there is C level label
> was found inside the block.

Ok, I see what you're doing, although I would have assumed that this could 
be done by simply looking at the "bb_readable()" flag on any of the parts 
of the loop, without having to allocate a new EP.

In other words, I would think that it should be possible to actually get
the "perfect"  translation for this:

		goto inside;
		while (x) {
			x++;
	inside:
		goto outside;
			x++;
		}
	outside:

without having any "loop-global" flags, by just using the regular "is this
part of the loop reachable" logic.

Does it get too complicated that way?

Also, as far as I can see, this:

> @@ -739,6 +749,11 @@
>  			add_label(ep, stmt->iterator_break);
>  		if (loop_bottom)
>  			add_label(ep, loop_bottom);
> +
> +		if (oldep && ep_haslabel(ep)) {
> +			concat_basic_block_list(ep->bbs, &oldep->bbs);
> +			oldep->active = ep->active;
> +		}

Is insufficient, since at the very least you'd want to also concatenate 
the symbols for the new entry-point, no?

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Wed, 31 Mar 2004 13:01:57 +0000
Message-ID: <20040331130157.GA14161 () 64m ! dyndns ! org>
--------------------
On Wed, Mar 31, 2004 at 08:59:22AM -0800, Linus Torvalds wrote:
> 
> 
> On Mon, 29 Mar 2004, Christopher Li wrote:
> So I'll apply your patch with the extra symbol-list concatenate, which 
> should fix the only real problem.

Here is a updated version of the patch with symbol-list concatenate.
Notice that I remove the "ep->syms = old->syms" line. So the decoy
ep will always start with empty symbols list.

Now I remember what I want to do before, it has been a while and this
is the bottom one of my patches. I try to reuse the ep->syms pointer.
But it doesn't work with new symbols list get created. Or I can use
"oldep->syms = ep->syms" in that case.

Great, now I can move to my next patch.

Chris



Index: sparse-be/linearize.h
===================================================================
--- sparse-be.orig/linearize.h	2004-03-16 01:17:24.000000000 -0800
+++ sparse-be/linearize.h	2004-03-29 01:43:31.000000000 -0800
@@ -70,6 +70,8 @@
  */
 #define BB_HASBRANCH	0x00000001
 
+#define EP_HASLABEL	0x00000001
+
 struct basic_block {
 	unsigned long flags;		/* BB status flags */
 	struct symbol *this;		/* Points to the symbol that owns "this" basic block - NULL if unreachable */
@@ -88,6 +90,7 @@
 }
 
 struct entrypoint {
+	unsigned long flags;		/* entry point status flags */
 	struct symbol *name;
 	struct symbol_list *syms;
 	struct basic_block_list *bbs;
Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-03-28 05:30:32.000000000 -0800
+++ sparse-be/linearize.c	2004-03-31 01:24:02.000000000 -0800
@@ -162,6 +162,7 @@
 }
 
 #define bb_reachable(bb) ((bb)->this != NULL)
+#define ep_haslabel(ep) ((ep)->flags & EP_HASLABEL)
 
 static struct basic_block * new_basic_block(struct entrypoint *ep, struct symbol *owner)
 {
@@ -573,6 +574,7 @@
 
 	case STMT_LABEL: {
 		add_label(ep, stmt->label_identifier);
+		ep->flags |= EP_HASLABEL;
 		linearize_statement(ep, stmt->label_statement);
 		break;
 	}
@@ -701,6 +703,13 @@
 		struct statement  *post_statement = stmt->iterator_post_statement;
 		struct expression *post_condition = stmt->iterator_post_condition;
 		struct symbol *loop_top = NULL, *loop_bottom = NULL;
+		struct entrypoint *oldep = NULL;
+
+		if (!bb_reachable(ep->active)) {
+			oldep = ep;
+			ep = alloc_entrypoint();
+			ep->active = oldep->active;
+		}
 
 		concat_symbol_list(stmt->iterator_syms, &ep->syms);
 		linearize_statement(ep, pre_statement);
@@ -739,6 +748,12 @@
 			add_label(ep, stmt->iterator_break);
 		if (loop_bottom)
 			add_label(ep, loop_bottom);
+
+		if (oldep && ep_haslabel(ep)) {
+			concat_basic_block_list(ep->bbs, &oldep->bbs);
+			concat_symbol_list(ep->syms, &oldep->syms);
+			oldep->active = ep->active;
+		}
 		break;
 	}
 
Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-03-24 01:56:59.000000000 -0800
+++ sparse-be/lib.h	2004-03-29 01:43:31.000000000 -0800
@@ -29,6 +29,7 @@
 struct expression;
 struct expression_list;
 struct basic_block;
+struct basic_block_list;
 struct entrypoint;
 struct instruction;
 
@@ -95,6 +96,11 @@
 	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
 }
 
+static inline void concat_basic_block_list(struct basic_block_list *from, struct basic_block_list **to)
+{
+	concat_ptr_list((struct ptr_list *)from, (struct ptr_list **)to);
+}
+
 static inline void add_symbol(struct symbol_list **list, struct symbol *sym)
 {
 	add_ptr_list((struct ptr_list **)list, sym);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Wed, 31 Mar 2004 16:59:22 +0000
Message-ID: <Pine.LNX.4.58.0403310857300.1116 () ppc970 ! osdl ! org>
--------------------


On Mon, 29 Mar 2004, Christopher Li wrote:
> 
> But the while loop contain a "loop_top" label make the body basic
> block reachable, then every one inside the loop is reachable.
> 
> If the loop_top start with unreachable, then find a C label in the middle
> of loop body. The loop_top part will be come reachable and you have to
> go back to regenerate those instructions.
> 
> Did I miss something?

No. I'm trying to think of some way to make it obvious, but you're right, 
I can't think of any.

So I'll apply your patch with the extra symbol-list concatenate, which 
should fix the only real problem.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Wed, 31 Mar 2004 22:19:41 +0000
Message-ID: <Pine.LNX.4.58.0403311415100.1116 () ppc970 ! osdl ! org>
--------------------


On Wed, 31 Mar 2004, Christopher Li wrote:
> 
> Here is a updated version of the patch with symbol-list concatenate.
> Notice that I remove the "ep->syms = old->syms" line. So the decoy
> ep will always start with empty symbols list.

I already did that, it's pushed out. My fixups were a bit silly, because I
didn't look at all the context (I restore the original "ep" but only
noticed later on that the value is dead by then), but I basically applied
your patch with a few trivial fixups.

I pushed it out to the BK trees, and also fixed another linearization
problem with constant-conditional loop conditionals (it would emit a
nonsensical conditional branch, instead of emitting a unconditional
branch).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Thu, 01 Apr 2004 17:06:53 +0000
Message-ID: <20040401170653.GA14903 () 64m ! dyndns ! org>
--------------------
On Wed, Mar 31, 2004 at 02:19:41PM -0800, Linus Torvalds wrote:
> 
> 
> On Wed, 31 Mar 2004, Christopher Li wrote:
> > 
> I already did that, it's pushed out. My fixups were a bit silly, because I
> didn't look at all the context (I restore the original "ep" but only
> noticed later on that the value is dead by then), but I basically applied
> your patch with a few trivial fixups.

Thanks, I already pull from the bk tree and merge your changes.

> 
> I pushed it out to the BK trees, and also fixed another linearization
> problem with constant-conditional loop conditionals (it would emit a
> nonsensical conditional branch, instead of emitting a unconditional
> branch).

My current change will going to rewrite that part. Sigh.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] PATCH: remove dead while loop
Date: Thu, 01 Apr 2004 17:06:53 +0000
Message-ID: <20040401170653.GA14903 () 64m ! dyndns ! org>
--------------------
On Wed, Mar 31, 2004 at 02:19:41PM -0800, Linus Torvalds wrote:
> 
> 
> On Wed, 31 Mar 2004, Christopher Li wrote:
> > 
> I already did that, it's pushed out. My fixups were a bit silly, because I
> didn't look at all the context (I restore the original "ep" but only
> noticed later on that the value is dead by then), but I basically applied
> your patch with a few trivial fixups.

Thanks, I already pull from the bk tree and merge your changes.

> 
> I pushed it out to the BK trees, and also fixed another linearization
> problem with constant-conditional loop conditionals (it would emit a
> nonsensical conditional branch, instead of emitting a unconditional
> branch).

My current change will going to rewrite that part. Sigh.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse be] RFC PATCH: condition branch simplify ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse be] RFC PATCH: condition branch simplify
Date: Thu, 01 Apr 2004 19:11:11 +0000
Message-ID: <20040401191111.GA15671 () 64m ! dyndns ! org>
--------------------
Hi Linus,

Please consider it as an RFC instead of a real patch submit.
It demonstrate the change I am working on.
Changes:
- Move the basic block less relies on the front end label.
  Goto directly use basic block as target instead of go through
  label. Most of the label and owner stuff is gone. bb_parents
  is in the basic block now.

- Introduce of the linearize_cond_expression to handle the folding
  of constant condition branch to simple goto's. It make if branch
  and while loop looks more flat. The price it pay is that some
  times it will left some empty goto blocks. It is not aiming at
  generate the most optimized at one pass. 

  But that should only happen if there is some constant folding going
  on. I try to optimized it away.  But the complexity it introduce
  make it not very worth while. I will left that to some back end
  pass.

- logical expression should be working now with very small price.
  e.g. 
  if ( 0 && a==5) {
      ...
  }
  will correctly skip the branch instruction. It should generate
  short circuit code correctly.

- introduce the PHI instruction to replace the MOVE instruction.
  so all the pseudo register has only one assignment. In other
  words,  the sub expression is in SSA form.  All the symbol
  value still stay in the memory.

- introduce the branch instruction to replace the condtrue/condfalse/jmp
  instruction.  It is used in linearize_cond_expression and it
  helps the simplify process. The reason to replace the jmp is that,
  if some branch can be optimized later on, just need to set the target
  to NULL, it don't need to change the instruction type. 

- introduce the switch instruction to replace the multivalue/multijmp
  instruction. All the terminator instruction fold into one instruction
  make it easier to iterate the out going edge. (instead of iterate
  the whole block to get to those terminate instructions.)

Any comment as welcome. Let me know how to shape it for submit.
 
Best Regards,

Chris

Index: sparse-be/linearize.h
===================================================================
--- sparse-be.orig/linearize.h	2004-03-31 23:50:22.000000000 -0800
+++ sparse-be/linearize.h	2004-04-01 12:32:17.000000000 -0800
@@ -20,11 +20,32 @@
 
 #define VOID (to_pseudo(0))
 
+struct multijmp {
+	struct basic_block *target;
+	int begin, end;
+};
+
+struct phi {
+	struct basic_block *source;
+	pseudo_t pseudo;
+};
+
 struct instruction {
 	struct symbol *type;
 	int opcode;
 	pseudo_t target;
 	union {
+		struct /* branch */ {
+			pseudo_t cond;
+			struct basic_block *bb_true, *bb_false;
+		};
+		struct /* switch */ {
+			pseudo_t switch_cond;
+			struct multijmp_list *multijmp_list;	/* switch */
+		};
+		struct /* phi_node */ {
+			struct phi_list *phi_list;
+		};
 		struct /* unops */ {
 			struct symbol *orig_type;	/* casts */
 			pseudo_t src;
@@ -42,18 +63,56 @@
 
 enum opcode {
 	OP_BADOP,
-	OP_CONDTRUE,
-	OP_CONDFALSE,
-	OP_SETVAL,
-	OP_MULTIVALUE,
-	OP_MULTIJUMP,
+	/* Terminator */
+	OP_RET,
+	OP_BR,
+	OP_SWITCH,
+	OP_INVOKE,
+	OP_UNWIND,
+	
+	/* Binary */
+	OP_ADD,
+	OP_SUB,
+	OP_MUL,
+	OP_DIV,
+	OP_REM,
+	OP_SHL,
+	OP_SHR,
+	
+	/* Logical */
+	OP_AND,
+	OP_OR,
+	OP_XOR,
+
+	/* Binary comparison */
+	OP_SET_EQ,
+	OP_SET_NE,
+	OP_SET_LE,
+	OP_SET_GE,
+	OP_SET_LT,
+	OP_SET_GT,
+	
+	/* Memory */
+	OP_MALLOC,
+	OP_FREE,
+	OP_ALLOCA,
 	OP_LOAD,
 	OP_STORE,
+	OP_SETVAL,
+	OP_GET_ELEMENT_PTR,
+
+	/* Other */
+	OP_PHI,
+	OP_CAST,
+	OP_CALL,
+	OP_VANEXT,
+	OP_VAARG,
+
+	/* The old op code */
+	OP_MULTIJUMP,
 	OP_MOVE,
 	OP_ARGUMENT,
-	OP_CALL,
 	OP_INDCALL,
-	OP_CAST,
 	OP_UNOP = 0x200,
 	OP_LASTUNOP = 0x3ff,
 	OP_BINOP = 0x400,
@@ -69,12 +128,15 @@
  * out of yet. 
  */
 #define BB_HASBRANCH	0x00000001
+#define BB_TERMINATED	0x00000001
+#define BB_REACHABLE	0x00000002
 
 #define EP_HASLABEL	0x00000001
 
 struct basic_block {
 	unsigned long flags;		/* BB status flags */
 	struct symbol *this;		/* Points to the symbol that owns "this" basic block - NULL if unreachable */
+	struct basic_block_list *parents; /* sources */
 	struct instruction_list *insns;	/* Linear list of instructions */
 	struct symbol *next;		/* Points to the symbol that describes the fallthrough */
 };
@@ -89,6 +151,16 @@
 	add_ptr_list((struct ptr_list **)list, insn);
 }
 
+static inline void add_multijmp(struct multijmp_list **list, struct multijmp *multijmp)
+{
+	add_ptr_list((struct ptr_list **)list, multijmp);
+}
+
+static inline void add_phi(struct phi_list **list, struct phi *phi)
+{
+	add_ptr_list((struct ptr_list **)list, phi);
+}
+
 struct entrypoint {
 	unsigned long flags;		/* entry point status flags */
 	struct symbol *name;
Index: sparse-be/linearize.c
===================================================================
--- sparse-be.orig/linearize.c	2004-03-31 23:50:22.000000000 -0800
+++ sparse-be/linearize.c	2004-04-01 17:06:40.000000000 -0800
@@ -18,6 +18,10 @@
 #include "expression.h"
 #include "linearize.h"
 
+#define bb_reachable(bb) ((bb) && ((bb)->flags & BB_REACHABLE))
+#define bb_terminated(bb) ((bb) && ((bb)->flags & BB_TERMINATED))
+#define ep_haslabel(ep) ((ep)->flags & EP_HASLABEL)
+
 pseudo_t linearize_statement(struct entrypoint *ep, struct statement *stmt);
 pseudo_t linearize_expression(struct entrypoint *ep, struct expression *expr);
 
@@ -39,6 +43,23 @@
 	return __alloc_basic_block(0);
 }
 
+static struct multijmp* alloc_multijmp(struct basic_block *target, int begin, int end)
+{
+	struct multijmp *multijmp = __alloc_multijmp(0);
+	multijmp->target = target;
+	multijmp->begin = begin;
+	multijmp->end = end;
+	return multijmp;
+}
+
+static struct phi* alloc_phi(struct basic_block *source, pseudo_t pseudo)
+{
+	struct phi *phi = __alloc_phi(0);
+	phi->source = source;
+	phi->pseudo = pseudo;
+	return phi;
+}
+
 static void show_instruction(struct instruction *insn)
 {
 	int op = insn->opcode;
@@ -47,11 +68,14 @@
 	case OP_BADOP:
 		printf("\tAIEEE! (%d %d)\n", insn->target.nr, insn->src.nr);
 		break;
-	case OP_CONDTRUE: case OP_CONDFALSE:
-		printf("\t%s %%r%d,%p\n",
-			op == OP_CONDTRUE ? "jne" : "jz",
-			insn->target.nr, insn->address->bb_target);
+	case OP_BR:
+		if (insn->bb_true && insn->bb_false) {
+			printf("\tbr\t%%r%d, .L%p, .L%p\n", insn->cond.nr, insn->bb_true, insn->bb_false);
+			break;
+		}
+		printf("\tbr\t.L%p\n", insn->bb_true ? insn->bb_true : insn->bb_false);
 		break;
+
 	case OP_SETVAL: {
 		struct expression *expr = insn->val;
 		switch (expr->type) {
@@ -72,21 +96,38 @@
 		}
 		break;
 	}
-	case OP_MULTIVALUE:
-		printf("\tswitch %%r%d\n", insn->target.nr);
+	case OP_SWITCH: {
+		struct multijmp *jmp;
+		printf("\tswitch %%r%d", insn->target.nr);
+		FOR_EACH_PTR(insn->multijmp_list, jmp) {
+			if (jmp->begin == jmp->end)
+				printf(", %d -> .L%p", jmp->begin, jmp->target);
+			else if (jmp->begin < jmp->end)
+				printf(", %d ... %d -> .L%p", jmp->begin, jmp->end, jmp->target);
+			else
+				printf(", default -> .L%p\n", jmp->target);
+		} END_FOR_EACH_PTR;
+		printf("\n");
 		break;
-	case OP_MULTIJUMP:
-		printf("\tcase %d ... %d -> %p\n", insn->begin, insn->end, insn->type);
+	}
+	
+	case OP_PHI: {
+		struct phi *phi;
+		char *s = " ";
+		printf("\t%%r%d <- phi", insn->target.nr);
+		FOR_EACH_PTR(insn->phi_list, phi) {
+			printf("%s(%%r%d, .L%p)", s, phi->pseudo.nr, phi->source);
+			s = ", ";
+		} END_FOR_EACH_PTR;
+		printf("\n");
 		break;
+	}	
 	case OP_LOAD:
 		printf("\tload %%r%d <- [%%r%d]\n", insn->target.nr, insn->src.nr);
 		break;
 	case OP_STORE:
 		printf("\tstore %%r%d -> [%%r%d]\n", insn->target.nr, insn->src.nr);
 		break;
-	case OP_MOVE:
-		printf("\t%%r%d <- %%r%d\n", insn->target.nr, insn->src.nr);
-		break;
 	case OP_ARGUMENT:
 		printf("\tpush %%r%d\n", insn->src.nr);
 		break;
@@ -120,24 +161,19 @@
 static void show_bb(struct basic_block *bb)
 {
 	struct instruction *insn;
-	struct symbol *owner = bb->this;
 
-	printf("bb: %p%s\n", bb, owner ? "" : " UNREACHABLE!!");
-	if (owner) {
+	printf("bb: %p\n", bb);
+	if (bb->parents) {
 		struct basic_block *from;
-		FOR_EACH_PTR(owner->bb_parents, from) {
+		FOR_EACH_PTR(bb->parents, from) {
 			printf("  **from %p**\n", from);
 		} END_FOR_EACH_PTR;
 	}
 	FOR_EACH_PTR(bb->insns, insn) {
 		show_instruction(insn);
 	} END_FOR_EACH_PTR;
-
-	if (bb->next) {
-		printf("\tgoto\t\t.L%p\n", bb->next->bb_target);
-	} else {
+	if (!bb_terminated(bb))
 		printf("\tEND\n");
-	}
 	printf("\n");
 }
 
@@ -161,90 +197,75 @@
 	printf("\n");
 }
 
-#define bb_reachable(bb) ((bb)->this != NULL)
-#define ep_haslabel(ep) ((ep)->flags & EP_HASLABEL)
-
-static struct basic_block * new_basic_block(struct entrypoint *ep, struct symbol *owner)
+static void bind_label(struct symbol *label, struct basic_block *bb, struct position pos)
 {
-	struct basic_block *bb;
-
-	if (!owner) {
-		static struct basic_block unreachable;
-		return &unreachable;
-	}
-		
-	bb = alloc_basic_block();
-	add_bb(&ep->bbs, bb);
-	bb->this = owner;
-	if (owner->bb_target)
-		warn(owner->pos, "Symbol already has a basic block %p", owner->bb_target);
-	owner->bb_target = bb;
-	return bb;
+	if (label->bb_target)
+		warn(pos, "label already binded\n");
+	label->bb_target = bb;
 }
 
-static void add_goto(struct basic_block *bb, struct symbol *sym)
+static struct basic_block * get_binded_block(struct entrypoint *ep, struct symbol *label)
 {
-	if (bb_reachable(bb)) {
-		bb->next = sym;
-		add_bb(&sym->bb_parents, bb);
+	struct basic_block *bb = label->bb_target;
+
+	if (!bb) {
+		label->bb_target = bb = alloc_basic_block();
+		bb->flags |= BB_REACHABLE;
 	}
+	return bb;
 }
 
-static void add_label(struct entrypoint *ep, struct symbol *sym)
+static void add_goto_from(struct basic_block *src, struct basic_block *dst)
 {
-	struct basic_block *new_bb = new_basic_block(ep, sym);
-	struct basic_block *bb = ep->active;
-
-	add_goto(bb, sym);
-	ep->active = new_bb;
-}
-
-/*
- * Add a anonymous label, return the symbol for it..
- *
- * If we already have a label for the top of the active
- * context, we can just re-use it.
- */
-static struct symbol *create_label(struct entrypoint *ep, struct position pos)
-{
-	struct basic_block *bb = ep->active;
-	struct symbol *label = bb->this;
-
-	if (!bb_reachable(bb) || !ptr_list_empty(bb->insns)) {
-		label = alloc_symbol(pos, SYM_LABEL);
-		add_label(ep, label);
+	if (bb_reachable(src)) {
+		struct instruction *br = alloc_instruction(OP_BR, NULL);
+		br->bb_true = dst;
+		dst->flags |= BB_REACHABLE;
+		src->flags |= BB_TERMINATED;
+		add_bb(&dst->parents, src);
+		add_instruction(&src->insns, br);
 	}
-	return label;
 }
 
 static void add_one_insn(struct entrypoint *ep, struct position pos, struct instruction *insn)
 {
 	struct basic_block *bb = ep->active;    
 
-	if (bb_reachable(bb)) {
-		if (bb->flags & BB_HASBRANCH) {
-			add_label(ep, alloc_symbol(pos, SYM_LABEL));
-			bb = ep->active;
-		}
+	if (bb_reachable(bb))
 		add_instruction(&bb->insns, insn);
-	}
 }
 
 static void set_unreachable(struct entrypoint *ep)
 {
-	ep->active = new_basic_block(ep, NULL);
+	ep->active->flags &= ~BB_REACHABLE;
+}
+
+static void set_activeblock(struct entrypoint *ep, struct basic_block *bb)
+{
+	if (!bb_terminated(ep->active))
+		add_goto_from(ep->active, bb);
+
+	ep->active = bb;
+	if (bb_reachable(bb))
+		add_bb(&ep->bbs, bb);
 }
 
-static void add_branch(struct entrypoint *ep, int opcode, struct expression *cond, struct symbol *target)
+static void add_branch(struct entrypoint *ep, struct expression *expr, pseudo_t cond, struct basic_block *bb_true, struct basic_block *bb_false)
 {
 	struct basic_block *bb = ep->active;
+	struct instruction *br;
 
 	if (bb_reachable(bb)) {
-		struct instruction *jump = alloc_instruction(opcode, target);
-		jump->address = target;
-		bb->flags |= BB_HASBRANCH;
-		add_instruction(&bb->insns, jump);
-		add_bb(&target->bb_parents, bb);
+       		br = alloc_instruction(OP_BR, expr->ctype);
+		br->cond = cond;
+		br->bb_true = bb_true;
+		br->bb_false = bb_false;
+		bb->flags |= BB_TERMINATED;
+		bb_true->flags |= BB_REACHABLE;
+		bb_false->flags |= BB_REACHABLE;
+		add_bb(&bb_true->parents, bb);
+		add_bb(&bb_false->parents, bb);
+		add_one_insn(ep, expr->pos, br);
 	}
 }
 
@@ -442,44 +463,93 @@
 	return result;
 }
 
-static void cond_branch(struct entrypoint *ep, int op, struct symbol *ctype, pseudo_t pseudo, struct symbol *target)
+static pseudo_t linearize_logical_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false);
+
+pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false);
+
+static pseudo_t linearize_logical(struct entrypoint *ep, struct expression *expr)
 {
+	pseudo_t src1, src2, target;
+	struct basic_block *bb_true = alloc_basic_block();
+	struct basic_block *bb_false = alloc_basic_block();
+	struct basic_block *merge = alloc_basic_block();
+	struct basic_block *first = bb_true;
+	struct basic_block *second = bb_false;
 	struct instruction *insn;
-	struct basic_block *bb = ep->active;
 
-	insn = alloc_instruction(op, ctype);
-	insn->address = target;
-	bb->flags |= BB_HASBRANCH;
-	add_instruction(&bb->insns, insn);
-	add_bb(&target->bb_parents, bb);
-}
+	if (expr->op == SPECIAL_LOGICAL_OR) {
+		first = bb_false;
+		second = bb_true;
+	}
 
-static void copy_pseudo(struct entrypoint *ep, struct expression *expr, pseudo_t old, pseudo_t new)
-{
-	struct instruction *insn = alloc_instruction(OP_MOVE, expr->ctype);
-	insn->target = new;
-	insn->src = old;
-	add_one_insn(ep, expr->pos, insn);
+	linearize_cond_branch(ep, expr->left, bb_true, bb_false);
+
+	set_activeblock(ep, first);
+	src1 = linearize_expression(ep, expr->right);
+	add_goto_from(ep->active, merge);
+
+	set_activeblock(ep, second);
+       	insn = alloc_instruction(OP_SETVAL, expr->ctype);
+	insn->target = src2 = alloc_pseudo();
+	insn->val = alloc_const_expression(expr->pos, expr->op == SPECIAL_LOGICAL_OR);
+	add_one_insn(ep, expr->pos,insn);
+
+	set_activeblock(ep, merge);
+
+	if (bb_reachable(bb_true) && bb_reachable(bb_false)) {
+		struct instruction *phi_node = alloc_instruction(OP_PHI, expr->ctype);
+		add_phi(&phi_node->phi_list, alloc_phi(first, src1));
+		add_phi(&phi_node->phi_list, alloc_phi(second, src2));
+		phi_node->target = target = alloc_pseudo();
+		add_one_insn(ep, expr->pos, phi_node);
+		set_activeblock(ep, alloc_basic_block());
+		return target;
+	}
+
+	return bb_reachable(first) ? src1 : src2;
 }
 
-static pseudo_t linearize_logical(struct entrypoint *ep, struct expression *expr)
+pseudo_t linearize_cond_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false)
 {
-	pseudo_t src1, src2, result;
-	struct symbol *label;
-	int op = (expr->op == SPECIAL_LOGICAL_OR) ? OP_CONDTRUE : OP_CONDFALSE;
+	if (!expr || !bb_reachable(ep->active))
+		return VOID;
 
-	src1 = linearize_expression(ep, expr->left);
-	result = alloc_pseudo();
-	copy_pseudo(ep, expr, src1, result);
+	switch (expr->type) {
 
-	/* Conditional jump */
-	label = alloc_symbol(expr->pos, SYM_LABEL);
-	cond_branch(ep, op, expr->ctype, src1, label);
+	case EXPR_STRING:
+	case EXPR_VALUE:
+		add_goto_from(ep->active, expr->value ? bb_true : bb_false);
+		return VOID;
+		
+	case EXPR_LOGICAL:
+		linearize_logical_branch(ep, expr, bb_true, bb_false);
+		return VOID;
 
-	src2 = linearize_expression(ep, expr->right);
-	copy_pseudo(ep, expr, src2, result);
-	add_label(ep, label);
-	return result;
+	case EXPR_PREOP:
+		if (expr->op == '!')
+			return linearize_cond_branch(ep, expr->unop, bb_false, bb_true);
+		/* fall through */
+	default: {
+		pseudo_t cond = linearize_expression(ep, expr);
+		add_branch(ep, expr, cond, bb_true, bb_false);
+
+		return VOID;
+	}
+	}
+	return VOID;
+}
+
+static pseudo_t linearize_logical_branch(struct entrypoint *ep, struct expression *expr, struct basic_block *bb_true, struct basic_block *bb_false)
+{
+	struct basic_block *next = alloc_basic_block();
+
+	if (expr->op == SPECIAL_LOGICAL_OR)
+		linearize_cond_branch(ep, expr->left, bb_true, next);
+	else
+		linearize_cond_branch(ep, expr->left, next, bb_false);
+	set_activeblock(ep, next);
+	linearize_cond_branch(ep, expr->right, bb_true, bb_false);
+	return VOID;
 }
 
 pseudo_t linearize_cast(struct entrypoint *ep, struct expression *expr)
@@ -575,20 +645,22 @@
 	}
 
 	case STMT_CASE: {
-		add_label(ep, stmt->case_label);
+		struct basic_block *bb = get_binded_block(ep, stmt->case_label);
+		set_activeblock(ep, bb);
 		linearize_statement(ep, stmt->case_statement);
 		break;
 	}
 
 	case STMT_LABEL: {
-		add_label(ep, stmt->label_identifier);
+		struct basic_block *bb = get_binded_block(ep, stmt->label_identifier);
+		set_activeblock(ep, bb);
 		ep->flags |= EP_HASLABEL;
 		linearize_statement(ep, stmt->label_statement);
 		break;
 	}
 
 	case STMT_GOTO: {
-		add_goto(ep->active, stmt->goto_label);
+		add_goto_from(ep->active, get_binded_block(ep, stmt->goto_label));
 		set_unreachable(ep);
 		break;
 	}
@@ -608,99 +680,67 @@
 	 * switch the arms around appropriately..
 	 */
 	case STMT_IF: {
-		struct symbol *target;
-		struct basic_block *if_block;
-		struct expression *cond = stmt->if_conditional;
-
-		if (cond->type == EXPR_VALUE) {
-			struct statement *always = stmt->if_true;
-			struct statement *never = stmt->if_false;
-
-			if (!cond->value) {
-				never = always;
-				always = stmt->if_false;
-			}
-			if (always)
-				linearize_statement(ep, always);
-			if (never) {
-				struct basic_block *bb = ep->active;
-				set_unreachable(ep);
-				linearize_statement(ep, never);
-
-				/*
-				 * If the "never case" is reachable some other
-				 * way, we need to merge the old always case
-				 * with the fallthrough of the never case.
-				 */
-				if (bb_reachable(ep->active)) {
-					add_goto(bb, create_label(ep, never->pos));
-					break;
-				}
+		struct basic_block *bb_true, *bb_false, *endif;
+ 		struct expression *cond = stmt->if_conditional;
 
-				/* Otherwise we just continue with the old always case.. */
-				ep->active = bb;
-			}
-			break;
-		}
-			
+		bb_true = alloc_basic_block();
+		bb_false = endif = alloc_basic_block();
 
-		target = alloc_symbol(stmt->pos, SYM_LABEL);
-		add_branch(ep, OP_CONDFALSE, cond, target);
+ 		linearize_cond_branch(ep, cond, bb_true, bb_false);
 
-		linearize_statement(ep, stmt->if_true);
-
-		if_block = ep->active;
-		add_label(ep, target);
-		
-		if (stmt->if_false) {
-			struct symbol *else_target = alloc_symbol(stmt->pos, SYM_LABEL);
-			add_goto(if_block, else_target);
-			linearize_statement(ep, stmt->if_false);
-			add_label(ep, else_target);
+		set_activeblock(ep, bb_true);
+ 		linearize_statement(ep, stmt->if_true);
+ 
+ 		if (stmt->if_false) {
+			endif = alloc_basic_block();
+			add_goto_from(bb_true, endif);
+			set_activeblock(ep, bb_false);
+ 			linearize_statement(ep, stmt->if_false);
 		}
+		set_activeblock(ep, endif);
 		break;
 	}
 
 	case STMT_SWITCH: {
-		int default_seen;
 		struct symbol *sym;
-		struct instruction *switch_value;
+		struct instruction *switch_ins;
+		struct basic_block *switch_end = alloc_basic_block();
 		pseudo_t pseudo;
 
-		/* Create the "head node" */
-		if (!bb_reachable(ep->active))
-			break;
-
 		pseudo = linearize_expression(ep, stmt->switch_expression);
-		switch_value = alloc_instruction(OP_MULTIVALUE, NULL);
-		switch_value->target = pseudo;
-		add_one_insn(ep, stmt->pos, switch_value);
+		switch_ins = alloc_instruction(OP_SWITCH, NULL);
+		switch_ins->target = pseudo;
+		add_one_insn(ep, stmt->pos, switch_ins);
+		ep->active->flags |= BB_TERMINATED;
 
-		/* Create all the sub-jumps */
-		default_seen = 0;
 		FOR_EACH_PTR(stmt->switch_case->symbol_list, sym) {
 			struct statement *case_stmt = sym->stmt;
-			struct instruction *sw_bb = alloc_instruction(OP_MULTIJUMP, sym);
-			if (!case_stmt->case_expression)
-				default_seen = 1;
-			if (case_stmt->case_expression)
-				sw_bb->begin = case_stmt->case_expression->value;
-			if (case_stmt->case_to)
-				sw_bb->end = case_stmt->case_to->value;
-			add_one_insn(ep, stmt->pos, sw_bb);
-			add_bb(&sym->bb_parents, ep->active);
+			struct basic_block *bb_case = get_binded_block(ep, sym);
+			struct multijmp *jmp;
+			int begin, end;
+			if (!case_stmt->case_expression) {
+			      jmp = alloc_multijmp(bb_case, 1, 0);
+			} else {
+				if (case_stmt->case_expression)
+					begin = end = case_stmt->case_expression->value;
+				if (case_stmt->case_to)
+					end = case_stmt->case_to->value;
+				if (begin > end)
+					jmp = alloc_multijmp(bb_case, end, begin);
+				else
+					jmp = alloc_multijmp(bb_case, begin, end);
+
+			}
+			add_multijmp(&switch_ins->multijmp_list, jmp);
+			add_bb(&bb_case->parents, ep->active);
 		} END_FOR_EACH_PTR;
 
-		/* Default fall-through case */
-		if (!default_seen)
-			add_goto(ep->active, stmt->switch_break);
-		set_unreachable(ep);
+		bind_label(stmt->switch_break, switch_end, stmt->pos);
 
 		/* And linearize the actual statement */
 		linearize_statement(ep, stmt->switch_statement);
+		set_activeblock(ep, switch_end);
 
-		/* ..then tie it all together at the end.. */
-		add_label(ep, stmt->switch_break);
 		break;
 	}
 
@@ -710,7 +750,7 @@
 		struct statement  *statement = stmt->iterator_statement;
 		struct statement  *post_statement = stmt->iterator_post_statement;
 		struct expression *post_condition = stmt->iterator_post_condition;
-		struct symbol *loop_top = NULL, *loop_bottom = NULL;
+		struct basic_block *loop_top, *loop_body, *loop_continue, *loop_end;
 		struct entrypoint *oldep = NULL;
 
 		if (!bb_reachable(ep->active)) {
@@ -721,46 +761,42 @@
 
 		concat_symbol_list(stmt->iterator_syms, &ep->syms);
 		linearize_statement(ep, pre_statement);
-		if (pre_condition && bb_reachable(ep->active)) {
-			if (pre_condition->type == EXPR_VALUE) {
-				if (!pre_condition->value) {
-					loop_bottom = alloc_symbol(stmt->pos, SYM_LABEL);
-					add_goto(ep->active, loop_bottom);
-					set_unreachable(ep);
-				}
-			} else {
-				loop_bottom = alloc_symbol(stmt->pos, SYM_LABEL);
-				add_branch(ep, OP_CONDFALSE, pre_condition, loop_bottom);
-			}
-		}
 
-		if (!post_condition || post_condition->type != EXPR_VALUE || post_condition->value)
-			loop_top = create_label(ep, stmt->pos);
+ 		loop_body = loop_top = alloc_basic_block();
+ 		loop_continue = alloc_basic_block();
+ 		loop_end = alloc_basic_block();
+ 
+		if (!post_statement && (pre_condition == post_condition)) {
+			/*
+			 * If it is a loop, optimize away the post_condition.
+			 */
+			post_condition = NULL;
+			loop_body = loop_continue;
+			loop_continue = loop_top;
+			loop_top->flags |= BB_REACHABLE;
+			set_activeblock(ep, loop_top);
+		}
 
-		linearize_statement(ep, statement);
+		loop_top->flags |= BB_REACHABLE;
+		if (pre_condition) 
+ 			linearize_cond_branch(ep, pre_condition, loop_body, loop_end);
 
-		if (stmt->iterator_continue->used)
-			add_label(ep, stmt->iterator_continue);
+		bind_label(stmt->iterator_continue, loop_continue, stmt->pos);
+		bind_label(stmt->iterator_break, loop_end, stmt->pos);
 
-		linearize_statement(ep, post_statement);
+		set_activeblock(ep, loop_body);
+		linearize_statement(ep, statement);
+		add_goto_from(ep->active, loop_continue);
 
-		if (!post_condition) {
-			add_goto(ep->active, loop_top);
-			set_unreachable(ep);
-		} else {
-			if (post_condition->type == EXPR_VALUE) {
-				if (post_condition->value) {
-					add_goto(ep->active, loop_top);
-					set_unreachable(ep);
-				}
-			} else
-				add_branch(ep, OP_CONDTRUE, post_condition, loop_top);
+		if (post_statement) {
+			set_activeblock(ep, loop_continue);
+			linearize_statement(ep, post_statement);
 		}
 
-		if (stmt->iterator_break->used)
-			add_label(ep, stmt->iterator_break);
-		if (loop_bottom)
-			add_label(ep, loop_bottom);
+		if (post_condition)
+ 			linearize_cond_branch(ep, post_condition, loop_top, loop_end);
+
+		set_activeblock(ep, loop_end);
 
 		/*
 		 * If we started out unreachable, maybe the inside
@@ -795,9 +831,11 @@
 	if (base_type->type == SYM_FN) {
 		if (base_type->stmt) {
 			struct entrypoint *ep = alloc_entrypoint();
+			struct basic_block *bb = alloc_basic_block();
 
 			ep->name = sym;
-			ep->active = new_basic_block(ep, sym);
+			bb->flags |= BB_REACHABLE;
+			set_activeblock(ep, bb);
 			concat_symbol_list(base_type->arguments, &ep->syms);
 			linearize_statement(ep, base_type->stmt);
 			show_entry(ep);
Index: sparse-be/symbol.h
===================================================================
--- sparse-be.orig/symbol.h	2004-03-31 23:50:22.000000000 -0800
+++ sparse-be/symbol.h	2004-04-01 12:32:17.000000000 -0800
@@ -95,7 +95,6 @@
 		struct symbol_list *symbol_list;
 		struct expression *initializer;
 		struct basic_block *bb_target;	/* label */
-		struct basic_block_list *bb_parents; /* sources */
 		long long value;		/* Initial value */
 	};
 	void *aux;				/* Auxiliary info, eg. backend information */
Index: sparse-be/lib.h
===================================================================
--- sparse-be.orig/lib.h	2004-04-01 01:37:44.000000000 -0800
+++ sparse-be/lib.h	2004-04-01 12:32:17.000000000 -0800
@@ -32,6 +32,7 @@
 struct basic_block_list;
 struct entrypoint;
 struct instruction;
+struct multijmp;
 
 struct token *skip_to(struct token *, int);
 struct token *expect(struct token *, int, const char *);
@@ -55,6 +56,8 @@
 DECLARE_ALLOCATOR(basic_block);
 DECLARE_ALLOCATOR(entrypoint);
 DECLARE_ALLOCATOR(instruction);
+DECLARE_ALLOCATOR(multijmp);
+DECLARE_ALLOCATOR(phi);
 
 
 #define LIST_NODE_NR (29)
Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c	2004-03-16 01:17:24.000000000 -0800
+++ sparse-be/lib.c	2004-04-01 12:32:17.000000000 -0800
@@ -159,6 +159,8 @@
 struct allocator_struct basic_block_allocator = { "basic_block", NULL, __alignof__(struct basic_block), CHUNK };
 struct allocator_struct entrypoint_allocator = { "entrypoint", NULL, __alignof__(struct entrypoint), CHUNK };
 struct allocator_struct instruction_allocator = { "instruction", NULL, __alignof__(struct instruction), CHUNK };
+struct allocator_struct multijmp_allocator = { "multijmp", NULL, __alignof__(struct multijmp), CHUNK };
+struct allocator_struct phi_allocator = { "phi", NULL, __alignof__(struct phi), CHUNK };
 
 #define __ALLOCATOR(type, size, x)				\
 	type *__alloc_##x(int extra)				\
@@ -180,6 +182,8 @@
 ALLOCATOR(scope); __ALLOCATOR(void, 0, bytes);
 ALLOCATOR(basic_block); ALLOCATOR(entrypoint);
 ALLOCATOR(instruction);
+ALLOCATOR(multijmp);
+ALLOCATOR(phi);
 
 int ptr_list_size(struct ptr_list *head)
 {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse be] RFC PATCH: condition branch simplify
Date: Fri, 02 Apr 2004 07:36:51 +0000
Message-ID: <Pine.LNX.4.58.0404012247160.1122 () ppc970 ! osdl ! org>
--------------------


On Thu, 1 Apr 2004, Christopher Li wrote:
> 
> Please consider it as an RFC instead of a real patch submit.
> It demonstrate the change I am working on.

Argh. Please do use "bound" instead of "binded". Yeah, I realize that 
some people do seem to use "binded", but it drives me mad.

> Changes:
> - Move the basic block less relies on the front end label.
>   Goto directly use basic block as target instead of go through
>   label. Most of the label and owner stuff is gone. bb_parents
>   is in the basic block now.

Hmm. I don't mind this per se, and it seems that you left the symbol for 
what I really used it for, ie as a indirection for labels and goto's, so 
that they can always be resolved even when the target (or the goto) hasn't 
been seen yet.

You allocate the basic block early, before actually seeing the label for
it, and I guess that's fine - it avoids the indirection later on, so I
don't disagree. Did you test what happens if the label doesn't exist?

On the whole, I think I like your change.

> - Introduce of the linearize_cond_expression to handle the folding
>   of constant condition branch to simple goto's. It make if branch
>   and while loop looks more flat. The price it pay is that some
>   times it will left some empty goto blocks. It is not aiming at
>   generate the most optimized at one pass. 

All the callers should have done this already on their own. Didn't they do 
that already?

In particular, a conditional expression that is always true or always 
false should _not_ just be turned into a unconditional branch or a no-op 
along with a target that is never used. I want the very common

	#define xxxx do { yyyy } while (0)

to literally have _zero_ cost at linearization, which implies that there
should be no label that breaks up what would otherwise have been a nice
basic block. This is why I was very careful when doing if-statements and 
iterators to _not_ generate unnecessary basic blocks.

I absolutely _detest_ having syntactic sugar (and the "do while (0)" thing 
is common syntactic sugar) impacting later optimization decisions. I do 
_not_ want a back-end that has to tie these pieces together. Some things 
are not for the back-end to worry about.

Basically, a compiler MUST ALWAYS generate the exact same code for

	aaa
	bbb
	ccc

as for

	do { aaa } while (0);
	do { bbb } while (0);
	do { ccc } while (0);

and a compiler that doesn't do that is in my opinion just buggy. And I 
don't trust the back-end to stitch them all together in all cases, so I 
want to do these kinds of trivial transformations _early_, so that nobody 
can ever get it wrong even by mistake.

So I'd rather have a bit more complicated iterator flattening, if it means 
that the iterator flattening does the right thing every time.

> - logical expression should be working now with very small price.
>   e.g. 
>   if ( 0 && a==5) {
>       ...
>   }
>   will correctly skip the branch instruction. It should generate
>   short circuit code correctly.

We should have done this at the tree level already, and you should never 
see anything like this when linearizing. Did you actually see this in 
practice? 

See "expand_logical()" in expand.c.

> - introduce the PHI instruction to replace the MOVE instruction.
>   so all the pseudo register has only one assignment. In other
>   words,  the sub expression is in SSA form.  All the symbol
>   value still stay in the memory.

I'll bow down to the back-end on this one, I have no real reason to care.

> - introduce the branch instruction to replace the condtrue/condfalse/jmp
>   instruction.  It is used in linearize_cond_expression and it
>   helps the simplify process. The reason to replace the jmp is that,
>   if some branch can be optimized later on, just need to set the target
>   to NULL, it don't need to change the instruction type. 

Ok. I definitely agree that it was a mistake to have separate instructions 
for true/false. I tried to keep the size of "struct instruction" down to a 
minimum, and you just made it grow by another pointer. Probably worth it.

> - introduce the switch instruction to replace the multivalue/multijmp
>   instruction. All the terminator instruction fold into one instruction
>   make it easier to iterate the out going edge. (instead of iterate
>   the whole block to get to those terminate instructions.)

No problem. 

I'm ok with your changes, apart from the picky naming thing ("bound").

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: [sparse be] RFC PATCH: condition branch simplify
Date: Fri, 02 Apr 2004 07:53:56 +0000
Message-ID: <406D1C14.2030400 () numba-tu ! com>
--------------------
Linus Torvalds wrote:

> Basically, a compiler MUST ALWAYS generate the exact same code for
>
>	aaa
>	bbb
>	ccc
>
>as for
>
>	do { aaa } while (0);
>	do { bbb } while (0);
>	do { ccc } while (0);
>
>and a compiler that doesn't do that is in my opinion just buggy.
>
Really?  I don't think so.

do { continue; } while (0);
do { break; } while (0);
etc.

but other than that I agree :-)

>And I don't trust the back-end to stitch them all together in all cases,
>
Well if it doesn't then it's buggy IMO.


Exciting progress.

Unfortunately all my spare cycles have been sunk into my FPGA MIPS 
computer, but it's got graphics running (demos!), runs code off the the 
external SRAM, and has serial in and out now :-)

Tommy


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse be] RFC PATCH: condition branch simplify
Date: Fri, 02 Apr 2004 12:36:32 +0000
Message-ID: <20040402123632.GA2502 () 64m ! dyndns ! org>
--------------------
On Thu, Apr 01, 2004 at 11:36:51PM -0800, Linus Torvalds wrote:
> 
> 
> On Thu, 1 Apr 2004, Christopher Li wrote:
> > 
> > Please consider it as an RFC instead of a real patch submit.
> > It demonstrate the change I am working on.
> 
> Argh. Please do use "bound" instead of "binded". Yeah, I realize that 
> some people do seem to use "binded", but it drives me mad.

Ouch. Sure.

> 
> Hmm. I don't mind this per se, and it seems that you left the symbol for 
> what I really used it for, ie as a indirection for labels and goto's, so 
> that they can always be resolved even when the target (or the goto) hasn't 
> been seen yet.

That is right.
Notice that these basic block has not add to the entry pointer yet.

> 
> You allocate the basic block early, before actually seeing the label for
> it, and I guess that's fine - it avoids the indirection later on, so I
> don't disagree. Did you test what happens if the label doesn't exist?

You mean the label haven't been used? It will generate discontinue
block at the place of label. I think we should able to make the front
end code mark the label is unused. Then ignore those labels.

> 
> On the whole, I think I like your change.
> 
> > - Introduce of the linearize_cond_expression to handle the folding
> >   of constant condition branch to simple goto's. It make if branch
> >   and while loop looks more flat. The price it pay is that some
> >   times it will left some empty goto blocks. It is not aiming at
> >   generate the most optimized at one pass. 
> 
> All the callers should have done this already on their own. Didn't they do 
> that already?
>

Yes, in a complicate way. I will try harder on better optimized
the block and emit a nice big block.
 
> 
> I absolutely _detest_ having syntactic sugar (and the "do while (0)" thing 
> is common syntactic sugar) impacting later optimization decisions. I do 
> _not_ want a back-end that has to tie these pieces together. Some things 
> are not for the back-end to worry about.

It is some thing that the back end has to worry about any way.
e.g. 

{
	int a =1;
	if (a) {
		b = 2;
	}
}

Now the after constant propagation and data flow analyze, the back
end can decide to remove the branch. Then back end need to do the job
that stitch them together any way.

> 
> Basically, a compiler MUST ALWAYS generate the exact same code for
> 
> 	aaa
> 	bbb
> 	ccc
> 
> as for
> 
> 	do { aaa } while (0);
> 	do { bbb } while (0);
> 	do { ccc } while (0);
>

I agree. But the question that is do we have to do that in the
linearizion step? It is only a middle layer of the representation.
The back end optimized code need to deal with that any way.
When all the basic block is ready. It is easy to
look that which block can be merged and how to merge them.
 
> and a compiler that doesn't do that is in my opinion just buggy. And I 
> don't trust the back-end to stitch them all together in all cases, so I 
> want to do these kinds of trivial transformations _early_, so that nobody 
> can ever get it wrong even by mistake.

I agree. If the compiler is buggy, the right fix should be fixing the
transform code to do the right thing. I am still not convince that
introduce extra complexity in linearizion step for some duplicated
function in the back end is worth while.

> So I'd rather have a bit more complicated iterator flattening, if it means 
> that the iterator flattening does the right thing every time.

I will try harder on that any way.

> 
> > - logical expression should be working now with very small price.
> >   e.g. 
> >   if ( 0 && a==5) {
> >       ...
> >   }
> >   will correctly skip the branch instruction. It should generate
> >   short circuit code correctly.
> 
> We should have done this at the tree level already, and you should never 
> see anything like this when linearizing. Did you actually see this in 
> practice? 
> 
> See "expand_logical()" in expand.c.
> 

Hmm. I know it will optimized away but I might give the wrong credit.
Does it handle label inside the expression after "0 &&" ?

> 
> I'm ok with your changes, apart from the picky naming thing ("bound").

Thanks, I will provide a better patch. I know Tommy is laughing on the
"bound" thing.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse, be] get loops working ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse, be] get loops working
Date: Sun, 08 Feb 2004 21:59:21 +0000
Message-ID: <20040208215921.GA12989 () gtf ! org>
--------------------

A little bit of sparse hacking for today as well.

The last big to-do is noticing and dealing with operand size.
Oh and 64-bit integer stuff is probably wrong.

Please do a

	bk pull bk://kernel.bkbits.net/jgarzik/sparse.be

This will update the following files:

 compile-i386.c |  143 ++++++++++++++++++++++++++++++++++++++++++++-------------
 1 files changed, 111 insertions(+), 32 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (04/02/08 1.449)
   [be] Handle 'break' and 'continue' inside loops.

<jgarzik@redhat.com> (04/02/08 1.448)
   [be] handle 'break' and 'continue' in loop emit code
   
   The loop generator should be correct now; all that remains is to
   actually generate the jumps based on the loop label info we now
   store in the "loop stack".

<jgarzik@redhat.com> (04/02/08 1.447)
   [be] Get most of loops working.
   
   The thing that remains is getting 'break' and 'continue' assigned
   to the correct jump targets.

diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Sun Feb  8 16:55:09 2004
+++ b/compile-i386.c	Sun Feb  8 16:55:09 2004
@@ -41,7 +41,6 @@
 #include "target.h"
 
 
-struct textbuf;
 struct textbuf {
 	unsigned int	len;	/* does NOT include terminating null */
 	char		*text;
@@ -49,12 +48,19 @@
 	struct textbuf	*prev;
 };
 
+struct loop_stack {
+	int		continue_lbl;
+	int		loop_bottom_lbl;
+	struct loop_stack *next;
+};
+
 struct function {
 	int stack_size;
 	int pseudo_nr;
 	struct ptr_list *pseudo_list;
 	struct ptr_list *atom_list;
 	struct ptr_list *str_list;
+	struct loop_stack *loop_stack;
 	struct symbol **argv;
 	unsigned int argc;
 	int ret_target;
@@ -1522,51 +1528,114 @@
 	} END_FOR_EACH_PTR;
 }
 
-static void x86_loop(struct statement *stmt)
+static void loopstk_push(int cont_lbl, int loop_bottom_lbl)
+{
+	struct function *f = current_func;
+	struct loop_stack *ls;
+
+	ls = malloc(sizeof(*ls));
+	ls->continue_lbl = cont_lbl;
+	ls->loop_bottom_lbl = loop_bottom_lbl;
+	ls->next = f->loop_stack;
+	f->loop_stack = ls;
+}
+
+static void loopstk_pop(void)
+{
+	struct function *f = current_func;
+	struct loop_stack *ls;
+
+	assert(f->loop_stack != NULL);
+	ls = f->loop_stack;
+	f->loop_stack = f->loop_stack->next;
+	free(ls);
+}
+
+static int loopstk_break(void)
+{
+	return current_func->loop_stack->loop_bottom_lbl;
+}
+
+static int loopstk_continue(void)
+{
+	return current_func->loop_stack->continue_lbl;
+}
+
+static void emit_loop(struct statement *stmt)
 {
 	struct statement  *pre_statement = stmt->iterator_pre_statement;
 	struct expression *pre_condition = stmt->iterator_pre_condition;
 	struct statement  *statement = stmt->iterator_statement;
 	struct statement  *post_statement = stmt->iterator_post_statement;
 	struct expression *post_condition = stmt->iterator_post_condition;
-	int loop_top = 0, loop_bottom = 0;
+	int loop_top = 0, loop_bottom, loop_continue;
+	int have_bottom = 0;
 	struct storage *val;
 
+	loop_bottom = new_label();
+	loop_continue = new_label();
+	loopstk_push(loop_continue, loop_bottom);
+
 	x86_symbol_decl(stmt->iterator_syms);
 	x86_statement(pre_statement);
 	if (pre_condition) {
 		if (pre_condition->type == EXPR_VALUE) {
 			if (!pre_condition->value) {
-				loop_bottom = new_label();
-				printf("\tjmp\t\t.L%d\n", loop_bottom);
+				struct storage *lbv;
+				lbv = new_storage(STOR_LABEL);
+				lbv->label = loop_bottom;
+				lbv->flags = STOR_WANTS_FREE;
+				insn("jmp", lbv, NULL, "go to loop bottom");
+				have_bottom = 1;
 			}
 		} else {
-			loop_bottom = new_label();
+			struct storage *lbv = new_storage(STOR_LABEL);
+			lbv->label = loop_bottom;
+			lbv->flags = STOR_WANTS_FREE;
+			have_bottom = 1;
+
 			val = x86_expression(pre_condition);
-			printf("\tje\t\tv%d, .L%d\n", val->pseudo, loop_bottom);
+
+			emit_move(val, REG_EAX, NULL, "loop pre condition");
+			insn("test", REG_EAX, REG_EAX, NULL);
+			insn("jz", lbv, NULL, NULL);
 		}
 	}
 	if (!post_condition || post_condition->type != EXPR_VALUE || post_condition->value) {
 		loop_top = new_label();
-		printf(".L%d:\n", loop_top);
+		emit_label(loop_top, "loop top");
 	}
 	x86_statement(statement);
 	if (stmt->iterator_continue->used)
-		printf(".L%p:\n", stmt->iterator_continue);
+		emit_label(loop_continue, "'continue' iterator");
 	x86_statement(post_statement);
 	if (!post_condition) {
-		printf("\tjmp\t\t.L%d\n", loop_top);
+		struct storage *lbv = new_storage(STOR_LABEL);
+		lbv->label = loop_top;
+		lbv->flags = STOR_WANTS_FREE;
+		insn("jmp", lbv, NULL, "go to loop top");
 	} else if (post_condition->type == EXPR_VALUE) {
-		if (post_condition->value)
-			printf("\tjmp\t\t.L%d\n", loop_top);
+		if (post_condition->value) {
+			struct storage *lbv = new_storage(STOR_LABEL);
+			lbv->label = loop_top;
+			lbv->flags = STOR_WANTS_FREE;
+			insn("jmp", lbv, NULL, "go to loop top");
+		}
 	} else {
+		struct storage *lbv = new_storage(STOR_LABEL);
+		lbv->label = loop_top;
+		lbv->flags = STOR_WANTS_FREE;
+
 		val = x86_expression(post_condition);
-		printf("\tjne\t\tv%d, .L%d\n", val->pseudo, loop_top);
+
+		emit_move(val, REG_EAX, NULL, "loop post condition");
+		insn("test", REG_EAX, REG_EAX, NULL);
+		insn("jnz", lbv, NULL, NULL);
 	}
-	if (stmt->iterator_break->used)
-		printf(".L%p:\n", stmt->iterator_break);
-	if (loop_bottom)
-		printf(".L%d:\n", loop_bottom);
+	if (have_bottom || stmt->iterator_break->used)
+		emit_label(loop_bottom, "loop bottom");
+
+	loopstk_pop();
 }
 
 /*
@@ -1605,7 +1674,7 @@
 		break;
 
 	case STMT_ITERATOR:
-		x86_loop(stmt);
+		emit_loop(stmt);
 		break;
 
 	case STMT_NONE:
@@ -1620,6 +1689,16 @@
 		if (stmt->goto_expression) {
 			struct storage *val = x86_expression(stmt->goto_expression);
 			printf("\tgoto *v%d\n", val->pseudo);
+		} else if (!strcmp("break", show_ident(stmt->goto_label->ident))) {
+			struct storage *lbv = new_storage(STOR_LABEL);
+			lbv->label = loopstk_break();
+			lbv->flags = STOR_WANTS_FREE;
+			insn("jmp", lbv, NULL, "'break'; go to loop bottom");
+		} else if (!strcmp("continue", show_ident(stmt->goto_label->ident))) {
+			struct storage *lbv = new_storage(STOR_LABEL);
+			lbv->label = loopstk_continue();
+			lbv->flags = STOR_WANTS_FREE;
+			insn("jmp", lbv, NULL, "'continue'; go to loop top");
 		} else {
 			struct storage *labelsym = new_labelsym(stmt->goto_label);
 			insn("jmp", labelsym, NULL, NULL);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse, be] operand size work ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse, be] operand size work
Date: Mon, 09 Feb 2004 22:27:40 +0000
Message-ID: <20040209222740.GA10933 () gtf ! org>
--------------------

Please do a

	bk pull bk://gkernel.bkbits.net/sparse.be

This will update the following files:

 compile-i386.c |  171 +++++++++++++++++++++++++++++++++++++++++++++++----------
 1 files changed, 141 insertions(+), 30 deletions(-)

through these ChangeSets:

<jgarzik@redhat.com> (04/02/09 1.452)
   [be] get operand size correct on mem->mem copies

<jgarzik@redhat.com> (04/02/09 1.451)
   [be] Fix binops.  We should now get operand size and sign correct.

<jgarzik@redhat.com> (04/02/08 1.450)
   [be] fix function name emitted for .size directive
   
   We were using the output of show_ident() without remembering
   that that function uses static storage.

diff -Nru a/compile-i386.c b/compile-i386.c
--- a/compile-i386.c	Mon Feb  9 17:21:48 2004
+++ b/compile-i386.c	Mon Feb  9 17:21:48 2004
@@ -11,7 +11,6 @@
  *
  * TODO list:
  * in general, any non-32bit SYM_BASETYPE is unlikely to work.
- * loops
  * complex initializers
  * bitfields
  * global struct/union variables
@@ -168,6 +167,9 @@
 	{ "%edx" },
 	{ "%esp" },
 	{ "%dl" },
+	{ "%dx" },
+	{ "%al" },
+	{ "%ax" },
 };
 
 static struct storage hardreg_storage_table[] = {
@@ -195,6 +197,21 @@
 		.type = STOR_REG,
 		.reg = &reg_info_table[4],
 	},
+
+	{	/* dx */
+		.type = STOR_REG,
+		.reg = &reg_info_table[5],
+	},
+
+	{	/* al */
+		.type = STOR_REG,
+		.reg = &reg_info_table[6],
+	},
+
+	{	/* ax */
+		.type = STOR_REG,
+		.reg = &reg_info_table[7],
+	},
 };
 
 #define REG_EAX (&hardreg_storage_table[0])
@@ -202,6 +219,9 @@
 #define REG_EDX (&hardreg_storage_table[2])
 #define REG_ESP (&hardreg_storage_table[3])
 #define REG_DL	(&hardreg_storage_table[4])
+#define REG_DX	(&hardreg_storage_table[5])
+#define REG_AL	(&hardreg_storage_table[6])
+#define REG_AX	(&hardreg_storage_table[7])
 
 
 static void emit_move(struct storage *src, struct storage *dest,
@@ -701,6 +721,7 @@
 	emit_atom_list(f);
 
 	/* function footer */
+	name = show_ident(sym->ident);
 	printf("\t.size\t%s, .-%s\n", name, name);
 
 	func_cleanup(f);
@@ -906,13 +927,33 @@
 	emit_unit_post();
 }
 
-static void emit_copy(struct storage *src,  struct symbol *src_ctype,
-		      struct storage *dest, struct symbol *dest_ctype)
+static void emit_copy(struct storage *dest, struct storage *src,
+		      struct symbol *ctype)
 {
+	struct storage *reg = NULL;
+
 	/* FIXME: Bitfield move! */
 
-	emit_move(src, REG_EAX, src_ctype, "begin copy ..");
-	emit_move(REG_EAX, dest, dest_ctype, ".... end copy");
+	switch (ctype->bit_size) {
+	case 8:
+		reg = REG_AL;
+		break;
+	case 16:
+		reg = REG_AX;
+		break;
+	case 32:
+		reg = REG_EAX;
+		break;
+	case 64:
+		reg = REG_EAX;	/* FIXME */
+		break;
+	default:
+		assert(0);
+		break;
+	}
+
+	emit_move(src, reg, ctype, "begin copy ..");
+	emit_move(reg, dest, ctype, ".... end copy");
 }
 
 static void emit_store(struct expression *dest_expr, struct storage *dest,
@@ -1087,38 +1128,110 @@
 	struct storage *left = x86_expression(expr->left);
 	struct storage *right = x86_expression(expr->right);
 	struct storage *new;
+	struct storage *accum_reg = NULL;
+	struct storage *result_reg = NULL;
 	const char *opname = NULL;
+	const char *suffix;
+	char movstr[16], opstr[16];
+	int is_signed, doing_divide = 0;
+
+	if ((expr->op == '/') || (expr->op == '%')) {
+		doing_divide = 1;
+		/* init EDX to 0 */
+		struct storage *val = new_storage(STOR_VALUE);
+		val->flags = STOR_WANTS_FREE;
+		emit_move(val, REG_EDX, NULL, "begin EXPR_DIVIDE");
+	}
 
-	/*
-	 * FIXME FIXME this routine is so wrong it's not even funny.
-	 * On x86 both mod/div are handled with the same instruction.
-	 * We don't pay attention to signed/unsigned issues,
-	 * and like elsewhere we hardcode the operand size at 32 bits.
-	 */
+	is_signed = type_is_signed(expr->ctype);
 
 	switch (expr->op) {
-	case '+':			opname = "addl";	break;
-	case '-':			opname = "subl";	break;
-	case '*':			opname = "mull";	break;
-	case '/':			opname = "divl";	break;
-	case '%':			opname = "modl";	break;
-	case '&':			opname = "andl";	break;
-	case '|':			opname = "orl";		break;
-	case '^':			opname = "xorl";	break;
-	case SPECIAL_LEFTSHIFT:		opname = "shll";	break;
-	case SPECIAL_RIGHTSHIFT:	opname = "shrl";	break;
-	default:			assert(0);		break;
+	case '+':
+		opname = "add";
+		break;
+	case '-':
+		opname = "sub";
+		break;
+	case '&':
+		opname = "and";
+		break;
+	case '|':
+		opname = "or";
+		break;
+	case '^':
+		opname = "xor";
+		break;
+	case SPECIAL_LEFTSHIFT:
+		opname = "shl";
+		break;
+	case SPECIAL_RIGHTSHIFT:
+		if (is_signed)
+			opname = "sar";
+		else
+			opname = "shr";
+		break;
+	case '*':
+		if (is_signed)
+			opname = "imul";
+		else
+			opname = "mul";
+		break;
+	case '/':
+	case '%':
+		if (is_signed)
+			opname = "idiv";
+		else
+			opname = "div";
+		break;
+	default:
+		assert(0);
+		break;
 	}
 
+	switch (expr->ctype->bit_size) {
+	case 8:
+		suffix = "b";
+		result_reg = accum_reg = REG_AL;
+		if (expr->op == '%')
+			result_reg = REG_DL;
+		break;
+	case 16:
+		suffix = "w";
+		result_reg = accum_reg = REG_AX;
+		if (expr->op == '%')
+			result_reg = REG_DX;
+		break;
+	case 32:
+		suffix = "l";
+		result_reg = accum_reg = REG_EAX;
+		if (expr->op == '%')
+			result_reg = REG_EDX;
+		break;
+	case 64:
+		suffix = "q";		/* FIXME */
+		result_reg = accum_reg = REG_EAX;	/* FIXME */
+		if (expr->op == '%')
+			result_reg = REG_EDX;
+		break;
+	default:
+		assert(0);
+		break;
+	}
+
+	sprintf(movstr, "mov%s", suffix);
+	sprintf(opstr, "%s%s", opname, suffix);
+
 	/* load op2 into EAX */
-	insn("movl", right, REG_EAX, "EXPR_BINOP/COMMA/LOGICAL");
+	insn(movstr, right, accum_reg,
+	     doing_divide ? NULL : "EXPR_BINOP/COMMA/LOGICAL");
 
 	/* perform binop */
-	insn(opname, left, REG_EAX, NULL);
+	insn(opstr, left, accum_reg, NULL);
 
-	/* store result (EAX) in new pseudo / stack slot */
+	/* store result (EAX or EDX) in new pseudo / stack slot */
 	new = stack_alloc(4);
-	insn("movl", REG_EAX, new, "end EXPR_BINOP");
+	insn(movstr, result_reg, new,
+	     doing_divide ? "end EXPR_DIVIDE" : "end EXPR_BINOP");
 
 	return new;
 }
@@ -1195,7 +1308,7 @@
 	if (postop) {
 		struct storage *new = stack_alloc(4);
 
-		emit_copy(addr, expr->unop->ctype, new, NULL);
+		emit_copy(new, addr, expr->unop->ctype);
 
 		retval = new;
 	} else
@@ -1806,12 +1919,10 @@
 {
 	struct expression *target = expr->left;
 	struct storage *val, *addr;
-	int bits;
 
 	if (!expr->ctype)
 		return NULL;
 
-	bits = expr->ctype->bit_size;
 	val = x86_expression(expr->right);
 	addr = x86_address_gen(target);
 
@@ -1819,7 +1930,7 @@
 	/* copy, where both operands are memory */
 	case STOR_PSEUDO:
 	case STOR_ARG:
-		emit_copy(val, expr->right->ctype, addr, expr->left->ctype);
+		emit_copy(addr, val, expr->ctype);
 		break;
 
 	/* copy, one or zero operands are memory */
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Tue, 10 Feb 2004 02:57:21 +0000
Message-ID: <Pine.LNX.4.58.0402091851520.2128 () home ! osdl ! org>
--------------------


On Mon, 9 Feb 2004, Jeff Garzik wrote:
> 
> Please do a
> 
> 	bk pull bk://gkernel.bkbits.net/sparse.be

Done.

One thing I'd love to do is to move the linearization pass from the 
"backend" to the front-end. Everybody needs to linearize the tree, and in 
fact even a lot of totally back-end-independent optimizations want to do 
it (code and symbol liveness analysis etc).

Is anybody interested in taking the statement tree, and turning it into a 
graph of basic blocks? That would allow the later phases to not do the 
recursive descent part any more..

		Linus


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Tue, 10 Feb 2004 03:11:01 +0000
Message-ID: <40284BC5.7030600 () pobox ! com>
--------------------
Linus Torvalds wrote:
> 
> On Mon, 9 Feb 2004, Jeff Garzik wrote:
> 
>>Please do a
>>
>>	bk pull bk://gkernel.bkbits.net/sparse.be
> 
> 
> Done.
> 
> One thing I'd love to do is to move the linearization pass from the 
> "backend" to the front-end. Everybody needs to linearize the tree, and in 
> fact even a lot of totally back-end-independent optimizations want to do 
> it (code and symbol liveness analysis etc).
> 
> Is anybody interested in taking the statement tree, and turning it into a 
> graph of basic blocks? That would allow the later phases to not do the 
> recursive descent part any more..


I was thinking about doing that myself, anyway.  I was pondering how to 
best move beyond i386, and generate for other architectures.  Doing that 
would necessitate a much higher level linearization...

I don't want to dissuade others, but I'll give it some more thought. 
Messing around with intermediate forms is fun.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Wed, 11 Feb 2004 22:06:08 +0000
Message-ID: <Pine.LNX.4.58.0402111355110.2128 () home ! osdl ! org>
--------------------


On Mon, 9 Feb 2004, Jeff Garzik wrote:
> > 
> > Is anybody interested in taking the statement tree, and turning it into a 
> > graph of basic blocks? That would allow the later phases to not do the 
> > recursive descent part any more..
> 
> I was thinking about doing that myself, anyway.  I was pondering how to 
> best move beyond i386, and generate for other architectures.  Doing that 
> would necessitate a much higher level linearization...

I've been thinking about this for a _loong_ time now, and I sat down and 
wrote part of this. It's a really stupid linearizer (and right now it 
dosn't actually even try to handle any control flow, which makes it 
useless), but I think the basics are there.

There's a "test-linearize" program to test it (it works as well as can be
expected for the back-end validator program, but that's the only thing
I've ever fed it).

		Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Wed, 11 Feb 2004 22:52:33 +0000
Message-ID: <Pine.LNX.4.58.0402111442450.2128 () home ! osdl ! org>
--------------------


On Wed, 11 Feb 2004, Linus Torvalds wrote:
> 
> I've been thinking about this for a _loong_ time now, and I sat down and 
> wrote part of this. It's a really stupid linearizer (and right now it 
> dosn't actually even try to handle any control flow, which makes it 
> useless), but I think the basics are there.

Ok, I added the notion to jump between basic blocks, so now it actually 
has some "meaningful" behaviour as a linearizer.

The print-out is pretty incomprehensible, since it mixes the old-style 
"print statement" with the new-style "print bb list", but you can test
it with trivial programs that only have if-statements as their control
flow.

		Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 02:45:06 +0000
Message-ID: <Pine.LNX.4.58.0402111832550.2128 () home ! osdl ! org>
--------------------


On Wed, 11 Feb 2004, Linus Torvalds wrote:
> 
> Ok, I added the notion to jump between basic blocks, so now it actually 
> has some "meaningful" behaviour as a linearizer.

Now I do iterators too, and I prettified the output a bit. The linearizer 
seems to do about as well as the old debug output ever did. I don't do 
"switch()" statements, but other than that things seem rasonably sane.

And the linearized format is a _lot_ easier to work with. For one thing, 
it has moved all the symbols in a function into a single list of symbols. 
For another, there is no statement-level nesting any more, just lists of 
simple statements and jumps between basic blocks.

Btw, the basic blocks aren't "basic" in the traditional sense. They are
"single entry, multiple-exit", since imho doing anything else is just
crazy. Some people call those kinds of things "tree regions", others call
them "superblocks". Whatever.  I call them "basic blocks", but if some
stickler feels strongly about them, we can rename the damn things.

"linearize.c" is about 250 lines of code, and some of that is the 
debugging code to print out the results. I didn't comment it, but it seems 
obvious enough to me. Feel free to send patches.

		Linus


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 19:26:18 +0000
Message-ID: <402BD35A.5000405 () pobox ! com>
--------------------
Linus Torvalds wrote:
> And the linearized format is a _lot_ easier to work with. For one thing, 
> it has moved all the symbols in a function into a single list of symbols. 
> For another, there is no statement-level nesting any more, just lists of 
> simple statements and jumps between basic blocks.
> 
> Btw, the basic blocks aren't "basic" in the traditional sense. They are
> "single entry, multiple-exit", since imho doing anything else is just
> crazy. Some people call those kinds of things "tree regions", others call
> them "superblocks". Whatever.  I call them "basic blocks", but if some
> stickler feels strongly about them, we can rename the damn things.


I've been thinking about this for a long time too :)

Treegions and superblocks are IMO an attempt to address the 
implementation problem of focusing too closely on the [classical] basic 
block, often to the exclusion of details you should be paying attention 
to surrounding you, which provide more context (and thus more 
opportunity for optimization).

I was thinking more of an initial form of a generic tree, where generic 
nodes may have N children.  A node can be a compound-stmt, switch-stmt, 
loop, add-op, sub-op -- both high level and low level constructs, 
including container nodes.

<tangent>
This form I'm thinking of is, not coincedentally, a lot like WHIRL, 
using in SGI's now-open sourced compiler :)  WHIRL is nice -- supports 
high level constructs in all your favorite languages, and is designed to 
be progressively lowered to asm, gradually eliminating the higher level 
constructs (bitfields, switch statements) for much lower level ones.

	http://unc.dl.sourceforge.net/sourceforge/open64/whirl.pdf
	(it's easy to read and fast to skim; less than 100 pages)

Besides wanting to build a backend, a pet annoyance of mine is gcc's not 
spitting out a portable intermediate representation, partially due to an 
RMS opinion I disagree with.  Something-like-WHIRL is IMO a great target 
for spitting out an intermediate representation of the tree, before it's 
linearized to a large degree.
</tangent>

Anyway, this "jg's tree form" seems a bit higher level that what you're 
doing with the basic blocks at goto targets.  A key problem with gcc 
that they are just now addressing is the free-fall one takes from the 
very high level tree to RTL, where a lot of useful optimization 
information is lost.

I would prefer to first take the statement tree and massage it into a 
more generic, easily walkable tree [which looks a lot like VH (very high 
level) WHIRL].

Since you say "the basic blocks aren't "basic" in the traditional 
sense", I am relieved that you aren't going immediately to as low a 
level as I had [incorrectly] presumed.  I'm still left wondering if 
generating VH WHIRL would be a peer effort, or something that would work 
post-linearization.  I'll give it some more thought.

<tangent>
Part of the reason why I dislike classical basic blocks and even 
superblocks/treegions is that you wind up implicitly limiting the scope 
of some of your optimizations.  I want to do things like pay attention 
values at all points in a variable's lifecycle, and it seems silly to 
limit data-based optimizations on anything except the function barrier 
itself.  I also don't want any impediments to moving blocks of code 
around.  It should be trivial for me to move all the cold paths to the 
end of the function, or heck even to a "cold path" ELF section with 
other cold path code.  So I want to avoid any artificial impediments to 
moving code around, or transforming code wildly :)
</tangent>

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 19:41:52 +0000
Message-ID: <402BD700.3020109 () pobox ! com>
--------------------
Jeff Garzik wrote:
> I was thinking more of an initial form of a generic tree, where generic 
> nodes may have N children.  A node can be a compound-stmt, switch-stmt, 
> loop, add-op, sub-op -- both high level and low level constructs, 
> including container nodes.


In other words, a lot like the existing statement tree, but more 
language agnostic (i.e. can walk w/out knowledge of the specific language).


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 19:58:30 +0000
Message-ID: <Pine.LNX.4.58.0402121133420.2226 () home ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Jeff Garzik wrote:
> 
> Treegions and superblocks are IMO an attempt to address the 
> implementation problem of focusing too closely on the [classical] basic 
> block, often to the exclusion of details you should be paying attention 
> to surrounding you, which provide more context (and thus more 
> opportunity for optimization).

I agree - superblocks aren't perfect.

That said, the real reason for liking them is that they are _simple_. They 
are in fact a lot simpler (in my opinion) than even the traditional basic 
block, because you don't have to worry about the issue that some basic 
blocks have just one (fallthrough) exit, while some have two. With 
superblocks, there are no special cases. There is always one fallthrough, 
and can barnch out any which way they damn well please, yet still 
maintaining the "only one entry" thing.

And that "one entry" part ends up being so important for simplicity that I 
don't believe in any more complex data structures. Anything else ends up 
being so complex that whatever gain it gets is not worth it.

I also wanted the format to be space-efficient: not only am I actually
re-using all the regular statements and just copying the pointers, the
format itself is quite dense (and I'm pretty proud over how damn well my
"pointer list" abstraction has worked).

> I was thinking more of an initial form of a generic tree, where generic 
> nodes may have N children.  A node can be a compound-stmt, switch-stmt, 
> loop, add-op, sub-op -- both high level and low level constructs, 
> including container nodes.

Why? The full parse obviously can't be a tree anyway - you will have
cycles. So if you start chopping up the tree, you might as well chop it up 
to something sumple.

Also, when I want to serialize, I want to _serialize_. I want something 
that can be written to a file or printed out, and there is no "structure" 
to it any more. That's what the superblocks are. There is structure, but 
the only structure is literally just the linkages between them, so it's 
the minimal structure you have to have.

So if you were to do an intermediate format, that's the perfect format: 
it's a trivial and _minimal_ flattening of the tree, nothing more.

If you looked at "linearize.c", you must have noticed that it literally 
doesn't do any strange transformations. It just flattens it, trying to do 
some minimal space optimizations. So something like

	aaa
	do {
		bbb
	} while (0)
	ccc

ends up being flattened as just

	aaa
	bbb
	ccc

but that's not because of any clever optimization, that's just because of
how the algorithm works by keeping around the "current block pointer".

So I wanted to find a format that simplifies the tree in ways that
actually matter for real C code (the above is very common for macros).

> Anyway, this "jg's tree form" seems a bit higher level that what you're 
> doing with the basic blocks at goto targets.  A key problem with gcc 
> that they are just now addressing is the free-fall one takes from the 
> very high level tree to RTL, where a lot of useful optimization 
> information is lost.

I leave all the high-level information in the flattened form. I agree with 
you that you shouldn't ever remove information, so I don't. Well, the only 
information I remove is the "loop vs goto" one, which I do on purpose: I 
feel that a compiler where the syntactic format of a loop matters is an 
inherently broken compiler, so I think it is literally wrong to consider 
loops anything but branches.

> I would prefer to first take the statement tree and massage it into a 
> more generic, easily walkable tree [which looks a lot like VH (very high 
> level) WHIRL].

I hate abstraction, and I think that gcc's main fault is complexity from 
trying to be clever. And I've worked with superblocks before, and found 
them very convenient for a lot of the "regular" optimizations (ie they are 
trivial to follow for things like liveness etc).

> Since you say "the basic blocks aren't "basic" in the traditional 
> sense", I am relieved that you aren't going immediately to as low a 
> level as I had [incorrectly] presumed.

It's a very high-level "basic block", and not just in having multiple
exists. In particular, it doesn't even split on local branch-overs as
described by the "? :" operator, or by a function call. It even leaves all
expressions in tree format, simply because I couldn't convince myself that 
there is a better format.

I want to do code/data liveness analysis, and the superblock format is 
perfect for that. 

> Part of the reason why I dislike classical basic blocks and even 
> superblocks/treegions is that you wind up implicitly limiting the scope 
> of some of your optimizations.  I want to do things like pay attention 
> values at all points in a variable's lifecycle, and it seems silly to 
> limit data-based optimizations on anything except the function barrier 
> itself.

Oh, I never meant for anybody to only look at a single basic block. That's 
why there is "struct entry_point", which is the function entrypoint and 
contains a list of all the basic blocks.

It's very easy (and indeed necessary) to do liveness analysis across basic
blocks, and then you can move and duplicate statements across too. Right
now my "pointer list" objects don't have the functions to remove entries
or add them to the head of the list (or to the middle, for that matter),
but that's just because I haven't needed them yet. The data structure 
itself is very amenable to inserts/deletes.

(Btw - I think that my "add_ptr_list()" thing is broken. I'll fix that)

> I also don't want any impediments to moving blocks of code 
> around.  It should be trivial for me to move all the cold paths to the 
> end of the function, or heck even to a "cold path" ELF section with 
> other cold path code.  So I want to avoid any artificial impediments to 
> moving code around, or transforming code wildly :)

Absolutely. It's a very simple format, don't worry.

		Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 20:56:55 +0000
Message-ID: <Pine.LNX.4.58.0402121242280.2226 () home ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Jeff Garzik wrote:
>
> Jeff Garzik wrote:
> > I was thinking more of an initial form of a generic tree, where generic 
> > nodes may have N children.  A node can be a compound-stmt, switch-stmt, 
> > loop, add-op, sub-op -- both high level and low level constructs, 
> > including container nodes.
> 
> In other words, a lot like the existing statement tree, but more 
> language agnostic (i.e. can walk w/out knowledge of the specific language).

Well, the existing tree could easily be expanded. It does try to be pretty 
language-agnostic, in fact. Although clearly it's geared towards C right 
now.

So I agree: there are optimizations that should be done purely on the tree 
form. That's where we do the inlining, for example, and the constant 
propagations. 

But things like "switch" statements are actually really hard to do in the 
tree. It's _really_ painful, with one case falling through to the next one 
(ie ordering matters) etc. It's something where you really want to get rid 
of the high-level representation, because it's just painful.

In contrast, changing it to a linearized tree is quite trivial. I just 
checked in my half-hour hack, which is impressively small considering how 
_hard_ it is to get right if you do it the wrong way around.

For example, try to parse duff's device properly with some high-level 
thing, and you'd just go _crazy_. In contrast, I just checked, and I got 
it right on the very first try, I do believe.

Here's duff.c:

	send(short *to, short *from, int count)
	{
		int n = (count + 7) / 8;

		switch (count % 8) {
		case 0:
		do {
				*to = *from++;
		case 7:
				*to = *from++;
		case 6:
				*to = *from++;
		case 5:
				*to = *from++;
		case 4:
				*to = *from++;
		case 3:
				*to = *from++;
		case 2:
				*to = *from++;
		case 1:
				*to = *from++;
		} while (--n > 0);
		}
	}

and here is what "test-linearize" generates from it (pseudo-assembly, but 
all the labels are correct etc, I do believe). There are a few empty 
blocks, because I'm a retard, but it all looks basically correct.

	ep 0x4001600c: send
	   sym: 0x400280dc to
	   sym: 0x40028244 from
	   sym: 0x400283ac count
	   sym: 0x4002849c n
	
	bb: 0x4019100c
		addi.32		v1,vFP,$offsetof(count:0x400283ac)
		ld.32		v2,[v1]
		movi.32		v3,$8
		mod.32		v4,v2,v3
		SWITCH		v4
		IF 0..0 goto .L0x4019101c
		IF 7..7 goto .L0x4019102c
		IF 6..6 goto .L0x40191034
		IF 5..5 goto .L0x4019103c
		IF 4..4 goto .L0x40191044
		IF 3..3 goto .L0x4019104c
		IF 2..2 goto .L0x40191054
		IF 1..1 goto .L0x4019105c
		goto		.L0x40191064
	
	bb: 0x40191014
		goto		.L0x4019101c
	
	bb: 0x4019101c
		goto		.L0x40191024
	
	bb: 0x40191024
		addi.32		v5,vFP,$offsetof(from:0x40028244)
		ld.32		v6,[v5]
		add.32		v7,v6,$1
		st.32		v7,[v5]
		ld.16		v8,[v6]
		addi.32		v9,vFP,$offsetof(to:0x400280dc)
		ld.32		v10,[v9]
		st.16		v8,[v10]
		goto		.L0x4019102c
	
	bb: 0x4019102c
		addi.32		v11,vFP,$offsetof(from:0x40028244)
		ld.32		v12,[v11]
		add.32		v13,v12,$1
		st.32		v13,[v11]
		ld.16		v14,[v12]
		addi.32		v15,vFP,$offsetof(to:0x400280dc)
		ld.32		v16,[v15]
		st.16		v14,[v16]
		goto		.L0x40191034
	
	bb: 0x40191034
		addi.32		v17,vFP,$offsetof(from:0x40028244)
		ld.32		v18,[v17]
		add.32		v19,v18,$1
		st.32		v19,[v17]
		ld.16		v20,[v18]
		addi.32		v21,vFP,$offsetof(to:0x400280dc)
		ld.32		v22,[v21]
		st.16		v20,[v22]
		goto		.L0x4019103c
	
	bb: 0x4019103c
		addi.32		v23,vFP,$offsetof(from:0x40028244)
		ld.32		v24,[v23]
		add.32		v25,v24,$1
		st.32		v25,[v23]
		ld.16		v26,[v24]
		addi.32		v27,vFP,$offsetof(to:0x400280dc)
		ld.32		v28,[v27]
		st.16		v26,[v28]
		goto		.L0x40191044
	
	bb: 0x40191044
		addi.32		v29,vFP,$offsetof(from:0x40028244)
		ld.32		v30,[v29]
		add.32		v31,v30,$1
		st.32		v31,[v29]
		ld.16		v32,[v30]
		addi.32		v33,vFP,$offsetof(to:0x400280dc)
		ld.32		v34,[v33]
		st.16		v32,[v34]
		goto		.L0x4019104c
	
	bb: 0x4019104c
		addi.32		v35,vFP,$offsetof(from:0x40028244)
		ld.32		v36,[v35]
		add.32		v37,v36,$1
		st.32		v37,[v35]
		ld.16		v38,[v36]
		addi.32		v39,vFP,$offsetof(to:0x400280dc)
		ld.32		v40,[v39]
		st.16		v38,[v40]
		goto		.L0x40191054
	
	bb: 0x40191054
		addi.32		v41,vFP,$offsetof(from:0x40028244)
		ld.32		v42,[v41]
		add.32		v43,v42,$1
		st.32		v43,[v41]
		ld.16		v44,[v42]
		addi.32		v45,vFP,$offsetof(to:0x400280dc)
		ld.32		v46,[v45]
		st.16		v44,[v46]
		goto		.L0x4019105c
	
	bb: 0x4019105c
		addi.32		v47,vFP,$offsetof(from:0x40028244)
		ld.32		v48,[v47]
		add.32		v49,v48,$1
		st.32		v49,[v47]
		ld.16		v50,[v48]
		addi.32		v51,vFP,$offsetof(to:0x400280dc)
		ld.32		v52,[v51]
		st.16		v50,[v52]
		addi.32		v53,vFP,$offsetof(n:0x4002849c)
		ld.32		v54,[v53]
		sub.32		v54,v54,$1
		st.32		v54,[v53]
		movi.32		v55,$0
		(null).32		v56,v54,v55
		jnz		v56,.L0x40191024
		goto		.L0x40191064
	
	bb: 0x40191064
		END

and I bet not a lot of people can do duff's device correctly with a 
linearization phase of 30 lines.

That's correct: the full linearization of a switch-statement is just 30
lines of code. Go look yourself (the case statement is 5 lines).

This is what I'm talking about when I talk about "simplicity".  Selecting
the right data structures so that you can keep it obvious without magical
special cases.

			Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 21:11:16 +0000
Message-ID: <Pine.LNX.4.58.0402121307560.2226 () home ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Linus Torvalds wrote:
> 
> and here is what "test-linearize" generates from it (pseudo-assembly, but 
> all the labels are correct etc, I do believe). There are a few empty 
> blocks, because I'm a retard, but it all looks basically correct.

Btw, please don't flame over the horrid "code generation". The individual
statements are all done with the old "show-parse.c" code that is totally
stateless and idiotic. It's just there to show that the data structures
are valid, nothing more. The duff's device example was more an example of
how the linearizer has created a reasonably sane set of blocks and tied
them together.

		Linus


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 21:30:38 +0000
Message-ID: <402BF07E.4020908 () pobox ! com>
--------------------
Linus Torvalds wrote:
> And that "one entry" part ends up being so important for simplicity that I 
> don't believe in any more complex data structures. Anything else ends up 
> being so complex that whatever gain it gets is not worth it.

hmmm, I'll have to think on this one.  It makes a lot of sense...


> I also wanted the format to be space-efficient: not only am I actually
> re-using all the regular statements and just copying the pointers, the
> format itself is quite dense (and I'm pretty proud over how damn well my
> "pointer list" abstraction has worked).

Yeah, the density really shows in linearize.c.

I wish glibc had a chunked allocator like the kernel's kmem_cache.


>>I was thinking more of an initial form of a generic tree, where generic 
>>nodes may have N children.  A node can be a compound-stmt, switch-stmt, 
>>loop, add-op, sub-op -- both high level and low level constructs, 
>>including container nodes.
> 
> 
> Why? The full parse obviously can't be a tree anyway - you will have
> cycles.

OK, even before your followup mails, this went a long way towards 
convincing me.


>>Anyway, this "jg's tree form" seems a bit higher level that what you're 
>>doing with the basic blocks at goto targets.  A key problem with gcc 
>>that they are just now addressing is the free-fall one takes from the 
>>very high level tree to RTL, where a lot of useful optimization 
>>information is lost.
> 
> 
> I leave all the high-level information in the flattened form. I agree with 
> you that you shouldn't ever remove information, so I don't. Well, the only 

Good :)  I think gcc's ABmode/BCmode/CDmode/BLAHmode stuff is lame.  I 
want the backend to be able to access C type information, or something 
darned close to it.  When C idioms can be mapped directly to hardware, 
it should be easy and obvious.  When idioms require a bit of massaging 
(long long ops ignoring mul/div) it's easy, too.  SImode and stuff just 
makes it's harder to directly connect machine "types" to C types.


> information I remove is the "loop vs goto" one, which I do on purpose: I 
> feel that a compiler where the syntactic format of a loop matters is an 
> inherently broken compiler, so I think it is literally wrong to consider 
> loops anything but branches.

Oh, definitely.  The kernel is full of implicit loops constructed w/ 
goto, as just one example.


> It's a very high-level "basic block", and not just in having multiple
> exists. In particular, it doesn't even split on local branch-overs as
> described by the "? :" operator, or by a function call. It even leaves all
> expressions in tree format, simply because I couldn't convince myself that 
> there is a better format.

Why don't expressions get linearized too?  I can see that adds the 
complication of generating temporaries (which at this level should be 
ctypes not pseudos), but it seems like the odd duck if everything else 
is linearized.  A lot of code can result from an expression.

Also (tangent) don't forget there is data outside function scope (global 
vars, static data, ...).  show-parse was always a bit haphazard about. 
That would need to be a peer to entry_point on a list somewhere, I suppose.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 21:48:02 +0000
Message-ID: <6906.65.113.40.130.1076622482.squirrel () numba-tu ! com>
--------------------
Jeff uttered:
> Why don't expressions get linearized too?  I can see that adds the
> complication of generating temporaries (which at this level should be
> ctypes not pseudos), but it seems like the odd duck if everything else
> is linearized.  A lot of code can result from an expression.

It remain to be seen if there's any advantage to doing that.  Of hand I
think that most of what needs to done can just be done with annotations on
the expressions and replacements.  Linearizing for the sake of linearizing
is stupid.  The BBs are different because you can't really do anything
until you know which branches can reach which code.  You don't have the
same problem for value flow in expressions (remember that && and || are
(or should be) linearized).

/Tommy



================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 21:49:25 +0000
Message-ID: <Pine.LNX.4.58.0402121340390.2226 () home ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Jeff Garzik wrote:
> 
> Why don't expressions get linearized too?  I can see that adds the 
> complication of generating temporaries (which at this level should be 
> ctypes not pseudos), but it seems like the odd duck if everything else 
> is linearized.  A lot of code can result from an expression.

Yeah. I do believe we want to linearize the expressions too. I literally
left them as-is because of not having thought the final format through,
and I'm a bit nervous about generating millions of temporaries etc. So
until I know what format I want for the linearized expressions, I'd rather
leave them in the original one - I'd hate to lose information at this
stage.

Part of the problem is that the "struct symbol" is one of the heaviest 
data structures in the whole parser, so generating a new symbol for each 
temporary value (which would be the right thing to do) would be horribly 
bad.

So I'd have to generate some kind of pseudo-register, the same way the
"show-parse.c" linearization does, but still keep the type information 
(which does exist in the expression itself, so..). And I don't know how to 
handle the issue of "memory-backed" vs "register" etc.

In other words: expressions are pretty easy to linearize (pure nice 
recursive descent, no strange issues), but there's a _lot_ of them, and I 
don't want this thing to blow up in my face. 

Suggestions welcome. 

		Linus


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 22:02:46 +0000
Message-ID: <402BF806.1050506 () pobox ! com>
--------------------
Linus Torvalds wrote:
> So I'd have to generate some kind of pseudo-register, the same way the
> "show-parse.c" linearization does, but still keep the type information 
> (which does exist in the expression itself, so..). And I don't know how to 
> handle the issue of "memory-backed" vs "register" etc.

Yep.  compile-i386.c has a struct storage instead of 'int' for pseudos, 
so that it can keep track of the underlying storage memory versus 
register versus static storage, etc.

When pondering the higher level linearize (including expressions), I was 
thinking I would create temporaries, but which would be described with 
nothing more than a unique id and a ctype.  i.e. consider how you might 
linearize... and then re-represent it in C.  "compiler temporaries" in 
this mythical C output can be represented with "int tmp_1234".  You're 
right that's thousands of symbols, though.

When doing my own thinking about backend stuff, I was guessing that 
generating the compiler temporaries at the higher level might lead to 
better code generation, but who knows.  Sounds like the overhead would 
suck, at present.


> In other words: expressions are pretty easy to linearize (pure nice 
> recursive descent, no strange issues), but there's a _lot_ of them, and I 
> don't want this thing to blow up in my face. 
> 
> Suggestions welcome. 

It's already done in compile-i386.c right now, so it's no skin off my 
back.  We can leave it as-is for now, and focus on other stuff.  There 
will be fun gcc statement expressions to linearize later on though...  :)

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 22:09:05 +0000
Message-ID: <Pine.LNX.4.58.0402121405430.2226 () home ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Jeff Garzik wrote:
> 
> It's already done in compile-i386.c right now, so it's no skin off my 
> back.  We can leave it as-is for now, and focus on other stuff.  There 
> will be fun gcc statement expressions to linearize later on though...  :)

Good point. I don't handle those at all right now, since I just copy the 
expression directly.

So you're right - I do need to linearize the expressions, if only to get 
to the statement expressions and linearize the substatement too. And once 
I'd do that, I might as well linearize them totally, since I'd need to 
solve the pseudo issues for the statement-expression case anyway.

Btw, don't worry about the strange cases for statement expressions: even
gcc doesn't handle them. I tested a long time ago: adding labels inside
statement expressions and doing other strange things silently just
generates crap code. So we don't have to worry about some insane semantics 
for insane code.

		Linus


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 22:16:35 +0000
Message-ID: <402BFB43.3080608 () pobox ! com>
--------------------
Just to let you know, I won't be bothering with linearize for a little 
while.  compile-i386.c will get shorter by using the new bblocks list, 
so I'll be messing around in the backend converting it.  It will also 
make stack frame calculations easier.

If you do high-level pseudos that would be convenient for me, too :)

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 22:32:38 +0000
Message-ID: <402BFF06.7050906 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Part of the problem is that the "struct symbol" is one of the heaviest 
> data structures in the whole parser, so generating a new symbol for each 
> temporary value (which would be the right thing to do) would be horribly 
> bad.

Do you really need to store anything more than a unique pointer to a ctype?

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 23:08:02 +0000
Message-ID: <Pine.LNX.4.58.0402121506390.2226 () home ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Jeff Garzik wrote:
> 
> Do you really need to store anything more than a unique pointer to a ctype?

No. That sounds like a really good idea - just allocate one pointer for
each pseudo, which ends up being just the pointer to the ctype. Everything 
else flows from there, and if you just create a new block allocator there 
should be basically zero overhead.

Good thinking.

		Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Thu, 12 Feb 2004 23:19:45 +0000
Message-ID: <Pine.LNX.4.58.0402121508290.2226 () home ! osdl ! org>
--------------------


Btw,
 I just committed my first _really_ simple reachability code. My test case 
for it was

	int main(int argc, char *argv)
	{
		if (1) {
			argc *= 2;
		} else {
			argc /= 2;
		}

		if (argc)
			goto test;

		if (0) {
			argc --;
	test:
			if (argv)
				argc += *argv;
		} else {
			argc ++;
		}
		return argc;
	}

which is an interesting case of where we can NOT remove the "if 0" side of
the statement at tree parse time, because it gets jumped into from another
point.

This kind of "trivial reachability" came for free when I added the
back-pointers from the basic blocks to the symbols that point to them
(which was something we'll need for other reasons later), and then one
special case stood out - some basic blocks just don't have owners, ie they
have no symbol pointing to them, and they exist only because my 
linearizer always wants _some_ basic block region active.

So the current sparse BK tree will correctly just throw away the truly 
unreachable code, and generates

	ep 0x4001600c: main
	   sym: 0x400280dc argc
	   sym: 0x400281cc argv

	bb: 0x4019100c
		addi.32		v1,vFP,$offsetof(argc:0x400280dc)
		ld.32		v2,[v1]
		movi.32		v3,$2
		mul.32		v4,v2,v3
		addi.32		v5,vFP,$offsetof(argc:0x400280dc)
		st.32		v4,[v5]
		addi.32		v6,vFP,$offsetof(argc:0x400280dc)
		ld.32		v7,[v6]
		jz		v7,.L0x40191018
		goto		.L0x40191024

	bb: 0x40191018
		addi.32		v8,vFP,$offsetof(argc:0x400280dc)
		ld.32		v9,[v8]
		add.32		v10,v9,$1
		st.32		v10,[v8]
		goto		.L0x4019103c

	bb: 0x40191024
		addi.32		v11,vFP,$offsetof(argv:0x400281cc)
		ld.32		v12,[v11]
		jz		v12,.L0x40191030
		addi.32		v13,vFP,$offsetof(argc:0x400280dc)
		ld.32		v14,[v13]
		addi.32		v15,vFP,$offsetof(argv:0x400281cc)
		ld.32		v16,[v15]
		ld.8		v17,[v16]
		sext8.32	v18,v17
		add.32		v19,v14,v18
		addi.32		v20,vFP,$offsetof(argc:0x400280dc)
		st.32		v19,[v20]
		goto		.L0x40191030

	bb: 0x40191030
		goto		.L0x4019103c

	bb: 0x4019103c
		addi.32		v21,vFP,$offsetof(argc:0x400280dc)
		ld.32		v22,[v21]
		addi.32		v23,vFP,$offsetof(return:0x400282bc)
		st.32		v22,[v23]
		ret		(0x400282bc)
		END

which is correct. Note how the truly unreachable statements don't exist.

			Linus


================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Fri, 13 Feb 2004 07:08:20 +0000
Message-ID: <402C77E4.5040909 () numba-tu ! com>
--------------------
Linus Torvalds wrote:

>So I'd have to generate some kind of pseudo-register, the same way the
>"show-parse.c" linearization does, but still keep the type information 
>(which does exist in the expression itself, so..). And I don't know how to 
>handle the issue of "memory-backed" vs "register" etc.
>  
>
Do you need to make a choice?  A simple regalloc might prefer if all 
variables have a home location and only potentiallly be cached in a 
register wereas a more ambious one would handle its spilling on its own 
and only use the home address if the variable ever has it's address 
taken. Or did I miss your point?

>In other words: expressions are pretty easy to linearize (pure nice 
>recursive descent, no strange issues), but there's a _lot_ of them, and I 
>don't want this thing to blow up in my face. 
>
>Suggestions welcome. 
>  
>
I'd be happy if they could be traversed in both directions (use and 
def).  What did you have in mind for liveness analysis?

/Tommy





================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Sun, 22 Feb 2004 18:15:19 +0000
Message-ID: <Pine.LNX.4.58.0402221007320.3301 () ppc970 ! osdl ! org>
--------------------

Ok,
 after a slight pause I got back to linearization, having had to mull on
how to do expressions right. I still don't do expressions, but thinking
about how to do it convinced me that I had to clean up the calling
conventions of the existing code, in particular since doing statement
expressions right requires me to keep track of what the "return pseudo"  
for a statement is. Something that a regular expression otherwise wouldn't
have to worry about.

Thinking about the next stage also convinced me that Tommy was right: I do 
want to keep the linearization as true basic blocks, so that I can more 
easily keep track of true symbol/pseudo liveness. With superblocks I'd 
have to track liveness on a instruction boundary, with simple basic blocks 
I can track it on a BB boundary.

So I made the linearizer do the right thing there. It causes a few more 
basic blocks, but they are simpler, and now it's trivial to change a basic 
block after-the-fact to switch the order of exit points around. 

This still does some fairly simple things wrong (notably, I'll need to fix
the handling of "return" to make inline functions do the right thing), and
I'll have to think about the exact IL representation of the expression
linearization a bit. I'll probably make it some trivial three-pseudo-
operand thing.

			Linus


================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Sun, 22 Feb 2004 21:59:28 +0000
Message-ID: <40392640.5060501 () numba-tu ! com>
--------------------
Linus Torvalds wrote:

>This still does some fairly simple things wrong (notably, I'll need to fix
>the handling of "return" to make inline functions do the right thing), and
>I'll have to think about the exact IL representation of the expression
>linearization a bit. I'll probably make it some trivial three-pseudo-
>operand thing.
>  
>

Allow me my $0.02:

#1: Having to worry about anti-dependence is a real bother so renaming 
all definitions to be unique eliminates this problem.  This is of course 
the SSA form.  Adding the phi-pseudo-assignment at the entry of the loop 
make it much simpler to track cross-basicblock flows. Eg.,

  a = fib();
  if (e > 0)
    a = fub();
  fab(a);

would look something like

  a.1 = fib()
  if (e.1 > 0) goto BB1
  goto BB2

BB1:
  a.2 = fub()
  goto BB2

BB2:
  a.3 = phi(a.1, a.2)
  $5 = fab(a.3)

#2: Now that control dependency is taken care of (all instructions in a 
basic block same the same control dependency) and anti-dependence is 
gone, the only annoying thing left is memory and exceptions.  By 
borrowing a trick from denotational semantics we can model all "state" 
by a pseudo value, say "s".  Thus, all state modifying expressions take 
this value and produces it, eg.

  *a = 42;
  *b = *a;

would turn into

  s.2 = st.32(s.1, a, 42)
  $1 = ld.32(s.2, a)
  s.3 = st.32(s.2, b, $1)

There are many nice consequences of doing this:
1. The only dependence between instructions are now true data 
dependences (and in fact the order in the basicblock is completely 
irrelevant).
2. Common subexpression elimination on memory operations becomes trivial 
(it is exactly like any other expression).
3. Load and store optimization becomes trivial as well, eg. in the above 
example the ld.32 is trivial to eliminate.
4. Alias analysis fits perfectly in this framework; we can split the 
state into several if we can guarentee that two pointers are unaliased.  
Eg.  in the above example the two stores become independent (after CSE 
and store-load optimization)

  (sa.1, sb.1) = split s.0
  ....
  sa.2 = st.32(sa.1, a, 42)
  sb.2 = st.32(sb.1, b, 42)
  ....
  s.1 = join sa.2, sb.2

To really appreciate this, notice that all decisions are local, thus 
doesn't require a global analysis of the tree/graph, an analysis which 
would have to be redone anytime anything changed.


Fine print:

Ok, so load isn't really side-effect free and we also need to address 
other effects such as division with zero.  In general we need to treat 
load as producing a new state as well, eg.

  s.2 = st.32(s.1, a, 42)
  ($1, s.3) = ld.32(s.2, a)
  s.4 = st.32(s.3, b, 42)

We can still apply load and store optimizations with a little more 
care.  Assuming $1 is dead, then the load can be eliminated because any 
exception (segmentation fault) caused by the load would also be caused 
by the store (unless we have write-only memory or the pointer a is 
marked volatile).

The pair result from load (and divide, etc) can be avoided by realizing 
that state lives in different world from other values and the former is 
only used for it dependence, thus we can reuse the same (pseudo) 
variable in two different contexts with two different meanings, eg.

  s.2 = st.32(s.1, a, 42)
  $1 = ld.32(s.2, a)
  s.3 = st.32($1, b, $1)

but arguably this isn't as pretty.

Thanks for your patience,

  Tommy





================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Mon, 23 Feb 2004 01:34:08 +0000
Message-ID: <Pine.LNX.4.58.0402221713560.1395 () ppc970 ! osdl ! org>
--------------------

Ok, I do basic block pointers both ways now, but Tommy also mentioned that
he finds the code hard to read and that I should comment it more. Augh. 
I'll try, but it would also help if you actually sent in specific 
questions (or just mentioned specific areas that you think need comments).

That way the comments would be a bit more directed.

Anyway, with that off my chest, here's the basic block parent code:

On Sun, 22 Feb 2004, Tommy Thorn wrote:
> 
> #1: Having to worry about anti-dependence is a real bother so renaming 
> all definitions to be unique eliminates this problem.  This is of course 
> the SSA form. 

I was hoping to not have to do this. As far as I can tell, this has to 
happen after linearization anyway, since you need full use and liveness 
information, which is basically impossible to extract from the 
"structured" tree format.

Also, I'm not 100% convinced about SSA. I agree that it is clearly nice
for optimizations, but on the other hand I'm not convinced it is even 
needed. Again, I'd like to walk before we run, and it would be nicer to 
have something that just does stupid liveness analysis, CSE and register 
allocation, and screw anything else at this point.

But to help make even a simple liveness analysis possible, I've added BB
"parent" information, and pushed the thing out to the BK tree. Of course, 
since I don't actually linearize expressions yet, this is pretty 
"pointless" (since there is nothing to analyze), but better get it working 
early rather than late.

So what we have now is:

 - each basic block is associated with exactly one symbol (I call
   it the "owner" of the basic block).

 - from the basic block you can get to the symbol by doing a simple 
   "bb->this" dereference, and you can get from the symbol to the basic 
   block by doing "sym->bb_target".

 - The symbol also has a list of "parents" to the BB, which are in the 
   "bb_parents" list. You can get the parents of a basic block like this:

	struct symbol *owner = bb->this;
	struct basic_block *from;

	FOR_EACH_PTR(owner->bb_parents, from) {
		printf("  **from %p**\n", from);
	} END_FOR_EACH_PTR;

so that you can now go both ways.

NOTE! I'm not doing computed goto's yet. It's not actually very hard at 
all to do, but I need to squirrel away the information that a label has 
had it's address taken, and I haven't done that yet. Once I do that, and 
just make a computed goto the parent of all such basic blocks, it will 
just automatically "do the right thing", and the back end doesn't need to 
worry (ie there is nothing special about computed goto's as far as anybody 
should be concerned - they just result in the goto being the parent of a 
_lot_ of blocks).

And yes, I do switches right too, as far as I can tell.

Examples speak more than any words can, so here's what "test-linearize" 
prints out for this trivial program:

	int main(int argc)
	{
		switch (argc) {

			for (;;) {
	case 1:
				argc = 1;
				break;
	default:
				argc++;
			}
		}
		return argc;
	}

which results in (the printout for "default" is broken, never mind, I'll 
fix that, it's a "code generation" bug rather than a linearization bug):

	ep 0x4002600c: main
	   sym: 0x4003b30c argc

	bb: 0x4006900c
		addi.32		v1,vFP,$offsetof(argc:0x4003b30c)
		ld.32		v2,[v1]
		SWITCH		v2
		IF 1..1 goto .L0x4006902c
		IF 0..0 goto .L0x4006903c
		END

	bb: 0x4006901c
	  **from 0x4006903c**
		goto		.L0x4006902c

	bb: 0x4006902c
	  **from 0x4006900c**
	  **from 0x4006901c**
		movi.32		v3,$1
		addi.32		v4,vFP,$offsetof(argc:0x4003b30c)
		st.32		v3,[v4]
		goto		.L0x4006904c

	bb: 0x4006903c
	  **from 0x4006900c**
		addi.32		v5,vFP,$offsetof(argc:0x4003b30c)
		ld.32		v6,[v5]
		add.32		v7,v6,$1
		st.32		v7,[v5]
		goto		.L0x4006901c

	bb: 0x4006904c
	  **from 0x4006902c**
		goto		.L0x4006905c

	bb: 0x4006905c
	  **from 0x4006904c**
		addi.32		v8,vFP,$offsetof(argc:0x4003b30c)
		ld.32		v9,[v8]
		addi.32		v10,vFP,$offsetof(return:0x4003b38c)
		st.32		v9,[v10]
		ret		(0x4003b38c)
		END

Ie note how each basic block now prints out all the sources to it.

I'll linearize the actual expressions next.

				Linus


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse, be] operand size work
Date: Mon, 23 Feb 2004 09:08:26 +0000
Message-ID: <Pine.LNX.4.58.0402230103130.3005 () ppc970 ! osdl ! org>
--------------------


On Thu, 12 Feb 2004, Linus Torvalds wrote:
> 
> So you're right - I do need to linearize the expressions, if only to get 
> to the statement expressions and linearize the substatement too. And once 
> I'd do that, I might as well linearize them totally, since I'd need to 
> solve the pseudo issues for the statement-expression case anyway.

Argh. I started doing some expression linearization. I only handle a
fairly small subset of expressions, and I'm not sure I do this at all
correctly. I generate simple instructions on pseudo's, described by
"struct instruction" (which basically boil down to a "operand type +
opcode + operand").

I'm not sure I'm going in the right direction, so I'll pause and see if 
anybody screams "no no no".

Still not a lot of comments, and I suspect that the best "documentation" 
is the "show_instruction()/show_bb()/show_entry()" functions at the top of 
linearize.c. They pretty much show all the data structure contents (except 
for the operand type) and are simple enough that they should explain how 
the data structures work and how they hang together.

		Linus


================================================================================


################################################################################

=== Thread: [sparse] Backend fun... ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] Backend fun...
Date: Thu, 15 Apr 2004 00:31:24 +0000
Message-ID: <407DD7DC.3070001 () pobox ! com>
--------------------

Lotsa neat stuff is definitely happening.  I'm currently buried with 
SATA (not to mention net drivers) in the Linux kernel, so I probably 
won't touch compile-i386.c for another month or two, at the very least.

I like the direction of sparse, and I would not be offended if other 
people started hacking on that code...


As a tangent, one key backend thing I wanted to do in sparse is to 
isolate the x86-isms even more, and pass those details dynamically into 
sparse.  Most of this stuff is already isolated in target.h AFAICS, but 
ISTR a few details buried in the code itself.



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: [sparse] Make warnings gcc alike ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: [sparse] Make warnings gcc alike
Date: Sun, 30 May 2004 21:47:32 +0000
Message-ID: <20040530214732.GA13190 () mars ! ravnborg ! org>
--------------------
Hi Linus.

Following patch changes warnings to follow the gcc syntax:
file:line:column: warning: ......

It also introduces a new function 'info()', that may be used to provide
additional info to a warning.

Main reason to introduce info() was to make warnings
spanning more lines only use one warning: tag.
This makes 'grep warning: ... | wc -l' reports correct
number of warnings.

Sample output:
fs/quota.c:279:17: warning: incorrect type in argument 1 (different address spaces)
fs/quota.c:279:17:  expected char const [noderef] *<noident><asn:1>
fs/quota.c:279:17:  got char const *special


	Sam

===== evaluate.c 1.187 vs edited =====
--- 1.187/evaluate.c	2004-05-30 05:21:43 +02:00
+++ edited/evaluate.c	2004-05-30 23:39:50 +02:00
@@ -729,8 +729,8 @@
 
 	// FIXME!! Cast it?
 	warn(expr->pos, "incorrect type in %s (%s)", where, typediff);
-	warn(expr->pos, "  expected %s", show_typename(target));
-	warn(expr->pos, "  got %s", show_typename(source));
+	info(expr->pos, "expected %s", show_typename(target));
+	info(expr->pos, "got %s", show_typename(source));
 	return 0;
 }
 
===== pre-process.c 1.72 vs edited =====
--- 1.72/pre-process.c	2004-04-21 18:39:57 +02:00
+++ edited/pre-process.c	2004-05-30 23:45:42 +02:00
@@ -658,7 +658,7 @@
 		    token_list_different(sym->arglist, arglist)) {
 			warn(left->pos, "preprocessor token %.*s redefined",
 					name->len, name->name);
-			warn(sym->pos, "this was the original definition");
+			info(sym->pos, "this was the original definition");
 		}
 		return 1;
 	}
===== lib.c 1.44 vs edited =====
--- 1.44/lib.c	2004-05-28 20:24:28 +02:00
+++ edited/lib.c	2004-05-30 23:34:49 +02:00
@@ -484,8 +484,24 @@
 	vsprintf(buffer, fmt, args);	
 	name = input_streams[pos.stream].name;
 		
-	fprintf(stderr, "%s: %s:%d:%d: %s\n",
-		type, name, pos.line, pos.pos, buffer);
+	fprintf(stderr, "%s:%d:%d: %s: %s\n",
+		name, pos.line, pos.pos, type, buffer);
+}
+
+void info(struct position pos, const char * fmt, ...)
+{
+	static char buffer[512];
+	const char *name;
+
+	va_list args;
+	va_start(args, fmt);
+
+	vsprintf(buffer, fmt, args);	
+	name = input_streams[pos.stream].name;
+		
+	fprintf(stderr, "%s:%d:%d:  %s\n",
+		name, pos.line, pos.pos, buffer);
+	va_end(args);
 }
 
 void warn(struct position pos, const char * fmt, ...)
===== lib.h 1.34 vs edited =====
--- 1.34/lib.h	2004-04-23 02:42:52 +02:00
+++ edited/lib.h	2004-05-30 23:13:07 +02:00
@@ -41,6 +41,7 @@
 
 struct token *skip_to(struct token *, int);
 struct token *expect(struct token *, int, const char *);
+extern void info(struct position pos, const char * fmt, ...);
 extern void warn(struct position, const char *, ...);
 extern void error(struct position, const char *, ...);
 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] Make warnings gcc alike
Date: Sun, 30 May 2004 22:01:38 +0000
Message-ID: <40BA59C2.4050707 () pobox ! com>
--------------------
Sam Ravnborg wrote:
> It also introduces a new function 'info()', that may be used to provide
> additional info to a warning.
> 
> Main reason to introduce info() was to make warnings
> spanning more lines only use one warning: tag.
> This makes 'grep warning: ... | wc -l' reports correct
> number of warnings.

While this is a nice effect, the purpose of a function named 'info()' is 
less clear than the existing 'warn()'...

IMO I would prefer two functions 'warn' and 'error' that support both 
single-line and multi-line output.  It shouldn't be hard to write "wrap 
at >75 columns" type code...

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] Make warnings gcc alike
Date: Mon, 31 May 2004 03:19:14 +0000
Message-ID: <Pine.LNX.4.58.0405302017170.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 30 May 2004, Jeff Garzik wrote:
> 
> While this is a nice effect, the purpose of a function named 'info()' is 
> less clear than the existing 'warn()'...

Well, I think "info()" should never go alone. 

Together with a "warn()" call (like it is used here) it makes fine sense. 
First you warn, and then you give additional information about the 
warning..

> IMO I would prefer two functions 'warn' and 'error' that support both 
> single-line and multi-line output.  It shouldn't be hard to write "wrap 
> at >75 columns" type code...

Augh. It gets really nasty. Plus we would have to be really careful to 
make sure that the wrapped part wouldn't look like another warning.

I like Sam's thing, but I don't like how it duplicates "do_warn()". I'd 
rather just make do_warn() usable even for "info()" too. Let me whip 
something up and test it.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] Make warnings gcc alike
Date: Mon, 31 May 2004 03:23:57 +0000
Message-ID: <Pine.LNX.4.58.0405302020360.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 30 May 2004, Linus Torvalds wrote:
> 
> Well, I think "info()" should never go alone. 
> 
> Together with a "warn()" call (like it is used here) it makes fine sense. 
> First you warn, and then you give additional information about the 
> warning..

The above also works well if we ever do a "verbose" thing, where the 
default is to just say "bad type", and the verbose mode is to explain 
_why_ it's bad. 

Right now I like how sparse is quite verbose, and tries to explain exactly
_why_ it thinks something is bad. It's useful not only because especially
historically sparse was just often wrong (and the verbose output made it
easier to pick out the crapola ones and/or debug sparse itself), but I
actually think it's a useful thing even for fixing up the code - instead
of having to worry about trying to figure out _what_ the type problems
are, sparse will tell you pretty clearly ("argument 2 has the wrong
address space").

But I can well imagine that somebody will find the verbose output of 
sparse irritating, and then we could just have a flag to shut sparse up 
about the "informational" part of the errors.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] Make warnings gcc alike
Date: Mon, 31 May 2004 03:35:31 +0000
Message-ID: <Pine.LNX.4.58.0405302035150.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 30 May 2004, Linus Torvalds wrote:
> 
> I like Sam's thing, but I don't like how it duplicates "do_warn()". I'd 
> rather just make do_warn() usable even for "info()" too. Let me whip 
> something up and test it.

Ok. Done. Pushed out.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: [sparse] Make warnings gcc alike
Date: Mon, 31 May 2004 06:24:26 +0000
Message-ID: <20040531062426.GA2216 () mars ! ravnborg ! org>
--------------------
On Sun, May 30, 2004 at 08:19:14PM -0700, Linus Torvalds wrote:
> 
> 
> On Sun, 30 May 2004, Jeff Garzik wrote:
> > 
> > While this is a nice effect, the purpose of a function named 'info()' is 
> > less clear than the existing 'warn()'...
> 
> Well, I think "info()" should never go alone. 
> 
> Together with a "warn()" call (like it is used here) it makes fine sense. 
> First you warn, and then you give additional information about the 
> warning..
When gcc reports an error it often given better information about
where it actually found the error:
In function foo ....

This tpe of information could also be printed out by info(),
and made conditional.
But I did not dive enough into sparse to check if this is worth doing.

Also even with the latest changes sparse still give a lot of output.
So no need to make it take up one more line for each warning for now.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [sparse] PATCH:  minor fix for initializer assign ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse] PATCH:  minor fix for initializer assign
Date: Sat, 17 Apr 2004 23:50:43 +0000
Message-ID: <20040417235043.GA23191 () 64m ! dyndns ! org>
--------------------
On Sun, Apr 18, 2004 at 12:21:51AM -0700, Christopher Li wrote:
> So I add that in evaluate.c, it seems fix the problem.
> Then feeding linearize.c can run all the way. I am sure the initializer

OOPS, not so fast. That is too early a claim. less eat the segment fault.

I need to make bitfield to pass the test.

Chris

There is more to come.

> need to count as assign, but I am not sure this patch cover all the case
> correctly.
> 
> Thanks, 
> 
> Chris
> 
> Index: sparse-be/evaluate.c
> ===================================================================
> --- sparse-be.orig/evaluate.c	2004-04-17 21:57:53.000000000 -0700
> +++ sparse-be/evaluate.c	2004-04-17 22:47:46.000000000 -0700
> @@ -1224,6 +1224,8 @@
>  			rtype = degenerate(expr, rtype, ep);
>  			expr = *ep;
>  			compatible_assignment_types(expr, ctype, ep, rtype, "initializer");
> +			if (ctype->type == SYM_NODE)
> +				ctype->ctype.modifiers |= MOD_ASSIGNED;
>  			/* strings are special: char arrays */
>  			if (rtype->type == SYM_ARRAY)
>  				size = get_expression_value(rtype->array_size);
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [sparse] PATCH: minor fix for initializer assign ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: [sparse] PATCH: minor fix for initializer assign
Date: Sun, 18 Apr 2004 07:21:51 +0000
Message-ID: <20040418072151.GA3729 () vmware ! com>
--------------------
Hi Linus,

I found out that the following input can cause segment fault on linearizing,
which is a scale down version of the problem in linearizing linearize.c

int foo(int d)
{
        int n = 0;
        n++ ;
}

The following code in expand.c consider the initializer is not part of the assign.
Then change the expression to value. Linearizion try to access that symbol by address
and segment faulted.

		/* Const symbol with a constant initializer? */
		if (!(sym->ctype.modifiers & (MOD_ASSIGNED | MOD_ADDRESSABLE))) {
			struct expression *value = sym->initializer;
			if (value) {
				if (value->type == EXPR_VALUE) {
					expr->type = EXPR_VALUE;
					expr->value = value->value;
				}
			}
		}

So I add that in evaluate.c, it seems fix the problem.
Then feeding linearize.c can run all the way. I am sure the initializer
need to count as assign, but I am not sure this patch cover all the case
correctly.

Thanks, 

Chris

Index: sparse-be/evaluate.c
===================================================================
--- sparse-be.orig/evaluate.c	2004-04-17 21:57:53.000000000 -0700
+++ sparse-be/evaluate.c	2004-04-17 22:47:46.000000000 -0700
@@ -1224,6 +1224,8 @@
 			rtype = degenerate(expr, rtype, ep);
 			expr = *ep;
 			compatible_assignment_types(expr, ctype, ep, rtype, "initializer");
+			if (ctype->type == SYM_NODE)
+				ctype->ctype.modifiers |= MOD_ASSIGNED;
 			/* strings are special: char arrays */
 			if (rtype->type == SYM_ARRAY)
 				size = get_expression_value(rtype->array_size);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] PATCH: minor fix for initializer assign
Date: Sun, 18 Apr 2004 17:46:34 +0000
Message-ID: <Pine.LNX.4.58.0404181024030.2808 () ppc970 ! osdl ! org>
--------------------


On Sun, 18 Apr 2004, Christopher Li wrote:
> 
> So I add that in evaluate.c, it seems fix the problem.

No, this is wrong, although I can see your confusion.

MOD_ASSIGNED is _not_ supposed to be set for initializers. It's supposed
to be set for normal assignments only. That way, if the _only_ assignment
to a symbol is its initializer, and the address of the symbol is never
taken, then we know it's constant.

This is a very simple optimization that hits VERY often for inline
functions (think of the argument to an inline function - the initializer
is the values passed into the function).

I agree that it is a special case, and that it's an optimization that 
later back-end processing would have noticed _anyway_ through constant 
propagation, but there is one really important reason for it: the kernel 
really wants

	__builtin_constant_p()

to work inside inline functions on the arguments, and I want to be able to 
evaluate that early.

So the real bug is that the "++" and "--" aren't considered assignments, 
although obviously they are. Fixed something like this..

		Linus

-----
# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/04/18 10:43:10-07:00 torvalds@ppc970.osdl.org 
#   Mark increment/decrements as assignments.
# 
# evaluate.c
#   2004/04/18 10:43:10-07:00 torvalds@ppc970.osdl.org +4 -0
#   Mark increment/decrements as assignments.
# 
diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	Sun Apr 18 10:45:31 2004
+++ b/evaluate.c	Sun Apr 18 10:45:31 2004
@@ -882,6 +882,10 @@
 		warn(expr->pos, "need lvalue expression for ++/--");
 		return NULL;
 	}
+
+	if (ctype->type == SYM_NODE)
+		ctype->ctype.modifiers |= MOD_ASSIGNED;
+
 	expr->ctype = ctype;
 	return ctype;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: [sparse] PATCH: minor fix for initializer assign
Date: Wed, 21 Apr 2004 10:10:01 +0000
Message-ID: <20040421101001.GA27098 () 64m ! dyndns ! org>
--------------------
On Sun, Apr 18, 2004 at 10:46:34AM -0700, Linus Torvalds wrote:
> 
> 
> On Sun, 18 Apr 2004, Christopher Li wrote:
> > 
> > So I add that in evaluate.c, it seems fix the problem.
> 
> No, this is wrong, although I can see your confusion.

You are right. I did not look careful enough on what is
that code try to do on converting expression to long value.

Guilty as it is, I am staying in the bug fixing mode for
a while. Try to pass the sparse source code first.

One thing I notice that if the source contain some thing
that sparse don't agree. Evaluation will exit early and linearizion
will see some abnormal AST comes in. I think may be sparse
need to have some way to report error just like
normal compiler does. Error won't stop evaluation, but don't
brother to start linearizion on errors.

> I agree that it is a special case, and that it's an optimization that 
> later back-end processing would have noticed _anyway_ through constant 
> propagation, but there is one really important reason for it: the kernel 
> really wants
> 
> 	__builtin_constant_p()
> 
> to work inside inline functions on the arguments, and I want to be able to 
> evaluate that early.

I am toying with the idea that do the pointer game in the MIR.
The inline function will copy and insert basic blocks instead
of C statement. It can do a lot of things otherwise be hard
in the AST. But it might slow down the checking though.

Is there any existing checking hard to perform in the  MIR?
Checking assign inside conditional expression cross my mind.

What do you think?

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] PATCH: minor fix for initializer assign
Date: Wed, 21 Apr 2004 19:00:35 +0000
Message-ID: <Pine.LNX.4.58.0404211140410.1775 () ppc970 ! osdl ! org>
--------------------


On Wed, 21 Apr 2004, Christopher Li wrote:
> 
> One thing I notice that if the source contain some thing
> that sparse don't agree. Evaluation will exit early and linearizion
> will see some abnormal AST comes in. I think may be sparse
> need to have some way to report error just like
> normal compiler does. Error won't stop evaluation, but don't
> brother to start linearizion on errors.

Yes. We should just exit on any syntax or type evaluation errors.  The 
only reason I made everything a "warning" instead of hard errors is that 
it historically gave much better coverage that way (ignore the stuff you 
don't understand, and continue giving warnings for the rest).

These days the front-end side is good enough that we could make errors
there fatal (and either stop immediately, or stop after that particular
pass has finished).

> > I agree that it is a special case, and that it's an optimization that 
> > later back-end processing would have noticed _anyway_ through constant 
> > propagation, but there is one really important reason for it: the kernel 
> > really wants
> > 
> > 	__builtin_constant_p()
> > 
> > to work inside inline functions on the arguments, and I want to be able to 
> > evaluate that early.
> 
> I am toying with the idea that do the pointer game in the MIR.
> The inline function will copy and insert basic blocks instead
> of C statement. It can do a lot of things otherwise be hard
> in the AST. But it might slow down the checking though.

The checking is one of the more important parts for me, that was why the
whole project started in the first place, after all. And one of the
reasons I want to do certain simplifications (like trivially unreachable
code etc) early is that I want to be able to do the warning checks early. 

But I don't see anything fundamental:

> Is there any existing checking hard to perform in the  MIR?
> Checking assign inside conditional expression cross my mind.

Agreed. On the other hand, that one is purely syntactic, and could be 
moved into the parse phase, ie even earlier than it is now. So if you want 
to make it linearize early, I'm ok with it.

What I'm _not_ ok with is to waste memory, though. In particular, I want
things to be evaluated as lazily as possible - I did some statistics early
on, and many (most?) C compilation unit have _more_ stuff in header files
(that seldom ends up being used) than they have in the "proper" C file
itself.

That is one of the reasons why I keep things in the highest possible
format until I need to actually look closer - symbols aren't actually
fully evaluated for their type until they are actually _used_, and a
unused inline function will never ever be evaluated or expanded at all, it
will have been made into a parse tree and never touched afterwards.

So I'd be very opposed to making linearization happen _too_ early, for 
example. I don't want to linearize inline functions before they are used 
etc.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [sparse] using basic blocks ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: [sparse] using basic blocks
Date: Sun, 23 May 2004 23:32:26 +0000
Message-ID: <40B1348A.5080907 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------030708090908030800010407
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit


How does one use the basic blocks generated by linearize_symbol()?

Am I missing something, or does something like the attached patch need 
to be applied?

	Jeff, looking into converting compile-i386.c




--------------030708090908030800010407
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== linearize.c 1.31 vs edited =====
--- 1.31/linearize.c	2004-04-22 21:50:45 -04:00
+++ edited/linearize.c	2004-05-23 19:29:59 -04:00
@@ -1033,15 +1033,16 @@
 	}
 }
 
-void linearize_symbol(struct symbol *sym)
+struct entrypoint *linearize_symbol(struct symbol *sym, int print_ep)
 {
+	struct entrypoint *ret_ep = NULL;
 	struct symbol *base_type;
 
 	if (!sym)
-		return;
+		return NULL;
 	base_type = sym->ctype.base_type;
 	if (!base_type)
-		return;
+		return NULL;
 	if (base_type->type == SYM_FN) {
 		if (base_type->stmt) {
 			struct entrypoint *ep = alloc_entrypoint();
@@ -1062,7 +1063,11 @@
 				add_one_insn(ep, pos, insn);
 			}
 			pack_basic_blocks(&ep->bbs);
-			show_entry(ep);
+			if (print_ep)
+				show_entry(ep);
+			ret_ep = ep;
 		}
 	}
+
+	return ret_ep;
 }
===== linearize.h 1.16 vs edited =====
--- 1.16/linearize.h	2004-04-22 20:54:06 -04:00
+++ edited/linearize.h	2004-05-23 19:30:18 -04:00
@@ -192,7 +192,7 @@
 	struct basic_block *active;
 };
 
-void linearize_symbol(struct symbol *sym);
+struct entrypoint *linearize_symbol(struct symbol *sym, int print_ep);
 
 #endif /* LINEARIZE_H */
 
===== test-linearize.c 1.2 vs edited =====
--- 1.2/test-linearize.c	2004-05-02 21:22:42 -04:00
+++ edited/test-linearize.c	2004-05-23 19:28:59 -04:00
@@ -26,7 +26,7 @@
 	check_duplicates(sym);
 	evaluate_symbol(sym);
 	expand_symbol(sym);
-	linearize_symbol(sym);
+	linearize_symbol(sym, 1);
 }
 
 int main(int argc, char **argv)

--------------030708090908030800010407--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: [sparse] using basic blocks
Date: Mon, 24 May 2004 03:18:33 +0000
Message-ID: <Pine.LNX.4.58.0405232017460.25502 () ppc970 ! osdl ! org>
--------------------


On Sun, 23 May 2004, Jeff Garzik wrote:
> 
> How does one use the basic blocks generated by linearize_symbol()?
> 
> Am I missing something, or does something like the attached patch need 
> to be applied?

Can't you clean up "test-linearize.c" at the same time, so that the 
"show_entry()" thing is done from there, rather than having that ugly 
"print" argument ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: [sparse] using basic blocks
Date: Mon, 24 May 2004 03:34:37 +0000
Message-ID: <40B16D4D.7000001 () pobox ! com>
--------------------
This is a multi-part message in MIME format.
--------------020305040702020703050307
Content-Type: text/plain; charset=us-ascii; format=flowed
Content-Transfer-Encoding: 7bit

Linus Torvalds wrote:
> 
> On Sun, 23 May 2004, Jeff Garzik wrote:
> 
>>How does one use the basic blocks generated by linearize_symbol()?
>>
>>Am I missing something, or does something like the attached patch need 
>>to be applied?
> 
> 
> Can't you clean up "test-linearize.c" at the same time, so that the 
> "show_entry()" thing is done from there, rather than having that ugly 
> "print" argument ;)


Boy that print_ep arg is ugly, isn't it?

Here ya go... (tested)


--------------020305040702020703050307
Content-Type: text/plain;
 name="patch"
Content-Transfer-Encoding: 7bit
Content-Disposition: inline;
 filename="patch"

===== linearize.c 1.31 vs edited =====
--- 1.31/linearize.c	2004-04-22 21:50:45 -04:00
+++ edited/linearize.c	2004-05-23 23:32:26 -04:00
@@ -213,7 +213,7 @@
 	printf("\n");
 }
 
-static void show_entry(struct entrypoint *ep)
+void show_entry(struct entrypoint *ep)
 {
 	struct symbol *sym;
 	struct basic_block *bb;
@@ -1033,15 +1033,16 @@
 	}
 }
 
-void linearize_symbol(struct symbol *sym)
+struct entrypoint *linearize_symbol(struct symbol *sym)
 {
 	struct symbol *base_type;
+	struct entrypoint *ret_ep = NULL;
 
 	if (!sym)
-		return;
+		return NULL;
 	base_type = sym->ctype.base_type;
 	if (!base_type)
-		return;
+		return NULL;
 	if (base_type->type == SYM_FN) {
 		if (base_type->stmt) {
 			struct entrypoint *ep = alloc_entrypoint();
@@ -1062,7 +1063,9 @@
 				add_one_insn(ep, pos, insn);
 			}
 			pack_basic_blocks(&ep->bbs);
-			show_entry(ep);
+			ret_ep = ep;
 		}
 	}
+
+	return ret_ep;
 }
===== linearize.h 1.16 vs edited =====
--- 1.16/linearize.h	2004-04-22 20:54:06 -04:00
+++ edited/linearize.h	2004-05-23 23:32:30 -04:00
@@ -192,7 +192,8 @@
 	struct basic_block *active;
 };
 
-void linearize_symbol(struct symbol *sym);
+struct entrypoint *linearize_symbol(struct symbol *sym);
+void show_entry(struct entrypoint *ep);
 
 #endif /* LINEARIZE_H */
 
===== test-linearize.c 1.2 vs edited =====
--- 1.2/test-linearize.c	2004-05-02 21:22:42 -04:00
+++ edited/test-linearize.c	2004-05-23 23:31:11 -04:00
@@ -23,10 +23,13 @@
 
 static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
 {
+	struct entrypoint *ep;
+
 	check_duplicates(sym);
 	evaluate_symbol(sym);
 	expand_symbol(sym);
-	linearize_symbol(sym);
+	ep = linearize_symbol(sym);
+	show_entry(ep);
 }
 
 int main(int argc, char **argv)

--------------020305040702020703050307--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: [users] warning ===

From: Rob Winchester <mipsv () yahoo ! com>
To: openoffice-users
Subject: Re: [users] warning
Date: Tue, 28 Sep 2004 05:54:42 +0000
Message-ID: <20040928055442.754.qmail () web41811 ! mail ! yahoo ! com>
--------------------
information for you:

Get Antivirus software :)

--- matthias.huetsch@sun.com wrote:

> information about you
> 
> > ---------------------------------------------------------------------
> To unsubscribe, e-mail: users-unsubscribe@openoffice.org
> For additional commands, e-mail: users-help@openoffice.org


=====
<A href="http://wwww.geocities.com/mipsv">Rob Winchester</a><br />
<a href="http://openoffice.org">Open Office - try it. Its great!</a><br />


		
__________________________________
Do you Yahoo!?
Yahoo! Mail - 50x more storage than other providers!
http://promotions.yahoo.com/new_mail

================================================================================

From: Dan Lewis <dlewis () delewis ! com>
To: openoffice-users
Subject: Re: [users] warning
Date: Fri, 01 Oct 2004 10:04:17 +0000
Message-ID: <200410010504.17546.dlewis () delewis ! com>
--------------------
On Friday 01 October 2004 06:52 am, Chadley Wilson wrote:
> On Friday, 1 October 2004 09:54, matthias.huetsch@sun.com wrote:
> > information about you
>
> What would that be?
     This has to be part of the latest virus or Trojan horse being 
passed around the internet. Someone with "users@openoffice.org" in 
their address book has become infected. There have been several emails 
to this mailing list lately which are very similar.

Dan


================================================================================

From: <dgordon8 () cogeco ! ca>
To: openoffice-users
Subject: RE: [users] warning
Date: Fri, 01 Oct 2004 10:41:59 +0000
Message-ID: <20041001104159.757CB616B () fep1 ! cogeco ! net>
--------------------
 > -----Original Message-----
> From: Dan Lewis [mailto:dlewis@delewis.com] 
> Sent: Friday, October 01, 2004 6:04 AM
> To: users@openoffice.org
> Subject: Re: [users] warning
> 
> On Friday 01 October 2004 06:52 am, Chadley Wilson wrote:
> > On Friday, 1 October 2004 09:54, matthias.huetsch@sun.com wrote:
> > > information about you
> >
> > What would that be?
>      This has to be part of the latest virus or Trojan horse being 
> passed around the internet. Someone with "users@openoffice.org" in 
> their address book has become infected. There have been 
> several emails 
> to this mailing list lately which are very similar.
> 
> Dan
> 
>

You are right and I would advise all windows users that subscribe to
this list to do a virus check on there computers especially anyone using
outlook or outlook express, anyone infected will be sending the virus to
the list there families and there friends.

Regards,
Dan Gordon
--------------------
Beer is the answer
Now, What was the
question ?
--------------------

---
Outgoing mail is certified Virus Free.
Checked by AVG anti-virus system (http://www.grisoft.com).
Version: 6.0.770 / Virus Database: 517 - Release Date: 9/27/2004
 


================================================================================

From: Chadley Wilson <chadley () pinteq ! co ! za>
To: openoffice-users
Subject: Re: [users] warning
Date: Fri, 01 Oct 2004 11:52:48 +0000
Message-ID: <200410011352.48948.chadley () pinteq ! co ! za>
--------------------
On Friday, 1 October 2004 09:54, matthias.huetsch@sun.com wrote:
> information about you
What would that be?
-- 
Chadley Wilson
Redhat Certified Technician 
Cert Number: 603004708291270
Pinnacle Micro
Manufacturers of Proline Computers
====================================
Exercise freedom, Use LINUX
=====================================

================================================================================

From: Jo <ml () winfix ! IT>
To: openoffice-users
Subject: Re: [users] warning
Date: Fri, 01 Oct 2004 12:07:17 +0000
Message-ID: <415D4875.7050301 () winfix ! IT>
--------------------
Rob Winchester schreef:

>information for you:
>
>Get Antivirus software :)
>  
>
Avast, Antivir and AVG are all available at no cost. Google for them.

Jo

================================================================================

From: Brian <bjbm () iinet ! net ! au>
To: openoffice-users
Subject: Re: [users] warning
Date: Fri, 01 Oct 2004 12:16:09 +0000
Message-ID: <415D4A89.2090100 () iinet ! net ! au>
--------------------
Dan Lewis wrote:

>On Friday 01 October 2004 06:52 am, Chadley Wilson wrote:
>  
>
>>On Friday, 1 October 2004 09:54, matthias.huetsch@sun.com wrote:
>>    
>>
>>>information about you
>>>      
>>>
>>What would that be?
>>    
>>
>     This has to be part of the latest virus or Trojan horse being 
>passed around the internet. Someone with "users@openoffice.org" in 
>their address book has become infected. There have been several emails 
>to this mailing list lately which are very similar.
>
>Dan
>
>  
>

Have you noticed they are always from the same sender? You would 
normally expect a range of "senders".
I am starting to wonder about Matthias.
The original email to the list would be very helpful here (for tracking 
purposes).

Brian

================================================================================

From: <dgordon8 () cogeco ! ca>
To: openoffice-users
Subject: RE: [users] warning
Date: Fri, 01 Oct 2004 12:48:51 +0000
Message-ID: <20041001124851.11E141E37 () fep2 ! cogeco ! net>
--------------------
 > -----Original Message-----
> From: Brian [mailto:bjbm@iinet.net.au] 
> Sent: Friday, October 01, 2004 8:16 AM
> To: users@openoffice.org
> Subject: Re: [users] warning
> 
> Dan Lewis wrote:
> 
> >On Friday 01 October 2004 06:52 am, Chadley Wilson wrote:
> >  
> >
> >>On Friday, 1 October 2004 09:54, matthias.huetsch@sun.com wrote:
> >>    
> >>
> >>>information about you
> >>>      
> >>>
> >>What would that be?
> >>    
> >>
> >     This has to be part of the latest virus or Trojan horse being 
> >passed around the internet. Someone with "users@openoffice.org" in 
> >their address book has become infected. There have been 
> several emails 
> >to this mailing list lately which are very similar.
> >
> >Dan
> >
> >  
> >
> 
> Have you noticed they are always from the same sender? You would 
> normally expect a range of "senders".
> I am starting to wonder about Matthias.
> The original email to the list would be very helpful here 
> (for tracking 
> purposes).
> 
> Brian
> 

Yes I have sent e-mail to them off list and hope they will clear this
matter up.

Regards,
Dan Gordon
--------------------
Beer is the answer
Now, What was the
question ?
--------------------

---
Outgoing mail is certified Virus Free.
Checked by AVG anti-virus system (http://www.grisoft.com).
Version: 6.0.770 / Virus Database: 517 - Release Date: 9/27/2004
 


================================================================================

From: Katgarden286 () aol ! com
To: openoffice-users
Subject: Re: [users] warning
Date: Fri, 01 Oct 2004 21:34:03 +0000
Message-ID: <104.5145ca1e.2e8f5f8b () aol ! com>
--------------------
-------------------------------1096680843
Content-Type: text/plain; charset="US-ASCII"
Content-Transfer-Encoding: 7bit

first noticed a "you are bad" email, it seemed to come from  
m(atthias)??huetsch ,  some  10 or so days ago, another user  actually posted to the huetsch  
address and advised that he/she is  infected... obviously to no avail, since 
now various posters get this  stuff....

-------------------------------1096680843--

================================================================================

From: Mhac Janapin <mhac () pbts ! net ! ph>
To: openoffice-users
Subject: Re: [users] warning
Date: Sat, 02 Oct 2004 00:54:34 +0000
Message-ID: <200410020854.34513.mhac () pbts ! net ! ph>
--------------------
Or best, SWITCH TO LINUX! Hurray!
^_^ Mhac


On Friday 01 October 2004 6:41 pm, dgordon8@cogeco.ca wrote:
>  > -----Original Message-----
> >
> > From: Dan Lewis [mailto:dlewis@delewis.com]
> > Sent: Friday, October 01, 2004 6:04 AM
> > To: users@openoffice.org
> > Subject: Re: [users] warning
> >
> > On Friday 01 October 2004 06:52 am, Chadley Wilson wrote:
> > > On Friday, 1 October 2004 09:54, matthias.huetsch@sun.com wrote:
> > > > information about you
> > >
> > > What would that be?
> >
> >      This has to be part of the latest virus or Trojan horse being
> > passed around the internet. Someone with "users@openoffice.org" in
> > their address book has become infected. There have been
> > several emails
> > to this mailing list lately which are very similar.
> >
> > Dan
>
> You are right and I would advise all windows users that subscribe to
> this list to do a virus check on there computers especially anyone using
> outlook or outlook express, anyone infected will be sending the virus to
> the list there families and there friends.
>
> Regards,
> Dan Gordon
> --------------------
> Beer is the answer
> Now, What was the
> question ?
> --------------------
>
> ---
> Outgoing mail is certified Virus Free.
> Checked by AVG anti-virus system (http://www.grisoft.com).
> Version: 6.0.770 / Virus Database: 517 - Release Date: 9/27/2004
>
>
>
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: users-unsubscribe@openoffice.org
> For additional commands, e-mail: users-help@openoffice.org

================================================================================

From: Graham Lauder <yorick () xtra ! co ! nz>
To: openoffice-users
Subject: Re: [users] warning
Date: Sat, 02 Oct 2004 02:39:00 +0000
Message-ID: <415E14C4.5040306 () xtra ! co ! nz>
--------------------
Katgarden286@aol.com wrote:

>first noticed a "you are bad" email, it seemed to come from  
>m(atthias)??huetsch ,  some  10 or so days ago, another user  actually posted to the huetsch  
>address and advised that he/she is  infected... obviously to no avail, since 
>now various posters get this  stuff....
>
>  
>
I suggest you ignore it.  Matthias is a regular poster.  The  virus is 
sourced most likely from  someone who has  Matthias email in their 
Outlook express address book.  It is an OLD trick of  virus hackers and 
people should know  better than blaming Matthias for the virus.

The virus is using his address... it is NOT coming from his machine!

Cheers
Yo




================================================================================


################################################################################

=== Thread: __func__ ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: __func__
Date: Wed, 18 Aug 2004 18:12:24 +0000
Message-ID: <20040818181224.DE27B1422D4F () darter ! rentec ! com>
--------------------

This implements __func__ correctly as a variable and not as a pre-
processor symbol.  The lib.c part (deleting one line) is unlikely
to apply cleanly, but is trivial to do by hand.

I don't believe this is 100% correct -- "./test-linearize ~/foo.c" fails to
list __func__ and I don't see why.

Morten



===== lib.c 1.64 vs edited =====
--- 1.64/lib.c	2004-08-17 14:25:35 -04:00
+++ edited/lib.c	2004-08-18 13:06:42 -04:00
@@ -746,7 +746,6 @@
 	add_pre_buffer("#define __unix__ 1\n");
 	add_pre_buffer("#define __GNUC__ 2\n");
 	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
-	add_pre_buffer("#define __func__ \"function\"\n");
 	add_pre_buffer("#define __FUNCTION__ \"function\"\n");
 	add_pre_buffer("#define __PRETTY_FUNCTION__ \"function\"\n");
 	add_pre_buffer("#define __extension__\n");
===== parse.c 1.150 vs edited =====
--- 1.150/parse.c	2004-08-17 14:30:03 -04:00
+++ edited/parse.c	2004-08-18 14:05:45 -04:00
@@ -890,8 +890,26 @@
 	ret->ctype.modifiers |= (MOD_AUTO | MOD_REGISTER);
 	bind_symbol(ret, &return_ident, NS_ITERATOR);
 	stmt->ret = ret;
-
 	fn_local_symbol(ret);
+
+	// static const char __func__[] = "function-name";
+	if (sym->ident) {
+		struct ctype const_char = { .modifiers = MOD_CONST, .base_type = &char_ctype };
+		struct symbol *array = indirect(sym->pos, &const_char, SYM_ARRAY);
+		struct expression *expr = alloc_expression(sym->pos, EXPR_STRING);
+		int len = sym->ident->len;
+		struct string *string = __alloc_string(len+1);
+
+		memcpy(string->data, sym->ident->name, len);
+		string->data[len] = '\0';
+		string->length = len+1;
+		expr->string = string;
+		expr->ctype = array;
+		array->initializer = expr;
+		array->ident = &__func___ident;
+		bind_symbol (array, &__func___ident, NS_SYMBOL);
+	}
+
 	return stmt;
 }
 
===== symbol.h 1.90 vs edited =====
--- 1.90/symbol.h	2004-08-17 14:26:25 -04:00
+++ edited/symbol.h	2004-08-18 13:42:04 -04:00
@@ -195,6 +195,7 @@
 			__VA_ARGS___ident,
 			__LINE___ident,
 			__FILE___ident,
+			__func___ident,
 			pragma_ident;
 
 #define symbol_is_typename(sym) ((sym)->type == SYM_TYPE)
===== symbol.c 1.100 vs edited =====
--- 1.100/symbol.c	2004-08-17 14:31:46 -04:00
+++ edited/symbol.c	2004-08-18 13:05:14 -04:00
@@ -539,6 +539,7 @@
 struct ident __VA_ARGS___ident = __INIT_IDENT("__VA_ARGS__");
 struct ident __LINE___ident = __INIT_IDENT("__LINE__");
 struct ident __FILE___ident = __INIT_IDENT("__FILE__");
+struct ident __func___ident = __INIT_IDENT("__func__");
 
 void init_symbols(void)
 {
@@ -572,6 +573,7 @@
 	hash_ident(&defined_ident);
 	hash_ident(&__LINE___ident);
 	hash_ident(&__FILE___ident);
+	hash_ident(&__func___ident);
 	hash_ident(&__VA_ARGS___ident);
 	hash_ident(&pragma_ident);
 	for (ptr = symbol_init_table; ptr->name; ptr++) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: __func__
Date: Wed, 18 Aug 2004 18:40:26 +0000
Message-ID: <20040818184026.GA28209 () 64m ! dyndns ! org>
--------------------
It has a few problem.
array is a type, to declare a variable you need a symbol node.
The __func__ did not show up because you haven't add it to stmt->syms.
And you want to put it to local function symbols so it get removed
when function ends.

I modify the patch a little bit and see if that is what you want.
I make it apply to the current BK.

Regards,

Chris

Index: sparse-be/lib.c
===================================================================
--- sparse-be.orig/lib.c        2004-08-18 11:25:53.000000000 -0400
+++ sparse-be/lib.c     2004-08-18 12:31:03.000000000 -0400
@@ -678,7 +678,6 @@
        add_pre_buffer("#define __STDC__ 1\n");
        add_pre_buffer("#define __GNUC__ 2\n");
        add_pre_buffer("#define __GNUC_MINOR__ 95\n");
-       add_pre_buffer("#define __func__ \"function\"\n");
        add_pre_buffer("#define __extension__\n");
        add_pre_buffer("#define __pragma__\n");
        // gcc defines __SIZE_TYPE__ to be size_t.  For linux/i86 and
Index: sparse-be/parse.c
===================================================================
--- sparse-be.orig/parse.c      2004-08-18 11:25:53.000000000 -0400
+++ sparse-be/parse.c   2004-08-18 14:29:48.000000000 -0400
@@ -866,6 +866,33 @@
        stmt->ret = ret;
 
        fn_local_symbol(ret);
+
+       if (sym->ident) {
+               struct symbol *funcname = alloc_symbol(sym->pos, SYM_NODE);
+               struct symbol *array = alloc_symbol(sym->pos, SYM_ARRAY);
+               struct expression *expr = alloc_expression(sym->pos, EXPR_STRING);
+               int len = sym->ident->len;
+               struct string *string = __alloc_string(len+1);
+
+               array->ctype.base_type = &char_ctype;
+               array->ctype.modifiers = MOD_CONST | MOD_STATIC;
+
+               memcpy(string->data, sym->ident->name, len);
+               string->data[len] = '\0';
+               string->length = len + 1;
+
+               expr->string = string;
+
+               funcname->initializer = expr;
+               funcname->ctype.modifiers = array->ctype.modifiers;
+               funcname->ctype.base_type = array;
+               funcname->ident = &__func___ident;
+               bind_symbol(funcname, &__func___ident, NS_SYMBOL);
+
+               add_symbol(&stmt->syms, funcname);
+               fn_local_symbol(funcname);
+       }
+
        return stmt;
 }
 
Index: sparse-be/symbol.c
===================================================================
--- sparse-be.orig/symbol.c     2004-08-18 11:25:53.000000000 -0400
+++ sparse-be/symbol.c  2004-08-18 12:32:32.000000000 -0400
@@ -545,6 +545,7 @@
 struct ident __VA_ARGS___ident = __INIT_IDENT("__VA_ARGS__");
 struct ident __LINE___ident = __INIT_IDENT("__LINE__");
 struct ident __FILE___ident = __INIT_IDENT("__FILE__");
+struct ident __func___ident = __INIT_IDENT("__func__");
 
 void init_symbols(void)
 {
@@ -578,6 +579,7 @@
        hash_ident(&defined_ident);
        hash_ident(&__LINE___ident);
        hash_ident(&__FILE___ident);
+       hash_ident(&__func___ident);
        hash_ident(&__VA_ARGS___ident);
        hash_ident(&pragma_ident);
        for (ptr = symbol_init_table; ptr->name; ptr++) {
Index: sparse-be/symbol.h
===================================================================
--- sparse-be.orig/symbol.h     2004-08-18 11:25:53.000000000 -0400
+++ sparse-be/symbol.h  2004-08-18 12:31:39.000000000 -0400
@@ -195,6 +195,7 @@
                        __VA_ARGS___ident,
                        __LINE___ident,
                        __FILE___ident,
+                       __func___ident,
                        pragma_ident;
 
 #define symbol_is_typename(sym) ((sym)->type == SYM_TYPE)


On Wed, Aug 18, 2004 at 02:12:24PM -0400, Morten Welinder wrote:
> 
> This implements __func__ correctly as a variable and not as a pre-
> processor symbol.  The lib.c part (deleting one line) is unlikely
> to apply cleanly, but is trivial to do by hand.
> 
> I don't believe this is 100% correct -- "./test-linearize ~/foo.c" fails to
> list __func__ and I don't see why.
> 
> Morten
> 
> 
> 
> ===== lib.c 1.64 vs edited =====
> --- 1.64/lib.c	2004-08-17 14:25:35 -04:00
> +++ edited/lib.c	2004-08-18 13:06:42 -04:00
> @@ -746,7 +746,6 @@
>  	add_pre_buffer("#define __unix__ 1\n");
>  	add_pre_buffer("#define __GNUC__ 2\n");
>  	add_pre_buffer("#define __GNUC_MINOR__ 95\n");
> -	add_pre_buffer("#define __func__ \"function\"\n");
>  	add_pre_buffer("#define __FUNCTION__ \"function\"\n");
>  	add_pre_buffer("#define __PRETTY_FUNCTION__ \"function\"\n");
>  	add_pre_buffer("#define __extension__\n");
> ===== parse.c 1.150 vs edited =====
> --- 1.150/parse.c	2004-08-17 14:30:03 -04:00
> +++ edited/parse.c	2004-08-18 14:05:45 -04:00
> @@ -890,8 +890,26 @@
>  	ret->ctype.modifiers |= (MOD_AUTO | MOD_REGISTER);
>  	bind_symbol(ret, &return_ident, NS_ITERATOR);
>  	stmt->ret = ret;
> -
>  	fn_local_symbol(ret);
> +
> +	// static const char __func__[] = "function-name";
> +	if (sym->ident) {
> +		struct ctype const_char = { .modifiers = MOD_CONST, .base_type = &char_ctype };
> +		struct symbol *array = indirect(sym->pos, &const_char, SYM_ARRAY);
> +		struct expression *expr = alloc_expression(sym->pos, EXPR_STRING);
> +		int len = sym->ident->len;
> +		struct string *string = __alloc_string(len+1);
> +
> +		memcpy(string->data, sym->ident->name, len);
> +		string->data[len] = '\0';
> +		string->length = len+1;
> +		expr->string = string;
> +		expr->ctype = array;
> +		array->initializer = expr;
> +		array->ident = &__func___ident;
> +		bind_symbol (array, &__func___ident, NS_SYMBOL);
> +	}
> +
>  	return stmt;
>  }
>  
> ===== symbol.h 1.90 vs edited =====
> --- 1.90/symbol.h	2004-08-17 14:26:25 -04:00
> +++ edited/symbol.h	2004-08-18 13:42:04 -04:00
> @@ -195,6 +195,7 @@
>  			__VA_ARGS___ident,
>  			__LINE___ident,
>  			__FILE___ident,
> +			__func___ident,
>  			pragma_ident;
>  
>  #define symbol_is_typename(sym) ((sym)->type == SYM_TYPE)
> ===== symbol.c 1.100 vs edited =====
> --- 1.100/symbol.c	2004-08-17 14:31:46 -04:00
> +++ edited/symbol.c	2004-08-18 13:05:14 -04:00
> @@ -539,6 +539,7 @@
>  struct ident __VA_ARGS___ident = __INIT_IDENT("__VA_ARGS__");
>  struct ident __LINE___ident = __INIT_IDENT("__LINE__");
>  struct ident __FILE___ident = __INIT_IDENT("__FILE__");
> +struct ident __func___ident = __INIT_IDENT("__func__");
>  
>  void init_symbols(void)
>  {
> @@ -572,6 +573,7 @@
>  	hash_ident(&defined_ident);
>  	hash_ident(&__LINE___ident);
>  	hash_ident(&__FILE___ident);
> +	hash_ident(&__func___ident);
>  	hash_ident(&__VA_ARGS___ident);
>  	hash_ident(&pragma_ident);
>  	for (ptr = symbol_init_table; ptr->name; ptr++) {
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: __func__
Date: Thu, 19 Aug 2004 15:43:28 +0000
Message-ID: <20040819154328.9040F1422D56 () darter ! rentec ! com>
--------------------

Thanks!

I have included this in my for-linus tree.

Morten




Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c |    4 ++-
 lib.c      |   36 ++++++++++++++++++++++++++++++++-
 lib.h      |    1 
 parse.c    |   65 +++++++++++++++++++++++++++++++++++++++++++++++++++----------
 parse.h    |    4 +--
 symbol.c   |   19 +++--------------
 symbol.h   |    1 
 7 files changed, 101 insertions(+), 29 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/19 1.737)
   Handle __func__ correctly as a variable and not a #define.
   With help from Christopher Li <sparse@chrisli.org>.

<welinder@troll.com> (04/08/17 1.736)
   Mondane cleanups at the level of typos.

<welinder@troll.com> (04/08/16 1.735)
   Introduce -Wdefault_bitfield_sign and only warn when asked for.

<welinder@troll.com> (04/08/16 1.734)
   parse.c:
     Get the right signedness (which broke when the code moved here).

<welinder@troll.com> (04/08/13 1.732)
   evaluate.c:
     Ignore MOD_EXPLICITLY_SIGNED for type comparisons.

<welinder@troll.com> (04/08/13 1.731)
   Don't complain over sign problems with unnamed bitfields.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: __func__
Date: Mon, 23 Aug 2004 02:53:25 +0000
Message-ID: <Pine.LNX.4.58.0408221947060.17766 () ppc970 ! osdl ! org>
--------------------


On Thu, 19 Aug 2004, Morten Welinder wrote:
>
> I have included this in my for-linus tree.

Morten,
 I pulled your tree, and there's some funky problems in your 
type-checking. You're doing them way too early.

Try this test-case:

	typedef struct {
		int a, b, c, d;
	} timestamp;

	unsigned long long timestamp = 0ULL;

and notice how it warns about "invalid modifiers". 

I checked in a fix, but you probably have a test-suite for this, so you 
should check my fix.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: alloca ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: alloca
Date: Tue, 27 Jul 2004 14:15:47 +0000
Message-ID: <20040727141547.2EA711422D53 () darter ! rentec ! com>
--------------------

This should be a reasonable prototype for __builtin_alloca.



===== check.c 1.31 vs 1.32 =====
--- 1.31/check.c	2004-07-24 02:35:38 -04:00
+++ 1.32/check.c	2004-07-27 09:58:38 -04:00
@@ -54,6 +54,7 @@
 	add_pre_buffer("extern void *__builtin_memset(void *, int, unsigned long);\n");	
 	add_pre_buffer("extern void __builtin_trap(void);\n");
 	add_pre_buffer("extern int __builtin_ffs(unsigned long);\n"); /* XXX(cw) check this */
+	add_pre_buffer("extern void *__builtin_alloca (unsigned long);\n";
 
 	args = argv;
 	for (;;) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: array pointer again ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: array pointer again
Date: Mon, 23 Aug 2004 21:57:39 +0000
Message-ID: <20040823215739.GA20757 () 64m ! dyndns ! org>
--------------------
I am getting some strange AST tree after evaluate this.

void foo(void)
{
        char b[10] ;
        b[0] = 4;
        *b = 4;
}

Here is test-parsing shows:

void ( extern [addressable] [toplevel] foo )( ... )
        movi.32         v1,$<noident>
        ld.32           v2,[v1]
        movi.32         v3,$__func__
        st.32           v2,[v3]
        movi.8          v4,$4
        addi.32         v5,vFP,$0
        st.8            v4,[v5]
        movi.8          v6,$4
        addi.32         v7,vFP,$0
        ld.80           v8,[v7]    <------------------
        st.8            v6,[v8]
.L0x4002d9e0:
        addi.32         v9,vFP,$offsetof(return:0x4002d9e0)
        ld.-1           v10,[v9]
        mov.-1          retval,10
        ret

b[0] is correct. But *b is evaluate to  **b. It seems that the
evaluate_symbol_expression adding (*) for it and not knowing
that b is a pointer to the storage address already.

I am working on a fix, but it seems very tricky to get all
the case right.

Chris 
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: array pointer again
Date: Tue, 24 Aug 2004 01:17:16 +0000
Message-ID: <20040824011716.GA22205 () 64m ! dyndns ! org>
--------------------
Yes  that make sense. I try a few case, it is a good fix.

Chris


On Mon, Aug 23, 2004 at 07:17:30PM -0700, Linus Torvalds wrote:
> 
> 
> On Mon, 23 Aug 2004, Christopher Li wrote:
> > 
> > b[0] is correct. But *b is evaluate to  **b. It seems that the
> > evaluate_symbol_expression adding (*) for it and not knowing
> > that b is a pointer to the storage address already.
> 
> Yes. 
> 
> At a first guess the problem would likely be that when we do the
> array->pointer conversion, we only do that on the type, not on the
> expression.
> 
> I've had that bug multiple times before, and it's so easy to overlook
> exactly because all of the normal users or sparse just check the type, not
> the actual expression tree.
> 
> I'm _almost_ certain that the problem is in "evaluate_dereference()",
> where when we deference the array, we do the right thing from a type
> standpoint, but since we _implicitly_ do the "addressof" operation, we do 
> not notice that we have a "*&(expr)" setup, and as a result we don't do 
> the
> 
> 	/* Simplify: *&(expr) => (expr) */
> 	if (op->type == EXPR_PREOP && op->op == '&') {
> 		*expr = *op->unop;
> 		return expr->ctype;
> 	}
> 
> part that we did just above.
> 
> My totally wild-assed guess for the proper fix would be something like 
> the appended ***TOTALLY***UNTESTED*** patch...
> 
> Can you check whether this seems to make any sense at all?
> 
> 		Linus
> 
> ----
> ===== evaluate.c 1.233 vs edited =====
> --- 1.233/evaluate.c	2004-08-14 10:27:22 -07:00
> +++ edited/evaluate.c	2004-08-23 19:16:22 -07:00
> @@ -1246,6 +1246,14 @@
>  		break;
>  
>  	case SYM_ARRAY:
> +		if (!lvalue_expression(op)) {
> +			warn(expr->pos, "non-lvalue array??");
> +			return NULL;
> +		}
> +
> +		/* Do the implied "addressof" on the array */
> +		*op = *op->unop;
> +
>  		/*
>  		 * When an array is dereferenced, we need to pick
>  		 * up the attributes of the original node too..
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: array pointer again
Date: Tue, 24 Aug 2004 02:17:30 +0000
Message-ID: <Pine.LNX.4.58.0408231903330.17766 () ppc970 ! osdl ! org>
--------------------


On Mon, 23 Aug 2004, Christopher Li wrote:
> 
> b[0] is correct. But *b is evaluate to  **b. It seems that the
> evaluate_symbol_expression adding (*) for it and not knowing
> that b is a pointer to the storage address already.

Yes. 

At a first guess the problem would likely be that when we do the
array->pointer conversion, we only do that on the type, not on the
expression.

I've had that bug multiple times before, and it's so easy to overlook
exactly because all of the normal users or sparse just check the type, not
the actual expression tree.

I'm _almost_ certain that the problem is in "evaluate_dereference()",
where when we deference the array, we do the right thing from a type
standpoint, but since we _implicitly_ do the "addressof" operation, we do 
not notice that we have a "*&(expr)" setup, and as a result we don't do 
the

	/* Simplify: *&(expr) => (expr) */
	if (op->type == EXPR_PREOP && op->op == '&') {
		*expr = *op->unop;
		return expr->ctype;
	}

part that we did just above.

My totally wild-assed guess for the proper fix would be something like 
the appended ***TOTALLY***UNTESTED*** patch...

Can you check whether this seems to make any sense at all?

		Linus

----
===== evaluate.c 1.233 vs edited =====
--- 1.233/evaluate.c	2004-08-14 10:27:22 -07:00
+++ edited/evaluate.c	2004-08-23 19:16:22 -07:00
@@ -1246,6 +1246,14 @@
 		break;
 
 	case SYM_ARRAY:
+		if (!lvalue_expression(op)) {
+			warn(expr->pos, "non-lvalue array??");
+			return NULL;
+		}
+
+		/* Do the implied "addressof" on the array */
+		*op = *op->unop;
+
 		/*
 		 * When an array is dereferenced, we need to pick
 		 * up the attributes of the original node too..
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: automatically minimizing error-inducing input ===

From: "Daniel S. Wilkerson" <dsw () eecs ! berkeley ! edu>
To: linux-sparse
Subject: automatically minimizing error-inducing input
Date: Fri, 29 Oct 2004 23:23:39 +0000
Message-ID: <4182D0FB.1D766E9 () cs ! berkeley ! edu>
--------------------
Some files crash sparse.  Debugging is easier if these files are made
smaller.  Minimizing inputs is a pain for humans, so we wrote a tool.

For example, the file "linux-2.6.10-rc1/fs/reiserfs/do_balan.c" crashes
"sparse".  Our tool "delta" reduced it from 1597 lines to 58 lines (4%)
that still crash sparse.

In general, given a decider-program and a file that passes it, delta finds
a smaller file that still passes; often this file is much smaller.  In
this case the decider-program, "sparse-crash", just says "is valid C and
crashes sparse".

Delta can be downloaded from http://www.cs.berkeley.edu/~dsw/ ;  Questions
and constructive feedback are welcome.

Rob Johnson
Daniel Wilkerson
Simon Goldsmith


--- sparse-crash decider-program that tests that files are valid C and yet
also crash sparse

#!/bin/bash
GCCARGS="-Wp,-MD,fs/reiserfs/.do_balan.o.d -nostdinc -iwithprefix include
-D__KERNEL__ -Iinclude  -Wall -Wstrict-prototypes -Wno-trigraphs
-fno-strict-aliasing -fno-common -Os -g  -save-temps -msoft-float
-mpreferred-stack-boundary=2  -march=i686
-Iinclude/asm-i386/mach-default   -DMODULE -DKBUILD_BASENAME=do_balan
-DKBUILD_MODNAME=reiserfs -c -o /dev/null /tmp/do_balan.c"
SPARSEARGS="-D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -D__i386__
-Wp,-MD,fs/reiserfs/.do_balan.o.d -nostdinc -iwithprefix include
-D__KERNEL__ -Iinclude  -Wall -Wstrict-prototypes -Wno-trigraphs
-fno-strict-aliasing -fno-common -Os -g  -save-temps -msoft-float
-mpreferred-stack-boundary=2  -march=i686
-Iinclude/asm-i386/mach-default   -DMODULE -DKBUILD_BASENAME=do_balan
-DKBUILD_MODNAME=reiserfs /tmp/do_balan.c"
gcc $GCCARGS &> /dev/null && (sparse $SPARSEARGS &> /dev/null; test $? -eq
139)

--- Some details

Multiple runs of delta are usually needed.  Below we give the shell
history of our runs of multidelta for this example ("multidelta" is a
wrapper around delta also provided).  The "-level" argument is a hint to
delta explained in the documentation; I often simply use 0, 1, 2, 3, and
10 three times each which is more than enough and completely automatic.

Since sparse takes .c files, we also had to comment-out the call to "cpp"
in multidelta.

--- transcript of running multidelta to minimize do_balan.c

 1103  multidelta ./sparse-crash /tmp/do_balan.c
 1105  multidelta ./sparse-crash /tmp/do_balan.c
 1107  multidelta ./sparse-crash /tmp/do_balan.c
 1109  multidelta ./sparse-crash /tmp/do_balan.c
 1112  multidelta ./sparse-crash /tmp/do_balan.c
 1114  multidelta ./sparse-crash /tmp/do_balan.c
 1116  multidelta ./sparse-crash /tmp/do_balan.c
 1129  multidelta -level=1 ./sparse-crash /tmp/do_balan.c
 1132  multidelta -level=1 ./sparse-crash /tmp/do_balan.c
 1133  multidelta -level=2 ./sparse-crash /tmp/do_balan.c
 1135  multidelta -level=3 ./sparse-crash /tmp/do_balan.c
 1136  multidelta -level=3 ./sparse-crash /tmp/do_balan.c
 1140  multidelta -level=10 ./sparse-crash /tmp/do_balan.c
 1144  multidelta -level=0 ./sparse-crash /tmp/do_balan.c
 1146  multidelta -level=0 ./sparse-crash /tmp/do_balan.c
 1148  multidelta -level=1 ./sparse-crash /tmp/do_balan.c
 1150  multidelta -level=1 ./sparse-crash /tmp/do_balan.c
 1152  multidelta -level=2 ./sparse-crash /tmp/do_balan.c
 1154  multidelta -level=2 ./sparse-crash /tmp/do_balan.c
 1156  multidelta -level=3 ./sparse-crash /tmp/do_balan.c
 1158  multidelta -level=10 ./sparse-crash /tmp/do_balan.c
 1160  multidelta -level=10 ./sparse-crash /tmp/do_balan.c


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 00:47:45 +0000
Message-ID: <Pine.LNX.4.58.0410291743270.28839 () ppc970 ! osdl ! org>
--------------------


On Fri, 29 Oct 2004, Daniel S. Wilkerson wrote:
> 
> For example, the file "linux-2.6.10-rc1/fs/reiserfs/do_balan.c" crashes
> "sparse".  Our tool "delta" reduced it from 1597 lines to 58 lines (4%)
> that still crash sparse.

Heh, interesting. I'm not seeing the crash, though, so I can't test out 
your delta thing. Just out of interest, which version of sparse are you 
working with?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Daniel S. Wilkerson" <dsw () eecs ! berkeley ! edu>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 00:54:17 +0000
Message-ID: <4182E639.8449CE66 () cs ! berkeley ! edu>
--------------------
Linus Torvalds wrote:

> On Fri, 29 Oct 2004, Daniel S. Wilkerson wrote:
> >
> > For example, the file "linux-2.6.10-rc1/fs/reiserfs/do_balan.c" crashes
> > "sparse".  Our tool "delta" reduced it from 1597 lines to 58 lines (4%)
> > that still crash sparse.
>
> Heh, interesting. I'm not seeing the crash, though, so I can't test out
> your delta thing. Just out of interest, which version of sparse are you
> working with?

Rob says: The one that was in bitkeeper as of 28 October 2004 2:50 pm
(California time).

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 01:17:13 +0000
Message-ID: <Pine.LNX.4.58.0410291813320.28839 () ppc970 ! osdl ! org>
--------------------


On Fri, 29 Oct 2004, Daniel S. Wilkerson wrote:
> 
> Rob says: The one that was in bitkeeper as of 28 October 2004 2:50 pm
> (California time).

Ahh, ok. Strange. That should be after my flurry of small patches (some of 
which were broken). 

Sometimes these things are configuration-dependent, so can you send me 
your reiserfs config? I've tried both on x86 and ppc64 with all the 
options on..

Oh, and if you can send the minimal case, maybe that will just show me ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Daniel S. Wilkerson" <dsw () eecs ! berkeley ! edu>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 02:04:31 +0000
Message-ID: <4182F6AF.305008AB () cs ! berkeley ! edu>
--------------------
This is a multi-part message in MIME format.

--Boundary_(ID_cSKIFQyFEv2p5FfyYbfnVg)
Content-type: text/plain; charset=us-ascii
Content-transfer-encoding: 7BIT

Linus Torvalds wrote:

> Sometimes these things are configuration-dependent, so can you send me
> your reiserfs config? I've tried both on x86 and ppc64 with all the
> options on..

Rob?

> Oh, and if you can send the minimal case, maybe that will just show me ;)

Please find the before and after files attached.

Daniel


--Boundary_(ID_cSKIFQyFEv2p5FfyYbfnVg)
Content-type: text/plain; charset=us-ascii; name=do_balan.c.before
Content-transfer-encoding: 7BIT
Content-disposition: inline; filename=do_balan.c.before

/*
 * Copyright 2000 by Hans Reiser, licensing governed by reiserfs/README
 */

/* Now we have all buffers that must be used in balancing of the tree 	*/
/* Further calculations can not cause schedule(), and thus the buffer 	*/
/* tree will be stable until the balancing will be finished 		*/
/* balance the tree according to the analysis made before,		*/
/* and using buffers obtained after all above.				*/


/**
 ** balance_leaf_when_delete
 ** balance_leaf
 ** do_balance
 **
 **/

#include <linux/config.h>
#include <asm/uaccess.h>
#include <linux/time.h>
#include <linux/reiserfs_fs.h>
#include <linux/buffer_head.h>

#ifdef CONFIG_REISERFS_CHECK

struct tree_balance * cur_tb = NULL; /* detects whether more than one
                                        copy of tb exists as a means
                                        of checking whether schedule
                                        is interrupting do_balance */
#endif

inline void do_balance_mark_leaf_dirty (struct tree_balance * tb, 
					struct buffer_head * bh, int flag)
{
    journal_mark_dirty(tb->transaction_handle,
                       tb->transaction_handle->t_super, bh) ;
}

#define do_balance_mark_internal_dirty do_balance_mark_leaf_dirty
#define do_balance_mark_sb_dirty do_balance_mark_leaf_dirty


/* summary: 
 if deleting something ( tb->insert_size[0] < 0 )
   return(balance_leaf_when_delete()); (flag d handled here)
 else
   if lnum is larger than 0 we put items into the left node
   if rnum is larger than 0 we put items into the right node
   if snum1 is larger than 0 we put items into the new node s1
   if snum2 is larger than 0 we put items into the new node s2 
Note that all *num* count new items being created.

It would be easier to read balance_leaf() if each of these summary
lines was a separate procedure rather than being inlined.  I think
that there are many passages here and in balance_leaf_when_delete() in
which two calls to one procedure can replace two passages, and it
might save cache space and improve software maintenance costs to do so.  

Vladimir made the perceptive comment that we should offload most of
the decision making in this function into fix_nodes/check_balance, and
then create some sort of structure in tb that says what actions should
be performed by do_balance.

-Hans */



/* Balance leaf node in case of delete or cut: insert_size[0] < 0
 *
 * lnum, rnum can have values >= -1
 *	-1 means that the neighbor must be joined with S
 *	 0 means that nothing should be done with the neighbor
 *	>0 means to shift entirely or partly the specified number of items to the neighbor
 */
static int balance_leaf_when_delete (struct tree_balance * tb, int flag)
{
    struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
    int item_pos = PATH_LAST_POSITION (tb->tb_path);
    int pos_in_item = tb->tb_path->pos_in_item;
    struct buffer_info bi;
    int n;
    struct item_head * ih;

    RFALSE( tb->FR[0] && B_LEVEL (tb->FR[0]) != DISK_LEAF_NODE_LEVEL + 1,
	    "vs- 12000: level: wrong FR %z", tb->FR[0]);
    RFALSE( tb->blknum[0] > 1,
	    "PAP-12005: tb->blknum == %d, can not be > 1", tb->blknum[0]);
    RFALSE( ! tb->blknum[0] && ! PATH_H_PPARENT(tb->tb_path, 0),
	    "PAP-12010: tree can not be empty");

    ih = B_N_PITEM_HEAD (tbS0, item_pos);

    /* Delete or truncate the item */

    switch (flag) {
    case M_DELETE:   /* delete item in S[0] */

	RFALSE( ih_item_len(ih) + IH_SIZE != -tb->insert_size[0],
	        "vs-12013: mode Delete, insert size %d, ih to be deleted %h",
 		 -tb->insert_size [0], ih);

	bi.tb = tb;
	bi.bi_bh = tbS0;
	bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
	bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
	leaf_delete_items (&bi, 0, item_pos, 1, -1);

	if ( ! item_pos && tb->CFL[0] ) {
	    if ( B_NR_ITEMS(tbS0) ) {
		replace_key(tb, tb->CFL[0],tb->lkey[0],tbS0,0);
	    }
	    else {
		if ( ! PATH_H_POSITION (tb->tb_path, 1) )
		    replace_key(tb, tb->CFL[0],tb->lkey[0],PATH_H_PPARENT(tb->tb_path, 0),0);
	    }
	} 

	RFALSE( ! item_pos && !tb->CFL[0],
		"PAP-12020: tb->CFL[0]==%p, tb->L[0]==%p", tb->CFL[0], tb->L[0]);
    
	break;

    case M_CUT: {  /* cut item in S[0] */
	bi.tb = tb;
	bi.bi_bh = tbS0;
	bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
	bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
	if (is_direntry_le_ih (ih)) {

	    /* UFS unlink semantics are such that you can only delete one directory entry at a time. */
	    /* when we cut a directory tb->insert_size[0] means number of entries to be cut (always 1) */
	    tb->insert_size[0] = -1;
	    leaf_cut_from_buffer (&bi, item_pos, pos_in_item, -tb->insert_size[0]);

	    RFALSE( ! item_pos && ! pos_in_item && ! tb->CFL[0],
		    "PAP-12030: can not change delimiting key. CFL[0]=%p", 
		    tb->CFL[0]);

	    if ( ! item_pos && ! pos_in_item && tb->CFL[0] ) {
		replace_key(tb, tb->CFL[0],tb->lkey[0],tbS0,0);
	    }
	} else {
	    leaf_cut_from_buffer (&bi, item_pos, pos_in_item, -tb->insert_size[0]);

	    RFALSE( ! ih_item_len(ih),
		"PAP-12035: cut must leave non-zero dynamic length of item");
	}
	break;
    }

    default:
	print_cur_tb ("12040");
	reiserfs_panic (tb->tb_sb, "PAP-12040: balance_leaf_when_delete: unexpectable mode: %s(%d)",
			(flag == M_PASTE) ? "PASTE" : ((flag == M_INSERT) ? "INSERT" : "UNKNOWN"), flag);
    }

    /* the rule is that no shifting occurs unless by shifting a node can be freed */
    n = B_NR_ITEMS(tbS0);
    if ( tb->lnum[0] )     /* L[0] takes part in balancing */
    {
	if ( tb->lnum[0] == -1 )    /* L[0] must be joined with S[0] */
	{
	    if ( tb->rnum[0] == -1 )    /* R[0] must be also joined with S[0] */
	    {			
		if ( tb->FR[0] == PATH_H_PPARENT(tb->tb_path, 0) )
		{
		    /* all contents of all the 3 buffers will be in L[0] */
		    if ( PATH_H_POSITION (tb->tb_path, 1) == 0 && 1 < B_NR_ITEMS(tb->FR[0]) )
			replace_key(tb, tb->CFL[0],tb->lkey[0],tb->FR[0],1);

		    leaf_move_items (LEAF_FROM_S_TO_L, tb, n, -1, NULL);
		    leaf_move_items (LEAF_FROM_R_TO_L, tb, B_NR_ITEMS(tb->R[0]), -1, NULL);

		    reiserfs_invalidate_buffer (tb, tbS0);
		    reiserfs_invalidate_buffer (tb, tb->R[0]);

		    return 0;
		}
		/* all contents of all the 3 buffers will be in R[0] */
		leaf_move_items (LEAF_FROM_S_TO_R, tb, n, -1, NULL);
		leaf_move_items (LEAF_FROM_L_TO_R, tb, B_NR_ITEMS(tb->L[0]), -1, NULL);

		/* right_delimiting_key is correct in R[0] */
		replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);

		reiserfs_invalidate_buffer (tb, tbS0);
		reiserfs_invalidate_buffer (tb, tb->L[0]);

		return -1;
	    }

	    RFALSE( tb->rnum[0] != 0, 
		    "PAP-12045: rnum must be 0 (%d)", tb->rnum[0]);
	    /* all contents of L[0] and S[0] will be in L[0] */
	    leaf_shift_left(tb, n, -1);

	    reiserfs_invalidate_buffer (tb, tbS0);

	    return 0;
	}
	/* a part of contents of S[0] will be in L[0] and the rest part of S[0] will be in R[0] */

	RFALSE( ( tb->lnum[0] + tb->rnum[0] < n ) || 
		( tb->lnum[0] + tb->rnum[0] > n+1 ),
		"PAP-12050: rnum(%d) and lnum(%d) and item number(%d) in S[0] are not consistent",
		tb->rnum[0], tb->lnum[0], n);
	RFALSE( ( tb->lnum[0] + tb->rnum[0] == n ) && 
		(tb->lbytes != -1 || tb->rbytes != -1),
		"PAP-12055: bad rbytes (%d)/lbytes (%d) parameters when items are not split", 
		tb->rbytes, tb->lbytes);
	RFALSE( ( tb->lnum[0] + tb->rnum[0] == n + 1 ) && 
		(tb->lbytes < 1 || tb->rbytes != -1),
		"PAP-12060: bad rbytes (%d)/lbytes (%d) parameters when items are split", 
		tb->rbytes, tb->lbytes);

	leaf_shift_left (tb, tb->lnum[0], tb->lbytes);
	leaf_shift_right(tb, tb->rnum[0], tb->rbytes);

	reiserfs_invalidate_buffer (tb, tbS0);

	return 0;
    }

    if ( tb->rnum[0] == -1 ) {
	/* all contents of R[0] and S[0] will be in R[0] */
	leaf_shift_right(tb, n, -1);
	reiserfs_invalidate_buffer (tb, tbS0);
	return 0;
    }

    RFALSE( tb->rnum[0], 
	    "PAP-12065: bad rnum parameter must be 0 (%d)", tb->rnum[0]);
    return 0;
}


static int balance_leaf (struct tree_balance * tb,
			 struct item_head * ih,		/* item header of inserted item (this is on little endian) */
			 const char * body,		/* body  of inserted item or bytes to paste */
			 int flag,			/* i - insert, d - delete, c - cut, p - paste
							   (see comment to do_balance) */
			 struct item_head * insert_key,  /* in our processing of one level we sometimes determine what
							    must be inserted into the next higher level.  This insertion
							    consists of a key or two keys and their corresponding
							    pointers */
			 struct buffer_head ** insert_ptr /* inserted node-ptrs for the next level */
    )
{
    struct buffer_head * tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
    int item_pos = PATH_LAST_POSITION (tb->tb_path);	/*  index into the array of item headers in S[0] 
							    of the affected item */
    struct buffer_info bi;
    struct buffer_head *S_new[2];  /* new nodes allocated to hold what could not fit into S */
    int snum[2];	    /* number of items that will be placed
                               into S_new (includes partially shifted
                               items) */
    int sbytes[2];          /* if an item is partially shifted into S_new then 
			       if it is a directory item 
			       it is the number of entries from the item that are shifted into S_new
			       else
			       it is the number of bytes from the item that are shifted into S_new
			    */
    int n, i;
    int ret_val;
    int pos_in_item;
    int zeros_num;

    PROC_INFO_INC( tb -> tb_sb, balance_at[ 0 ] );

    /* Make balance in case insert_size[0] < 0 */
    if ( tb->insert_size[0] < 0 )
	return balance_leaf_when_delete (tb, flag);
  
    zeros_num = 0;
    if (flag == M_INSERT && body == 0)
	zeros_num = ih_item_len( ih );

    pos_in_item = tb->tb_path->pos_in_item;
    /* for indirect item pos_in_item is measured in unformatted node
       pointers. Recalculate to bytes */
    if (flag != M_INSERT && is_indirect_le_ih (B_N_PITEM_HEAD (tbS0, item_pos)))
	pos_in_item *= UNFM_P_SIZE;

    if ( tb->lnum[0] > 0 ) {
	/* Shift lnum[0] items from S[0] to the left neighbor L[0] */
	if ( item_pos < tb->lnum[0] ) {
	    /* new item or it part falls to L[0], shift it too */
	    n = B_NR_ITEMS(tb->L[0]);

	    switch (flag) {
	    case M_INSERT:   /* insert item into L[0] */

		if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
		    /* part of new item falls into L[0] */
		    int new_item_len;
		    int version;

		    ret_val = leaf_shift_left (tb, tb->lnum[0]-1, -1);

		    /* Calculate item length to insert to S[0] */
		    new_item_len = ih_item_len(ih) - tb->lbytes;
		    /* Calculate and check item length to insert to L[0] */
		    put_ih_item_len(ih, ih_item_len(ih) - new_item_len );

		    RFALSE( ih_item_len(ih) <= 0,
			    "PAP-12080: there is nothing to insert into L[0]: ih_item_len=%d",
                            ih_item_len(ih));

		    /* Insert new item into L[0] */
		    bi.tb = tb;
		    bi.bi_bh = tb->L[0];
		    bi.bi_parent = tb->FL[0];
		    bi.bi_position = get_left_neighbor_position (tb, 0);
		    leaf_insert_into_buf (&bi, n + item_pos - ret_val, ih, body,
					  zeros_num > ih_item_len(ih) ? ih_item_len(ih) : zeros_num);

		    version = ih_version (ih);

		    /* Calculate key component, item length and body to insert into S[0] */
                    set_le_ih_k_offset( ih, le_ih_k_offset( ih ) + (tb->lbytes << (is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0)) );

		    put_ih_item_len( ih, new_item_len );
		    if ( tb->lbytes >  zeros_num ) {
			body += (tb->lbytes - zeros_num);
			zeros_num = 0;
		    }
		    else
			zeros_num -= tb->lbytes;

		    RFALSE( ih_item_len(ih) <= 0,
			"PAP-12085: there is nothing to insert into S[0]: ih_item_len=%d",
			ih_item_len(ih));
		} else {
		    /* new item in whole falls into L[0] */
		    /* Shift lnum[0]-1 items to L[0] */
		    ret_val = leaf_shift_left(tb, tb->lnum[0]-1, tb->lbytes);
		    /* Insert new item into L[0] */
		    bi.tb = tb;
		    bi.bi_bh = tb->L[0];
		    bi.bi_parent = tb->FL[0];
		    bi.bi_position = get_left_neighbor_position (tb, 0);
		    leaf_insert_into_buf (&bi, n + item_pos - ret_val, ih, body, zeros_num);
		    tb->insert_size[0] = 0;
		    zeros_num = 0;
		}
		break;

	    case M_PASTE:   /* append item in L[0] */

		if ( item_pos == tb->lnum[0] - 1 && tb->lbytes != -1 ) {
		    /* we must shift the part of the appended item */
		    if ( is_direntry_le_ih (B_N_PITEM_HEAD (tbS0, item_pos))) {

			RFALSE( zeros_num,
				"PAP-12090: invalid parameter in case of a directory");
			/* directory item */
			if ( tb->lbytes > pos_in_item ) {
			    /* new directory entry falls into L[0] */
			    struct item_head * pasted;
			    int l_pos_in_item = pos_in_item;
							  
			    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 entries from given directory item */
			    ret_val = leaf_shift_left(tb, tb->lnum[0], tb->lbytes - 1);
			    if ( ret_val && ! item_pos ) {
				pasted =  B_N_PITEM_HEAD(tb->L[0],B_NR_ITEMS(tb->L[0])-1);
				l_pos_in_item += I_ENTRY_COUNT(pasted) - (tb->lbytes-1);
			    }

			    /* Append given directory entry to directory item */
			    bi.tb = tb;
			    bi.bi_bh = tb->L[0];
			    bi.bi_parent = tb->FL[0];
			    bi.bi_position = get_left_neighbor_position (tb, 0);
			    leaf_paste_in_buffer (&bi, n + item_pos - ret_val, l_pos_in_item,
						  tb->insert_size[0], body, zeros_num);

			    /* previous string prepared space for pasting new entry, following string pastes this entry */

			    /* when we have merge directory item, pos_in_item has been changed too */

			    /* paste new directory entry. 1 is entry number */
			    leaf_paste_entries (bi.bi_bh, n + item_pos - ret_val, l_pos_in_item, 1,
						(struct reiserfs_de_head *)body, 
						body + DEH_SIZE, tb->insert_size[0]
				);
			    tb->insert_size[0] = 0;
			} else {
			    /* new directory item doesn't fall into L[0] */
			    /* Shift lnum[0]-1 items in whole. Shift lbytes directory entries from directory item number lnum[0] */
			    leaf_shift_left (tb, tb->lnum[0], tb->lbytes);
			}
			/* Calculate new position to append in item body */
			pos_in_item -= tb->lbytes;
		    }
		    else {
			/* regular object */
			RFALSE( tb->lbytes <= 0,
			        "PAP-12095: there is nothing to shift to L[0]. lbytes=%d",
				tb->lbytes);
			RFALSE( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0, item_pos)),
                                "PAP-12100: incorrect position to paste: item_len=%d, pos_in_item=%d",
				ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)), pos_in_item);

			if ( tb->lbytes >= pos_in_item ) {
			    /* appended item will be in L[0] in whole */
			    int l_n;

			    /* this bytes number must be appended to the last item of L[h] */
			    l_n = tb->lbytes - pos_in_item;

			    /* Calculate new insert_size[0] */
			    tb->insert_size[0] -= l_n;

			    RFALSE( tb->insert_size[0] <= 0,
				    "PAP-12105: there is nothing to paste into L[0]. insert_size=%d",
				    tb->insert_size[0]);
			    ret_val =  leaf_shift_left(tb,tb->lnum[0], 
						       ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)));
			    /* Append to body of item in L[0] */
			    bi.tb = tb;
			    bi.bi_bh = tb->L[0];
			    bi.bi_parent = tb->FL[0];
			    bi.bi_position = get_left_neighbor_position (tb, 0);
			    leaf_paste_in_buffer(
				&bi,n + item_pos - ret_val,
				ih_item_len( B_N_PITEM_HEAD(tb->L[0],n+item_pos-ret_val)),
				l_n,body, zeros_num > l_n ? l_n : zeros_num
				);
			    /* 0-th item in S0 can be only of DIRECT type when l_n != 0*/
			    {
				int version;
				int temp_l = l_n;
				
				RFALSE (ih_item_len (B_N_PITEM_HEAD (tbS0, 0)),
					"PAP-12106: item length must be 0");
				RFALSE (comp_short_le_keys (B_N_PKEY (tbS0, 0),
							    B_N_PKEY (tb->L[0],
									    n + item_pos - ret_val)),
					"PAP-12107: items must be of the same file");
				if (is_indirect_le_ih(B_N_PITEM_HEAD (tb->L[0],
								      n + item_pos - ret_val)))	{
				    temp_l = l_n << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT);
				}
				/* update key of first item in S0 */
				version = ih_version (B_N_PITEM_HEAD (tbS0, 0));
				set_le_key_k_offset (version, B_N_PKEY (tbS0, 0), 
						     le_key_k_offset (version, B_N_PKEY (tbS0, 0)) + temp_l);
				/* update left delimiting key */
				set_le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]),
						     le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0])) + temp_l);
			    }

			    /* Calculate new body, position in item and insert_size[0] */
			    if ( l_n > zeros_num ) {
				body += (l_n - zeros_num);
				zeros_num = 0;
			    }
			    else
				zeros_num -= l_n;
			    pos_in_item = 0;	

			    RFALSE( comp_short_le_keys 
				    (B_N_PKEY(tbS0,0),
				     B_N_PKEY(tb->L[0],B_NR_ITEMS(tb->L[0])-1)) ||
				
				    !op_is_left_mergeable 
				    (B_N_PKEY (tbS0, 0), tbS0->b_size) ||
				    !op_is_left_mergeable
				    (B_N_PDELIM_KEY(tb->CFL[0],tb->lkey[0]), 
				     tbS0->b_size),
				    "PAP-12120: item must be merge-able with left neighboring item");
			}
			else /* only part of the appended item will be in L[0] */
			{
			    /* Calculate position in item for append in S[0] */
			    pos_in_item -= tb->lbytes;

			    RFALSE( pos_in_item <= 0,
				    "PAP-12125: no place for paste. pos_in_item=%d", pos_in_item);

			    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
			    leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
			}
		    }
		}
		else /* appended item will be in L[0] in whole */
		{
		    struct item_head * pasted;

			if ( ! item_pos  && op_is_left_mergeable (B_N_PKEY (tbS0, 0), tbS0->b_size) )
			{ /* if we paste into first item of S[0] and it is left mergable */
			    /* then increment pos_in_item by the size of the last item in L[0] */
			    pasted = B_N_PITEM_HEAD(tb->L[0],n-1);
			    if ( is_direntry_le_ih (pasted) )
				pos_in_item += ih_entry_count(pasted);
			    else
				pos_in_item += ih_item_len(pasted);
			}

		    /* Shift lnum[0] - 1 items in whole. Shift lbytes - 1 byte from item number lnum[0] */
		    ret_val = leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
		    /* Append to body of item in L[0] */
		    bi.tb = tb;
		    bi.bi_bh = tb->L[0];
		    bi.bi_parent = tb->FL[0];
		    bi.bi_position = get_left_neighbor_position (tb, 0);
		    leaf_paste_in_buffer (&bi, n + item_pos - ret_val, pos_in_item, tb->insert_size[0],
					  body, zeros_num);

		    /* if appended item is directory, paste entry */
		    pasted = B_N_PITEM_HEAD (tb->L[0], n + item_pos - ret_val);
		    if (is_direntry_le_ih (pasted))
			leaf_paste_entries (
			    bi.bi_bh, n + item_pos - ret_val, pos_in_item, 1, 
			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
			    );
		    /* if appended item is indirect item, put unformatted node into un list */
		    if (is_indirect_le_ih (pasted))
			set_ih_free_space (pasted, 0);
		    tb->insert_size[0] = 0;
		    zeros_num = 0;
		}
		break;
	    default:    /* cases d and t */
		reiserfs_panic (tb->tb_sb, "PAP-12130: balance_leaf: lnum > 0: unexpectable mode: %s(%d)",
				(flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
	    }
	} else { 
	    /* new item doesn't fall into L[0] */
	    leaf_shift_left(tb,tb->lnum[0],tb->lbytes);
	}
    }	/* tb->lnum[0] > 0 */

    /* Calculate new item position */
    item_pos -= ( tb->lnum[0] - (( tb->lbytes != -1 ) ? 1 : 0));

    if ( tb->rnum[0] > 0 ) {
	/* shift rnum[0] items from S[0] to the right neighbor R[0] */
	n = B_NR_ITEMS(tbS0);
	switch ( flag ) {

	case M_INSERT:   /* insert item */
	    if ( n - tb->rnum[0] < item_pos )
	    { /* new item or its part falls to R[0] */
		if ( item_pos == n - tb->rnum[0] + 1 && tb->rbytes != -1 )
		{ /* part of new item falls into R[0] */
		    loff_t old_key_comp, old_len, r_zeros_number;
		    const char * r_body;
		    int version;
		    loff_t offset;

		    leaf_shift_right(tb,tb->rnum[0]-1,-1);

		    version = ih_version(ih);
		    /* Remember key component and item length */
                    old_key_comp = le_ih_k_offset( ih );
		    old_len = ih_item_len(ih);

		    /* Calculate key component and item length to insert into R[0] */
                    offset = le_ih_k_offset( ih ) + ((old_len - tb->rbytes )<<(is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0));
                    set_le_ih_k_offset( ih, offset );
		    put_ih_item_len( ih, tb->rbytes);
		    /* Insert part of the item into R[0] */
		    bi.tb = tb;
		    bi.bi_bh = tb->R[0];
		    bi.bi_parent = tb->FR[0];
		    bi.bi_position = get_right_neighbor_position (tb, 0);
		    if ( (old_len - tb->rbytes) > zeros_num ) {
			r_zeros_number = 0;
			r_body = body + (old_len - tb->rbytes) - zeros_num;
		    }
		    else {
			r_body = body;
			r_zeros_number = zeros_num - (old_len - tb->rbytes);
			zeros_num -= r_zeros_number;
		    }

		    leaf_insert_into_buf (&bi, 0, ih, r_body, r_zeros_number);

		    /* Replace right delimiting key by first key in R[0] */
		    replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);

		    /* Calculate key component and item length to insert into S[0] */
                    set_le_ih_k_offset( ih, old_key_comp );
		    put_ih_item_len( ih, old_len - tb->rbytes );

		    tb->insert_size[0] -= tb->rbytes;

		}
		else /* whole new item falls into R[0] */
		{					  
		    /* Shift rnum[0]-1 items to R[0] */
		    ret_val = leaf_shift_right(tb,tb->rnum[0]-1,tb->rbytes);
		    /* Insert new item into R[0] */
		    bi.tb = tb;
		    bi.bi_bh = tb->R[0];
		    bi.bi_parent = tb->FR[0];
		    bi.bi_position = get_right_neighbor_position (tb, 0);
		    leaf_insert_into_buf (&bi, item_pos - n + tb->rnum[0] - 1, ih, body, zeros_num);

		    if ( item_pos - n + tb->rnum[0] - 1 == 0 ) {
			replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);

		    }
		    zeros_num = tb->insert_size[0] = 0;
		}
	    }
	    else /* new item or part of it doesn't fall into R[0] */
	    {
		leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
	    }
	    break;

	case M_PASTE:   /* append item */

	    if ( n - tb->rnum[0] <= item_pos )  /* pasted item or part of it falls to R[0] */
	    {
		if ( item_pos == n - tb->rnum[0] && tb->rbytes != -1 )
		{ /* we must shift the part of the appended item */
		    if ( is_direntry_le_ih (B_N_PITEM_HEAD(tbS0, item_pos)))
		    { /* we append to directory item */
			int entry_count;

			RFALSE( zeros_num,
				"PAP-12145: invalid parameter in case of a directory");
			entry_count = I_ENTRY_COUNT(B_N_PITEM_HEAD(tbS0, item_pos));
			if ( entry_count - tb->rbytes < pos_in_item )
			    /* new directory entry falls into R[0] */
			{
			    int paste_entry_position;

			    RFALSE( tb->rbytes - 1 >= entry_count || 
				    ! tb->insert_size[0],
				    "PAP-12150: no enough of entries to shift to R[0]: rbytes=%d, entry_count=%d",
				    tb->rbytes, entry_count);
			    /* Shift rnum[0]-1 items in whole. Shift rbytes-1 directory entries from directory item number rnum[0] */
			    leaf_shift_right(tb,tb->rnum[0],tb->rbytes - 1);
			    /* Paste given directory entry to directory item */
			    paste_entry_position = pos_in_item - entry_count + tb->rbytes - 1;
			    bi.tb = tb;
			    bi.bi_bh = tb->R[0];
			    bi.bi_parent = tb->FR[0];
			    bi.bi_position = get_right_neighbor_position (tb, 0);
			    leaf_paste_in_buffer (&bi, 0, paste_entry_position,
						  tb->insert_size[0],body,zeros_num);
			    /* paste entry */
			    leaf_paste_entries (
				bi.bi_bh, 0, paste_entry_position, 1, (struct reiserfs_de_head *)body, 
				body + DEH_SIZE, tb->insert_size[0]
				);								
						
			    if ( paste_entry_position == 0 ) {
				/* change delimiting keys */
				replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
			    }

			    tb->insert_size[0] = 0;
			    pos_in_item++;
			}
			else /* new directory entry doesn't fall into R[0] */
			{
			    leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
			}
		    }
		    else /* regular object */
		    {
			int n_shift, n_rem, r_zeros_number;
			const char * r_body;

			/* Calculate number of bytes which must be shifted from appended item */
			if ( (n_shift = tb->rbytes - tb->insert_size[0]) < 0 )
			    n_shift = 0;

			RFALSE(pos_in_item != ih_item_len(B_N_PITEM_HEAD (tbS0, item_pos)),
			       "PAP-12155: invalid position to paste. ih_item_len=%d, pos_in_item=%d",
                               pos_in_item, ih_item_len( B_N_PITEM_HEAD(tbS0,item_pos)));

			leaf_shift_right(tb,tb->rnum[0],n_shift);
			/* Calculate number of bytes which must remain in body after appending to R[0] */
			if ( (n_rem = tb->insert_size[0] - tb->rbytes) < 0 )
			    n_rem = 0;
			
			{
			  int version;
			  unsigned long temp_rem = n_rem;
			  
			  version = ih_version (B_N_PITEM_HEAD (tb->R[0],0));
			  if (is_indirect_le_key(version,B_N_PKEY(tb->R[0],0))){
			      temp_rem = n_rem << (tb->tb_sb->s_blocksize_bits -
					 UNFM_P_SHIFT);
			  }
			  set_le_key_k_offset (version, B_N_PKEY(tb->R[0],0), 
					       le_key_k_offset (version, B_N_PKEY(tb->R[0],0)) + temp_rem);
			  set_le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0]), 
					       le_key_k_offset (version, B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) + temp_rem);
			}
/*		  k_offset (B_N_PKEY(tb->R[0],0)) += n_rem;
		  k_offset (B_N_PDELIM_KEY(tb->CFR[0],tb->rkey[0])) += n_rem;*/
			do_balance_mark_internal_dirty (tb, tb->CFR[0], 0);

			/* Append part of body into R[0] */
			bi.tb = tb;
			bi.bi_bh = tb->R[0];
			bi.bi_parent = tb->FR[0];
			bi.bi_position = get_right_neighbor_position (tb, 0);
			if ( n_rem > zeros_num ) {
			    r_zeros_number = 0;
			    r_body = body + n_rem - zeros_num;
			}
			else {
			    r_body = body;
			    r_zeros_number = zeros_num - n_rem;
			    zeros_num -= r_zeros_number;
			}

			leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0] - n_rem, r_body, r_zeros_number);

			if (is_indirect_le_ih (B_N_PITEM_HEAD(tb->R[0],0))) {
#if 0
			    RFALSE( n_rem,
				    "PAP-12160: paste more than one unformatted node pointer");
#endif
			    set_ih_free_space (B_N_PITEM_HEAD(tb->R[0],0), 0);
			}
			tb->insert_size[0] = n_rem;
			if ( ! n_rem )
			    pos_in_item ++;
		    }
		}
		else /* pasted item in whole falls into R[0] */
		{
		    struct item_head * pasted;

		    ret_val = leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
		    /* append item in R[0] */
		    if ( pos_in_item >= 0 ) {
			bi.tb = tb;
			bi.bi_bh = tb->R[0];
			bi.bi_parent = tb->FR[0];
			bi.bi_position = get_right_neighbor_position (tb, 0);
			leaf_paste_in_buffer(&bi,item_pos - n + tb->rnum[0], pos_in_item,
					     tb->insert_size[0],body, zeros_num);
		    }

		    /* paste new entry, if item is directory item */
		    pasted = B_N_PITEM_HEAD(tb->R[0], item_pos - n + tb->rnum[0]);
		    if (is_direntry_le_ih (pasted) && pos_in_item >= 0 ) {
			leaf_paste_entries (
			    bi.bi_bh, item_pos - n + tb->rnum[0], pos_in_item, 1, 
			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
			    );
			if ( ! pos_in_item ) {

			    RFALSE( item_pos - n + tb->rnum[0],
				    "PAP-12165: directory item must be first item of node when pasting is in 0th position");

			    /* update delimiting keys */
			    replace_key(tb, tb->CFR[0],tb->rkey[0],tb->R[0],0);
			}
		    }

		    if (is_indirect_le_ih (pasted))
			set_ih_free_space (pasted, 0);
		    zeros_num = tb->insert_size[0] = 0;
		}
	    }
	    else /* new item doesn't fall into R[0] */
	    {
		leaf_shift_right(tb,tb->rnum[0],tb->rbytes);
	    }
	    break;
	default:    /* cases d and t */
	    reiserfs_panic (tb->tb_sb, "PAP-12175: balance_leaf: rnum > 0: unexpectable mode: %s(%d)",
			    (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
	}
    
    }	/* tb->rnum[0] > 0 */


    RFALSE( tb->blknum[0] > 3,
	    "PAP-12180: blknum can not be %d. It must be <= 3",  tb->blknum[0]);
    RFALSE( tb->blknum[0] < 0,
	    "PAP-12185: blknum can not be %d. It must be >= 0",  tb->blknum[0]);

    /* if while adding to a node we discover that it is possible to split
       it in two, and merge the left part into the left neighbor and the
       right part into the right neighbor, eliminating the node */
    if ( tb->blknum[0] == 0 ) { /* node S[0] is empty now */

	RFALSE( ! tb->lnum[0] || ! tb->rnum[0],
	        "PAP-12190: lnum and rnum must not be zero");
	/* if insertion was done before 0-th position in R[0], right
	   delimiting key of the tb->L[0]'s and left delimiting key are
	   not set correctly */
	if (tb->CFL[0]) {
	    if (!tb->CFR[0])
		reiserfs_panic (tb->tb_sb, "vs-12195: balance_leaf: CFR not initialized");
	    copy_key (B_N_PDELIM_KEY (tb->CFL[0], tb->lkey[0]), B_N_PDELIM_KEY (tb->CFR[0], tb->rkey[0]));
	    do_balance_mark_internal_dirty (tb, tb->CFL[0], 0);
	}

	reiserfs_invalidate_buffer(tb,tbS0);									
	return 0;
    }


    /* Fill new nodes that appear in place of S[0] */

    /* I am told that this copying is because we need an array to enable
       the looping code. -Hans */
    snum[0] = tb->s1num,
	snum[1] = tb->s2num;
    sbytes[0] = tb->s1bytes;
    sbytes[1] = tb->s2bytes;
    for( i = tb->blknum[0] - 2; i >= 0; i-- ) {

	RFALSE( !snum[i], "PAP-12200: snum[%d] == %d. Must be > 0", i, snum[i]);

	/* here we shift from S to S_new nodes */

	S_new[i] = get_FEB(tb);

	/* initialized block type and tree level */
        set_blkh_level( B_BLK_HEAD(S_new[i]), DISK_LEAF_NODE_LEVEL );


	n = B_NR_ITEMS(tbS0);
	
	switch (flag) {
	case M_INSERT:   /* insert item */

	    if ( n - snum[i] < item_pos )
	    { /* new item or it's part falls to first new node S_new[i]*/
		if ( item_pos == n - snum[i] + 1 && sbytes[i] != -1 )
		{ /* part of new item falls into S_new[i] */
		    int old_key_comp, old_len, r_zeros_number;
		    const char * r_body;
		    int version;

		    /* Move snum[i]-1 items from S[0] to S_new[i] */
		    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, -1, S_new[i]);
		    /* Remember key component and item length */
		    version = ih_version (ih);
                    old_key_comp = le_ih_k_offset( ih );
		    old_len = ih_item_len(ih);

		    /* Calculate key component and item length to insert into S_new[i] */
                    set_le_ih_k_offset( ih,
                                le_ih_k_offset(ih) + ((old_len - sbytes[i] )<<(is_indirect_le_ih(ih)?tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT:0)) );

		    put_ih_item_len( ih, sbytes[i] );

		    /* Insert part of the item into S_new[i] before 0-th item */
		    bi.tb = tb;
		    bi.bi_bh = S_new[i];
		    bi.bi_parent = NULL;
		    bi.bi_position = 0;

		    if ( (old_len - sbytes[i]) > zeros_num ) {
			r_zeros_number = 0;
			r_body = body + (old_len - sbytes[i]) - zeros_num;
		    }
		    else {
			r_body = body;
			r_zeros_number = zeros_num - (old_len - sbytes[i]);
			zeros_num -= r_zeros_number;
		    }

		    leaf_insert_into_buf (&bi, 0, ih, r_body, r_zeros_number);

		    /* Calculate key component and item length to insert into S[i] */
                    set_le_ih_k_offset( ih, old_key_comp );
		    put_ih_item_len( ih, old_len - sbytes[i] );
		    tb->insert_size[0] -= sbytes[i];
		}
		else /* whole new item falls into S_new[i] */
		{
		    /* Shift snum[0] - 1 items to S_new[i] (sbytes[i] of split item) */
		    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i] - 1, sbytes[i], S_new[i]);

		    /* Insert new item into S_new[i] */
		    bi.tb = tb;
		    bi.bi_bh = S_new[i];
		    bi.bi_parent = NULL;
		    bi.bi_position = 0;
		    leaf_insert_into_buf (&bi, item_pos - n + snum[i] - 1, ih, body, zeros_num);

		    zeros_num = tb->insert_size[0] = 0;
		}
	    }

	    else /* new item or it part don't falls into S_new[i] */
	    {
		leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
	    }
	    break;

	case M_PASTE:   /* append item */

	    if ( n - snum[i] <= item_pos )  /* pasted item or part if it falls to S_new[i] */
	    {
		if ( item_pos == n - snum[i] && sbytes[i] != -1 )
		{ /* we must shift part of the appended item */
		    struct item_head * aux_ih;

		    RFALSE( ih, "PAP-12210: ih must be 0");

		    if ( is_direntry_le_ih (aux_ih = B_N_PITEM_HEAD(tbS0,item_pos))) {
			/* we append to directory item */

			int entry_count;
		
			entry_count = ih_entry_count(aux_ih);

			if ( entry_count - sbytes[i] < pos_in_item  && pos_in_item <= entry_count ) {
			    /* new directory entry falls into S_new[i] */
		  
			    RFALSE( ! tb->insert_size[0],
				    "PAP-12215: insert_size is already 0");
			    RFALSE( sbytes[i] - 1 >= entry_count,
				    "PAP-12220: there are no so much entries (%d), only %d",
				    sbytes[i] - 1, entry_count);

			    /* Shift snum[i]-1 items in whole. Shift sbytes[i] directory entries from directory item number snum[i] */
			    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i]-1, S_new[i]);
			    /* Paste given directory entry to directory item */
			    bi.tb = tb;
			    bi.bi_bh = S_new[i];
			    bi.bi_parent = NULL;
			    bi.bi_position = 0;
			    leaf_paste_in_buffer (&bi, 0, pos_in_item - entry_count + sbytes[i] - 1,
						  tb->insert_size[0], body,zeros_num);
			    /* paste new directory entry */
			    leaf_paste_entries (
				bi.bi_bh, 0, pos_in_item - entry_count + sbytes[i] - 1,
				1, (struct reiserfs_de_head *)body, body + DEH_SIZE,
				tb->insert_size[0]
				);
			    tb->insert_size[0] = 0;
			    pos_in_item++;
			} else { /* new directory entry doesn't fall into S_new[i] */
			    leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
			}
		    }
		    else /* regular object */
		    {
			int n_shift, n_rem, r_zeros_number;
			const char * r_body;

			RFALSE( pos_in_item != ih_item_len(B_N_PITEM_HEAD(tbS0,item_pos)) ||
			        tb->insert_size[0] <= 0,
			        "PAP-12225: item too short or insert_size <= 0");

			/* Calculate number of bytes which must be shifted from appended item */
			n_shift = sbytes[i] - tb->insert_size[0];
			if ( n_shift < 0 )
			    n_shift = 0;
			leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], n_shift, S_new[i]);

			/* Calculate number of bytes which must remain in body after append to S_new[i] */
			n_rem = tb->insert_size[0] - sbytes[i];
			if ( n_rem < 0 )
			    n_rem = 0;
			/* Append part of body into S_new[0] */
			bi.tb = tb;
			bi.bi_bh = S_new[i];
			bi.bi_parent = NULL;
			bi.bi_position = 0;

			if ( n_rem > zeros_num ) {
			    r_zeros_number = 0;
			    r_body = body + n_rem - zeros_num;
			}
			else {
			    r_body = body;
			    r_zeros_number = zeros_num - n_rem;
			    zeros_num -= r_zeros_number;
			}

			leaf_paste_in_buffer(&bi, 0, n_shift, tb->insert_size[0]-n_rem, r_body,r_zeros_number);
			{
			    struct item_head * tmp;

			    tmp = B_N_PITEM_HEAD(S_new[i],0);
			    if (is_indirect_le_ih (tmp)) {
				set_ih_free_space (tmp, 0);
				set_le_ih_k_offset( tmp, le_ih_k_offset(tmp) + 
					            (n_rem << (tb->tb_sb->s_blocksize_bits - UNFM_P_SHIFT)));
			    } else {
				set_le_ih_k_offset( tmp, le_ih_k_offset(tmp) + 
				                    n_rem );
			    }
			}

			tb->insert_size[0] = n_rem;
			if ( ! n_rem )
			    pos_in_item++;
		    }
		}
		else
		    /* item falls wholly into S_new[i] */
		{
		    int ret_val;
		    struct item_head * pasted;

#ifdef CONFIG_REISERFS_CHECK
		    struct item_head * ih = B_N_PITEM_HEAD(tbS0,item_pos);

		    if ( ! is_direntry_le_ih(ih) && (pos_in_item != ih_item_len(ih) ||
						     tb->insert_size[0] <= 0) )
			reiserfs_panic (tb->tb_sb, "PAP-12235: balance_leaf: pos_in_item must be equal to ih_item_len");
#endif /* CONFIG_REISERFS_CHECK */

		    ret_val = leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);

		    RFALSE( ret_val,
			    "PAP-12240: unexpected value returned by leaf_move_items (%d)",
			    ret_val);

		    /* paste into item */
		    bi.tb = tb;
		    bi.bi_bh = S_new[i];
		    bi.bi_parent = NULL;
		    bi.bi_position = 0;
		    leaf_paste_in_buffer(&bi, item_pos - n + snum[i], pos_in_item, tb->insert_size[0], body, zeros_num);

		    pasted = B_N_PITEM_HEAD(S_new[i], item_pos - n + snum[i]);
		    if (is_direntry_le_ih (pasted))
		    {
			leaf_paste_entries (
			    bi.bi_bh, item_pos - n + snum[i], pos_in_item, 1, 
			    (struct reiserfs_de_head *)body, body + DEH_SIZE, tb->insert_size[0]
			    );
		    }

		    /* if we paste to indirect item update ih_free_space */
		    if (is_indirect_le_ih (pasted))
			set_ih_free_space (pasted, 0);
		    zeros_num = tb->insert_size[0] = 0;
		}
	    }

	    else /* pasted item doesn't fall into S_new[i] */
	    {
		leaf_move_items (LEAF_FROM_S_TO_SNEW, tb, snum[i], sbytes[i], S_new[i]);
	    }
	    break;
	default:    /* cases d and t */
	    reiserfs_panic (tb->tb_sb, "PAP-12245: balance_leaf: blknum > 2: unexpectable mode: %s(%d)",
			    (flag == M_DELETE) ? "DELETE" : ((flag == M_CUT) ? "CUT" : "UNKNOWN"), flag);
	}

	memcpy (insert_key + i,B_N_PKEY(S_new[i],0),KEY_SIZE);
	insert_ptr[i] = S_new[i];

	RFALSE (!buffer_journaled (S_new [i]) || buffer_journal_dirty (S_new [i]) ||
		buffer_dirty (S_new [i]),
		"PAP-12247: S_new[%d] : (%b)", i, S_new[i]);
    }

    /* if the affected item was not wholly shifted then we perform all necessary operations on that part or whole of the
       affected item which remains in S */
    if ( 0 <= item_pos && item_pos < tb->s0num )
    { /* if we must insert or append into buffer S[0] */

	switch (flag)
	{
	case M_INSERT:   /* insert item into S[0] */
	    bi.tb = tb;
	    bi.bi_bh = tbS0;
	    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
	    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
	    leaf_insert_into_buf (&bi, item_pos, ih, body, zeros_num);

	    /* If we insert the first key change the delimiting key */
	    if( item_pos == 0 ) {
		if (tb->CFL[0]) /* can be 0 in reiserfsck */
		    replace_key(tb, tb->CFL[0], tb->lkey[0],tbS0,0);

	    }
	    break;

	case M_PASTE: {  /* append item in S[0] */
	    struct item_head * pasted;

	    pasted = B_N_PITEM_HEAD (tbS0, item_pos);
	    /* when directory, may be new entry already pasted */
	    if (is_direntry_le_ih (pasted)) {
		if ( pos_in_item >= 0 &&
		    pos_in_item <= ih_entry_count(pasted) ) {

		    RFALSE( ! tb->insert_size[0], 
			    "PAP-12260: insert_size is 0 already");

		    /* prepare space */
		    bi.tb = tb;
		    bi.bi_bh = tbS0;
		    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
		    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
		    leaf_paste_in_buffer(&bi, item_pos, pos_in_item, tb->insert_size[0], body, zeros_num);

		    /* paste entry */
		    leaf_paste_entries (
			bi.bi_bh, item_pos, pos_in_item, 1, (struct reiserfs_de_head *)body,
			body + DEH_SIZE, tb->insert_size[0]
			);
		    if ( ! item_pos && ! pos_in_item ) {
			RFALSE( !tb->CFL[0] || !tb->L[0], 
				"PAP-12270: CFL[0]/L[0] must be specified");
			if (tb->CFL[0]) {
			    replace_key(tb, tb->CFL[0], tb->lkey[0],tbS0,0);

			}
		    }
		    tb->insert_size[0] = 0;
		}
	    } else { /* regular object */
		if ( pos_in_item == ih_item_len(pasted) ) {

		    RFALSE( tb->insert_size[0] <= 0,
			    "PAP-12275: insert size must not be %d",
                            tb->insert_size[0]);
		    bi.tb = tb;
		    bi.bi_bh = tbS0;
		    bi.bi_parent = PATH_H_PPARENT (tb->tb_path, 0);
		    bi.bi_position = PATH_H_POSITION (tb->tb_path, 1);
		    leaf_paste_in_buffer (&bi, item_pos, pos_in_item, tb->insert_size[0], body, zeros_num);

		    if (is_indirect_le_ih (pasted)) {
#if 0
			RFALSE( tb->insert_size[0] != UNFM_P_SIZE,
				"PAP-12280: insert_size for indirect item must be %d, not %d",
				UNFM_P_SIZE, tb->insert_size[0]);
#endif
			set_ih_free_space (pasted, 0);
		    }
		    tb->insert_size[0] = 0;
		}

#ifdef CONFIG_REISERFS_CHECK
		else {
		    if ( tb->insert_size[0] ) {
			print_cur_tb ("12285");
			reiserfs_panic (tb->tb_sb, "PAP-12285: balance_leaf: insert_size must be 0 (%d)", tb->insert_size[0]);
		    }
		}
#endif /* CONFIG_REISERFS_CHECK */
	    
	    }
	} /* case M_PASTE: */
	}
    }

#ifdef CONFIG_REISERFS_CHECK
    if ( flag == M_PASTE && tb->insert_size[0] ) {
	print_cur_tb ("12290");
	reiserfs_panic (tb->tb_sb, "PAP-12290: balance_leaf: insert_size is still not 0 (%d)", tb->insert_size[0]);
    }
#endif /* CONFIG_REISERFS_CHECK */

    return 0;
} /* Leaf level of the tree is balanced (end of balance_leaf) */



/* Make empty node */
void make_empty_node (struct buffer_info * bi)
{
    struct block_head * blkh;

    RFALSE( bi->bi_bh == NULL, "PAP-12295: pointer to the buffer is NULL");

    blkh = B_BLK_HEAD(bi->bi_bh);
    set_blkh_nr_item( blkh, 0 );
    set_blkh_free_space( blkh, MAX_CHILD_SIZE(bi->bi_bh) );

    if (bi->bi_parent)
	B_N_CHILD (bi->bi_parent, bi->bi_position)->dc_size = 0; /* Endian safe if 0 */
}


/* Get first empty buffer */
struct buffer_head * get_FEB (struct tree_balance * tb)
{
    int i;
    struct buffer_head * first_b;
    struct buffer_info bi;

    for (i = 0; i < MAX_FEB_SIZE; i ++)
	if (tb->FEB[i] != 0)
	    break;

    if (i == MAX_FEB_SIZE)
	reiserfs_panic(tb->tb_sb, "vs-12300: get_FEB: FEB list is empty");

    bi.tb = tb;
    bi.bi_bh = first_b = tb->FEB[i];
    bi.bi_parent = NULL;
    bi.bi_position = 0;
    make_empty_node (&bi);
    set_buffer_uptodate(first_b);
    tb->FEB[i] = NULL;
    tb->used[i] = first_b;

    return(first_b);
}


/* This is now used because reiserfs_free_block has to be able to
** schedule.
*/
static void store_thrown (struct tree_balance * tb, struct buffer_head * bh)
{
    int i;

    if (buffer_dirty (bh))
      reiserfs_warning (tb->tb_sb, "store_thrown deals with dirty buffer");
    for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i ++)
	if (!tb->thrown[i]) {
	    tb->thrown[i] = bh;
	    get_bh(bh) ; /* free_thrown puts this */
	    return;
	}
    reiserfs_warning (tb->tb_sb, "store_thrown: too many thrown buffers");
}

static void free_thrown(struct tree_balance *tb) {
    int i ;
    b_blocknr_t blocknr ;
    for (i = 0; i < sizeof (tb->thrown)/sizeof (tb->thrown[0]); i++) {
	if (tb->thrown[i]) {
	    blocknr = tb->thrown[i]->b_blocknr ;
	    if (buffer_dirty (tb->thrown[i]))
	      reiserfs_warning (tb->tb_sb,
				"free_thrown deals with dirty buffer %d",
				blocknr);
	    brelse(tb->thrown[i]) ; /* incremented in store_thrown */
	    reiserfs_free_block (tb->transaction_handle, NULL, blocknr, 0);
	}
    }
}

void reiserfs_invalidate_buffer (struct tree_balance * tb, struct buffer_head * bh)
{
    struct block_head *blkh;
    blkh = B_BLK_HEAD(bh);
    set_blkh_level( blkh, FREE_LEVEL );
    set_blkh_nr_item( blkh, 0 );
    
    clear_buffer_dirty(bh);
    store_thrown (tb, bh);
}

/* Replace n_dest'th key in buffer dest by n_src'th key of buffer src.*/
void replace_key (struct tree_balance * tb, struct buffer_head * dest, int n_dest,
		  struct buffer_head * src, int n_src)
{

    RFALSE( dest == NULL || src == NULL,
	    "vs-12305: source or destination buffer is 0 (src=%p, dest=%p)",
	    src, dest);
    RFALSE( ! B_IS_KEYS_LEVEL (dest),
	    "vs-12310: invalid level (%z) for destination buffer. dest must be leaf",
	    dest);
    RFALSE( n_dest < 0 || n_src < 0,
	    "vs-12315: src(%d) or dest(%d) key number < 0", n_src, n_dest);
    RFALSE( n_dest >= B_NR_ITEMS(dest) || n_src >= B_NR_ITEMS(src),
	    "vs-12320: src(%d(%d)) or dest(%d(%d)) key number is too big",
	    n_src, B_NR_ITEMS(src), n_dest, B_NR_ITEMS(dest));
   
    if (B_IS_ITEMS_LEVEL (src))
	/* source buffer contains leaf node */
	memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PITEM_HEAD(src,n_src), KEY_SIZE);
    else
	memcpy (B_N_PDELIM_KEY(dest,n_dest), B_N_PDELIM_KEY(src,n_src), KEY_SIZE);

    do_balance_mark_internal_dirty (tb, dest, 0);
}


int get_left_neighbor_position (
				struct tree_balance * tb, 
				int h
				)
{
  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);

  RFALSE( PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FL[h] == 0,
	  "vs-12325: FL[%d](%p) or F[%d](%p) does not exist", 
	  h, tb->FL[h], h, PATH_H_PPARENT (tb->tb_path, h));

  if (Sh_position == 0)
    return B_NR_ITEMS (tb->FL[h]);
  else
    return Sh_position - 1;
}


int get_right_neighbor_position (struct tree_balance * tb, int h)
{
  int Sh_position = PATH_H_POSITION (tb->tb_path, h + 1);

  RFALSE( PATH_H_PPARENT (tb->tb_path, h) == 0 || tb->FR[h] == 0,
	  "vs-12330: F[%d](%p) or FR[%d](%p) does not exist", 
	  h, PATH_H_PPARENT (tb->tb_path, h), h, tb->FR[h]);

  if (Sh_position == B_NR_ITEMS (PATH_H_PPARENT (tb->tb_path, h)))
    return 0;
  else
    return Sh_position + 1;
}


#ifdef CONFIG_REISERFS_CHECK

int is_reusable (struct super_block * s, b_blocknr_t block, int bit_value);
static void check_internal_node (struct super_block * s, struct buffer_head * bh, char * mes)
{
  struct disk_child * dc;
  int i;

  RFALSE( !bh, "PAP-12336: bh == 0");

  if (!bh || !B_IS_IN_TREE (bh))
    return;
 
  RFALSE( !buffer_dirty (bh) && 
	  !(buffer_journaled(bh) || buffer_journal_dirty(bh)),
	  "PAP-12337: buffer (%b) must be dirty", bh);
  dc = B_N_CHILD (bh, 0);

  for (i = 0; i <= B_NR_ITEMS (bh); i ++, dc ++) {
    if (!is_reusable (s, dc_block_number(dc), 1) ) {
      print_cur_tb (mes);
      reiserfs_panic (s, "PAP-12338: check_internal_node: invalid child pointer %y in %b", dc, bh);
    }
  }
}


static int locked_or_not_in_tree (struct buffer_head * bh, char * which)
{
  if ( (!buffer_journal_prepared (bh) && buffer_locked (bh)) ||
        !B_IS_IN_TREE (bh) ) {
    reiserfs_warning (NULL, "vs-12339: locked_or_not_in_tree: %s (%b)",
                      which, bh);
    return 1;
  } 
  return 0;
}


static int check_before_balancing (struct tree_balance * tb)
{
  int retval = 0;	

  if ( cur_tb ) {
    reiserfs_panic (tb->tb_sb, "vs-12335: check_before_balancing: "
		    "suspect that schedule occurred based on cur_tb not being null at this point in code. "
		    "do_balance cannot properly handle schedule occurring while it runs.");
  }
  
  /* double check that buffers that we will modify are unlocked. (fix_nodes should already have
     prepped all of these for us). */
  if ( tb->lnum[0] ) {
    retval |= locked_or_not_in_tree (tb->L[0], "L[0]");
    retval |= locked_or_not_in_tree (tb->FL[0], "FL[0]");
    retval |= locked_or_not_in_tree (tb->CFL[0], "CFL[0]");
    check_leaf (tb->L[0]);
  }
  if ( tb->rnum[0] ) {
    retval |= locked_or_not_in_tree (tb->R[0], "R[0]");
    retval |= locked_or_not_in_tree (tb->FR[0], "FR[0]");
    retval |= locked_or_not_in_tree (tb->CFR[0], "CFR[0]");
    check_leaf (tb->R[0]);
  }
  retval |= locked_or_not_in_tree (PATH_PLAST_BUFFER (tb->tb_path), "S[0]");
  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));

  return retval;
}


void check_after_balance_leaf (struct tree_balance * tb)
{
    if (tb->lnum[0]) {
	if (B_FREE_SPACE (tb->L[0]) != 
	    MAX_CHILD_SIZE (tb->L[0]) - dc_size(B_N_CHILD (tb->FL[0], get_left_neighbor_position (tb, 0)))) {
	    print_cur_tb ("12221");
	    reiserfs_panic (tb->tb_sb, "PAP-12355: check_after_balance_leaf: shift to left was incorrect");
	}
    }
    if (tb->rnum[0]) {
	if (B_FREE_SPACE (tb->R[0]) != 
	    MAX_CHILD_SIZE (tb->R[0]) - dc_size(B_N_CHILD (tb->FR[0], get_right_neighbor_position (tb, 0)))) {
	    print_cur_tb ("12222");
	    reiserfs_panic (tb->tb_sb, "PAP-12360: check_after_balance_leaf: shift to right was incorrect");
	}
    }
    if (PATH_H_PBUFFER(tb->tb_path,1) &&
	(B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) != 
		    (MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
		    PATH_H_POSITION (tb->tb_path, 1)))) )) {
	int left = B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0));
	int right = (MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)) -
		    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1),
			PATH_H_POSITION (tb->tb_path, 1))));
	print_cur_tb ("12223");
	reiserfs_warning (tb->tb_sb,
	    "B_FREE_SPACE (PATH_H_PBUFFER(tb->tb_path,0)) = %d; "
    	    "MAX_CHILD_SIZE (%d) - dc_size( %y, %d ) [%d] = %d",
	    left,
	    MAX_CHILD_SIZE (PATH_H_PBUFFER(tb->tb_path,0)),
	    PATH_H_PBUFFER(tb->tb_path,1),
	    PATH_H_POSITION (tb->tb_path, 1),
	    dc_size(B_N_CHILD (PATH_H_PBUFFER(tb->tb_path,1), PATH_H_POSITION (tb->tb_path, 1 )) ),
	    right );
	reiserfs_panic (tb->tb_sb, "PAP-12365: check_after_balance_leaf: S is incorrect");
    }
}


void check_leaf_level (struct tree_balance * tb)
{
  check_leaf (tb->L[0]);
  check_leaf (tb->R[0]);
  check_leaf (PATH_PLAST_BUFFER (tb->tb_path));
}

void check_internal_levels (struct tree_balance * tb)
{
  int h;

  /* check all internal nodes */
  for (h = 1; tb->insert_size[h]; h ++) {
    check_internal_node (tb->tb_sb, PATH_H_PBUFFER (tb->tb_path, h), "BAD BUFFER ON PATH");
    if (tb->lnum[h])
      check_internal_node (tb->tb_sb, tb->L[h], "BAD L");
    if (tb->rnum[h])
      check_internal_node (tb->tb_sb, tb->R[h], "BAD R");
  }

}

#endif






/* Now we have all of the buffers that must be used in balancing of
   the tree.  We rely on the assumption that schedule() will not occur
   while do_balance works. ( Only interrupt handlers are acceptable.)
   We balance the tree according to the analysis made before this,
   using buffers already obtained.  For SMP support it will someday be
   necessary to add ordered locking of tb. */

/* Some interesting rules of balancing:

   we delete a maximum of two nodes per level per balancing: we never
   delete R, when we delete two of three nodes L, S, R then we move
   them into R.

   we only delete L if we are deleting two nodes, if we delete only
   one node we delete S

   if we shift leaves then we shift as much as we can: this is a
   deliberate policy of extremism in node packing which results in
   higher average utilization after repeated random balance operations
   at the cost of more memory copies and more balancing as a result of
   small insertions to full nodes.

   if we shift internal nodes we try to evenly balance the node
   utilization, with consequent less balancing at the cost of lower
   utilization.

   one could argue that the policy for directories in leaves should be
   that of internal nodes, but we will wait until another day to
   evaluate this....  It would be nice to someday measure and prove
   these assumptions as to what is optimal....

*/

static inline void do_balance_starts (struct tree_balance *tb)
{
    /* use print_cur_tb() to see initial state of struct
       tree_balance */

    /* store_print_tb (tb); */

    /* do not delete, just comment it out */
/*    print_tb(flag, PATH_LAST_POSITION(tb->tb_path), tb->tb_path->pos_in_item, tb, 
	     "check");*/
    RFALSE( check_before_balancing (tb), "PAP-12340: locked buffers in TB");
#ifdef CONFIG_REISERFS_CHECK
    cur_tb = tb;
#endif
}


static inline void do_balance_completed (struct tree_balance * tb)
{
    
#ifdef CONFIG_REISERFS_CHECK
    check_leaf_level (tb);
    check_internal_levels (tb);
    cur_tb = NULL;
#endif

    /* reiserfs_free_block is no longer schedule safe.  So, we need to
    ** put the buffers we want freed on the thrown list during do_balance,
    ** and then free them now
    */

    REISERFS_SB(tb->tb_sb)->s_do_balance ++;


    /* release all nodes hold to perform the balancing */
    unfix_nodes(tb);

    free_thrown(tb) ;
}





void do_balance (struct tree_balance * tb, /* tree_balance structure */
		 struct item_head * ih,	   /* item header of inserted item */
		 const char * body,  /* body  of inserted item or bytes to paste */
		 int flag)  /* i - insert, d - delete
			       c - cut, p - paste
						      
			       Cut means delete part of an item
			       (includes removing an entry from a
			       directory).
						      
			       Delete means delete whole item.
						      
			       Insert means add a new item into the
			       tree.
						      						      
			       Paste means to append to the end of an
			       existing file or to insert a directory
			       entry.  */
{
    int child_pos, /* position of a child node in its parent */
	h;	   /* level of the tree being processed */
    struct item_head insert_key[2]; /* in our processing of one level
				       we sometimes determine what
				       must be inserted into the next
				       higher level.  This insertion
				       consists of a key or two keys
				       and their corresponding
				       pointers */
    struct buffer_head *insert_ptr[2]; /* inserted node-ptrs for the next
					  level */

    tb->tb_mode = flag;
    tb->need_balance_dirty = 0;

    if (FILESYSTEM_CHANGED_TB(tb)) {
        reiserfs_panic(tb->tb_sb, "clm-6000: do_balance, fs generation has changed\n") ;
    }
    /* if we have no real work to do  */
    if ( ! tb->insert_size[0] ) {
	reiserfs_warning (tb->tb_sb,
			  "PAP-12350: do_balance: insert_size == 0, mode == %c",
			  flag);
	unfix_nodes(tb);
	return;
    }

    atomic_inc (&(fs_generation (tb->tb_sb)));
    do_balance_starts (tb);
    
	/* balance leaf returns 0 except if combining L R and S into
	   one node.  see balance_internal() for explanation of this
	   line of code.*/
	child_pos = PATH_H_B_ITEM_ORDER (tb->tb_path, 0) +
	  balance_leaf (tb, ih, body, flag, insert_key, insert_ptr);

#ifdef CONFIG_REISERFS_CHECK
    check_after_balance_leaf (tb);
#endif

    /* Balance internal level of the tree. */
    for ( h = 1; h < MAX_HEIGHT && tb->insert_size[h]; h++ )
	child_pos = balance_internal (tb, h, child_pos, insert_key, insert_ptr);


    do_balance_completed (tb);

}

--Boundary_(ID_cSKIFQyFEv2p5FfyYbfnVg)
Content-type: text/plain; charset=us-ascii; name=do_balan.c.after
Content-transfer-encoding: 7BIT
Content-disposition: inline; filename=do_balan.c.after

#include <linux/reiserfs_fs.h>
static int
balance_leaf (struct tree_balance *tb, struct item_head *ih,	/* item header of inserted item (this is on little endian) */
	      int flag,		/* i - insert, d - delete, c - cut, p - paste                                                      (see comment to do_balance) */
	      struct buffer_head **insert_ptr	/* inserted node-ptrs for the next level */
  )
{
  struct buffer_head *tbS0 = PATH_PLAST_BUFFER (tb->tb_path);
  int item_pos = PATH_LAST_POSITION (tb->tb_path);
  int ret_val;
  int pos_in_item;
  int zeros_num;
  if (tb->lnum[0] > 0)
    {
      if (item_pos < tb->lnum[0])
	{
	  switch (flag)
	    {
	      if (item_pos == tb->lnum[0] - 1 && tb->lbytes != -1)
		{
		  if (tb->lbytes > zeros_num)
		    {
		      if (tb->lbytes > pos_in_item)
			{
			  if (ret_val && !item_pos)
			    {
			    }
			}
		      else
			{
			  RFALSE (comp_short_le_keys
				  (B_N_PKEY (tbS0, 0),
				   B_N_PKEY (tb->L[0],
					     B_NR_ITEMS (tb->L[0]) - 1))
				  ||
				  (B_N_PDELIM_KEY (tb->CFL[0], tb->lkey[0]),
				   tbS0->b_size),
				  "PAP-12120: item must be merge-able with left neighboring item");
			}
		    }
		  {
		    int n_shift, n_rem, r_zeros_number;
		    /*              k_offset (B_N_PKEY(tb->R[0],0)) += n_rem;
		     */ if (n_rem > zeros_num)
		      {
		      }
		  }
		  if (pos_in_item >= 0)
		    {
		      if (!pos_in_item)
			{
			}
		    }
		}
	    }
	}
    }
}

--Boundary_(ID_cSKIFQyFEv2p5FfyYbfnVg)--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: rtjohnso () EECS ! Berkeley ! EDU
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 02:16:09 +0000
Message-ID: <1042a14103d70b.103d70b1042a14 () EECS ! Berkeley ! EDU>
--------------------
Daniel S. Wilkerson wrote:
> Linus Torvalds wrote:
> > Sometimes these things are configuration-dependent, so can you 
> send me
> > your reiserfs config? I've tried both on x86 and ppc64 with all the
> > options on..
> 
> Rob?

The config is from "make allmodconfig".  I just checked it with the current BK sparse and and a pristine kernel tree and I still get the crash.

Best,
Rob

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 06:32:00 +0000
Message-ID: <Pine.LNX.4.58.0410292328540.28839 () ppc970 ! osdl ! org>
--------------------


On Fri, 29 Oct 2004 rtjohnso@EECS.Berkeley.EDU wrote:
> 
> The config is from "make allmodconfig".  I just checked it with the
> current BK sparse and and a pristine kernel tree and I still get the
> crash.

Damn. Where did you get your sparse tree from? Is the top-of-tree

	ChangeSet@1.894, 2004-10-29 10:58:42-07:00, torvalds@ppc970.osdl.org
	  Use 'bad_type' instead of NULL when something bad happens
	  in type evaluation.
	...

I just did a "make allmodconfig", and I just get

	..
	  CHECK   fs/reiserfs/do_balan.c
	fs/reiserfs/do_balan.c:463:8: warning: too long token expansion
	  CC [M]  fs/reiserfs/do_balan.o
	..

and no problems. I assume you're x86?

Will look at your test-case tomorrow. It could certainly be some subtle 
stack smash due to overrunning a buffer or something, and then just 
depending on what compiler compiled sparse...

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Andi Kleen <ak () suse ! de>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 07:18:25 +0000
Message-ID: <20041030071825.GB18074 () wotan ! suse ! de>
--------------------
> Will look at your test-case tomorrow. It could certainly be some subtle 
> stack smash due to overrunning a buffer or something, and then just 
> depending on what compiler compiled sparse...

If it's that then running it in valgrind may give clues.


-Andi
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 17:38:33 +0000
Message-ID: <Pine.LNX.4.58.0410301037530.28839 () ppc970 ! osdl ! org>
--------------------


On Sat, 30 Oct 2004, Andi Kleen wrote:
> 
> If it's that then running it in valgrind may give clues.

My main development environment is ppc64, and I _think_ valgrind only 
works on x86, right?

I'll take a look. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 18:05:24 +0000
Message-ID: <Pine.LNX.4.58.0410301104540.28839 () ppc970 ! osdl ! org>
--------------------


On Sat, 30 Oct 2004, Linus Torvalds wrote:
> 
> On Sat, 30 Oct 2004, Andi Kleen wrote:
> > 
> > If it's that then running it in valgrind may give clues.
> 
> My main development environment is ppc64, and I _think_ valgrind only 
> works on x86, right?
> 
> I'll take a look. 

Ran it on x86, not a peep out of valgrind either. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: rtjohnso () EECS ! Berkeley ! EDU
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 18:38:28 +0000
Message-ID: <10464281044a8b.1044a8b1046428 () EECS ! Berkeley ! EDU>
--------------------
I just did a fresh check out of sparse, and the problem disappeared (very odd, since I haven't touched sparse at all).  I'm sorry for the bogus bug report.  I'll figure out what went wrong on my end and make sure it never happens again.

But the main point of our message was to let you guys know about delta, and potentially save you some time in the future minimizing error-inducing source files.  I'm re-running the current sparse over the whole kernel tree, and I'll let you know if I find another good example for you to try out with delta.

Thanks for giving this so much attention.

Best,
Rob


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Daniel S. Wilkerson" <dsw () eecs ! berkeley ! edu>
To: linux-sparse
Subject: Re: automatically minimizing error-inducing input
Date: Sat, 30 Oct 2004 23:56:22 +0000
Message-ID: <41842A26.3828AE1A () cs ! berkeley ! edu>
--------------------
rtjohnso@eecs.berkeley.edu wrote:

> But the main point of our message was to let you guys know about delta, and potentially save you some time in the future minimizing error-inducing source files.

Yes; I find it indispensable.  A factor of 20 reduction that we demonstrated to you is rather small.  I just minimized a 14 thousand line file to two pages yesterday while taking a break, which is completely typical; I hacked a few dependencies out of it and ran it again and it was just a few lines.  The
final file size seems to almost always be half a page to two pages, no matter what the bug is or how big the original file was.  In other words, it works best in situations where it is needed the most.  The best part is you can hang out with your friends while it works.

Daniel


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: bad_expr_type ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: bad_expr_type
Date: Mon, 26 Jul 2004 19:20:38 +0000
Message-ID: <20040726192038.0E0301422D58 () darter ! rentec ! com>
--------------------


I changed bad_expr_type to what's seen below in order to better understand
some error message.  IMHO, some variant of the stuff below should be
committed.

Anyway, the program

    typedef double mydouble;

    static int
    foo (double x, mydouble y)
    {
      return x == y;
    }

...now yields...

> /scratch/welinder/sparse/check ~/foo.c
/home/welinder/foo.c:6:12: warning: incompatible types for operation ==:
/home/welinder/foo.c:6:12:   left side has type double x
/home/welinder/foo.c:6:12:   right side has type double [usertype] y

...which isn't right.

Morten







static struct symbol *bad_expr_type(struct expression *expr)
{
	warn(expr->pos, "incompatible types for operation %s:", show_special (expr->op));
	switch (expr->type) {
	case EXPR_BINOP:
	case EXPR_COMPARE:
		info(expr->pos, "  left side has type %s", show_typename (expr->left->ctype));
		info(expr->pos, "  right side has type %s", show_typename (expr->right->ctype));
		break;
	case EXPR_PREOP:
	case EXPR_POSTOP:
		info(expr->pos, "  argument has type %s", show_typename (expr->unop->ctype));
		break;
	default:
		info(expr->pos, "  better add some stuff here.");
		break;
	}

	return NULL;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: bad_expr_type
Date: Mon, 26 Jul 2004 19:57:32 +0000
Message-ID: <20040726195732.0D04A1422D58 () darter ! rentec ! com>
--------------------



/home/welinder/foo.c:6:12: warning: incompatible types for operation ==:
/home/welinder/foo.c:6:12:   left side has type double x
/home/welinder/foo.c:6:12:   right side has type double [usertype] y

Fixed by this patch.  Looks like simple oversight.

Morten




===== evaluate.c 1.216 vs edited =====
--- 1.216/evaluate.c	2004-07-24 21:45:40 -04:00
+++ edited/evaluate.c	2004-07-26 15:51:59 -04:00
@@ -212,7 +212,22 @@
 
 static struct symbol *bad_expr_type(struct expression *expr)
 {
-	warn(expr->pos, "incompatible types for operation");
+	warn(expr->pos, "incompatible types for operation %s:", show_special (expr->op));
+	switch (expr->type) {
+	case EXPR_BINOP:
+	case EXPR_COMPARE:
+		info(expr->pos, "  left side has type %s", show_typename (expr->left->ctype));
+		info(expr->pos, "  right side has type %s", show_typename (expr->right->ctype));
+		break;
+	case EXPR_PREOP:
+	case EXPR_POSTOP:
+		info(expr->pos, "  argument has type %s", show_typename (expr->unop->ctype));
+		break;
+	default:
+		info(expr->pos, "  better add some stuff here.");
+		break;
+	}
+
 	return NULL;
 }
 
@@ -741,6 +756,10 @@
 		return &bool_ctype;
 	}
 	ctype = compatible_float_binop(&expr->left, &expr->right);
+	if (ctype) {
+		expr->ctype = &bool_ctype;
+		return &bool_ctype;
+	}
 
 	return bad_expr_type(expr);
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: bitwise glitch ===

From: frank zago <fzago () systemfabricworks ! com>
To: linux-sparse
Subject: bitwise glitch
Date: Sat, 30 Oct 2004 22:55:31 +0000
Message-ID: <41841BE3.1030107 () systemfabricworks ! com>
--------------------
The following test case shows 2 problems regarding bitwise. It might be 
related to the use of typedefs. See comments.

Compiles with
  ./cgcc -Wbitwise -Wall  -g  tst.c   -o tst




#ifndef __CHECKER__
#define __bitwise
#else
#define __bitwise __attribute((bitwise))
#endif

typedef enum {
foo1,
foo2
} __bitwise foo_t;

static void func1(foo_t arg)
{
        return;
}

typedef void (*func_t)(foo_t arg);
extern func_t func2;

int main(void)
{
        /* Correct */
        func1(foo1);

        /* Should warn */
        func1(0);

        /* Should not warn */
        func2(foo2);

        return 0;
}


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bitwise glitch
Date: Sat, 30 Oct 2004 23:16:49 +0000
Message-ID: <Pine.LNX.4.58.0410301609470.28839 () ppc970 ! osdl ! org>
--------------------


On Sat, 30 Oct 2004, frank zago wrote:
>
> The following test case shows 2 problems regarding bitwise. It might be 
> related to the use of typedefs. See comments.

That's not how enum typing works. At least not for now.

> typedef enum {
> 	foo1,
> 	foo2
> } __bitwise foo_t;

This declares four different symbols:

 - the unnamed "enum" type itself
 - foo_t, which is a "__bitwise" version of the enum type
 - "foo1" and "foo2", which are integer constants of the "enum" type.

And the _only_ of the symbols that is __bitwise is "foo_t". 


>         /* Correct */
>         func1(foo1);

The reason this doesn't warn is that "foo1" has the value 0, and that's 
special for bitwise types (integer zero has the same bit representation in 
all types).

>         /* Should warn */
>         func1(0);

Same issue here. Zero is special.

>         /* Should not warn */
>         func2(foo2);

This warns, becasue you are passing in an integer enum 1 which is _not_ 
bitwise.

To get what you actually want, you need to do something like

	typedef int __bitwise foo_t;

	typedef enum {
		foo1 = (foo_t __force) 1,
		foo2 = (foo_t __force) 2,
	};

instead.

Pretty? No. Maybe your syntax would be preferable, but it's not how sparse 
works right now at least.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: bogus warning: cannot size expression ===

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 11:32:30 +0000
Message-ID: <20041027113230.GA16826 () iam ! uni-bonn ! de>
--------------------
Sparse newbie found bogus sparse warning, hope it's alright to
report these here without having dived into the source at all:

The following stripped-down code generates a bogus

  foo.c:16:12: warning: cannot size expression

warning, when used with Dave Jones' 2004-10-27 sparse tarball.  It
looks like the problem is non-local, because changing completely
unrelated parts of the source makes the warning disappear.

Hope that helps,
Ralf


struct A;
struct B {
  struct A *pA;
};
struct C;
struct E {
  struct A **pA;
  struct C *pC;
};
void f(struct E *pE, struct B *pB)
{
  pB->pA = pE->pA[0];
}
static const struct { int x; } foo[] = {{ 1 }};
struct C {
  int bar[(sizeof foo/sizeof foo[0])];          /* line 16 */
};
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 14:56:15 +0000
Message-ID: <Pine.LNX.4.58.0410270747160.28839 () ppc970 ! osdl ! org>
--------------------


On Wed, 27 Oct 2004, Ralf Wildenhues wrote:
>
> Sparse newbie found bogus sparse warning, hope it's alright to
> report these here without having dived into the source at all:

Absolutely.

> The following stripped-down code generates a bogus
> 
>   foo.c:16:12: warning: cannot size expression

Thanks. Indeed.

The trouble is (was) that sparse did the "sizeof" type evaluation using
the cheaper "examine_symbol_type()", which only evaluates the type. It
really needs to do a full "evaluate_symbol()", in order to get the
initializer evaluated, though, since the size depends on the initializer.

> warning, when used with Dave Jones' 2004-10-27 sparse tarball.  It
> looks like the problem is non-local, because changing completely
> unrelated parts of the source makes the warning disappear.

Yes, it happens to depend on just which order things get evaluated in, and 
other unrelated expressions may or may not end up evaluating the type of 
that symbol, or just by changing the list of symbols change ordering.

Thanks for finding it.

I haven't checked in the fix yet, because I'm torn between just making 
sizeof() do the full symbol examination, or making "examine_symbol_type()" 
do a better job. The former is simpler and right, but on the other hand, 
there are other users of examine_symbol_type(), and they might validly 
expect to get the _full_ type.

Looking at this a bit more, there is another (performance) bug with symbol
evaluation, namely that we can end up evaluating the same symbol over and
over again, and go through the whole damn initializer too every time.  
There's nothing that does a "we've already evaluated this symbol" check.

Ho humm..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 15:03:46 +0000
Message-ID: <Pine.LNX.4.58.0410270802161.28839 () ppc970 ! osdl ! org>
--------------------


On Wed, 27 Oct 2004, Linus Torvalds wrote:
> 
> Looking at this a bit more, there is another (performance) bug with symbol
> evaluation, namely that we can end up evaluating the same symbol over and
> over again, and go through the whole damn initializer too every time.  
> There's nothing that does a "we've already evaluated this symbol" check.

It's more than a performance bug, I realized. This simple program will 
segfault sparse:

	int a[] = { sizeof(a) };

becasue we evaluate a recursively forever (well, until we run out of 
stackspace).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 15:23:25 +0000
Message-ID: <20041027152325.GA22543 () iam ! uni-bonn ! de>
--------------------
* Linus Torvalds wrote on Wed, Oct 27, 2004 at 05:03:46PM CEST:
> 
> It's more than a performance bug, I realized. This simple program will 
> segfault sparse:
> 
> 	int a[] = { sizeof(a) };
>
> becasue we evaluate a recursively forever (well, until we run out of 
> stackspace).

The program is not valid C.  Cannot reproduce the segfault, however.

While trying out sparse, I found more occasions where it segfaulted,
esp. after many warnings.  If these are deemed worth reporting as
well, I'll do that next time.  From earlier posts on this list it
did not seem like these were worth the effort (reasoning that if
your parse tree is borked anyway, why bother).

Regards,
Ralf
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 15:28:19 +0000
Message-ID: <20041027152819.CE0011422D5E () darter ! rentec ! com>
--------------------

> If these are deemed worth reporting as well, I'll do that next time.

Please do.  While sparse may have gotten thoroughly confused it is
still useful to not have it crash.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 15:57:19 +0000
Message-ID: <20041027155719.GA22846 () iam ! uni-bonn ! de>
--------------------
* Morten Welinder wrote on Wed, Oct 27, 2004 at 05:28:19PM CEST:
> 
> > If these are deemed worth reporting as well, I'll do that next time.
> 
> Please do.  While sparse may have gotten thoroughly confused it is
> still useful to not have it crash.

Here you go.  One occurence I found was an incomplete enum due to
header file not found, which boils down to:

static void foo(enum bar baz);  /* segfaults sparse */

Regards,
Ralf
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Wed, 27 Oct 2004 16:25:25 +0000
Message-ID: <Pine.LNX.4.58.0410270921280.28839 () ppc970 ! osdl ! org>
--------------------


On Wed, 27 Oct 2004, Ralf Wildenhues wrote:
>
> * Linus Torvalds wrote on Wed, Oct 27, 2004 at 05:03:46PM CEST:
> > 
> > It's more than a performance bug, I realized. This simple program will 
> > segfault sparse:
> > 
> > 	int a[] = { sizeof(a) };
> >
> > becasue we evaluate a recursively forever (well, until we run out of 
> > stackspace).
> 
> The program is not valid C.  Cannot reproduce the segfault, however.

The segfault happens with the trivial fix for your original problem, ie 
using "evaluate_symbol()" instead of "examine_symbol_type()" to get 
sizeof() to work correctly.

However, I just checked in the _proper_ fix, which is to evaluate the 
array size at "examint_symbol_type()" time. Cleaned things up a lot,
actually (still more to do: now we can remove the code that counts
sizes at "evaluate_initializer()" time, since it's not useful any more).

> While trying out sparse, I found more occasions where it segfaulted,
> esp. after many warnings.  If these are deemed worth reporting as
> well, I'll do that next time.

Yes, especially if you can boil it down to simple test-cases.

Usually it's just sparse getting confused, often because of buggy programs 
(or because sparse couldn't find a header file or didn't have the right 
#defines). Having NULL types etc sometimes gets through, and I'd like to 
find them and fix them,

>			  From earlier posts on this list it
> did not seem like these were worth the effort (reasoning that if
> your parse tree is borked anyway, why bother).

Quite often the real fix would be to make major errors just stop the 
parse, yes. On the other hand, if there's a nice test-case, we can just 
fix it and continue.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Thu, 28 Oct 2004 11:58:35 +0000
Message-ID: <20041028115835.GA9805 () iam ! uni-bonn ! de>
--------------------
> * Morten Welinder wrote on Wed, Oct 27, 2004 at 05:28:19PM CEST:
> > 
> > > If these are deemed worth reporting as well, I'll do that next time.
> > 
> > Please do.  While sparse may have gotten thoroughly confused it is
> > still useful to not have it crash.

More tests, put in a patch together with the ones I already sent:

badtype2 segfaults on buggy code (similar to last one, now badtype1),
badtype3 similarly,

builtin_safe1 uses __builtin_safe_p.  sparse does not consider pure and
const attributes here yet (which might be considered worthwhile),

varargs1 gives a bogus warning on valid code.

Generally, it's a good idea to just throw a bunch of C files at sparse
to find more problems like this.  The gcc testsuite is a good example
(where typical problem cases are small already), and, in fact, produces
twenty-some core files.

Regards,
Ralf


diff -Nur old/validation/badtype1.c sparse-bk/validation/badtype1.c
--- old/validation/badtype1.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/badtype1.c	2004-10-27 17:52:19.000000000 +0200
@@ -0,0 +1 @@
+static void foo(enum bar baz);
diff -Nur old/validation/badtype2.c sparse-bk/validation/badtype2.c
--- old/validation/badtype2.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/badtype2.c	2004-10-27 18:39:51.000000000 +0200
@@ -0,0 +1,10 @@
+//typedef int undef;
+extern undef bar(void);
+static undef foo(char *c)
+{
+  char p = *c;
+  switch (p) {
+  default:
+    return bar();
+  }
+}
diff -Nur old/validation/badtype3.c sparse-bk/validation/badtype3.c
--- old/validation/badtype3.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/badtype3.c	2004-10-28 13:39:02.000000000 +0200
@@ -0,0 +1,10 @@
+int
+foo (int (*func) (undef, void*), void* data)
+{
+  int err = 0;
+  while (cur) {
+    if ((*func) (cur, data))
+      break;
+  }
+  return err;
+}
diff -Nur old/validation/builtin_safe1.c sparse-bk/validation/builtin_safe1.c
--- old/validation/builtin_safe1.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/builtin_safe1.c	2004-10-28 10:23:01.000000000 +0200
@@ -0,0 +1,26 @@
+#define MY_MACRO(a) do { \
+  __builtin_warning(!__builtin_safe_p(a), "Macro argument with side effects"); \
+    a;	\
+  } while (0)
+
+int g(int);
+int h(int) __attribute__((pure));
+int i(int) __attribute__((const));
+
+int foo(int x, int y)
+{
+  /* unsafe: */
+  MY_MACRO(x++);
+  MY_MACRO(x+=1);
+  MY_MACRO(x=x+1);
+  MY_MACRO(x%=y);
+  MY_MACRO(x=y);
+  MY_MACRO(g(x));
+  MY_MACRO((y,g(x)));
+  /* safe: */
+  MY_MACRO(x+1);
+  MY_MACRO(h(x));
+  MY_MACRO(i(x));
+  return x;
+}
+
diff -Nur old/validation/struct-size1.c sparse-bk/validation/struct-size1.c
--- old/validation/struct-size1.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/struct-size1.c	2004-10-27 12:58:34.000000000 +0200
@@ -0,0 +1,17 @@
+struct A;
+struct B {
+  struct A *pA;
+};
+struct C;
+struct E {
+  struct A **pA;
+  struct C *pC;
+};
+void f(struct E *pE, struct B *pB)
+{
+  pB->pA = pE->pA[0];
+}
+static const struct { int x; } foo[] = {{ 1 }};
+struct C {
+  int bar[(sizeof foo/sizeof foo[0])];
+};
diff -Nur old/validation/varargs1.c sparse-bk/validation/varargs1.c
--- old/validation/varargs1.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/varargs1.c	2004-10-28 10:15:29.000000000 +0200
@@ -0,0 +1,5 @@
+extern int foo (const char *, ...);
+void error(const char err[])
+{
+  foo("%s\n",err);
+}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Thu, 28 Oct 2004 14:46:30 +0000
Message-ID: <Pine.LNX.4.58.0410280737380.28839 () ppc970 ! osdl ! org>
--------------------


On Thu, 28 Oct 2004, Ralf Wildenhues wrote:
> 
> builtin_safe1 uses __builtin_safe_p.  sparse does not consider pure and
> const attributes here yet (which might be considered worthwhile),

I agree, I was going to do it, but when I parse attributes, I don't
actually save them away yet. I'll encode them as a list of "identifier +
expression" thing, I guess - although I worry about some attributes that I 
might want to test for types often (performance issues). The modifier bits 
are all gone, so the other alternative is to split that up into two words, 
and continue to use the bitmap.

> varargs1 gives a bogus warning on valid code.

Now this one is _strange_. For some reason it thinks "err" has a type
smaller than "int", and has decided to do the varargs implied integer
conversion, and then later on it figures out it's a pointer, and warns
about it ;)

I suspect my "arrays implicitly convert to pointers in function arguments"  
code is broken (it's yet another silly C special case), but I'm just
surprised.

> Generally, it's a good idea to just throw a bunch of C files at sparse
> to find more problems like this.  The gcc testsuite is a good example
> (where typical problem cases are small already), and, in fact, produces
> twenty-some core files.

I have to admit that my testing has mainly been the kernel - I do a 
checking make on the kernel to see that I didn't screw up somewhere. So 
it's mainly valid code.

It would probably be good to have a "make test" thing that would be easy 
to run adn add tests to - right now I never use the validation files, 
because they all have to be run and interpreted by hand..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Thu, 28 Oct 2004 15:01:40 +0000
Message-ID: <Pine.LNX.4.58.0410280751190.28839 () ppc970 ! osdl ! org>
--------------------


On Thu, 28 Oct 2004, Linus Torvalds wrote:
> 
> I suspect my "arrays implicitly convert to pointers in function arguments"  
> code is broken (it's yet another silly C special case), but I'm just
> surprised.

Heh. Yes. I didn't fix up the type evaluation (and the size in particular)  
of the node when I convert it from an unsized array (size=-1) to a pointer
(size=bits_in_pointer).

Fixed and checked in.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Fri, 29 Oct 2004 12:01:32 +0000
Message-ID: <20041029120132.GA23925 () iam ! uni-bonn ! de>
--------------------
* Linus Torvalds wrote on Thu, Oct 28, 2004 at 04:46:30PM CEST:
> On Thu, 28 Oct 2004, Ralf Wildenhues wrote:
> > 
> > Generally, it's a good idea to just throw a bunch of C files at sparse
> > to find more problems like this.  The gcc testsuite is a good example
> > (where typical problem cases are small already), and, in fact, produces
> > twenty-some core files.
> 
> I have to admit that my testing has mainly been the kernel - I do a 
> checking make on the kernel to see that I didn't screw up somewhere. So 
> it's mainly valid code.

Most of the gcc testsuite is valid code as well, just ugly corner cases.

> It would probably be good to have a "make test" thing that would be easy 
> to run adn add tests to - right now I never use the validation files, 
> because they all have to be run and interpreted by hand..

As sparse warning messages stabilize, one could just add expected output
files and wrap a testsuite around it.

Another nice case with two failures: Doesn't recognize the valid C99
boolean type, plus segfaults (without #define'ing bar it also faults).


diff -Nur old/validation/bool1.c sparse-bk/validation/bool1.c
--- old/validation/bool1.c	1970-01-01 01:00:00.000000000 +0100
+++ sparse-bk/validation/bool1.c	2004-10-29 11:52:11.000000000 +0200
@@ -0,0 +1,10 @@
+#include <stdbool.h>
+#define bar _Bool
+typedef bar (*fn) (void);
+struct A { };
+int foo (bar, struct A *);
+bar is_bar (void);
+void baz (void)
+{
+	foo (is_bar (), ((struct A *) (~0)));
+}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: bogus warning: cannot size expression
Date: Fri, 29 Oct 2004 18:02:27 +0000
Message-ID: <Pine.LNX.4.58.0410291059310.28839 () ppc970 ! osdl ! org>
--------------------


On Fri, 29 Oct 2004, Ralf Wildenhues wrote:
> 
> As sparse warning messages stabilize, one could just add expected output
> files and wrap a testsuite around it.

Yup.

> Another nice case with two failures: Doesn't recognize the valid C99
> boolean type, plus segfaults (without #define'ing bar it also faults).

Ok, sparse internally already actually _had_ a boolean type, I just didn't 
even realize that C99 exposed something like that. I added it, although 
right now it's a pretty strange type (it literally has a size of one bit, 
which means that "sizeof(_Bool)" will complain about not being able to 
size it). Whether that is correct or not, I don't know, but it sure is 
sensible.

I also fixed this test-case regardless, by adding a "bad_ctype" to go with 
the notion of "incomplete_ctype" - make type errors still return a "valid" 
type, except it's one that can't be used for anything. 

There are likely tons of places left that return NULL, but now it should 
be easy to make those just return &bad_ctype instead, and not need those 
silly NULL tests. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: branch following. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: branch following.
Date: Wed, 01 Dec 2004 07:31:26 +0000
Message-ID: <Pine.LNX.4.58.0411302318320.22796 () ppc970 ! osdl ! org>
--------------------

Lookie here (pretty silly example, but it's actually boiled down from a 
real-life example in the kernel that actually did something similar):

	int test(int *ptr)
	{
		int retval = 1;

		if (ptr && *ptr) 
			retval = 2;
		if (!ptr || *ptr == 1) {
			retval = 10;
			if (!ptr)
				retval = 20;
		}
		return retval;
	}

and look what it linearizes to:

	test:
	ENTRY:
	.L0xf7f9e00c:
		phisrc.32  %phi2(retval) <- $1
		br         %arg1, .L0xf7f9e084, .L0xf7f9e124

	.L0xf7f9e084:
		load.32    %r3 <- 0[%arg1]
		br         %r3, .L0xf7f9e034, .L0xf7f9e05c

	.L0xf7f9e034:
		phisrc.32  %phi4(retval) <- $2
		br         .L0xf7f9e05c

	.L0xf7f9e05c:
		br         %arg1, .L0xf7f9e0fc, .L0xf7f9e124

	.L0xf7f9e0fc:
		load.32    %r6 <- 0[%arg1]
		seteq.1    %r7 <- %r6, $1
		br         %r7, .L0xf7f9e0ac, .L0xf7f9e0d4

	.L0xf7f9e0ac:
		phisrc.32  %phi5(retval) <- $10
		br         %arg1, .L0xf7f9e0d4, .L0xf7f9e124

	.L0xf7f9e124:
		phisrc.32  %phi6(retval) <- $20
		br         .L0xf7f9e0d4

	.L0xf7f9e0d4:
		phi.32     %r9 <- %phi2(retval), %phi2(retval), %phi4(retval), %phi5(retval), %phi6(retval)
		ret.32     %r9


Note how the initial "ptr" test jumps directly to the "retval = 20" case
if ptr is NULL on entry. It doesn't remove the other tests yet (that takes
some more work) but at least it's noticed early that it can just follow
the original conditional branch all the way down to its logical
conclusion.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: cgcc -- run checker, then compiler ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: cgcc -- run checker, then compiler
Date: Thu, 29 Jul 2004 15:56:02 +0000
Message-ID: <20040729155602.7A3C71422D53 () darter ! rentec ! com>
--------------------

FYI,

this little script which I call cgcc is useful for checking projects that
does seem compile right when $CC fails to create .o files.  It runs first
the checker and then the compiler.  It's in perl for no particular good
reason.

You could even run in this mode normally if you don't mind that your
compiles take extra time.  Just do

    make CC=/scratch/welinder/sparse/cgcc

or something like that.

Morten



#!/usr/bin/perl -w
# -----------------------------------------------------------------------------

my $cc = $ENV{'REAL_CC'} || 'cc';
my $check = $ENV{'CHECK'} || 'check';

# Look for a .c file.  We don't want to the checker on .o or .so files
# in the link run.  (This simplistic check knows nothing about options
# with arguments, but it seems to do the job.)
my $seen_a_c_file = 0;
foreach (@ARGV) {
    if (/^[^-].*\.c/) {
	$seen_a_c_file = 1;
	last;
    }
}

if ($seen_a_c_file) {
    system ($check, @ARGV);
}

exec ($cc, @ARGV);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: check for attempts to OR with zero. ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: check for attempts to OR with zero.
Date: Mon, 25 Oct 2004 05:03:50 +0000
Message-ID: <20041025050350.GB10541 () redhat ! com>
--------------------
This diff attempts to catch code that does things like..

	foo |= 0;

It also manages to trap cases where we do things like
	foo |= (1<<0)
which I've seen in a few vendor drivers.

but does the right thing if we have any non-zero bits
in the RHS of the expression.

		Dave

diff -urpN --exclude-from=/home/davej/.exclude sparse-linus/expression.c sparse-dj/expression.c
--- sparse-linus/expression.c	2004-10-25 00:26:49.684873664 -0400
+++ sparse-dj/expression.c	2004-10-25 00:40:06.260775720 -0400
@@ -603,6 +604,8 @@ static struct token *cast_expression(str
 			top->left = left;				\
 			top->right = right;				\
 			left = top;					\
+			if (right->value == 0)				\
+				warning(next->pos, "Right hand side of boolean expression is zero.");	\
 		}							\
 	}								\
 out:									\



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: check for attempts to OR with zero.
Date: Mon, 25 Oct 2004 14:49:33 +0000
Message-ID: <Pine.LNX.4.58.0410250746210.3016 () ppc970 ! osdl ! org>
--------------------


On Mon, 25 Oct 2004, Dave Jones wrote:
>
> This diff attempts to catch code that does things like..
> 
> 	foo |= 0;

Same problem as with the previous patch. You really need to check for 
EXPR_VALUE _and_ you can't do it at parse time anyway, because it's so 
early here that the expression hasn't been simplified at all, so your code 
would not even find things like

	foo |= (0);

> It also manages to trap cases where we do things like
> 	foo |= (1<<0)
> which I've seen in a few vendor drivers.

What's wrong with that? Maybe the fact that you don't check for EXPR_VALUE 
means that it catches wrong things.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: check for attempts to shift zero. ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: check for attempts to shift zero.
Date: Mon, 25 Oct 2004 05:01:32 +0000
Message-ID: <20041025050132.GA10541 () redhat ! com>
--------------------
This trivial patch adds a warning for code that tries to do..

	(0>>n)

or
	(0<<n)

which seems like a silly thing to do.
I was tempted to also add checks for things like (1<<0),
but that seems to be used in quite a lot of code, and
adds to readability somewhat.

		Dave


diff -urpN --exclude-from=/home/davej/.exclude sparse-linus/evaluate.c sparse-dj/evaluate.c
--- sparse-linus/evaluate.c	2004-10-25 00:26:49.600886432 -0400
+++ sparse-dj/evaluate.c	2004-10-25 00:55:55.128525896 -0400
@@ -777,6 +777,8 @@ static struct symbol *evaluate_shift(str
 		ctype = integer_promotion(rtype);
 		if (rtype->bit_size != ctype->bit_size)
 			expr->right = cast_to(expr->right, ctype);
+		if (left->value == 0)
+			warning(expr->pos, "Trying to shift zero.");
 		return expr->ctype;
 	}
 	return bad_expr_type(expr);

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: check for attempts to shift zero.
Date: Mon, 25 Oct 2004 14:45:45 +0000
Message-ID: <Pine.LNX.4.58.0410250737080.3016 () ppc970 ! osdl ! org>
--------------------


On Mon, 25 Oct 2004, Dave Jones wrote:
>
> This trivial patch adds a warning for code that tries to do..
> 
> 	(0>>n)
> 
> or
> 	(0<<n)
> 
> which seems like a silly thing to do.

I actually believe that the above happens quite naturally. At least for 
constant values of "n", where you often have

	#define XXXX 0
	#define YYYY 1
	#define ZZZZ 2
	..

	/* Values are bits 12-16 */
	#define VAL_MASK 12

	#define FULL_VALUE(x,y) (((x) << VAL_MASK) | (y))

	...
	a = FULL_VALUE(XXXX);

ie you have a setup where you have values encoded in the bits of a bigger 
constant value. Things like the ioctl.h _IOC macros come to mind.

> I was tempted to also add checks for things like (1<<0),
> but that seems to be used in quite a lot of code, and
> adds to readability somewhat.

Indeed. Same reason. There are also often values that are 
implementation-dependent, or where you want to use a symbolic shift for 
other reasons, and the symbol might just be a hardcoded zero.

That said, you're doing this at the wrong point, and in the wrong way:

> diff -urpN --exclude-from=/home/davej/.exclude sparse-linus/evaluate.c sparse-dj/evaluate.c
> --- sparse-linus/evaluate.c	2004-10-25 00:26:49.600886432 -0400
> +++ sparse-dj/evaluate.c	2004-10-25 00:55:55.128525896 -0400
> @@ -777,6 +777,8 @@ static struct symbol *evaluate_shift(str
>  		ctype = integer_promotion(rtype);
>  		if (rtype->bit_size != ctype->bit_size)
>  			expr->right = cast_to(expr->right, ctype);
> +		if (left->value == 0)
> +			warning(expr->pos, "Trying to shift zero.");
>  		return expr->ctype;

First off, you should check that the left type is a EXPR_VALUE before you 
check "left->value". Otherwise, "left->value" might just be 0 even though 
it's something completely different (now, admittedly, this is very 
unlikely, since almost all expression types have something in those 8 
bytes, but still).

Secondly, you shouldn't check for a constant value at type evaluation 
time. At that point we haven't yet simplified the tree even trivially, so 
an expression like (4-4) will still be an expression, and inline 
functions will not have been handled. 

So you should check for constant values only at the "expand" phase.

The only exception to that is the NULL pointer thing, which literally is
the constant 0, not the _expression_ with the value 0.  So that one can be
done before any folding.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: const char *foo = { "bar" }; ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: const char *foo = { "bar" };
Date: Wed, 28 Jul 2004 19:14:35 +0000
Message-ID: <20040728191435.B0DE11422D58 () darter ! rentec ! com>
--------------------

The line

  const char *foo = { "bar" };

yields a check warning.  Gcc and sun CC are silent.

Morten



> ./check ~/foo.c
/home/welinder/foo.c:1:21: warning: incorrect type in initializer (different base types)
/home/welinder/foo.c:1:21:    expected char 
/home/welinder/foo.c:1:21:    got char static [addressable] *<noident>
You have mail in /var/mail//welinder
> gcc-3.4 -Wall -c ~/foo.c
> /opt/SUNWspro/bin/cc -V -c  ~/foo.c
cc: Sun WorkShop 6 update 2 C 5.3 Patch 111679-08 2002/05/09
acomp: Sun WorkShop 6 update 2 C 5.3 Patch 111679-08 2002/05/09
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: const char *foo = { "bar" };
Date: Thu, 29 Jul 2004 06:00:12 +0000
Message-ID: <Pine.LNX.4.58.0407282257390.2522 () ppc970 ! osdl ! org>
--------------------


On Wed, 28 Jul 2004, Morten Welinder wrote:
> 
> The line
> 
>   const char *foo = { "bar" };
> 
> yields a check warning.  Gcc and sun CC are silent.

Hmm.. Damn, that's one ugly initializer. What kind of twisted code are you 
testing that shows all these bad things people are doing? 

It would actually trigger the "allow a scalar initializer inside 
brackets", but the thing is, we don't think we're assigning a scalar at 
all, we're initializing an array.

Oh, well. I'll try to make the parser handle that sanely, but it will 
probably be a day or two, so if somebody else beats me to it..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: crazy kernel programmer(s) ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: crazy kernel programmer(s)
Date: Sat, 04 Dec 2004 06:14:10 +0000
Message-ID: <41B155B2.1040507 () osdl ! org>
--------------------

from Linux 2.6.10-rc3 and current sparse:

fs/ext3/namei.c:497:21: warning: crazy programmer

init/initramfs.c:222:14: warning: crazy programmer


so is simplify_one_memop() correct or crazy?

-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: crazy kernel programmer(s)
Date: Sat, 04 Dec 2004 17:51:59 +0000
Message-ID: <Pine.LNX.4.58.0412040950070.22796 () ppc970 ! osdl ! org>
--------------------


On Fri, 3 Dec 2004, Randy.Dunlap wrote:
> 
> from Linux 2.6.10-rc3 and current sparse:
> 
> fs/ext3/namei.c:497:21: warning: crazy programmer
> 
> init/initramfs.c:222:14: warning: crazy programmer
> 
> so is simplify_one_memop() correct or crazy?

I think simplify_one_memop() is right, but I think it's right only because 
some earlier phase was wrong. The message _should_ happen only if a 
uninitialized variable is used to initialize itself, but it's more likely 
that sparse just messed up the flow somehow and just _thinks_ it is 
uninitialized.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: deathnote ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: deathnote
Date: Mon, 08 Nov 2004 18:15:12 +0000
Message-ID: <20041108181512.GC3990 () 64m ! dyndns ! org>
--------------------
Hi Linus,

What is the plan to use the deathnote instruction?
I guess as some kind of hint to release the register
for allocation?

I am try to add the list of instructions which use a
pseudo, not sure it can replace the deathnote or not.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Mon, 08 Nov 2004 19:44:41 +0000
Message-ID: <20041108194441.GA4766 () 64m ! dyndns ! org>
--------------------
On Mon, Nov 08, 2004 at 02:02:25PM -0800, Linus Torvalds wrote:
> 
> 
> On Mon, 8 Nov 2004, Christopher Li wrote:
> 
> Check the current BK tree, I _just_ committed that exact thing. Every 
> pseudo has a list of instructions that use it.
>

Ha. I have the patch for that also. You beats me again :-)

> 
> I'm not sure what I want to do about the death/use information. Deathnotes
> are still much simpler to just have explicit, rather than having to figure
> out liveness. On the other hand, with usage pointers, it may get
> sufficiently easy to determine liveness that the deathnotes aren't worth
> it any more.
> 
> And while deathnotes are easy to generate, they are also easy to get 
> wrong, ie any basic block movement (or unreachable bb's) just make them 
> useless, so I've been considering removing them. 
> 

Me too. That is why I try to find out how you are going to use it.


> Also, it turns out that usage notes are pretty nasty too. There can
> obvously be many users, but the _common_ case by far (at least before any
> CSE) is a single user for a single pseudo. Which is the absolute worst
> case for the list_ptr implementation I did. So if you have a better notion
> of usage (linked list embedded _inside_ the "struct instruction" and the
> "phi nodes" themselves), I'm certainly not married to my current (very
> simple) usage list.

Yes, I think realize that also. I did the very simple pointer list right now. 
But it is kind of painful once you start to manipulate the item in the list.
Maybe some thing like the Linux double link list.

> 
> What do you want to do, btw? CSE? Or do you want to try to convert local
> symbols into pseudos?

Yes, convert local to pseudos. That is a well defined goal and should
be useful. 

I am also toying the idea of having the LIR for x86 and maybe generate very
silly assembler output from the linearizer since the linearizer gets fairly
complete now.  It needs some register allocation, maybe start from the very
simple one first.

In long term I want to take a closer look at Tommy's graph base stuff see
if we can resurrect it. But that is still up in the air.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Mon, 08 Nov 2004 22:02:25 +0000
Message-ID: <Pine.LNX.4.58.0411081354450.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Christopher Li wrote:
> 
> What is the plan to use the deathnote instruction?
> I guess as some kind of hint to release the register
> for allocation?

Yes.  We can obviously generate liveness information later, but it tends 
to be expensive. It's fairly cheap to generate as we go along linearizing, 
so I did that instead.

> I am try to add the list of instructions which use a
> pseudo, not sure it can replace the deathnote or not.

Check the current BK tree, I _just_ committed that exact thing. Every 
pseudo has a list of instructions that use it.

I'm not sure what I want to do about the death/use information. Deathnotes
are still much simpler to just have explicit, rather than having to figure
out liveness. On the other hand, with usage pointers, it may get
sufficiently easy to determine liveness that the deathnotes aren't worth
it any more.

And while deathnotes are easy to generate, they are also easy to get 
wrong, ie any basic block movement (or unreachable bb's) just make them 
useless, so I've been considering removing them. 

Also, it turns out that usage notes are pretty nasty too. There can
obvously be many users, but the _common_ case by far (at least before any
CSE) is a single user for a single pseudo. Which is the absolute worst
case for the list_ptr implementation I did. So if you have a better notion
of usage (linked list embedded _inside_ the "struct instruction" and the
"phi nodes" themselves), I'm certainly not married to my current (very
simple) usage list.

What do you want to do, btw? CSE? Or do you want to try to convert local
symbols into pseudos?

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Mon, 08 Nov 2004 23:51:38 +0000
Message-ID: <Pine.LNX.4.58.0411081519120.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Christopher Li wrote:
> 
> Yes, convert local to pseudos. That is a well defined goal and should
> be useful. 

Ok. I've committed my pretty simplistic first steps, and in particular 
I've attached a "virtual pseudo" to the symbols used, and get usage notes 
through that. The "test-linearize" thing will show them, and running 
linearization on sparse seems to imply it is sane. I had to fix up some 
silly cases to make it sensible: we didn't have any way to show that some 
symbol gets initialized with an argument, for example.

So for example, parse.c (alloc_statement) gives this:

ep 0xf7fe2020: alloc_statement
   sym: 0xf7dda048 pos
        store %arg1 -> 0[pos]
        load %r22 <- 0[pos]
   sym: 0xf7dda138 type
        store %arg2 -> 0[type]
        load %r20 <- 0[type]
   sym: 0xf7dda228 stmt
        store %r19 -> 0[stmt]
        load %r21 <- 0[stmt]
        load %r23 <- 0[stmt]
        load %r24 <- 0[stmt]
	...

which is nice an all, and it shows that all of the symbols can be
_trivially_ changed to a pseudo, since they all have just a single store
to them, and thus all the load instructions can be just replaced with the
original value. _trivial_. We don't even need to do any reachability
analysis, since it doesn't matter (if the store wasn't before the load,
it's all undefined anyway, and we might as well use a random value, and
select the initial value to be that "random" one).

But I haven't looked at any of the nontrivial cases, and still haven't 
decided exactly how to generate the phi-nodes for that usage.

But I think the infrastructure is right.

Oh, btw - this all _does_ work right for structures and unions too, but
you really have to check the offset and the type of the loads/stores too, 
so it's a bit more complex. For example:

	struct hello {
		int a;
		int b;
	};

	union hmm {
		int a;
		int b;
	};

	int fn1(void)
	{
		struct hello a;
		union hmm b;

		a.a = 1;
		a.b = 2;
		b.a = 3;
		return a.a + a.b + b.b;
	}

generates (the load/store things at the "sym:" listings are just the 
_usage_ printouts, they are not the actual code - my test-linearizer just 
prints out the usage instructions for debugging):

	ep 0xf7fe200c: fn1
	   sym: 0xf7fd1c10 a
	        store $1 -> 0[a]
	        store $2 -> 4[a]
	        load %r1 <- 0[a]
	        load %r2 <- 4[a]
	   sym: 0xf7fd1c88 b
	        store $3 -> 0[b]
	        load %r4 <- 0[b]

	ENTRY:
	bb: 0xf7fa6024
	   test.c:11:5
	        store $1 -> 0[a]
	        store $2 -> 4[a]
	        store $3 -> 0[b]
	        load %r1 <- 0[a]
	        load %r2 <- 4[a]
	        %r3 <- add  %r1, %r2
	        deathnote %r1
	        deathnote %r2
	        load %r4 <- 0[b]
	        %r5 <- add  %r3, %r4
	        deathnote %r3
	        deathnote %r4
	        ret %r5

and it's entirely possible (and should even be easy) to disambiguate all
the structure members. Similarly, it's entirely possible to see the
_overlapping_ union members, but that just needs a _lot_ of care. They
happen to be identical in my example (ie the easy case, with 100%
overlap), but more complex cases of partial overlap really are a _lot_
more complex.

What I'm trying to say is that I think the infrastructure is there to
actually turn each of the union/member _partial_ accesses into individual
pseudos, and we should be able to generate 100% code from the above. But
it will require some careful checking ;)

Finally: note the "external visibility" marker that we get if somebody
ever takes an address of a symbol. At that point you can obviously no
longer use trivial symbol usage overlappingness to generate pseudos. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Tue, 09 Nov 2004 00:45:02 +0000
Message-ID: <Pine.LNX.4.58.0411081640100.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Linus Torvalds wrote:
> 
> Oh, btw - this all _does_ work right for structures and unions too, but
> you really have to check the offset and the type of the loads/stores too, 
> so it's a bit more complex.

I phrased that badly. Structures aren't any more complex than any other
case, it's just that non-structures will work "by accident" even if you
don't track the offsets and types of the load/store instructions.

So all cases are really the same, it's just that the simple scalar 
variable case is a degenerate case of the general issue, and it's easy to 
write buggy code that gets the (common) scalar case right without really 
being correct.

And unions obviously have the issue of possibly getting fractional type 
conversions etc - the info is all there, but the general case is just much 
more complicated than the trivial case that at some point it might be 
easiest to just decide that unions are always addressable, especially if 
they have FP values in them.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Tue, 09 Nov 2004 03:50:10 +0000
Message-ID: <Pine.LNX.4.58.0411081940460.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Christopher Li wrote:
> 
> Ha. I have the patch for that also. You beats me again :-)

I've improved my pseudo usage tracking.

It now just literally tracks the _pointer_ to the pseudo. You can't really 
tell what instruction it is (the pseudo might be in the "src" field or the 
"target" field or in a totally separate phi-node etc), but on the other 
hand it is now _very_ easy to replace all uses of one pseudo with another. 
Just walk the list of pointers, and fill in the new pseudo. 

The reason I wanted to have an instruction pointer was because that was
very useful to determine how a symbol-pseudo was used: was the instruction 
that used it an OP_LOAD or an OP_STORE. However, since a symbol pseudo can 
only ever be used in the _address_ of a memory op, it's easy to get to the 
"struct isntruction", when we know the address of the pseudo, since the 
address of a symbol pseudo (as opposed to the much more general case of 
any random pseudo) will always be the "src" field of the instruction.

So now I can take a symbol, and from that one I have the symbol-pseudo, 
and can follow every single use of that symbol-pseudo by just looking 
through the list of users and calculating the instruction from there. That 
gives me whether the use will write to the symbol or read from it, and 
then I've got all the info I need.

I only do single-def cases right now, but for those I seem to do the right 
thing:

	int fn1(int argc)
	{
	        int i = argc;
	        return i + i;
	}

results in

	ep 0xf7fe200c: fn1
	   sym: 0xf7fd1760 argc
	   sym: 0xf7fd1850 i

	ENTRY:
	bb: 0xf7fa6024
	   test.c:1:5
	        %r-1 <- %arg1
	        %r-1 <- %arg1
	        %r-1 <- %arg1
	        deathnote %r1
	        %r-1 <- %arg1
	        %r-1 <- %arg1
	        %r4 <- add  %arg1, %arg1
	        deathnote %r2
	        deathnote %r3
	        ret %r4

where now the deathnotes are bogus, and the %r-1 <- xxx are just nops 
(it's "move to VOID" that it just prints out strangely).

So if you ignore the crap, it has generated

	%r4 <- add  %arg1, %arg1
	ret %r4

out of the thing, because it could replace the single-assigned "i" with 
the pseudo that was used to assign it.

It's got a few rough edges still, and maybe I'm doing something totally 
crazy, but the basic idea seems not totally unreasonable.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Tue, 09 Nov 2004 07:14:42 +0000
Message-ID: <Pine.LNX.4.58.0411082306110.2301 () ppc970 ! osdl ! org>
--------------------


On Mon, 8 Nov 2004, Linus Torvalds wrote:
> 
> I've improved my pseudo usage tracking.

Ok. I've done some more work, and the good news is that I actually ended
up finding a really stupid bug in the inliner because the linearized
output is now so readable (for some pretty strange definition of readable,
admittedly) that I could actually see that it was _wrong_.

Maybe it's just my coding style, but even the stupid symbol->pseudo thing
triggers a _lot_ (ie the "one single def site" case, which is the trivial
one). And the replacement really does make the code a lot more readable.

Anyway, I'm happy with the thing for now, and I'll hold off for a while in 
case people have comments.

I made the linearizer debug output a bit less readable again by exposing
the "dead" loads and stores (they store to a VOID pseudo address), because
that helped debugging, so if you want to see something more readable, just
run it through "grep -v '[[]VOID'" to remove the dead instructions.

I'll have to come up with some clever plan to handle symbols with multiple 
writes to them - they don't look hard per se, but while I can trivially 
find the instructions that write to a symbol from the "users" list, I 
don't have any way to get to the basic block from there. I guess I need to 
just add a pointer to the bb from the instruction. Oh, well. So much for 
small instructions ;)

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: deathnote
Date: Tue, 09 Nov 2004 19:44:10 +0000
Message-ID: <17769.65.113.40.130.1100029450.squirrel () numba-tu ! com>
--------------------
Linus Torvalds said:
> It now just literally tracks the _pointer_ to the pseudo. You can't really
> tell what instruction it is (the pseudo might be in the "src" field or the
> "target" field or in a totally separate phi-node etc), but on the other
> hand it is now _very_ easy to replace all uses of one pseudo with another.
> Just walk the list of pointers, and fill in the new pseudo.
>
> The reason I wanted to have an instruction pointer was because that was
> very useful to determine how a symbol-pseudo was used: was the instruction
> that used it an OP_LOAD or an OP_STORE. However, since a symbol pseudo can
> only ever be used in the _address_ of a memory op, it's easy to get to the
> "struct isntruction", when we know the address of the pseudo, since the
> address of a symbol pseudo (as opposed to the much more general case of
> any random pseudo) will always be the "src" field of the instruction.

I'm sure I didn't get this right.  What the point of this nasty hack if you
know that all the instructions in the list are the same kind.  Why not just
point to the instruction and get the pseudo from the src field?

Enlighten me please.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Tue, 09 Nov 2004 20:08:06 +0000
Message-ID: <Pine.LNX.4.58.0411091159070.2301 () ppc970 ! osdl ! org>
--------------------


On Tue, 9 Nov 2004, Tommy Thorn wrote:

> Linus Torvalds said:
> > It now just literally tracks the _pointer_ to the pseudo. You can't really
> > tell what instruction it is (the pseudo might be in the "src" field or the
> > "target" field or in a totally separate phi-node etc), but on the other
> > hand it is now _very_ easy to replace all uses of one pseudo with another.
> > Just walk the list of pointers, and fill in the new pseudo.
> >
> > The reason I wanted to have an instruction pointer was because that was
> > very useful to determine how a symbol-pseudo was used: was the instruction
> > that used it an OP_LOAD or an OP_STORE. However, since a symbol pseudo can
> > only ever be used in the _address_ of a memory op, it's easy to get to the
> > "struct isntruction", when we know the address of the pseudo, since the
> > address of a symbol pseudo (as opposed to the much more general case of
> > any random pseudo) will always be the "src" field of the instruction.
> 
> I'm sure I didn't get this right.  What the point of this nasty hack if you
> know that all the instructions in the list are the same kind.  Why not just
> point to the instruction and get the pseudo from the src field?
> 
> Enlighten me please.

Because in _general_, the pseudo can be anywhere, and as such the usage
notes must not say "it's always used by 'insn->src'". It can be in a
phi-node that is pointed to by the instruction, it can be in the "target"
field ("target" is actually a _use_, not a def for things like OP_STORE),
and it can be pretty much anywhere.

HOWEVER. symbol pseudos are different. We can fundamentally never generate
a symbol pseudo that isn't just an address of a load/store (*). So if, and
_only_ if, we know that we're walking the usage chain of a symbol pseudo,
we can get at the instruction.

Which is just as well. Most of the rest of the pseudo operations don't
care at all about how they are used: they know that all usage is reads,
and the only special case is the single "def" that all normal pseudos
have (and which is an instruction pointer, becasue at that point we always 
know how to find the def - it's the "target" in the instruction).

		Linus

(*) This is not some arbitrary made-up rule, either. We absolutely _never_
want to see a symbol as part of any regular instruction, except as an
address. And the regular address thing causes us to do an OP_SETVAL, which
doesn't use a symbol pseudo at all, it uses the symbol itself directly.  
I guess we _could_ use a symbol pseudo there, but we really don't care at
that point.

The point being that it would be horribly horribly wrong to have an 
instruction that looks like

	%rX <- add symbol, %rY

we want to replace symbols with pseudos, we definitely do _not_ want to
replace pseudos with symbols ;)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Tue, 09 Nov 2004 20:08:30 +0000
Message-ID: <20041109200830.GA6377 () 64m ! dyndns ! org>
--------------------
I like your clean up and the access data change.

I think the bit filed load/store is not 100% correct. I saw you already
have a comment about Bogus test that in the source.

Trivial test case is:

void foo(void){
        struct a {
                int a:24;
                int b:8;
        } c;
        c.a = 1000;
        c.b = 200;
}

For most of the pseudo usage, we don't care too much about the
instruction type as long as we knows it is using as source.

However, there is need to distinct the load/store address usage
from the other usage. Because when you search for the local memory
symbol to promote as pseudo, you are looking for the local
memory whose usage is all load/store and nothing else. Right now
load/store get mixed in the list you can't tell.

Maybe we should have the separate load/store list in the
symbol structure. If the instruction is load/store, add to that
list instead.

Chris

On Tue, Nov 09, 2004 at 12:08:06PM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 9 Nov 2004, Tommy Thorn wrote:
> 
> > Linus Torvalds said:
> > > It now just literally tracks the _pointer_ to the pseudo. You can't really
> > > tell what instruction it is (the pseudo might be in the "src" field or the
> > > "target" field or in a totally separate phi-node etc), but on the other
> > > hand it is now _very_ easy to replace all uses of one pseudo with another.
> > > Just walk the list of pointers, and fill in the new pseudo.
> > >
> > > The reason I wanted to have an instruction pointer was because that was
> > > very useful to determine how a symbol-pseudo was used: was the instruction
> > > that used it an OP_LOAD or an OP_STORE. However, since a symbol pseudo can
> > > only ever be used in the _address_ of a memory op, it's easy to get to the
> > > "struct isntruction", when we know the address of the pseudo, since the
> > > address of a symbol pseudo (as opposed to the much more general case of
> > > any random pseudo) will always be the "src" field of the instruction.
> > 
> > I'm sure I didn't get this right.  What the point of this nasty hack if you
> > know that all the instructions in the list are the same kind.  Why not just
> > point to the instruction and get the pseudo from the src field?
> > 
> > Enlighten me please.
> 
> Because in _general_, the pseudo can be anywhere, and as such the usage
> notes must not say "it's always used by 'insn->src'". It can be in a
> phi-node that is pointed to by the instruction, it can be in the "target"
> field ("target" is actually a _use_, not a def for things like OP_STORE),
> and it can be pretty much anywhere.
> 
> HOWEVER. symbol pseudos are different. We can fundamentally never generate
> a symbol pseudo that isn't just an address of a load/store (*). So if, and
> _only_ if, we know that we're walking the usage chain of a symbol pseudo,
> we can get at the instruction.
> 
> Which is just as well. Most of the rest of the pseudo operations don't
> care at all about how they are used: they know that all usage is reads,
> and the only special case is the single "def" that all normal pseudos
> have (and which is an instruction pointer, becasue at that point we always 
> know how to find the def - it's the "target" in the instruction).
> 
> 		Linus
> 
> (*) This is not some arbitrary made-up rule, either. We absolutely _never_
> want to see a symbol as part of any regular instruction, except as an
> address. And the regular address thing causes us to do an OP_SETVAL, which
> doesn't use a symbol pseudo at all, it uses the symbol itself directly.  
> I guess we _could_ use a symbol pseudo there, but we really don't care at
> that point.
> 
> The point being that it would be horribly horribly wrong to have an 
> instruction that looks like
> 
> 	%rX <- add symbol, %rY
> 
> we want to replace symbols with pseudos, we definitely do _not_ want to
> replace pseudos with symbols ;)
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Wed, 10 Nov 2004 00:04:35 +0000
Message-ID: <Pine.LNX.4.58.0411091559000.2301 () ppc970 ! osdl ! org>
--------------------


On Tue, 9 Nov 2004, Christopher Li wrote:
> 
> I think the bit filed load/store is not 100% correct. I saw you already
> have a comment about Bogus test that in the source.

Actually, it is "kind of" correct, because the store code is silly enough
to think that it can do any byte stores directly:

        if (ad->bit_size & (OFFSET_ALIGN-1))
                goto unaligned;

but that includes a 3-byte store ;)

I don't actually know how to determine which sizes are "ok", because it 
will depend on the architecture. One test would be to just check that 
bit_size is a power-of-2, but on x86 you an actually do a 10-byte FP store 
as one instruction, so..

I'll make it use the power-of-two rule for now.

> For most of the pseudo usage, we don't care too much about the
> instruction type as long as we knows it is using as source.
> 
> However, there is need to distinct the load/store address usage
> from the other usage. Because when you search for the local memory
> symbol to promote as pseudo, you are looking for the local
> memory whose usage is all load/store and nothing else. Right now
> load/store get mixed in the list you can't tell.

..and that's exactly why we calculate the instruction address, and look at 
whether it is a OP_LOAD or OP_STORE.

> Maybe we should have the separate load/store list in the
> symbol structure. If the instruction is load/store, add to that
> list instead.

It's easier to just put them on the same list, because the symbol case is 
actually not going to be very interesting in the long run.  It's only 
right now that we are trying to do the symbol->pseudo conversions that 
this matters at all, and once that is done, we're never going to be 
interested in it again.

So considering that we _can_ get at the instruction type, we're ok.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Wed, 10 Nov 2004 00:20:58 +0000
Message-ID: <Pine.LNX.4.58.0411091619060.2301 () ppc970 ! osdl ! org>
--------------------


On Tue, 9 Nov 2004, Linus Torvalds wrote:
> 
> I'll make it use the power-of-two rule for now.

Btw, you'll still see the

	c.b = 200;

assignment as a

	store $200 -> 0[c]

and I think that is actually correct. The debug print-out doesn't show the
fact that the type of the store is a 8-it store at bit-offset 24, but the
information is all there in the instruction, just not printed out. I
think.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Wed, 10 Nov 2004 15:28:49 +0000
Message-ID: <20041110152849.GA924 () 64m ! dyndns ! org>
--------------------
On Tue, Nov 09, 2004 at 04:04:35PM -0800, Linus Torvalds wrote:
> 
> ..and that's exactly why we calculate the instruction address, and look at 
> whether it is a OP_LOAD or OP_STORE.

Hmm, I toke me a while to figure out why symbol pseudo only has OP_LOAD
or OP_STORE. In fact the OP_SETVAL do directly use the symbol pseudo.
If I understand that correctly. That is better than have a different
list. It is effectually just has a different pseudo to put the load/stores.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: deathnote
Date: Wed, 10 Nov 2004 19:20:28 +0000
Message-ID: <Pine.LNX.4.58.0411101110080.2301 () ppc970 ! osdl ! org>
--------------------


On Wed, 10 Nov 2004, Christopher Li wrote:
> On Tue, Nov 09, 2004 at 04:04:35PM -0800, Linus Torvalds wrote:
> > 
> > ..and that's exactly why we calculate the instruction address, and look at 
> > whether it is a OP_LOAD or OP_STORE.
> 
> Hmm, I toke me a while to figure out why symbol pseudo only has OP_LOAD
> or OP_STORE. In fact the OP_SETVAL do directly use the symbol pseudo.

No, OP_SETVAL uses the symbol directly, and sets "insn->symbol = ctype" -
it doesn't actually create any symbol pseudos.

The only thing that uses "symbol_pseudo()" is OP_LOAD, OP_STORE and
OP_CALL. And OP_CALL does it only for function symbols, so I felt that we
can ignore that case here.

But you are right in that maybe OP_SETVAL _could_ use a symbol pseudo.  
The code would still work, because if somebody takes the address of a
symbol, we will have set MOD_ADDRESSABLE, and we won't be trying any
replacement. But I really think that OP_SETVAL is special. It's moving to 
a "OP_SETADDRESS", because it really doesn't set a value any more at all.

[ Correction: I guess it _does_ set a FVAL, but that's arguably because I 
  did PSEUDO_VAL the wrong way. I should either make PSEUDO_VAL take an 
  expression pointer (and allow either FP or integer values) _or_ I should 
  just add a PSEUDO_FVAL. I think the latter is the right thing to do. 
  Once that is done, "OP_SETVAL" really always is just a symbol address ]

> If I understand that correctly. That is better than have a different
> list. It is effectually just has a different pseudo to put the load/stores.

Yes. I considered actually splitting the symbol pseudo into a "store 
symbol pseudo" and a "load symbol pseudo", and while it would have made it 
really easy to see if we only have a single store, it didn't really seem 
worth the extra work (we'd have to add yet another pointer to "struct 
symbol" - maybe not a lot, but it just didn't seem worth it).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: definition of "null pointer constant" ===

From: =?ISO-8859-2?Q?=C9rsek_L=E1szl=F3?= <lacos () chello ! hu>
To: linux-sparse
Subject: definition of "null pointer constant"
Date: Sun, 28 Nov 2004 01:07:22 +0000
Message-ID: <Pine.LNX.4.58.0411280133340.3406 () lacos>
--------------------
On 2004-10-25,
in message <Pine.LNX.4.58.0410250737080.3016 () ppc970 ! osdl ! org>,
Linus Torvalds wrote:

> The only exception to that is the NULL pointer thing, which literally
> is the constant 0, not the _expression_ with the value 0.


ISO/IEC 9899:1999 states in 6.3.2.3 Pointers / 3:

        "An integer constant expression with the value 0, or such an
        expression cast to type void *, is called a null pointer
        constant."

(In 6.6 Constant expressions / 6, it states:

        "An integer constant expression shall have integer type and
        shall only have operands that are integer constants,
        enumeration constants, character constants, sizeof expressions
        whose results are integer constants, and floating constants
        that are the immediate operands of casts. Cast operators in an
        integer constant expression shall only convert arithmetic
        types to integer types, except as part of an operand to the
        sizeof operator.")


$ nl -ba a.c
     1  static int *a(void)
     2  {
     3    return 0;
     4  }
     5
     6  static int *b(void)
     7  {
     8    return (void*)0;
     9  }
$ ./check a.c
a.c:3:10: warning: Using plain integer as NULL pointer


If I err or am irrelevant, I apologize. I'm laconic because I want to make
the smallest noise possible in case I'm wrong (rather than out of
rudeness). I compiled sparse-2004-11-28 with "gcc (GCC) 3.3.5 (Debian
1:3.3.5-2)".

lacos
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: definition of "null pointer constant"
Date: Sun, 28 Nov 2004 01:58:02 +0000
Message-ID: <200411280158.iAS1w2q22119 () troll ! rentec ! com>
--------------------

You are right that "0" is a perfectly fine NULL pointer as far as
C99 is concerned.  (Perhaps except for vararg arguments; not sure.)

But sparse does not follow C99, but more like "C99 as Linus thinks
it should have been".  The point is that using 0 for NULL (or vice
versa) in practice is a sign of type confusion.  I have seen lots
of cases like:

#define FALSE 0
...
foo *
bar (int baz)
{
  if (baz < 0) return FALSE;
  ...
}

That's perfectly fine C99, but it's not pretty and likely not intended.
Such code is typically produced under the assumption that cut-and-paste
automatically fixes bugs sometime between "cut" and "paste".

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?ISO-8859-2?Q?=C9rsek_L=E1szl=F3?= <lacos () chello ! hu>
To: linux-sparse
Subject: Re: definition of "null pointer constant"
Date: Sun, 28 Nov 2004 04:10:09 +0000
Message-ID: <Pine.LNX.4.58.0411280303200.3596 () lacos>
--------------------
On Sat, 27 Nov 2004, Morten Welinder wrote:

> You are right that "0" is a perfectly fine NULL pointer as far as
> C99 is concerned.  (Perhaps except for vararg arguments; not sure.)

"0" is passed as an "int" through "...". NULL is an implementation-defined
null pointer constant (7.17 Common definitions <stddef.h>), it might be
"0", "((void *)0)", or "(4-4)". The last argument to execl(), for example,
must be "(char *)0" or "(char *)NULL"; none of "NULL" or "0" is enough (in
theory at least). With "0" (explicitly cast if necessary) I remind myself
that there is no universal null pointer, while NULL made me have this
impression.

I understand that macros can be useful for tools like sparse to check the
programmer's idea of the surrounding context. I started to gibber because
I was aware of "my context" and interpreted the warning as a false
positive.

Thank you for your answer.

lacos
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: definition of "null pointer constant"
Date: Sun, 28 Nov 2004 06:04:31 +0000
Message-ID: <Pine.LNX.4.58.0411272157350.22796 () ppc970 ! osdl ! org>
--------------------


On Sat, 27 Nov 2004, Morten Welinder wrote:
> 
> You are right that "0" is a perfectly fine NULL pointer as far as
> C99 is concerned.  (Perhaps except for vararg arguments; not sure.)

varargs is the classic case of where NULL as 0 really doesn't work. But I 
don't think it's the really good case. The real reason I hate "0 as NULL" 
is because it allows mistakes that should not be allowed.

I have literally seen code like

	int i = NULL;

where somebody really meant the NUL character, ie '\0'. And I think that a 
compiler that does not complain about usage like that is so horribly 
broken than it's not even funny. 

I really feel very strongly about it. I consider it a serious _bug_ to 
think that "0" is a pointer, or think that "NULL" is anything _but_ a 
pointer. 

I'm 100% convinced that the only reason 0 woks as the NULL pointer is
entirely historical, and comes from K&R not doing very much type-checking
at all. In a language without types (which C really historically largely
was: the "types" in original C are not really so much about "types" as
about "memory layout"), mixing integers and pointers makes perfect sense, 
and "0" just happens to be the one obvious bit pattern that is special and 
easy to test for to boot.

But things have gotten better. 

> But sparse does not follow C99, but more like "C99 as Linus thinks
> it should have been".

Absolutely. I'm a huge C bigot, and I _like_ C, but not enough to think 
that some standards-paper is actually _worth_ anything. Sparse does 
extensions to the language that I think are critical, and part of the 
extension is the requirement that pointers be marked as such. The standard 
can go screw itself when it's really wrong.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: function body variable declarations ===

From: Josh Boyer <jdub () us ! ibm ! com>
To: linux-sparse
Subject: function body variable declarations
Date: Tue, 23 Nov 2004 20:19:35 +0000
Message-ID: <1101241174.30816.7.camel () weaponx ! rchland ! ibm ! com>
--------------------
Hi all,

Should sparse handle variables that aren't declared at the beginning of
a function?  Seems gcc doesn't have a problem with this, so I'm just
wondering if sparse differs here.

And yes, I am well aware of peoples opinions of how gcc handles certain
things, so please try not to flame a newbie user like me.

Below is the testcase and sparse output for what I'm talking about.

thx,
josh

int main(int argc, char **argv)
{
	int i = 0;

	for (i = 0; i < 10; i++) {
		i += i;
	}

	int c = 2;

	return c;
}

$ ./bin/sparse foo.c
foo.c:9:2: warning: typename in expression
foo.c:9:6: warning: Expected ; at end of statement
foo.c:9:6: warning: got c
foo.c:9:2: warning: undefined identifier 'int'
foo.c:11:9: warning: undefined identifier 'c'

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Tue, 23 Nov 2004 21:21:40 +0000
Message-ID: <Pine.LNX.4.58.0411231308040.20993 () ppc970 ! osdl ! org>
--------------------


On Tue, 23 Nov 2004, Josh Boyer wrote:
> 
> Should sparse handle variables that aren't declared at the beginning of
> a function?  Seems gcc doesn't have a problem with this, so I'm just
> wondering if sparse differs here.

I don't much like that syntax, and not all versions of gcc that are used 
to compile the kernel can handle it either, so for now I wouldn't want to 
support it.

The one special case is the

	for (int i = xxx..

thing, which I heartily agree with from a syntactic standpoint, and I made 
sparse support (not that it has ever gotten tested, I think).

But if somebody wants to add it, along with a cmd line flag to enable it 
(please keep it disabled by default), go wild. It really shouldn't be 
hard at all.

[ time passes ]

Duh.  The _parsing_ part is trivial. I checked in something that parses 
it, although right now it warns unconditionally.

NOTE NOTE NOTE! It may parse it, but it linearizes the assignments 
incorrectly. It will linearize any initializers at the top of the 
function, which is not right. I'm not sure what I should do to support 
this feature properly.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Tue, 23 Nov 2004 22:08:12 +0000
Message-ID: <23310.65.113.40.130.1101247692.squirrel () numba-tu ! com>
--------------------
Linus Torvalds said:
> On Tue, 23 Nov 2004, Josh Boyer wrote:
>>
>> Should sparse handle variables that aren't declared at the beginning of
>> a function?  Seems gcc doesn't have a problem with this, so I'm just
>> wondering if sparse differs here.
>
> I don't much like that syntax, and not all versions of gcc that are used
> to compile the kernel can handle it either, so for now I wouldn't want to
> support it.

Isn't this part of C99?

IMO this is the way it should always have been.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jdub () us ! ibm ! com>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Tue, 23 Nov 2004 23:17:50 +0000
Message-ID: <1101251827.21318.5.camel () 67-41-71-119 ! roch ! qwest ! net>
--------------------
On Tue, 2004-11-23 at 15:21, Linus Torvalds wrote:
> On Tue, 23 Nov 2004, Josh Boyer wrote:
> > 
> > Should sparse handle variables that aren't declared at the beginning of
> > a function?  Seems gcc doesn't have a problem with this, so I'm just
> > wondering if sparse differs here.
> 
> I don't much like that syntax, and not all versions of gcc that are used 
> to compile the kernel can handle it either, so for now I wouldn't want to 
> support it.

I don't like it either.  I'm playing with an older version of the 2.6
kernel and I just happened to notice that sparse didn't like that enough
to issue "warning: too many warnings" and promptly stop my kernel
compile :).

> 
> The one special case is the
> 
> 	for (int i = xxx..
> 
> thing, which I heartily agree with from a syntactic standpoint, and I made 
> sparse support (not that it has ever gotten tested, I think).

Yep, agreed.

> Duh.  The _parsing_ part is trivial. I checked in something that parses 
> it, although right now it warns unconditionally.

Cool, I'll check it out tomorrow.

> 
> NOTE NOTE NOTE! It may parse it, but it linearizes the assignments 
> incorrectly. It will linearize any initializers at the top of the 
> function, which is not right. I'm not sure what I should do to support 
> this feature properly.

Noted.  Not quite understood (yet), but noted :).  

thx,
josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jdub () us ! ibm ! com>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Tue, 23 Nov 2004 23:22:51 +0000
Message-ID: <1101252140.21347.3.camel () 67-41-71-119 ! roch ! qwest ! net>
--------------------
On Tue, 2004-11-23 at 16:08, Tommy Thorn wrote:
> Linus Torvalds said:
> > On Tue, 23 Nov 2004, Josh Boyer wrote:
> >>
> >> Should sparse handle variables that aren't declared at the beginning of
> >> a function?  Seems gcc doesn't have a problem with this, so I'm just
> >> wondering if sparse differs here.
> >
> > I don't much like that syntax, and not all versions of gcc that are used
> > to compile the kernel can handle it either, so for now I wouldn't want to
> > support it.
> 
> Isn't this part of C99?

I think so.

> 
> IMO this is the way it should always have been.

It has it's advantages, sure.  I get confused easily though, and seeing
a new variable in the middle of a function often makes me think, "Hm... 
did the developer miss a corner case and add a quick hack, or was this
always like this...".

But that's just my paranoid opinion :).

josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Tue, 23 Nov 2004 23:35:19 +0000
Message-ID: <Pine.LNX.4.58.0411231532560.20993 () ppc970 ! osdl ! org>
--------------------


On Tue, 23 Nov 2004, Tommy Thorn wrote:
> 
> Isn't this part of C99?

Yes, however, from a kernel checking standpoint, it's definitely not part 
of the acceptable language, because older gcc versions don't understand 
it, so at the very least I want to warn about it.

Even in C99 mode, the thing is an abomination. Declaring variables 
wherever you happen to need them is lazy, and in my opinion just makes it 
harder to visually find the declarations. In almost all cases where I 
actually see people using that thing, I tend to go "Ewww..".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Tommy Thorn" <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Tue, 23 Nov 2004 23:48:39 +0000
Message-ID: <27320.65.113.40.130.1101253719.squirrel () numba-tu ! com>
--------------------
Linus Torvalds said:
> Even in C99 mode, the thing is an abomination. Declaring variables
> wherever you happen to need them is lazy, and in my opinion just makes it
> harder to visually find the declarations. In almost all cases where I
> actually see people using that thing, I tend to go "Ewww..".

Heh, I actually tried to resist this thread, but ...

It's a matter of taste and definitely not an issue of laziness.  Keeping the
declaration with the initialization (often the only assignment) keeps the
scope down and keeps the declaration closer to its use.  It the ideal style
when you always want to keep your variables initialized.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: =?iso-8859-1?Q?J=F6rn?= Engel <joern () wohnheim ! fh-wedel ! de>
To: linux-sparse
Subject: Re: function body variable declarations
Date: Wed, 24 Nov 2004 15:28:37 +0000
Message-ID: <20041124152837.GD906 () wohnheim ! fh-wedel ! de>
--------------------
On Tue, 23 November 2004 15:48:39 -0800, Tommy Thorn wrote:
> Linus Torvalds said:
> > Even in C99 mode, the thing is an abomination. Declaring variables
> > wherever you happen to need them is lazy, and in my opinion just makes it
> > harder to visually find the declarations. In almost all cases where I
> > actually see people using that thing, I tend to go "Ewww..".
> 
> It's a matter of taste and definitely not an issue of laziness.  Keeping the
> declaration with the initialization (often the only assignment) keeps the
> scope down and keeps the declaration closer to its use.  It the ideal style
> when you always want to keep your variables initialized.

Checking for uninitialized variables is pretty simple to do
automatically.

Keeping variable lifetime as short as possible is a valid argument,
but declaring them later is only half the solution.  The lifetime
_starts_ later, but it still _ends_ at the same position.

Like with most other things between personal taste and codingstyle,
the best solution is to keep functions small.  In this particular
case, the lifetime of variables will be obvious and tricky games
become pointless. ;)

Jrn

-- 
And spam is a useful source of entropy for /dev/random too!
-- Jasmine Strong
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: how to get all symbols ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: how to get all symbols
Date: Fri, 22 Oct 2004 18:06:03 +0000
Message-ID: <20041022180603.GA7462 () 64m ! dyndns ! org>
--------------------
It seems in the current sparse I can't visit the symbols which not on the used_list.
e.g. I want to list all the macro defined after the pre processing.

I write a function to iterate all the symbols. It seems that this function should
belong to symbol.c. But hash_table is static to tokenize.c so I put it there for now.

Comment?

Chris

Index: sparse-be/tokenize.c
===================================================================
--- sparse-be.orig/tokenize.c	2004-10-09 12:54:53.000000000 -0400
+++ sparse-be/tokenize.c	2004-10-22 13:45:15.000000000 -0400
@@ -708,6 +708,23 @@
 	}
 }
 
+void iterate_all_symbols(void (*callback)(struct symbol *), enum namespace ns)
+{
+	int i;
+	struct symbol *sym;
+
+	for (i =0; i < IDENT_HASH_SIZE; i++) {
+		struct ident * ident = hash_table[i];
+
+		while (ident) {
+			for (sym = ident->symbols; sym; sym = sym->next_id)
+				if (sym->namespace & ns)
+					callback(sym);
+			ident = ident->next;
+		}
+	}
+}
+
 static struct ident *alloc_ident(const char *name, int len)
 {
 	struct ident *ident = __alloc_ident(len);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: how to get all symbols
Date: Fri, 22 Oct 2004 22:15:49 +0000
Message-ID: <20041022221549.GA8442 () 64m ! dyndns ! org>
--------------------
Thanks for the tip. That is exactly what I am looking for.
And it is much cleaner.

Speaking of FOR_EACH_PTR, why does check.c and test-linearize.c
all use iterate instead of FOR_EACH_PTR?
I try the following patch and it seems worked.

Chris

Index: sparse-be/test-linearize.c
===================================================================
--- sparse-be.orig/test-linearize.c	2004-10-17 18:47:04.000000000 -0400
+++ sparse-be/test-linearize.c	2004-10-22 13:13:17.000000000 -0400
@@ -21,23 +21,12 @@
 #include "expression.h"
 #include "linearize.h"
 
-static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
-{
-	struct entrypoint *ep;
-
-	check_duplicates(sym);
-	evaluate_symbol(sym);
-	expand_symbol(sym);
-	ep = linearize_symbol(sym);
-	if (ep)
-		show_entry(ep);
-}
-
 int main(int argc, char **argv)
 {
 	int fd;
 	char *filename = NULL, **args;
 	struct token *token;
+	struct symbol *sym;
 
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
@@ -84,6 +73,16 @@
 	translation_unit(token, &used_list);
 
 	// Do type evaluation and simplify
-	symbol_iterate(used_list, clean_up_symbol, NULL);
+	FOR_EACH_PTR(used_list, sym) {
+		struct entrypoint *ep;
+
+		check_duplicates(sym);
+		evaluate_symbol(sym);
+		expand_symbol(sym);
+		ep = linearize_symbol(sym);
+		if (ep)
+			show_entry(ep);
+	} END_FOR_EACH_PTR(sym);
+	
 	return 0;
 }


On Fri, Oct 22, 2004 at 03:30:08PM -0700, Linus Torvalds wrote:
> 
> 
> On Fri, 22 Oct 2004, Christopher Li wrote:
> >
> > It seems in the current sparse I can't visit the symbols which not on the used_list.
> > e.g. I want to list all the macro defined after the pre processing.
> 
> Sure you can. You just have to know the scope they were declared in. Then 
> you have a nice list of all symbols in that scope through 
> "scope->symbols".
> 
> So if you're interested in macros, then (since they are all at the 
> top-level), you should be able to just do
> 
> 	struct symbol *sym;
> 
> 	FOR_EACH_PTR(file_scope->symbols, sym) {
> 		if (sym->namespace != NS_MACRO)
> 			continue;
> 		/* HERE I AM ! */
> 	} END_FOR_EACH_PTR;
> 
> since all macros are in the top-level scope.
> 
> Testing it, I noticed that yes, it works, but we don't actually set the 
> "sym->ident" field to point to the identifier for preprocessor symbols, so 
> it's nastier than it should be to print things out sanely. I'll fix that.
> 
> 		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: how to get all symbols
Date: Fri, 22 Oct 2004 22:30:08 +0000
Message-ID: <Pine.LNX.4.58.0410221517100.2101 () ppc970 ! osdl ! org>
--------------------


On Fri, 22 Oct 2004, Christopher Li wrote:
>
> It seems in the current sparse I can't visit the symbols which not on the used_list.
> e.g. I want to list all the macro defined after the pre processing.

Sure you can. You just have to know the scope they were declared in. Then 
you have a nice list of all symbols in that scope through 
"scope->symbols".

So if you're interested in macros, then (since they are all at the 
top-level), you should be able to just do

	struct symbol *sym;

	FOR_EACH_PTR(file_scope->symbols, sym) {
		if (sym->namespace != NS_MACRO)
			continue;
		/* HERE I AM ! */
	} END_FOR_EACH_PTR;

since all macros are in the top-level scope.

Testing it, I noticed that yes, it works, but we don't actually set the 
"sym->ident" field to point to the identifier for preprocessor symbols, so 
it's nastier than it should be to print things out sanely. I'll fix that.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: how to get all symbols
Date: Fri, 22 Oct 2004 23:09:28 +0000
Message-ID: <Pine.LNX.4.58.0410221603210.2101 () ppc970 ! osdl ! org>
--------------------


On Fri, 22 Oct 2004, Linus Torvalds wrote:
> 
> Testing it, I noticed that yes, it works, but we don't actually set the 
> "sym->ident" field to point to the identifier for preprocessor symbols, so 
> it's nastier than it should be to print things out sanely. I'll fix that.

Ok, fixed. Although sparse.bkbits.net seems to be busy, so I can't push it 
out there. 

Anyway, this patch shows example use, along with whether a macro was ever 
used or not..

It's kind of cool to see the usage markers on the macros, actually. I'm
thinking that this could be used for checking whether a header file is at
all useful - if it has no symbols (macros included) that were used, it's
not very interesting. Maybe a way to prune out unnecessary header
inclusion.

Of course, the 

	#ifndef XXXXX_H
	#define XXXXX_H
	...

pattern at the top of header files does end up marking 'XXXXX_H' used 
occasionally (if the header file was included twice), so it would have to 
be a heuristic. And handling include-files that are interesting only 
because they include _other_ include files also ends up being something 
that needs manual decision, I guess.

		Linus

----
===== check.c 1.37 vs edited =====
--- 1.37/check.c	2004-10-11 06:32:51 -07:00
+++ edited/check.c	2004-10-22 16:02:19 -07:00
@@ -22,6 +22,19 @@
 #include "symbol.h"
 #include "expression.h"
 #include "linearize.h"
+#include "scope.h"
+
+static void show_macros(struct symbol_list *list)
+{
+	struct symbol *sym;
+	FOR_EACH_PTR(list, sym) {
+		if (sym->namespace != NS_MACRO)
+			continue;
+		printf("[%s] %s\n",
+			sym->used ? "*" : " ",
+			show_ident(sym->ident));
+	} END_FOR_EACH_PTR(sym);
+}
 
 static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
 {
@@ -116,5 +129,7 @@
 
 	// Do type evaluation and simplify
 	symbol_iterate(used_list, clean_up_symbol, NULL);
+
+	show_macros(file_scope->symbols);
 	return 0;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: how to get all symbols
Date: Sat, 23 Oct 2004 01:51:48 +0000
Message-ID: <Pine.LNX.4.58.0410221851120.2101 () ppc970 ! osdl ! org>
--------------------


On Fri, 22 Oct 2004, Christopher Li wrote:
> 
> Speaking of FOR_EACH_PTR, why does check.c and test-linearize.c
> all use iterate instead of FOR_EACH_PTR?

Entirely historical reasons. "iterate()" was the original bad interface.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: initializer handling re-work ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: initializer handling re-work
Date: Fri, 24 Sep 2004 01:06:30 +0000
Message-ID: <Pine.LNX.4.58.0409231752130.25656 () ppc970 ! osdl ! org>
--------------------

Richard Henderson pointed out that sparse doesn't handle initializers of 
the more complicated kind, like

	struct xxx var = {
		.a[10].xyzzy = 1
	};

which was definitely true. In fact, we discouraged these kinds of 
initializers from the kernel, because they are so hard to parse.

But my pride was wounded, so I decided to do them right. It turned out to 
be harder than I really expected, because the pseudo-linearized parse 
format for initializers (with a list of expressions interspersed with 
occasional "positional markers") really didn't lend itself well to do 
anything like that cleanly.

So I had to pretty much totally rework how the initializers got parsed and
evaluated. I think it's cleaner now, and what happens is that the
EXPR_INDEX (array index info) and EXPR_IDENTIFIER (structure member name
marker) are no longer just anonymous position markers, they actually have
the expression they marked nested inside of them.

When the initializer is type-evaluated, all these markers are then turned
into EXPR_POS markers, which have the byte offsets in them. So an 
initializer is now a tree of these EXPR_INITIALIZER lists, each of which 
ends up having a list of EXPR_POS expressions (except for a potential zero 
offset one), which then have the actual value expressions inside of them.

The expansion phase then flattens the EXPR_POS tree as far as it can 
(but if you have an array _range_ initializer, it can't be flattened), and 
also sorts the dang thing.

Yes, sorts. I wrote a sort routine. I don't actually know what I'm doing,
so it's probably O(exp(n)) or something, but for the "already sorted" case
it should work fine, and really just verifies the order. For the "we need
to actually do some real work to sort the thing" case, it may or may not
suck dead baby donkeys through a straw.

I looked at the sort that Jeff had already written, and decided that I 
really want to do an in-place sort rather than an insertion sort into a 
big array. In particular I didn't want to do any extra work for the 
already-sorted case. Somebody with more energy than I have might want to 
see what kind of melt-down my sort has with a nasty input set..

NOTE NOTE NOTE! I haven't really verified that Jeff's compiler can make 
any sense at all of the new initializer setup. So things like that might 
have broken horribly. But I think the new world order is better than what 
we used to have.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: initializer handling re-work
Date: Fri, 24 Sep 2004 01:33:10 +0000
Message-ID: <41537956.1070209 () pobox ! com>
--------------------
Linus Torvalds wrote:
> Richard Henderson pointed out that sparse doesn't handle initializers of 
> the more complicated kind, like
> 
> 	struct xxx var = {
> 		.a[10].xyzzy = 1
> 	};
> 
> which was definitely true. In fact, we discouraged these kinds of 
> initializers from the kernel, because they are so hard to parse.
> 
> But my pride was wounded, so I decided to do them right. It turned out to 

Awesome.

Initializers in compile-i386 are not really well done, simply because 
the pre-existing initializer setup was such a pain, particularly for 
nested initializers.


> NOTE NOTE NOTE! I haven't really verified that Jeff's compiler can make 
> any sense at all of the new initializer setup. So things like that might 
> have broken horribly. But I think the new world order is better than what 
> we used to have.

Anything should be better than the previous stuff.  Pride restored :)

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: initializer handling re-work
Date: Fri, 24 Sep 2004 03:39:29 +0000
Message-ID: <Pine.LNX.4.58.0409232027520.25656 () ppc970 ! osdl ! org>
--------------------


On Thu, 23 Sep 2004, Linus Torvalds wrote:
> 
> I looked at the sort that Jeff had already written, and decided that I 
> really want to do an in-place sort rather than an insertion sort into a 
> big array. In particular I didn't want to do any extra work for the 
> already-sorted case. Somebody with more energy than I have might want to 
> see what kind of melt-down my sort has with a nasty input set..

The sort definitely ends up being a bogo-sort for any larger input size. 
Judging by a quick test it's O(n**2):

	torvalds@ppc970:~/BK/sparse> time ./a.out 10000 u
	real    0m1.003s
	user    0m1.001s
	sys     0m0.001s

	torvalds@ppc970:~/BK/sparse> time ./a.out 20000 u
	real    0m4.016s
	user    0m4.013s
	sys     0m0.002s

	torvalds@ppc970:~/BK/sparse> time ./a.out 40000 u
	real    0m16.075s
	user    0m16.070s
	sys     0m0.002s


so we seem to have a nice quadratic scaling. 

On the other hand, it really _is_ pretty fast with a sorted list:

	torvalds@ppc970:~/BK/sparse> time ./a.out 10000000 s
	real    0m0.703s
	user    0m0.647s
	sys     0m0.056s

	torvalds@ppc970:~/BK/sparse> time ./a.out 100000000 s
	real    0m6.755s
	user    0m6.119s
	sys     0m0.628s

ie a ten million entry list doesn't take ages, which is a good sign. The
hundred-million entry list takes a few seconds, but dammit, at that point
I suspect sparse will have hit other problems than the sorting long
before..

I suspect that the only really _big_ initializers are all automatically 
generated, and they would all be sorted. So my theory is that we only care 
about scaling well with sorted input, and there we're O(n), with a 
reasonably small constant factor too..

I'm sure you can do a lot better, though. Anybody up for a small pointless 
ego trip down CS student memory lane?

		Linus


-- test-sort.c --
#include <stdio.h>
#include <stdlib.h>

#include "lib.h"

#define MAX 40000

int cmp(const void *a, const void *b)
{
	if (a < b)
		return 1;
	if (a > b)
		return -1;
	return 0;
}

int main(int argc, char **argv)
{
	int i;
	struct ptr_list *list = NULL;
	int max, sorted;

	if (argc < 3)
		exit(1);

	max = atoi(argv[1]);
	sorted = argv[2][0] == 's';
	for (i = 0; i < max; i++) {
		unsigned long nr = i;
		if (!sorted)
			nr = random() % max;
		add_ptr_list(&list, (void *)nr);
	}
	sort_list(&list, cmp);
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: initializer handling re-work
Date: Fri, 24 Sep 2004 13:11:48 +0000
Message-ID: <20040924131148.1DED91422D53 () darter ! rentec ! com>
--------------------

I can fix it one of these days.  I take it there is no rush.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: list now archived ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: list now archived
Date: Sat, 17 Apr 2004 21:52:41 +0000
Message-ID: <4081A729.9020602 () pobox ! com>
--------------------
at marc:

	http://marc.theaimsgroup.com/?l=linux-sparse&r=1&w=2


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: memop simplification.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: memop simplification..
Date: Sat, 27 Nov 2004 20:53:40 +0000
Message-ID: <Pine.LNX.4.58.0411271238580.22796 () ppc970 ! osdl ! org>
--------------------

Ok, I just implemented memop simplification that takes generalized memory 
operations, not just local symbols. I still do the local symbol 
optimization first, because I can do that part with less overhead, since I 
know a-priori that the local symbols are dead at exit etc.

I don't do any type-based alias analysis (quite frankly, I think it's a
horrid example of an optimization rule), but I can (and do) do some alias
analysis statically just based on common subexpressions and the pointer
offsets.

Example input file designed to show it:

	struct hello {
		int a:5;
		int b:5;
		int c:22;
		int d;
	};

	int test(struct hello *p, int *c)
	{
		int n = p->a;
		int k = *c;
		p->d = 1;
		n += p->b;
		*c = 0;
		return n + p->c + k;
	}

here the "p->d" access does not alias the p->a/b/c accesses, but the "*c"  
access can alias anything. So current sparse generates:

	ep 0xf7fe200c: test

	ENTRY:
	bb: 0xf7f9e00c
	   test.c:8:5
	        load %r2 <- 0.0.32[%arg1]	# load p->a/b
	        %r3 <- CAST(5->32) %r2		# %r3 = p->a
	        load %r5 <- 0.0.32[%arg2]	# load *c
	        store $1 -> 4.0.32[%arg1]	# p->d = 1
	        %r9 <- shr  %r2, $5
	        %r10 <- CAST(5->32) %r9		# %r10 = p->b. Note the lack of re-load
	        %r12 <- add  %r3, %r10
	        store $0 -> 0.0.32[%arg2]	# *c = 0
	        load %r16 <- 0.0.32[%arg1]	# need to re-load now ;(
	        %r17 <- shr  %r16, $10
	        %r18 <- CAST(22->32) %r17	# %r18 = p->c
	        %r19 <- add  %r12, %r18
	        %r21 <- add  %r19, %r5
	        ret %r21

which seems pretty optimal (note that the cast operations do the masking 
by virtue of casting from a n-bit value to a 32-bit value).

Of course, I won't guarantee that I actually check all the dominance 
issues properly. But it does do cross-basic-block analysis, and my trivial 
test-cases seem sane enough.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: more sparse borkage. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: more sparse borkage.
Date: Thu, 25 Mar 2004 20:19:07 +0000
Message-ID: <Pine.LNX.4.58.0403251157300.1106 () ppc970 ! osdl ! org>
--------------------

Ok, 

 as I fixed a confusion I had about type-name visibility that Dave Jones
found, and that affected the hisax/st5481_usb ISDN driver, I realized just
how easy it is to support types as "real entities" in expressions, because
I needed to trigger a warning on such a condition anyway.

So instead of warning about it, I just implemented a limited form of
"types as first-class citizens".

What I wanted to do is to basically do the type equality testign that the
kernel "max()" macro does with that strange "(void) (&_x == &_y)"  
comparison:

	#define max(x,y) ({ \
	        typeof(x) _x = (x);     \
	        typeof(y) _y = (y);     \
	        (void) (&_x == &_y);    \
	        _x > _y ? _x : _y; })

and make it a real type comparison that could be used to actually 
parameterize a macro.

The strange comparison works fine for gettign the warning we want in
"max()", but it doesn't allow us to _behave_ differently depending on the
types. The kernel user access macros use "sizeof" to behave pseudo-
differently depending on types, but you can't do anything fancy with it.

In other words, I wanted to be able to do something like this

	#define format(x) 				\
		(typeof(x) == int ? "%d" :		\
		 typeof(x) == long ? "%ld" : "%x")

	#define print(x) printf(format(x),x)

and it should just work (and work even if "int" and "long" happen to be
the same size).

Now, the above doesn't actually work right now, for a silly reason: the
"(typeof(x)" thing is parsed as a cast, and then the code is unhappy about
not getting the ending ")". In other cases the "typeof" is expected to be
the start of a variable declaration, not an expression. But both those
cases can be worked around with a strange syntactic trick:

	#define format(x)				\
		(0, typeof(x) == int ? "%d" :		\
		 typeof(x) == long ? "%ld" : "%x")

	#define print(x) printf(format(x),x)

and this does indeed work, and because all of it is obviously compile-time 
constants, it even folds correctly.

You can try the above with the x86 toy backend in the current BK tree, and
you'll see how it all is done correctly.

I think the above is a cool feature. It's _especially_ cool if I ever 
actually get around to implementing the untyped inline functions, ie what 
I really want to work is something like

	static inline max(a,b)
	{
		if (typeof(a) != typeof(b))
			__compile_time_warning();
		return a > b ? a : b;
	}

where all argument types are inherited from the context of the calling
process (I may have problems with the return type, sadly).

Cool, or crazy.. You decide.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: patch to compile on mac os x 10.3 ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: patch to compile on mac os x 10.3
Date: Fri, 09 Jul 2004 05:41:00 +0000
Message-ID: <20040709054100.GA30080 () 64m ! dyndns ! org>
--------------------
On Fri, Jul 09, 2004 at 02:03:19AM -0500, Brian R. Gaeke wrote:
> 
> diff -ru sparse-bk/lib.c sparse-bk-macosx/lib.c
> --- sparse-bk/lib.c	Tue Jul  6 18:00:20 2004
> +++ sparse-bk-macosx/lib.c	Fri Jul  9 01:58:50 2004
> @@ -83,6 +83,9 @@
>  };
>  
>  #define CHUNK 32768
> +#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
> +#define MAP_ANONYMOUS MAP_ANON
> +#endif


If I were you, I will move the #ifdef to lib.h header file. Linus prefer #ifdef
stay in the head file instead of c file. Better abstraction.

While you were there, can you verify that on MAC OSX mmap anonymous page
actually always get zeroed page? I know some cygwin mmap is broken on that.


>  #define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
>  #define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
>  
> diff -ru sparse-bk/symbol.c sparse-bk-macosx/symbol.c
> --- sparse-bk/symbol.c	Sun Jun  6 18:00:23 2004
> +++ sparse-bk-macosx/symbol.c	Fri Jul  9 01:56:37 2004
> @@ -511,6 +511,9 @@
>  IDENT(for); IDENT(while); IDENT(do); IDENT(goto);
>  
>  IDENT(__asm__); IDENT(__asm); IDENT(asm);
> +#ifdef __volatile
> +#undef __volatile
> +#endif
>  IDENT(__volatile__); IDENT(__volatile); IDENT(volatile);
>  IDENT(__attribute__); IDENT(__attribute);
>  IDENT(defined);

I think it would be better not to touch the __volatile, unless
there is a good reason. I think the following patch should work.

 
Index: sparse-be/symbol.c
===================================================================
--- sparse-be.orig/symbol.c     2004-07-08 09:24:34.000000000 -0400
+++ sparse-be/symbol.c  2004-07-09 01:13:01.000000000 -0400
@@ -511,7 +511,7 @@
 IDENT(for); IDENT(while); IDENT(do); IDENT(goto);
 
 IDENT(__asm__); IDENT(__asm); IDENT(asm);
-IDENT(__volatile__); IDENT(__volatile); IDENT(volatile);
+IDENT(__volatile__); IDENT(volatile);
 IDENT(__attribute__); IDENT(__attribute);
 IDENT(defined);
 
@@ -520,6 +520,7 @@
 struct ident __VA_ARGS___ident = __INIT_IDENT("__VA_ARGS__");
 struct ident __LINE___ident = __INIT_IDENT("__LINE__");
 struct ident __FILE___ident = __INIT_IDENT("__FILE__");
+struct ident __volatile_ident = __INIT_IDENT("__volatile");
 
 void init_symbols(void)
 {


Just my $.02

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Brian R. Gaeke" <brg () dgate ! org>
To: linux-sparse
Subject: patch to compile on mac os x 10.3
Date: Fri, 09 Jul 2004 07:03:19 +0000
Message-ID: <20040709070318.GA30170 () sartre ! dgate ! org>
--------------------

--FCuugMFkClbJLl1L
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline


Hi there,

I patched sparse-2004-07-09 so that it compiles on my Mac OS X 10.3
machine. I also verified that it still compiles on Linux.  (I was using
gcc 3.3.x in both instances.)  If you are interested, the patch is attached.

-Brian

-- 
Brian R. Gaeke, brg at dgate.org -- GnuPG encrypted mail gleefully accepted

--FCuugMFkClbJLl1L
Content-Type: text/plain; charset=us-ascii
Content-Disposition: attachment; filename=patch

diff -ru sparse-bk/lib.c sparse-bk-macosx/lib.c
--- sparse-bk/lib.c	Tue Jul  6 18:00:20 2004
+++ sparse-bk-macosx/lib.c	Fri Jul  9 01:58:50 2004
@@ -83,6 +83,9 @@
 };
 
 #define CHUNK 32768
+#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
+#define MAP_ANONYMOUS MAP_ANON
+#endif
 #define blob_alloc(size) mmap(NULL, ((size)+4095) & ~4095, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
 #define blob_free(addr,size) munmap((addr), ((size)+4095) & ~4095)
 
diff -ru sparse-bk/symbol.c sparse-bk-macosx/symbol.c
--- sparse-bk/symbol.c	Sun Jun  6 18:00:23 2004
+++ sparse-bk-macosx/symbol.c	Fri Jul  9 01:56:37 2004
@@ -511,6 +511,9 @@
 IDENT(for); IDENT(while); IDENT(do); IDENT(goto);
 
 IDENT(__asm__); IDENT(__asm); IDENT(asm);
+#ifdef __volatile
+#undef __volatile
+#endif
 IDENT(__volatile__); IDENT(__volatile); IDENT(volatile);
 IDENT(__attribute__); IDENT(__attribute);
 IDENT(defined);

--FCuugMFkClbJLl1L--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: patching 'extern' (drivers/media/video/bttv-driver.c) ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: patching 'extern' (drivers/media/video/bttv-driver.c)
Date: Fri, 11 Jun 2004 21:42:38 +0000
Message-ID: <20040611144238.10a61ca2.rddunlap () osdl ! org>
--------------------


I've been handed a number of small patches that remove the
storage class specifier 'extern' from several .c files
where the function is actually implemented.

Documentation/CodingStyle doesn't say anything about 'extern'.
I recall Andrew having me omit it from the syscalls.h header
file patch.


I don't see anything wrong with using 'extern' as is done below
(i.e., it looks like legal C to me), unless it appears with
both internal and external linkage in the same translation unit.

Comments?

(This may be a bad example since bttv_reinit_bt848()
is used only in this one source file, so it doesn't need
to be 'extern'.)


E.g.:

  CHECK   drivers/media/video/bttv-driver.c
drivers/media/video/bttv-driver.c:1071:13: warning: function with
external linkage has definition

--- linux-2.5/drivers/media/video/bttv-driver.c 2004-06-11
13:44:22.000000000 -0700
+++ linux-2.5-fix/drivers/media/video/bttv-driver.c     2004-06-11
13:44:08.000000000 -0700
@@ -1068,7 +1068,7 @@ static void init_bt848(struct bttv *btv)
        init_irqreg(btv);
 }

-extern void bttv_reinit_bt848(struct bttv *btv)
+void bttv_reinit_bt848(struct bttv *btv)
 {
        unsigned long flags;


Thanks.
--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: prettier linearized output? ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: prettier linearized output?
Date: Mon, 01 Nov 2004 20:11:08 +0000
Message-ID: <Pine.LNX.4.58.0411011203120.28839 () ppc970 ! osdl ! org>
--------------------

I have a "cunning" plan to make the linearizer output a bit more readable, 
which I've put the foundations for by trying to put in pseudo deathnotes 
in the linerized output, and now by having a final pass over the bb list 
to copy all the phi node information to the sources of the thing.

This _hopefully_ means that it should be possible to generate some real 
pseudo-assembly with a "register allocator" that makes it a bit more 
readable than the mess it has now.

However, what I'm really missing is converting local variables that 
haven't had their address taken into pseudo's. I assume that there is some 
trivial algorithm for that - it _sounds_ like it should be easy to do, but 
I've got no clue.

Does anybody have a clue-bat for me? Something that takes a symbol that we 
know is "well-behaved" (trivially testable by just verifying that its 
address has never been taken, and that it's an automatic variable), and 
just convert it into a pseudo instead of a real symbol?

I was thinking of something that creates a new pseudo for each assignment, 
and then a phi-node for each read depending on reachability. It _sounds_ 
like that is a valid thing to do, but I have this suspicion that I'm a 
retard and that I'm missing something..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Tommy Thorn <tommy () numba-tu ! com>
To: linux-sparse
Subject: Re: prettier linearized output?
Date: Mon, 01 Nov 2004 20:42:00 +0000
Message-ID: <41869F98.5010504 () numba-tu ! com>
--------------------
Linus Torvalds wrote:

>However, what I'm really missing is converting local variables that 
>haven't had their address taken into pseudo's. I assume that there is some 
>trivial algorithm for that - it _sounds_ like it should be easy to do, but 
>I've got no clue.
>  
>
That would be most excellent!

>Does anybody have a clue-bat for me? Something that takes a symbol that we 
>know is "well-behaved" (trivially testable by just verifying that its 
>address has never been taken, and that it's an automatic variable), and 
>just convert it into a pseudo instead of a real symbol?
>
>I was thinking of something that creates a new pseudo for each assignment, 
>and then a phi-node for each read depending on reachability. It _sounds_ 
>like that is a valid thing to do, but I have this suspicion that I'm a 
>retard and that I'm missing something..
>  
>
I'm not sure which "reads" you're refering to?  Surely you don't want a 
phi assignment for each use?

What I did on sparse as it looked 18 months ago was very simple: for 
every non-static variable which didn't have it's address taken 
(externals are static too) I allocated a pseudo everytime the variable 
was defined (= assigned) and replaced all uses with the pseudo 
representing the current value.  At the beginning of all basic blocks I 
inserted phi assignments where all the definitions met.  Note:
- I changed the linearization pass to not generate the memory operations 
for those variables
- More than necessary phi assignments were inserted because I didn't 
prune phi assignments there weren't used (easy to add) and I didn't 
optimize for phi assigments where all arguments were the same (j = 
phi(i, i, i)).
- You'll pretty much have to know about loops or be prepared to iterate 
until the set of phi assignments reaches a fixpoint.  I implemented a 
version of Havlak's loop classification for that purpose.  Should I work 
on getting it in a shape for inclusion in sparse?

This essentially realizes the SSA form.  There are better algorithms for 
this, but they are more complicated.

Tommy

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: prettier linearized output?
Date: Mon, 01 Nov 2004 21:14:34 +0000
Message-ID: <Pine.LNX.4.58.0411011300350.28839 () ppc970 ! osdl ! org>
--------------------


On Mon, 1 Nov 2004, Tommy Thorn wrote:
> >I was thinking of something that creates a new pseudo for each assignment, 
> >and then a phi-node for each read depending on reachability. It _sounds_ 
> >like that is a valid thing to do, but I have this suspicion that I'm a 
> >retard and that I'm missing something..
>
> I'm not sure which "reads" you're refering to?  Surely you don't want a 
> phi assignment for each use?

I don't see how to avoid that, except in the trivial case.

Basically, my algorithm would be (for each "well-behaved" symbol:
 - for_each_basic_block() {
	struct instruction *assign = NULL;
	for_each_instruction(bb) {
		if (phinode of this symbol)
			assign = insns;
		else if assignment to 'sym' {
			create new pseudo;
			insert newinsn 'def'
			assign = def
		}
	}
	/* Did we have an assignment in this basic block? */
	if (assign) {
		for_each_child(bb) {
			if (firstinstr = phi-node for this sym) {
				if (assign not in phi-list)
					add to phi-list
			} else {
				insert phi-node for this sym with
				one phi-entry (assign)
			}
		]
	}

which seems to be good.

Afterwards, go through all the phi-nodes and simplify them (ie if they are
single-entry lists, just replace the pseudo with the single pseudo that
defined them).

> What I did on sparse as it looked 18 months ago was very simple: for 
> every non-static variable which didn't have it's address taken 
> (externals are static too) I allocated a pseudo everytime the variable 
> was defined (= assigned) and replaced all uses with the pseudo 
> representing the current value.  At the beginning of all basic blocks I 
> inserted phi assignments where all the definitions met.

That sounds equivalent.  No?

> - You'll pretty much have to know about loops or be prepared to iterate 
> until the set of phi assignments reaches a fixpoint.  I implemented a 
> version of Havlak's loop classification for that purpose.  Should I work 
> on getting it in a shape for inclusion in sparse?

Why would I have to care about loops? The above seems to be linear in
instructions + edges*defs (for each symbol, so I guess it's not exactly
cheap) and looks like it should work to me. It never recurses anywhere.

But for all I know, I'm missing something.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: printf("hello world") ===

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: printf("hello world")
Date: Thu, 08 Jul 2004 01:57:32 +0000
Message-ID: <Pine.LNX.4.44.0407072103100.17815-100000 () nondot ! org>
--------------------

Hi Sparsers,

I recently found out about Sparse and am quite excited about it.  Are you
guys familiar with LLVM (http://llvm.org/)?  Judging by the FAQ in your
tarball, sparse and LLVM have very very similar goals.  In the case of
LLVM, we have started with re-engineering the optimizer and backend,
but haven't done anything substantial with the front-end.

Have you considered using LLVM as the backend for sparse?  You appear to
already be generating virtually perfect LLVM code (the IR in linearize.h
is almost identical to the LLVM IR).  From this you could either emit a
.ll file, or (for efficiency) link directly to an LLVM backend.  Doing so
would give you access to the wealth of LLVM optimizations, whole-program
and runtime optzn capabilities, and all of the LLVM native code
generators (currently X86 and Sparc, with PPC and a couple others on the
way).

In any case, I would really love to hear what your plans are for Sparse.
I'm dreaming of a day when llvmgcc can be used only for C++ support... and
someday perhaps not even that.

-Chris

-- 
http://llvm.cs.uiuc.edu/
http://www.nondot.org/~sabre/Projects/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: tommy () numba-tu ! com
To: linux-sparse
Subject: Re: printf("hello world")
Date: Thu, 08 Jul 2004 02:05:54 +0000
Message-ID: <4950.65.113.40.130.1089252354.squirrel () numba-tu ! com>
--------------------
Hi Chris,

at least some of us are well aware of LLVM, and though I don't see sparse
ever integrating with LLVM, there's nothing stopping a motivated hacker
from hooking the two together.  BTW, it's no accident that the current
backend matches so well - it's by design, Chris Li's design.

I can only speak for me, but I'm investigating a different path, using a
GSA form.  So far it looks very promising, but I haven't released any code
yet, and when (if) I do, it's far from certain that Linus will adopt it in
his tree.

If anyone want to discuss GSA and the stuff I've been working on send me a
personal note as it doesn't seem to interest the majority of this list.

Cheers,
Tommy



> Hi Sparsers,
>
> I recently found out about Sparse and am quite excited about it.  Are you
> guys familiar with LLVM (http://llvm.org/)?  Judging by the FAQ in your
> tarball, sparse and LLVM have very very similar goals.  In the case of
> LLVM, we have started with re-engineering the optimizer and backend,
> but haven't done anything substantial with the front-end.
>
> Have you considered using LLVM as the backend for sparse?  You appear to
> already be generating virtually perfect LLVM code (the IR in linearize.h
> is almost identical to the LLVM IR).  From this you could either emit a
> .ll file, or (for efficiency) link directly to an LLVM backend.  Doing so
> would give you access to the wealth of LLVM optimizations, whole-program
> and runtime optzn capabilities, and all of the LLVM native code
> generators (currently X86 and Sparc, with PPC and a couple others on the
> way).
>
> In any case, I would really love to hear what your plans are for Sparse.
> I'm dreaming of a day when llvmgcc can be used only for C++ support... and
> someday perhaps not even that.
>
> -Chris
>
> --
> http://llvm.cs.uiuc.edu/
> http://www.nondot.org/~sabre/Projects/
>
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
>

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: printf("hello world")
Date: Thu, 08 Jul 2004 02:22:48 +0000
Message-ID: <Pine.LNX.4.44.0407072119290.18256-100000 () nondot ! org>
--------------------
On Wed, 7 Jul 2004 tommy@numba-tu.com wrote:
> Hi Chris,
> at least some of us are well aware of LLVM, and though I don't see sparse
> ever integrating with LLVM, there's nothing stopping a motivated hacker
> from hooking the two together.  BTW, it's no accident that the current
> backend matches so well - it's by design, Chris Li's design.

Can you give more detail about why you don't ever see sparse integrating
with LLVM?  They seem to be such a perfect match on all levels.  Is it
just that Sparse is intended more as a checker tool than as an end-to-end
compiler?


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: printf("hello world")
Date: Thu, 08 Jul 2004 04:45:46 +0000
Message-ID: <20040708044546.GA23627 () 64m ! dyndns ! org>
--------------------
On Wed, Jul 07, 2004 at 07:05:54PM -0700, tommy@numba-tu.com wrote:
> at least some of us are well aware of LLVM, and though I don't see sparse
> ever integrating with LLVM, there's nothing stopping a motivated hacker
> from hooking the two together.  BTW, it's no accident that the current
> backend matches so well - it's by design, Chris Li's design.
> 

Ha, I miss a great thread today. Yes, I toke the IR similar to LLVM
and I want to make sparse generate LLVM compatible asm code. We can
have something to verify and compare with.
On the other hand, integrating with LLVM is not the ultimate goal for me.

No offense but I don't like the C++ implementation  of LLVM, especial
the heavy use of template.

Speak of the current status of my sparse hacking relate to generate
LLVM compatible code, I think the only big piece missing is generating
the get element ptr instruction. Sparse front end do the sized pointer
evaluate very early, so reconstruct and the path to get to the sub
element is a little massive. I try to find a cleaner way out and not
hurt the checking part of the story.  That is what I have been left
two months ago. I have been beat up so heavily I did not have chance
to make some real progress recently.

But things is getting much better now, I can spent some time hacking
on sparse again. It has been great fun.


> I can only speak for me, but I'm investigating a different path, using a
> GSA form.  So far it looks very promising, but I haven't released any code
> yet, and when (if) I do, it's far from certain that Linus will adopt it in
> his tree.

I am taking baby steps since I am still learning the compiler.
Tommy has a more ambition plan in mind. I just want the infrastructure
here can allow Tommy's back end or the less ambition multi-pass approach.

I can't say I understand Tommy's GSA yet but it looks very cool.

Chris

> 
> > Hi Sparsers,
> >
> > I recently found out about Sparse and am quite excited about it.  Are you
> > guys familiar with LLVM (http://llvm.org/)?  Judging by the FAQ in your
> > tarball, sparse and LLVM have very very similar goals.  In the case of
> > LLVM, we have started with re-engineering the optimizer and backend,
> > but haven't done anything substantial with the front-end.
> >
> > Have you considered using LLVM as the backend for sparse?  You appear to
> > already be generating virtually perfect LLVM code (the IR in linearize.h
> > is almost identical to the LLVM IR).  From this you could either emit a
> > .ll file, or (for efficiency) link directly to an LLVM backend.  Doing so
> > would give you access to the wealth of LLVM optimizations, whole-program
> > and runtime optzn capabilities, and all of the LLVM native code
> > generators (currently X86 and Sparc, with PPC and a couple others on the
> > way).
> >
> > In any case, I would really love to hear what your plans are for Sparse.
> > I'm dreaming of a day when llvmgcc can be used only for C++ support... and
> > someday perhaps not even that.
> >
> > -Chris
> >
> > --
> > http://llvm.cs.uiuc.edu/
> > http://www.nondot.org/~sabre/Projects/
> >
> > -
> > To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> > the body of a message to majordomo@vger.kernel.org
> > More majordomo info at  http://vger.kernel.org/majordomo-info.html
> >
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: printf("hello world")
Date: Thu, 08 Jul 2004 05:14:51 +0000
Message-ID: <Pine.LNX.4.58.0407072206350.1764 () ppc970 ! osdl ! org>
--------------------


On Wed, 7 Jul 2004, Chris Lattner wrote:
> 
> Can you give more detail about why you don't ever see sparse integrating
> with LLVM?  They seem to be such a perfect match on all levels.  Is it
> just that Sparse is intended more as a checker tool than as an end-to-end
> compiler?

I would love to have a back-end, and I don't personally much care _what_ 
back-end, as one of my main reasons for wanting a back-end at all is just 
verification.

The front-end does a fairly good job these days, but the fact is that it
hasn't really been _tested_ on anything than the checker thing, which
means that while I know the types are "roughly" correct, I also bet there
are a ton of silly bugs in the details that arise from just the simple
fact that the checker part doesn't care that deeply about types.

For example, I've tried to make it do all the right things for structure 
member offset calculations etc, but all of that is totally irrelevant to 
kernel source code checking, so _none_ of it has ever really been tested.

Being able to compile a real program would probably find a _lot_ of small 
bugs in the front-end, and as such I'd love to have even a stupid 
back-end.

> Anyway, I'm just curious what is in store for the future of Sparse.  Is it
> to become a full fledged compiler?  If not, why is the continuing
> optimization/codegen work?

One of the things I feel strongly about is the fact that it's really a 
front-end, and try to keep the back-end somewhat separate (possibly a 
separate project altogether, but even if it's integrated into the sparse 
source tree, I'd like to put it in a separate subdirectory etc). 

As to code-gen: see above. I did a stupid pseudo-code-generator in one of
the very earliest versions, just because it was the easiest way to
validate that the parse tree was at all sensible. But having a pseudo- 
code generator that you can eyeball the result for is a lot less testable 
than having a real one where you can just test whether it worked or not.

And yes, I'd love to eventually make sparse a real compiler. It's not the 
primary objective, but it wouldn't hurt to have more free compilers out 
there.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: printf("hello world")
Date: Thu, 08 Jul 2004 05:28:11 +0000
Message-ID: <20040708052811.GB23627 () 64m ! dyndns ! org>
--------------------
On Thu, Jul 08, 2004 at 01:58:48AM -0500, Chris Lattner wrote:

> 
> In any case, if anyone is interested in this (perhaps the other Chris L?
> :) ), I would be happy to help in a secondary role.

Agree.

Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: printf("hello world")
Date: Thu, 08 Jul 2004 06:58:48 +0000
Message-ID: <Pine.LNX.4.44.0407080146470.21917-100000 () nondot ! org>
--------------------
On Wed, 7 Jul 2004, Linus Torvalds wrote:
> On Wed, 7 Jul 2004, Chris Lattner wrote:
> >
> > Can you give more detail about why you don't ever see sparse integrating
> > with LLVM?  They seem to be such a perfect match on all levels.  Is it
> > just that Sparse is intended more as a checker tool than as an end-to-end
> > compiler?
>
> I would love to have a back-end, and I don't personally much care _what_
> back-end, as one of my main reasons for wanting a back-end at all is just
> verification.

Understood.

> The front-end does a fairly good job these days, but the fact is that it
> hasn't really been _tested_ on anything than the checker thing, which
> means that while I know the types are "roughly" correct, I also bet there
> are a ton of silly bugs in the details that arise from just the simple
> fact that the checker part doesn't care that deeply about types.

I agree.  From my perspective, running the code through a backend and
being able to actually execute the compiled code seems like the only real
way to do end-to-end testing of the front-end.  It certainly makes finding
test cases simpler. :)

> Being able to compile a real program would probably find a _lot_ of small
> bugs in the front-end, and as such I'd love to have even a stupid
> back-end.

Agreed.

> > Anyway, I'm just curious what is in store for the future of Sparse.  Is it
> > to become a full fledged compiler?  If not, why is the continuing
> > optimization/codegen work?
>
> One of the things I feel strongly about is the fact that it's really a
> front-end, and try to keep the back-end somewhat separate (possibly a
> separate project altogether, but even if it's integrated into the sparse
> source tree, I'd like to put it in a separate subdirectory etc).

That makes an incredible amount of sense, and that's what I like about
Sparse: it's the exact same design as we are using for LLVM.  LLVM is a
very modular system, where all of the optimizations are indepedent of each
other and which are independent from all of the backends.  This is a very
important design goal of LLVM and runs deeply through it.

> And yes, I'd love to eventually make sparse a real compiler. It's not the
> primary objective, but it wouldn't hurt to have more free compilers out
> there.

I think that you are definitely understating the value of a solid and fast
replacement for GCC.  End users are clearly fed up with many of the
fundamental design decisions made in GCC and the GCC developers show
little interest in changing them.


================================================================================


################################################################################

=== Thread: replace_by_integer ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: replace_by_integer
Date: Tue, 21 Sep 2004 14:51:27 +0000
Message-ID: <20040921145127.B73461422D58 () darter ! rentec ! com>
--------------------


Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/janitorial

This will update the following files:

 pre-process.c |    4 ++--
 1 files changed, 2 insertions(+), 2 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/09/21 1.798)
   Fix replace_by_integer.

diff -Nru a/pre-process.c b/pre-process.c
--- a/pre-process.c	2004-09-21 10:51:05 -04:00
+++ b/pre-process.c	2004-09-21 10:51:05 -04:00
@@ -87,8 +87,8 @@
 
 static void replace_with_integer(struct token *token, unsigned int val)
 {
-	char *buf = __alloc_bytes(10);
-	sprintf(buf, "%d", val);
+	char *buf = __alloc_bytes(11);
+	sprintf(buf, "%u", val);
 	token_type(token) = TOKEN_NUMBER;
 	token->number = buf;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: simple Question ===

From: "Alvin Antony" <Alvin.Antony () internet ! lmu ! de>
To: struts-user
Subject: simple Question
Date: Fri, 16 Jul 2004 12:14:59 +0000
Message-ID: <s0f7e2ff.028 () ip1 ! internet ! lmu ! de>
--------------------
hi friends,
          how can i prevent the user from refreshing the page and repeating the save process a second time?. Is the Transaction token is good for checking this? 

thanks a lot,
Alvin

________________________________________________________________
Alvin Antony
Software Engineer

Ludwig-Maximilians-Universitaet Mnchen
Zentrale Universitaetsverwaltung
Referat IIIA 3 (Anwendungs Entwicklung)
Theresienstr. 37 / 2. Stock  Zi. 249
80333 Muenchen

phone  +49 (089) 2180 - 4005
        
mail      alvin.antony@Verwaltung.Uni-muenchen.de 
web     http://informationstechnik.verwaltung.uni-muenchen.de 

>>> bulandaltaf_pk@yahoo.com 16.07.04 13.14 >>>
Dear,

First u need to set the hyperlink of the action(in
which u have implemented delete method logic) on the
primary key basis through which u will delete the
record and create an action forard in struts config
file(action of the class in which u have implementated
the logic to diaplay records in the view) and forward
to that action from delete method.

---------------- Struits-config.xml ----------------
<forward name="viewAction"
type="viewAction.do?parameter=methodName">
-----------------------------------------------------

------------------- View ----------------------------
<a href="deleteAction.do?primaryKey=xyz"> Delete </a>
(or use struts link tag)
-----------------------------------------------------

from delete action u need to forward to viewAction and
all display logic will be there.

Plz let me know in case of any inconvenience/problem.

regards,
Buland

--- Jon Barber <jon.barber@acm.org> wrote:
> Dear All,
> 
> Trawled through the archive with no luck, but then I
> couldn't work out
> the best search terms for this question, so.......
> 
> I'm writing a shopping basket app with the usual
> requirements, and using
> tiles which has made things a lot less painful.
> However, I have this one
> problem that I can't work out a nice way to solve.
> 
> On every page of the basket the contents of the
> basket are shown in a
> panel at the bottom of the page, and against each
> product is a 'delete'
> hyperlink.  When the user clicks on this link the
> product should be
> removed and the page refreshed to show the modified
> info.
> 
> My question is - how to code the logic to do the
> deletion of the product
> in such a way that the refreshing of the page is
> handled in a nice way ?
> I have the usual way of using an Action to populate
> the contexts to
> render the page, and then an Action to process the
> users response. When
> a product is removed I will have to delete the
> product & then redirect
> the user back to the Action to populate the page all
> over again.
> 
> As far as I can see I have 2 options :
> 
> 1. Have one Action that performs the product removal
> and that accepts a
> URL as a parameter that then redirects the user
> using that URL. I will
> have to place the necessary URL in the context so
> that when the page is
> rendered the redirect URL is set correctly for
> wherever the user is.
> Painful & not very nice - every populate Action will
> have to put the
> correct URL for itself into the context.
> 
> 2. Have a seperate Action for every single delete
> page so that each
> instance knows where to send the user back to. Not
> much different from 1
> & leads to a lot of Actions.
> 
> Any ideas ? 
> 
> Am I missing the obvious ? For example, for 1 can I
> simply use the
> present request URL as the URL to redirect the user
> to to redraw the
> page ?
> 
> Jon.
> 
>
---------------------------------------------------------------------
> To unsubscribe, e-mail:
> user-unsubscribe@struts.apache.org
> For additional commands, e-mail:
> user-help@struts.apache.org
> 
> 


=====

Buland Altaf Malik,
Software Engineer, 
Softech System's(pvt)Ltd. 
10/25 asad jan road lahore,cantt - 54810 Pakistan
Tel: 92-42-6665812 , 92-42-6660802

Mob: 0333-4344113
Fax: 92-42-6665792

http://www.softech.com.pk
buland_altaf@hotmail.com




		
__________________________________
Do you Yahoo!?
Yahoo! Mail is new and improved - Check it out!
http://promotions.yahoo.com/new_mail

---------------------------------------------------------------------
To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
For additional commands, e-mail: user-help@struts.apache.org



---------------------------------------------------------------------
To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
For additional commands, e-mail: user-help@struts.apache.org


================================================================================

From: "Geeta Ramani" <gramani () terralink ! com>
To: struts-user
Subject: RE: simple Question
Date: Fri, 16 Jul 2004 12:19:26 +0000
Message-ID: <DDCE91EE629CD311B4DA006094B997B967F1CB () zeus ! terralink ! com>
--------------------
Hi Alvin: 

This question has appeared a few times, so you may benefit from searching the archives. Short answer(s): either use tokens (like you suggested) or use a redirect instead of a forward.

Regards,
Geeta

> -----Original Message-----
> From: Alvin Antony [mailto:Alvin.Antony@internet.lmu.de]
> Sent: Friday, July 16, 2004 8:15 AM
> To: user@struts.apache.org
> Subject: simple Question
> 
> 
> hi friends,
>           how can i prevent the user from refreshing the page 
> and repeating the save process a second time?. Is the 
> Transaction token is good for checking this? 
> 
> thanks a lot,
> Alvin
> 
> ________________________________________________________________
> Alvin Antony
> Software Engineer
> 
> Ludwig-Maximilians-Universitaet Mnchen
> Zentrale Universitaetsverwaltung
> Referat IIIA 3 (Anwendungs Entwicklung)
> Theresienstr. 37 / 2. Stock  Zi. 249
> 80333 Muenchen
> 
> phone  +49 (089) 2180 - 4005
>         
> mail      alvin.antony@Verwaltung.Uni-muenchen.de 
> web     http://informationstechnik.verwaltung.uni-muenchen.de 
> 
> >>> bulandaltaf_pk@yahoo.com 16.07.04 13.14 >>>
> Dear,
> 
> First u need to set the hyperlink of the action(in
> which u have implemented delete method logic) on the
> primary key basis through which u will delete the
> record and create an action forard in struts config
> file(action of the class in which u have implementated
> the logic to diaplay records in the view) and forward
> to that action from delete method.
> 
> ---------------- Struits-config.xml ----------------
> <forward name="viewAction"
> type="viewAction.do?parameter=methodName">
> -----------------------------------------------------
> 
> ------------------- View ----------------------------
> <a href="deleteAction.do?primaryKey=xyz"> Delete </a>
> (or use struts link tag)
> -----------------------------------------------------
> 
> from delete action u need to forward to viewAction and
> all display logic will be there.
> 
> Plz let me know in case of any inconvenience/problem.
> 
> regards,
> Buland
> 
> --- Jon Barber <jon.barber@acm.org> wrote:
> > Dear All,
> > 
> > Trawled through the archive with no luck, but then I
> > couldn't work out
> > the best search terms for this question, so.......
> > 
> > I'm writing a shopping basket app with the usual
> > requirements, and using
> > tiles which has made things a lot less painful.
> > However, I have this one
> > problem that I can't work out a nice way to solve.
> > 
> > On every page of the basket the contents of the
> > basket are shown in a
> > panel at the bottom of the page, and against each
> > product is a 'delete'
> > hyperlink.  When the user clicks on this link the
> > product should be
> > removed and the page refreshed to show the modified
> > info.
> > 
> > My question is - how to code the logic to do the
> > deletion of the product
> > in such a way that the refreshing of the page is
> > handled in a nice way ?
> > I have the usual way of using an Action to populate
> > the contexts to
> > render the page, and then an Action to process the
> > users response. When
> > a product is removed I will have to delete the
> > product & then redirect
> > the user back to the Action to populate the page all
> > over again.
> > 
> > As far as I can see I have 2 options :
> > 
> > 1. Have one Action that performs the product removal
> > and that accepts a
> > URL as a parameter that then redirects the user
> > using that URL. I will
> > have to place the necessary URL in the context so
> > that when the page is
> > rendered the redirect URL is set correctly for
> > wherever the user is.
> > Painful & not very nice - every populate Action will
> > have to put the
> > correct URL for itself into the context.
> > 
> > 2. Have a seperate Action for every single delete
> > page so that each
> > instance knows where to send the user back to. Not
> > much different from 1
> > & leads to a lot of Actions.
> > 
> > Any ideas ? 
> > 
> > Am I missing the obvious ? For example, for 1 can I
> > simply use the
> > present request URL as the URL to redirect the user
> > to to redraw the
> > page ?
> > 
> > Jon.
> > 
> >
> ---------------------------------------------------------------------
> > To unsubscribe, e-mail:
> > user-unsubscribe@struts.apache.org
> > For additional commands, e-mail:
> > user-help@struts.apache.org
> > 
> > 
> 
> 
> =====
> 
> Buland Altaf Malik,
> Software Engineer, 
> Softech System's(pvt)Ltd. 
> 10/25 asad jan road lahore,cantt - 54810 Pakistan
> Tel: 92-42-6665812 , 92-42-6660802
> 
> Mob: 0333-4344113
> Fax: 92-42-6665792
> 
> http://www.softech.com.pk
> buland_altaf@hotmail.com
> 
> 
> 
> 
> 		
> __________________________________
> Do you Yahoo!?
> Yahoo! Mail is new and improved - Check it out!
> http://promotions.yahoo.com/new_mail
> 
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
> For additional commands, e-mail: user-help@struts.apache.org
> 
> 
> 
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
> For additional commands, e-mail: user-help@struts.apache.org
> 
> 

---------------------------------------------------------------------
To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
For additional commands, e-mail: user-help@struts.apache.org


================================================================================

From: Paul McCulloch <paul.mcculloch () axiossystems ! com>
To: struts-user
Subject: RE: simple Question
Date: Fri, 16 Jul 2004 12:28:22 +0000
Message-ID: <7EBA35CAB674CF439C47F17AF5A7090101821F41 () edn-exc-01 ! axiossystems ! com>
--------------------
I use a two pronged approach:
1) After a save do a redirecting forward. This means that refresh will not
resubmit the save process.
2) Use tokens so that if somehow the user manages to resubmit the save
process you can intercept this.

Paul

> -----Original Message-----
> From: Alvin Antony [mailto:Alvin.Antony@internet.lmu.de]
> Sent: 16 July 2004 13:15
> To: user@struts.apache.org
> Subject: simple Question
> 
> 
> hi friends,
>           how can i prevent the user from refreshing the page 
> and repeating the save process a second time?. Is the 
> Transaction token is good for checking this? 
> 
> thanks a lot,
> Alvin
> 
> ________________________________________________________________
> Alvin Antony
> Software Engineer
> 
> Ludwig-Maximilians-Universitaet Mnchen
> Zentrale Universitaetsverwaltung
> Referat IIIA 3 (Anwendungs Entwicklung)
> Theresienstr. 37 / 2. Stock  Zi. 249
> 80333 Muenchen
> 
> phone  +49 (089) 2180 - 4005
>         
> mail      alvin.antony@Verwaltung.Uni-muenchen.de 
> web     http://informationstechnik.verwaltung.uni-muenchen.de 
> 
> >>> bulandaltaf_pk@yahoo.com 16.07.04 13.14 >>>
> Dear,
> 
> First u need to set the hyperlink of the action(in
> which u have implemented delete method logic) on the
> primary key basis through which u will delete the
> record and create an action forard in struts config
> file(action of the class in which u have implementated
> the logic to diaplay records in the view) and forward
> to that action from delete method.
> 
> ---------------- Struits-config.xml ----------------
> <forward name="viewAction"
> type="viewAction.do?parameter=methodName">
> -----------------------------------------------------
> 
> ------------------- View ----------------------------
> <a href="deleteAction.do?primaryKey=xyz"> Delete </a>
> (or use struts link tag)
> -----------------------------------------------------
> 
> from delete action u need to forward to viewAction and
> all display logic will be there.
> 
> Plz let me know in case of any inconvenience/problem.
> 
> regards,
> Buland
> 
> --- Jon Barber <jon.barber@acm.org> wrote:
> > Dear All,
> > 
> > Trawled through the archive with no luck, but then I
> > couldn't work out
> > the best search terms for this question, so.......
> > 
> > I'm writing a shopping basket app with the usual
> > requirements, and using
> > tiles which has made things a lot less painful.
> > However, I have this one
> > problem that I can't work out a nice way to solve.
> > 
> > On every page of the basket the contents of the
> > basket are shown in a
> > panel at the bottom of the page, and against each
> > product is a 'delete'
> > hyperlink.  When the user clicks on this link the
> > product should be
> > removed and the page refreshed to show the modified
> > info.
> > 
> > My question is - how to code the logic to do the
> > deletion of the product
> > in such a way that the refreshing of the page is
> > handled in a nice way ?
> > I have the usual way of using an Action to populate
> > the contexts to
> > render the page, and then an Action to process the
> > users response. When
> > a product is removed I will have to delete the
> > product & then redirect
> > the user back to the Action to populate the page all
> > over again.
> > 
> > As far as I can see I have 2 options :
> > 
> > 1. Have one Action that performs the product removal
> > and that accepts a
> > URL as a parameter that then redirects the user
> > using that URL. I will
> > have to place the necessary URL in the context so
> > that when the page is
> > rendered the redirect URL is set correctly for
> > wherever the user is.
> > Painful & not very nice - every populate Action will
> > have to put the
> > correct URL for itself into the context.
> > 
> > 2. Have a seperate Action for every single delete
> > page so that each
> > instance knows where to send the user back to. Not
> > much different from 1
> > & leads to a lot of Actions.
> > 
> > Any ideas ? 
> > 
> > Am I missing the obvious ? For example, for 1 can I
> > simply use the
> > present request URL as the URL to redirect the user
> > to to redraw the
> > page ?
> > 
> > Jon.
> > 
> >
> ---------------------------------------------------------------------
> > To unsubscribe, e-mail:
> > user-unsubscribe@struts.apache.org
> > For additional commands, e-mail:
> > user-help@struts.apache.org
> > 
> > 
> 
> 
> =====
> 
> Buland Altaf Malik,
> Software Engineer, 
> Softech System's(pvt)Ltd. 
> 10/25 asad jan road lahore,cantt - 54810 Pakistan
> Tel: 92-42-6665812 , 92-42-6660802
> 
> Mob: 0333-4344113
> Fax: 92-42-6665792
> 
> http://www.softech.com.pk
> buland_altaf@hotmail.com
> 
> 
> 
> 
> 		
> __________________________________
> Do you Yahoo!?
> Yahoo! Mail is new and improved - Check it out!
> http://promotions.yahoo.com/new_mail
> 
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
> For additional commands, e-mail: user-help@struts.apache.org
> 
> 
> 
> ---------------------------------------------------------------------
> To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
> For additional commands, e-mail: user-help@struts.apache.org
> 


**********************************************************************
Axios Email Confidentiality Footer
Privileged/Confidential Information may be contained in this message. If you are not the addressee indicated in this message (or responsible for delivery of the message to such person), you may not copy or deliver this message to anyone. In such case, you should destroy this message, and notify us immediately. If you or your employer does not consent to Internet email messages of this kind, please advise us immediately. Opinions, conclusions and other information expressed in this message are not given or endorsed by my Company or employer unless otherwise indicated by an authorised representative independent of this message.
WARNING:
While Axios Systems Ltd takes steps to prevent computer viruses from being transmitted via electronic mail attachments we cannot guarantee that attachments do not contain computer virus code.  You are therefore strongly advised to undertake anti virus checks prior to accessing the attachment to this electronic mail.  Axios Systems Ltd grants no warranties regarding performance use or quality of any attachment and undertakes no liability for loss or damage howsoever caused.
**********************************************************************


---------------------------------------------------------------------
To unsubscribe, e-mail: user-unsubscribe@struts.apache.org
For additional commands, e-mail: user-help@struts.apache.org


================================================================================


################################################################################

=== Thread: simple question ===

From: "Mercadante, Thomas F" <thomas.mercadante () labor ! state ! ny ! us>
To: oracle-l
Subject: RE: simple question
Date: Thu, 08 Jan 2004 20:39:35 +0000
Message-ID: <F001.005DC2CE.20040108123935 () fatcity ! com>
--------------------
This message is in MIME format. Since your mail reader does not understand
this format, some or all of this message may not be legible.

------_=_NextPart_001_01C3D627.6CF0B00C
Content-Type: text/plain

Remove the  
 
r number(10);
 
and it should be fine.
 

Tom Mercadante 
Oracle Certified Professional 

-----Original Message-----
Sent: Thursday, January 08, 2004 3:24 PM
To: Multiple recipients of list ORACLE-L


CREATE OR REPLACE PROCEDURE labware_admin.truncate_tables
(
    schema_owner        IN VARCHAR2
) 
AS
   r number(10);
BEGIN
FOR r IN (SELECT table_name FROM dba_tables WHERE owner=schema_owner)
  LOOP
    EXECUTE IMMEDIATE 'truncate table schema_owner.'||r.table_name;
  END LOOP;
END;  
 
 
ERROR:  Line 14 Column 55 PLS-00364: loop index variable 'R' use is invalid.
 
 
Any ideas?
 
Thank you!
 
 



  _____  

Do you Yahoo!?
Yahoo! Hotjobs: Enter
<http://pa.yahoo.com/*http://us.rd.yahoo.com/hotjobs/mail_footer_email/evt=2
1482/*http://hotjobs.sweepstakes.yahoo.com/signingbonus> the "Signing Bonus"
Sweepstakes


------_=_NextPart_001_01C3D627.6CF0B00C
Content-Type: text/html
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META HTTP-EQUIV=3D"Content-Type" CONTENT=3D"text/html; =
charset=3DUS-ASCII">


<META content=3D"MSHTML 5.50.4933.1800" name=3DGENERATOR></HEAD>
<BODY>
<DIV><FONT face=3DArial color=3D#0000ff size=3D2><SPAN =
class=3D637362820-08012004>Remove=20
the&nbsp; </SPAN></FONT></DIV>
<DIV><FONT face=3DArial color=3D#0000ff size=3D2><SPAN=20
class=3D637362820-08012004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial color=3D#0000ff size=3D2><SPAN =
class=3D637362820-08012004>r=20
number(10);</SPAN></FONT></DIV>
<DIV><FONT face=3DArial color=3D#0000ff size=3D2><SPAN=20
class=3D637362820-08012004></SPAN></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial color=3D#0000ff size=3D2><SPAN =
class=3D637362820-08012004>and it=20
should be fine.</SPAN></FONT></DIV>
<DIV><FONT face=3DArial color=3D#0000ff size=3D2></FONT>&nbsp;</DIV>
<P><FONT face=3DArial size=3D2>Tom Mercadante</FONT> <BR><FONT =
face=3DArial=20
size=3D2>Oracle Certified Professional</FONT> </P>
<BLOCKQUOTE>
  <DIV class=3DOutlookMessageHeader dir=3Dltr align=3Dleft><FONT =
face=3DTahoma=20
  size=3D2>-----Original Message-----<BR><B>From:</B> oranew2004=20
  [mailto:oranew2004@yahoo.com]<BR><B>Sent:</B> Thursday, January 08, =
2004 3:24=20
  PM<BR><B>To:</B> Multiple recipients of list =
ORACLE-L<BR><B>Subject:</B> Re:=20
  simple question<BR><BR></FONT></DIV>
  <DIV>CREATE OR REPLACE PROCEDURE=20
  labware_admin.truncate_tables<BR>(<BR>&nbsp;&nbsp;&nbsp;=20
  schema_owner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IN =
VARCHAR2<BR>)=20
  <BR>AS</DIV>
  <DIV>&nbsp;&nbsp; r number(10);</DIV>
  <DIV>BEGIN</DIV>
  <DIV>FOR r IN (SELECT table_name FROM dba_tables WHERE=20
  owner=3Dschema_owner)<BR>&nbsp; LOOP<BR>&nbsp;&nbsp;&nbsp; EXECUTE =
IMMEDIATE=20
  'truncate table schema_owner.'||r.table_name;<BR>&nbsp; END =
LOOP;</DIV>
  <DIV>END;&nbsp; </DIV>
  <DIV>&nbsp;</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>ERROR:&nbsp; Line 14 Column 55 PLS-00364: loop index variable =
'R' use is=20
  invalid.</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>Any ideas?</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>Thank you!</DIV>
  <DIV>&nbsp;</DIV>
  <DIV>&nbsp;</DIV>
  <P>
  <HR SIZE=3D1>
  Do you Yahoo!?<BR>Yahoo! Hotjobs: <A=20
  =
href=3D"http://pa.yahoo.com/*http://us.rd.yahoo.com/hotjobs/mail_footer_=
email/evt=3D21482/*http://hotjobs.sweepstakes.yahoo.com/signingbonus">En=
ter=20
  the "Signing Bonus" Sweepstakes</A></BLOCKQUOTE></BODY></HTML>

------_=_NextPart_001_01C3D627.6CF0B00C--
-- 
Please see the official ORACLE-L FAQ: http://www.orafaq.net
-- 
Author: Mercadante, Thomas F
  INET: thomas.mercadante@labor.state.ny.us

Fat City Network Services    -- 858-538-5051 http://www.fatcity.com
San Diego, California        -- Mailing list and web hosting services
---------------------------------------------------------------------
To REMOVE yourself from this mailing list, send an E-Mail message
to: ListGuru@fatcity.com (note EXACT spelling of 'ListGuru') and in
the message BODY, include a line containing: UNSUB ORACLE-L
(or the name of mailing list you want to be removed from).  You may
also send the HELP command for other information (like subscribing).
================================================================================

From: <Stephen.Lee () DTAG ! Com>
To: oracle-l
Subject: RE: simple question
Date: Thu, 08 Jan 2004 21:04:29 +0000
Message-ID: <F001.005DC2D7.20040108130429 () fatcity ! com>
--------------------
I'll add that if you have foreign keys, they will mess you up.  Here is an
old script I have in my stash that you can modify with info already provided
by others.

procedure truncate_all(code_word in varchar2 default 'XXX') is
   cursor c1 is select table_name,constraint_name from user_constraints
where constraint_type = 'R';
   cursor c2 is select table_name from user_tables;
   handle integer;
   rows integer;
begin
   if code_word != 'NUKE' then
      raise_application_error(-20001, 'WRONG MAGIC WORD, BUCKWHEAT.');
   end if;
   dbms_output.enable(100000);
   handle := dbms_sql.open_cursor;
   for t in c1 loop
      dbms_sql.parse(handle,'alter table '||t.table_name||' disable
constraint '||t.constraint_name, dbms_sql.native);
      rows := dbms_sql.execute(handle);
   end loop;
   for t in c2 loop
      dbms_sql.parse(handle,'truncate table '||t.table_name,
dbms_sql.native);
      rows := dbms_sql.execute(handle);
   end loop;
   for t in c1 loop
      dbms_sql.parse(handle,'alter table '||t.table_name||' enable
constraint '||t.constraint_name, dbms_sql.native);
      rows := dbms_sql.execute(handle);
   end loop;
exception
   when others then
      dbms_output.put_line(SQLCODE||': '||SQLERRM);
end;
-- 
Please see the official ORACLE-L FAQ: http://www.orafaq.net
-- 
Author: <Stephen.Lee@DTAG.Com
  INET: Stephen.Lee@DTAG.Com

Fat City Network Services    -- 858-538-5051 http://www.fatcity.com
San Diego, California        -- Mailing list and web hosting services
---------------------------------------------------------------------
To REMOVE yourself from this mailing list, send an E-Mail message
to: ListGuru@fatcity.com (note EXACT spelling of 'ListGuru') and in
the message BODY, include a line containing: UNSUB ORACLE-L
(or the name of mailing list you want to be removed from).  You may
also send the HELP command for other information (like subscribing).
================================================================================

From: Mladen Gogala <mladen () wangtrading ! com>
To: oracle-l
Subject: Re: simple question
Date: Thu, 08 Jan 2004 21:09:25 +0000
Message-ID: <F001.005DC2D8.20040108130925 () fatcity ! com>
--------------------
Why do you have r declared as number(10)?
On 01/08/2004 03:24:25 PM, oranew2004 wrote:
> CREATE OR REPLACE PROCEDURE labware_admin.truncate_tables
> (
>     schema_owner        IN VARCHAR2
> ) 
> AS
>    r number(10);
> BEGIN
> FOR r IN (SELECT table_name FROM dba_tables WHERE owner=schema_owner)
>   LOOP
>     EXECUTE IMMEDIATE 'truncate table schema_owner.'||r.table_name;
>   END LOOP;
> END;  
>  
>  
> ERROR:  Line 14 Column 55 PLS-00364: loop index variable 'R' use is invalid.
>  
>  
> Any ideas?
>  
> Thank you!
>  
>  
> 
> 
> ---------------------------------
> Do you Yahoo!?
> Yahoo! Hotjobs: Enter the "Signing Bonus" Sweepstakes

--
Mladen Gogala
Oracle DBA
-- 
Please see the official ORACLE-L FAQ: http://www.orafaq.net
-- 
Author: Mladen Gogala
  INET: mladen@wangtrading.com

Fat City Network Services    -- 858-538-5051 http://www.fatcity.com
San Diego, California        -- Mailing list and web hosting services
---------------------------------------------------------------------
To REMOVE yourself from this mailing list, send an E-Mail message
to: ListGuru@fatcity.com (note EXACT spelling of 'ListGuru') and in
the message BODY, include a line containing: UNSUB ORACLE-L
(or the name of mailing list you want to be removed from).  You may
also send the HELP command for other information (like subscribing).
================================================================================

From: =?koi8-r?B?7NXHz9fTy8nKIO0u9y4=?= <noc () golden-babylon ! ru>
To: freebsd-doc
Subject: simple question
Date: Fri, 30 Jan 2004 12:29:55 +0000
Message-ID: <180729059942.20040130152955 () golden-babylon ! ru>
--------------------
Hello,

  As said at section 3.4.2 in document http://www.freebsd.org/doc/en_US.ISO8859-1/articles/releng/article.html
  second disc in distribution must contain CVS repository, but on
  5.2-RELEASE disk i didn't find it.
  Maybe i poor seeking or devel version not contains it?
  Sorry for bad english :(

-- 
  ,  ..
     ""                        mailto:noc@golden-babylon.ru
                                                                 +7 (095) 705-99-44


_______________________________________________
freebsd-doc@freebsd.org mailing list
http://lists.freebsd.org/mailman/listinfo/freebsd-doc
To unsubscribe, send any mail to "freebsd-doc-unsubscribe@freebsd.org"
================================================================================

From: =?koi8-r?B?7NXHz9fTy8nKIO0u9y4=?= <noc () golden-babylon ! ru>
To: freebsd-doc
Subject: simple question
Date: Fri, 30 Jan 2004 12:29:55 +0000
Message-ID: <180729059942.20040130152955 () golden-babylon ! ru>
--------------------
Hello,

  As said at section 3.4.2 in document http://www.freebsd.org/doc/en_US.ISO8859-1/articles/releng/article.html
  second disc in distribution must contain CVS repository, but on
  5.2-RELEASE disk i didn't find it.
  Maybe i poor seeking or devel version not contains it?
  Sorry for bad english :(

-- 
  ,  ..
     ""                        mailto:noc@golden-babylon.ru
                                                                 +7 (095) 705-99-44


_______________________________________________
freebsd-doc@freebsd.org mailing list
http://lists.freebsd.org/mailman/listinfo/freebsd-doc
To unsubscribe, send any mail to "freebsd-doc-unsubscribe@freebsd.org"
================================================================================

From: "Muhammad Talha" <talha () worldcall ! net ! pk>
To: spamassassin-users
Subject: simple question
Date: Mon, 02 Feb 2004 00:17:24 +0000
Message-ID: <041701c3e921$f213ead0$23c051cb () ns3 ! worldcall ! net ! pk>
--------------------
This is a multi-part message in MIME format.

------=_NextPart_000_0414_01C3E94B.D7D73490
Content-Type: text/plain;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

Dear all=20

i have accidently mis-spelled the email address while installing =
Mail-SpamAssassin-2.63
how can i correct my email address . which is aslo used in spam reports =
.


Thanks and Regards

Talha



------=_NextPart_000_0414_01C3E94B.D7D73490
Content-Type: text/html;
	charset="iso-8859-1"
Content-Transfer-Encoding: quoted-printable

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML><HEAD>
<META http-equiv=3DContent-Type content=3D"text/html; =
charset=3Diso-8859-1">
<META content=3D"MSHTML 6.00.2800.1276" name=3DGENERATOR>
<STYLE></STYLE>
</HEAD>
<BODY bgColor=3D#ffffff>
<DIV><FONT face=3DArial size=3D2>Dear all </FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>i have accidently mis-spelled the email =
address=20
while installing Mail-SpamAssassin-2.63</FONT></DIV>
<DIV><FONT face=3DArial size=3D2>how can i correct my email address . =
which is aslo=20
used in spam reports .</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Thanks and Regards</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2>Talha</FONT></DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV>
<DIV><FONT face=3DArial size=3D2></FONT>&nbsp;</DIV></BODY></HTML>

------=_NextPart_000_0414_01C3E94B.D7D73490--

================================================================================

From: Bob Apthorpe <apthorpe+sa () cynistar ! net>
To: spamassassin-users
Subject: Re: simple question
Date: Mon, 02 Feb 2004 00:20:26 +0000
Message-ID: <20040201182026.649641f0.apthorpe+sa () cynistar ! net>
--------------------
Hi,

On Mon, 2 Feb 2004 05:17:24 +0500 "Muhammad Talha" <talha@worldcall.net.pk> wrote:

> i have accidently mis-spelled the email address while installing Mail-SpamAssassin-2.63
> how can i correct my email address . which is aslo used in spam reports .

Edit /usr/share/spamassassin/10_misc.cf and change the 'report_contact'
field to the proper address.

hth,

-- Bob
================================================================================

From: "Muhammad Talha" <talha () worldcall ! net ! pk>
To: spamassassin-users
Subject: Re: simple question
Date: Mon, 02 Feb 2004 00:25:04 +0000
Message-ID: <044a01c3e923$043400f0$23c051cb () ns3 ! worldcall ! net ! pk>
--------------------
Thanks Bob for your quick reply

this solved my problem :)
----- Original Message ----- 
From: "Bob Apthorpe" <apthorpe+sa@cynistar.net>
To: <spamassassin-users@incubator.apache.org>
Sent: Monday, February 02, 2004 5:20 AM
Subject: Re: simple question


> Hi,
>
> On Mon, 2 Feb 2004 05:17:24 +0500 "Muhammad Talha"
<talha@worldcall.net.pk> wrote:
>
> > i have accidently mis-spelled the email address while installing
Mail-SpamAssassin-2.63
> > how can i correct my email address . which is aslo used in spam reports
.
>
> Edit /usr/share/spamassassin/10_misc.cf and change the 'report_contact'
> field to the proper address.
>
> hth,
>
> -- Bob
>

================================================================================

From: "Simon L. Nielsen" <simon () freebsd ! org>
To: freebsd-doc
Subject: Re: simple question
Date: Sun, 08 Feb 2004 11:36:03 +0000
Message-ID: <20040208113602.GB770 () arthur ! nitro ! dk>
--------------------

--LpQ9ahxlCli8rRTG
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
Content-Transfer-Encoding: quoted-printable

On 2004.01.30 15:29:55 +0300, ????????? ?.?. wrote:
> Hello,
>=20
>   As said at section 3.4.2 in document http://www.freebsd.org/doc/en_US.I=
SO8859-1/articles/releng/article.html
>   second disc in distribution must contain CVS repository, but on
>   5.2-RELEASE disk i didn't find it.
>   Maybe i poor seeking or devel version not contains it?

It is correct that on FreeBSD 5.2 the compressed CVS repository is not
on disc2 (at least not on the disc2 distributed by the FreeBSD project;
CD vendors might choose to do it differently).  I think FreeBSD 4.7 was
the last version which included the repository on disc2.

The article should be updated accordingly...

The simplest way to get the FreeBSD CVS repository is probably by using
CVSup from one of the mirror sites.

--=20
Simon L. Nielsen
FreeBSD Documentation Team

--LpQ9ahxlCli8rRTG
Content-Type: application/pgp-signature
Content-Disposition: inline

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.2.3 (FreeBSD)

iD8DBQFAJh8ih9pcDSc1mlERAkikAJ9ry/lcKUK5yaVTTXq7S2oRUdlXqwCff1+G
RMayL6C6YYZMatuev/1dJRw=
=469p
-----END PGP SIGNATURE-----

--LpQ9ahxlCli8rRTG--
================================================================================

From: "Peter Huncar" <hunci () hunci ! sk>
To: openbsd-misc
Subject: simple question
Date: Sat, 13 Mar 2004 21:53:50 +0000
Message-ID: <002801c40945$ab2d90a0$14140a0a () zgub>
--------------------
I've bought a cheap line interactive UPS with RS-232 port to comunicate
with the computer. Is there any software/daemon I can use it with?

Thank you.

Peter Huncar

================================================================================

From: Greg Thomas <getbsd () dslextreme ! com>
To: openbsd-misc
Subject: Re: simple question
Date: Sun, 14 Mar 2004 00:11:29 +0000
Message-ID: <242C989C-754C-11D8-8947-0003935163A4 () dslextreme ! com>
--------------------
On Mar 13, 2004, at 1:53 PM, Peter Huncar wrote:

> I've bought a cheap line interactive UPS with RS-232 port to comunicate
> with the computer. Is there any software/daemon I can use it with?

Check the apc-upsd or nut ports.

Greg

================================================================================

From: Ajay <abra9823 () mail ! usyd ! edu ! au>
To: python-list
Subject: simple question
Date: Sun, 05 Sep 2004 14:39:58 +0000
Message-ID: <1094395198.413b253e46462 () www-mail ! usyd ! edu ! au>
--------------------
hi!

i have created a logger
self.logger = logging.getLogger('smsapp')
hdlr = logging.FileHandler('logs/smsapp.log')
formatter = logging.Formatter ('%(asctime)s %(levelname)s %(message)s')
hdlr.setFormatter(formatter)
self.logger.addHandler(hdlr)
self.logger.setLevel(logging.DEBUG)

when i log an error
self.logger.error("Illegal date index, "  str(dateIndex))
i get an error in my code
Traceback (most recent call last):
  File "/usr/local/lib/python2.3/logging/__init__.py", line 674, in emit
    msg = self.format(record)
  File "/usr/local/lib/python2.3/logging/__init__.py", line 567, in format
    return fmt.format(record)
  File "/usr/local/lib/python2.3/logging/__init__.py", line 362, in format
    record.message = record.getMessage()
  File "/usr/local/lib/python2.3/logging/__init__.py", line 233, in
getMessage
    msg = msg % self.args
TypeError: not all arguments converted during string formatting

dateIndex is an int

thanks

cheers


----------------------------------------------------------------
This message was sent using IMP, the Internet Messaging Program.
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Peter Otten <__peter__ () web ! de>
To: python-list
Subject: Re: simple question
Date: Sun, 05 Sep 2004 14:55:44 +0000
Message-ID: <chf9dh$hg8$07$1 () news ! t-online ! com>
--------------------
Ajay wrote:

> self.logger.error("Illegal date index, "  str(dateIndex))

I think you meant 

self.logger.error("Illegal date index ",  str(dateIndex))

error(fmt, arg1, arg2, ..., argN)

is just a convenient alternative to

error(fmt % (arg1, arg2, ..., argN))

Therefore

self.logger.error("Illegal date index %s", dateIndex)

or

self.logger.error("Illegal date index " + str(dateIndex))

should both work.

Peter



-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: "Patel, Nilesh M" <Nilesh.M.Patel () questdiagnostics ! com>
To: gtk
Subject: simple question
Date: Tue, 28 Sep 2004 19:15:02 +0000
Message-ID: <D3A481AC7F0A9F4D93199726B27492EAA9B472 () tbrws0030 ! us ! qdx ! com>
--------------------

quick question.

I know this maybe a stupid question, but when I do this:

./configure --prefix=/opt/gtk

shouldn't my package (pkgconfig) be installed in the /opt/gtk directory. after I run that command I go to the /opt/gtk directory but see nothing there. is this correct? or should i see somethign there?







Send gtk-list mailing list submissions to
	gtk-list@gnome.org

To subscribe or unsubscribe via the World Wide Web, visit
	http://mail.gnome.org/mailman/listinfo/gtk-list
or, via email, send a message with subject or body 'help' to
	gtk-list-request@gnome.org

You can reach the person managing the list at
	gtk-list-owner@gnome.org





==============================================================================
The contents of this message, together with any attachments, are intended only for the use of the person(s) to which they are addressed and may contain confidential and/or privileged information. Further, any medical information herein is confidential and protected by law. It is unlawful for unauthorized persons to use, review, copy, disclose, or disseminate confidential medical information. If you are not the intended recipient, immediately advise the sender and delete this message and any attachments. Any distribution, or copying of this message, or any attachment, is prohibited.
==============================================================================

_______________________________________________
gtk-list mailing list
gtk-list@gnome.org
http://mail.gnome.org/mailman/listinfo/gtk-list

================================================================================

From: Tristan Van Berkom <tristan.van.berkom () gmail ! com>
To: gtk
Subject: Re: simple question
Date: Tue, 28 Sep 2004 19:22:05 +0000
Message-ID: <560259cb04092812227f507173 () mail ! gmail ! com>
--------------------
On Tue, 28 Sep 2004 15:15:02 -0400, Patel, Nilesh M 
[...]
> I know this maybe a stupid question, but when I do this:
> 
> ./configure --prefix=/opt/gtk
> 
> shouldn't my package (pkgconfig) be installed in the /opt/gtk directory. after I run 
> that command I go to the /opt/gtk directory but see nothing there. is this correct? 
> or should i see somethign there?

    The `configure' script will only configure things localy in the
package directory,
once your package has been built and installed it should be installed under
the directory specified in prefix (i.e.,  libs will go to /opt/gtk/lib
and binaries will
go to /opt/gtk/bin etc...).

Cheers,
                                                          -Tristan
_______________________________________________
gtk-list mailing list
gtk-list@gnome.org
http://mail.gnome.org/mailman/listinfo/gtk-list
================================================================================


################################################################################

=== Thread: simplify_float_cmp ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: simplify_float_cmp
Date: Mon, 26 Jul 2004 13:49:33 +0000
Message-ID: <20040726134933.A0F4F1422D58 () darter ! rentec ! com>
--------------------

Floating point stuff landed...  Great.

One small thing I noticed: simplify_float_cmp loads the two values before
it checks that they really are values.  (Whereas simplify_float_preop
loads after.)

Loading random bit patterns in floating point registers is known to make
Alphas rather upset.  Please consider the following trivial patch.

Morten





cd /scratch/welinder/sparse-2004-07-26/
diff -s -u /scratch/welinder/sparse-2004-07-26/expand.c\~ /scratch/welinder/sparse-2004-07-26/expand.c
--- /scratch/welinder/sparse-2004-07-26/expand.c~	2004-07-24 19:00:32.000000000 -0400
+++ /scratch/welinder/sparse-2004-07-26/expand.c	2004-07-26 09:45:47.000000000 -0400
@@ -243,11 +243,13 @@
 static int simplify_float_cmp(struct expression *expr, struct symbol *ctype)
 {
 	struct expression *left = expr->left, *right = expr->right;
-	long double l = left->fvalue, r = right->fvalue;
+	long double l, r;
 
 	if (left->type != EXPR_FVALUE || right->type != EXPR_FVALUE)
 		return 0;
 
+	l = left->fvalue;
+	r = right->fvalue;
 	switch (expr->op) {
 	case '<':		expr->value = l < r; break;
 	case '>':		expr->value = l > r; break;

Diff finished at Mon Jul 26 09:46:14
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: simplify_int_binop ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: simplify_int_binop
Date: Mon, 26 Jul 2004 13:58:43 +0000
Message-ID: <20040726135843.AE59E1422D58 () darter ! rentec ! com>
--------------------

The signed division should check for overflow: (INT_MIN / -1) overflows.
(IMHO, doing everything twice in this function isn't looking as neat as
it probably did at first; the signed and unsigned cases share little by
now.)

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: simplify_int_binop
Date: Mon, 26 Jul 2004 16:22:40 +0000
Message-ID: <Pine.LNX.4.58.0407260906450.2522 () ppc970 ! osdl ! org>
--------------------


On Mon, 26 Jul 2004, Morten Welinder wrote:
> 
> The signed division should check for overflow: (INT_MIN / -1) overflows.

Argh. We should probably check for overflow in the regular math operators 
too for the signed case (ie all of +/-/* are undefined on overflow, might 
as well warn). 

This test should do it for the division:

	if (is_signed && l == mask && sr == -1) goto Overflow;

> (IMHO, doing everything twice in this function isn't looking as neat as
> it probably did at first; the signed and unsigned cases share little by
> now.)

I have a cunning plan. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: simplify_int_binop
Date: Mon, 26 Jul 2004 16:39:25 +0000
Message-ID: <Pine.LNX.4.58.0407260939020.2522 () ppc970 ! osdl ! org>
--------------------


On Mon, 26 Jul 2004, Linus Torvalds wrote:
> 
> I have a cunning plan. 

Pushed out. It may make some people barf, but I find it very readable.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sizeof (char[]) { "Foo" } ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: sizeof (char[]) { "Foo" }
Date: Wed, 28 Jul 2004 21:21:10 +0000
Message-ID: <20040728212110.80B0F1422D58 () darter ! rentec ! com>
--------------------

I'm told this is a C99 addition to keep an eye on:

int i = sizeof (char[]) { "Foo" };

..and sure enough:

> gcc-3.4 -Wall -c ~/foo.c
> ./check ~/foo.c
/home/welinder/foo.c:1:25: warning: Expected ; at end of declaration
/home/welinder/foo.c:1:25: warning: got {
/home/welinder/foo.c:1:9: warning: cannot size expression



postfix_expression:
      primary_expression
    | postfix_expression '[' expression ']'
    | postfix_expression '(' argument_expression_list? ')' -> $$ = (call $1)
    | postfix_expression '.' IDENTIFIER
    | postfix_expression '->' IDENTIFIER
    | postfix_expression '++'
    | postfix_expression '--'
    | '(' type_name ')' '{' initializer_list '}'
    | '(' type_name ')' '{' initializer_list ',' '}'
    ;

argument_expression_list:
      assignment_expression
    | argument_expression_list ',' assignment_expression
    ;

unary_expression:
      postfix_expression
    | '++' unary_expression
    | '--' unary_expression
    | unary_operator cast_expression
    | sizeof unary_expression
    | sizeof '(' type_name ')'
    ;
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sizeof (char[]) { "Foo" }
Date: Thu, 29 Jul 2004 06:47:58 +0000
Message-ID: <Pine.LNX.4.58.0407282337270.2522 () ppc970 ! osdl ! org>
--------------------


On Wed, 28 Jul 2004, Morten Welinder wrote:
> 
> I'm told this is a C99 addition to keep an eye on:
> 
> int i = sizeof (char[]) { "Foo" };

That's really a nasty thing..

We already _do_ handle

	(char []) { 'a', 'b'}

as an expression, and doing sizeof() on it would work (except we only bind 
the array size when it is used as an _initializer_ so right now you 
actually get "warning: cannot size expression" from sparse on an unsized 
array expression like that.

So that's not a problem - apart from the fact that we need to handle that 
nasty { "xxx" } syntax oddity for initializer expressions.

The _real_ problem is that the above sizeof-expression is not a 
well-parsing expression.

Sizeof() can take either a type _or_ an expression. Sparse just does a 
single-token lookahead, and it sees

	sizeof(char

and it decides that it's a type-expression, which it is:

	sizeof(char[])

is a perfectly legal parse, which just doesn't have a size.

I assume it should just look at the '{' and decide that the size it found
wasn't a size after all, and re-start the parse as an initializer
expression. What a crock.

So you can actually get sparse to _parse_ the above, by adding another set
of parentheses (and using the "char array" format instead of the string
shorthand):

	int i = sizeof((char[])"Foo");

or

	int i = sizeof((char[]) { 'F', 'o', 'o', '\0' });

both parse well (but then sparse will say "cannot size expression" as per 
above - that's a totally different issue).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sizeof (char[]) { "Foo" }
Date: Thu, 29 Jul 2004 17:57:02 +0000
Message-ID: <Pine.LNX.4.58.0407291054150.9073 () ppc970 ! osdl ! org>
--------------------


On Wed, 28 Jul 2004, Linus Torvalds wrote:
>
> On Wed, 28 Jul 2004, Morten Welinder wrote:
> > 
> > I'm told this is a C99 addition to keep an eye on:
> > 
> > int i = sizeof (char[]) { "Foo" };
> 
> That's really a nasty thing..

.. but easily parsed, apart from the (totally separate) bug of not being 
able to handle the string initializer inside a '{'.

But apart from that, it now works:

	int i = sizeof (int[]) { 1,2,3 };

correctly evaluates to "12". So

	int i = sizeof(char []) { 'F', 'o', 'o', 0 };

but the { string } thing doesn't parse yet. That'll have to be a special
case.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sizeof/alignof/typeof on bitfields. ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: sizeof/alignof/typeof on bitfields.
Date: Tue, 24 Aug 2004 18:00:46 +0000
Message-ID: <20040824180046.99E0A1422D5B () darter ! rentec ! com>
--------------------


Linus,

your check_modifiers fix looks good.  (C's silly scoping rules bite again.)

Newer gccs (such as 3.4) disallow sizeof/alignof/typeof on bitfields.  That
is probably good as that in turn disallows casts to bitfields -- there will
be no way to name the type -- and other things you probably don't want to
think about.

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c |    6 ++++--
 symbol.c   |    2 ++
 symbol.h   |    9 ++++++++-
 3 files changed, 14 insertions(+), 3 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/24 1.743)
   Disallow sizeof/alignof/typeof on bitfields.

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sizeof/alignof/typeof on bitfields.
Date: Tue, 24 Aug 2004 18:31:03 +0000
Message-ID: <20040824183103.GB7260 () mars ! ravnborg ! org>
--------------------
On Tue, Aug 24, 2004 at 02:00:46PM -0400, Morten Welinder wrote:
> 
> 
> Linus,
> 
> your check_modifiers fix looks good.  (C's silly scoping rules bite again.)
> 
> Newer gccs (such as 3.4) disallow sizeof/alignof/typeof on bitfields.  That
> is probably good as that in turn disallows casts to bitfields -- there will
> be no way to name the type -- and other things you probably don't want to
> think about.
> 
> Morten
> 
> 
> 
> Linus, please do a
> 
> 	bk pull http://sparse-mw.bkbits.net:8080/for-linus
> 
> This will update the following files:
> 
>  evaluate.c |    6 ++++--
>  symbol.c   |    2 ++
>  symbol.h   |    9 ++++++++-
>  3 files changed, 14 insertions(+), 3 deletions(-)
> 
> through these ChangeSets:
> 
> <welinder@troll.com> (04/08/24 1.743)
>    Disallow sizeof/alignof/typeof on bitfields.

Please include the patch as well.
It allows us to see what you actually did without firing up a browser.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sizeof/alignof/typeof on bitfields.
Date: Tue, 24 Aug 2004 19:19:27 +0000
Message-ID: <20040824191927.A98A11422D5B () darter ! rentec ! com>
--------------------

> Please include the patch as well.

OK, ok...

Now, we cannot just waste email like this, so I have included also a patch
that fixes structure layout in the face of zero-width bitfields.

Morten





Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 evaluate.c |    6 ++++--
 symbol.c   |   17 +++++++++++------
 symbol.h   |    9 ++++++++-
 3 files changed, 23 insertions(+), 9 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/24 1.744)
   fix layout of zero-width bitfields.

<welinder@troll.com> (04/08/24 1.743)
   Disallow sizeof/alignof/typeof on bitfields.

diff -Nru a/symbol.c b/symbol.c
--- a/symbol.c	2004-08-24 15:16:55 -04:00
+++ b/symbol.c	2004-08-24 15:16:55 -04:00
@@ -101,16 +101,21 @@
 	/*
 	 * Bitfields have some very special rules..
 	 */
-	if (sym->fieldwidth) {
+	if (is_bitfield_type (sym)) {
 		unsigned long bit_offset = bit_size & align_bit_mask;
+		int room = base_size - bit_offset;
+		// Zero-width fields just fill up the unit.
+		int width = sym->fieldwidth ? sym->fieldwidth : (bit_offset ? room : 0);
 
-		if (bit_offset + sym->fieldwidth > base_size) {
+		if (width > room) {
 			bit_size = (bit_size + align_bit_mask) & ~align_bit_mask;
 			bit_offset = 0;
 		}
 		sym->offset = (bit_size - bit_offset) >> 3;
 		sym->bit_offset = bit_offset;
-		info->bit_size = bit_size + sym->fieldwidth;
+		info->bit_size = bit_size + width;
+		// warn (sym->pos, "bitfield: offset=%d:%d  size=:%d", sym->offset, sym->bit_offset, width);
+
 		return;
 	}
 
@@ -121,6 +126,7 @@
 	sym->offset = bit_size >> 3;
 
 	info->bit_size = bit_size + sym->bit_size;
+	// warn (sym->pos, "regular: offset=%d", sym->offset);
 }
 
 static void examine_struct_union_type(struct symbol *sym, int advance)
@@ -194,9 +200,6 @@
  * Fill in type size and alignment information for
  * regular SYM_TYPE things.
  */
-#define MOD_STRIP (MOD_CONST | MOD_VOLATILE | MOD_ADDRESSABLE | \
-		  MOD_NODEREF | MOD_ACCESSED | MOD_ASSIGNED | \
-		  MOD_SAFE | MOD_FORCE | MOD_STORAGE)
 struct symbol *examine_symbol_type(struct symbol * sym)
 {
 	unsigned int bit_size, alignment;
diff -Nru a/evaluate.c b/evaluate.c
--- a/evaluate.c	2004-08-24 15:16:56 -04:00
+++ b/evaluate.c	2004-08-24 15:16:56 -04:00
@@ -1528,6 +1528,8 @@
 		if (!evaluate_expression(expr->cast_expression))
 			return NULL;
 		size = expr->cast_expression->ctype->bit_size;
+		if (is_bitfield_type (expr->cast_expression->ctype))
+			warn(expr->pos, "sizeof applied to bitfield type");
 	}
 	if (size & 7)
 		warn(expr->pos, "cannot size expression");
@@ -1546,6 +1548,8 @@
 		if (!type)
 			return NULL;
 	}
+	if (is_bitfield_type (expr->cast_expression->ctype))
+		warn(expr->pos, "alignof applied to bitfield type");
 	examine_symbol_type(type);
 	expr->type = EXPR_VALUE;
 	expr->value = type->ctype.alignment;
@@ -2120,8 +2124,6 @@
 
 static void evaluate_if_statement(struct statement *stmt)
 {
-	struct symbol *ctype;
-
 	if (!stmt->if_conditional)
 		return;
 
diff -Nru a/symbol.c b/symbol.c
--- a/symbol.c	2004-08-24 15:16:56 -04:00
+++ b/symbol.c	2004-08-24 15:16:56 -04:00
@@ -244,6 +244,8 @@
 		return sym;
 	case SYM_TYPEOF: {
 		struct symbol *base = evaluate_expression(sym->initializer);
+		if (is_bitfield_type (base))
+			warn(base->pos, "typeof applied to bitfield type");
 		if (base) {
 			if (base->type == SYM_NODE)
 				base = base->ctype.base_type;
diff -Nru a/symbol.h b/symbol.h
--- a/symbol.h	2004-08-24 15:16:56 -04:00
+++ b/symbol.h	2004-08-24 15:16:56 -04:00
@@ -227,13 +227,20 @@
 extern void merge_type(struct symbol *sym, struct symbol *base_type);
 extern void check_declaration(struct symbol *sym);
 
-static inline int is_int_type(struct symbol *type)
+static inline int is_int_type(const struct symbol *type)
 {
 	if (type->type == SYM_NODE)
 		type = type->ctype.base_type;
 	return (type->type == SYM_ENUM) ||
 	       (type->type == SYM_BITFIELD) ||
 	       type->ctype.base_type == &int_type;
+}
+
+static inline int is_bitfield_type(const struct symbol *type)
+{
+	if (type->type == SYM_NODE)
+		type = type->ctype.base_type;
+	return (type->type == SYM_BITFIELD);
 }
 
 #endif /* SEMANTIC_H */
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse and gcc-3.4.0 testsuite: results. ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: sparse and gcc-3.4.0 testsuite: results.
Date: Wed, 01 Dec 2004 12:42:55 +0000
Message-ID: <E1CZTot-000Cle-00.adobriyan-mail-ru () f24 ! mail ! ru>
--------------------
In case somebody else interested, sparse-1.1078 doesn't like some files from
gcc-3.4.0-20040420 (I got it from FC2 disk) testsuite.

Relative to gcc/testsuite/gcc.c-torture/:
============================================================================
sparse: flow.c:892: vrfy_flow: Assertion `!entry' failed.

	compile/20000728-1.c
	compile/940718-1.c

Both have for(;;) (while(1) doesn't trigger assert):

void f(void)
{
	for (;;)
		;
}
============================================================================
Infinite loop:

	compile/990523-1.c


================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse and gcc-3.4.0 testsuite: results.
Date: Wed, 01 Dec 2004 18:15:03 +0000
Message-ID: <Pine.LNX.4.58.0412011012040.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Alexey Dobriyan wrote:
> 
> void f(void)
> {
> 	for (;;)
> 		;
> }

Wow. This had me stumped. I was looking for various flow simplification
bugs until I thought to print out what the code was _before_ any 
optimization at all.

We don't linearize that right in the first place. An iterator without a
post-condition did total and utter crap. No broken optimizations, just a
totally broken initial linearization - it would literally fall through the
end of the loop into empty space. Embarrassing.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse breakage ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 18:05:15 +0000
Message-ID: <20040731180515.GA4738 () 64m ! dyndns ! org>
--------------------
On Sat, Jul 31, 2004 at 01:48:42PM -0700, Linus Torvalds wrote:
> 
> The kernel doesn't often do this, but apparently the OSS linear conversion 
> does end up using computed labels.
> 
> Trivial test-case:
> 
> 	int fn(int i)
> 	{
> 		__label__ a,b;
> 		goto *(i ? &&a : &&b);
> 	a:
> 		return 1;
> 	b:
> 		return 2;
> 	}
> 
> but I don't know how to fix the linearizer for this.
> 
> Basically, it should be linearized roughly as a switch to _all_ labels in
> that function, to get the potential liveness etc right.

Is there any chance goto an arbitrary address or assign the label to
a variable?  I will see what I can do.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 18:10:45 +0000
Message-ID: <20040731181045.GB4738 () 64m ! dyndns ! org>
--------------------
Good idea.

Chris

On Sat, Jul 31, 2004 at 04:24:17PM -0500, Chris Lattner wrote:
> On Sat, 31 Jul 2004, Linus Torvalds wrote:
> 
> FWIW, this is exactly what we do in LLVM.  Taking the address of a block
> actually results in an integer block number.  An indirect goto is actually
> code generated as a switch instruction on this block number to the
> appropriate destinations.
> 
> -Chris
> 
> -- 
> http://llvm.cs.uiuc.edu/
> http://nondot.org/sabre/
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 20:48:42 +0000
Message-ID: <Pine.LNX.4.58.0407311340410.1795 () ppc970 ! osdl ! org>
--------------------

On Sat, 31 Jul 2004, Dave Jones wrote:
>
> sparse -D__i386__=1 -Wp,-MD,sound/core/oss/.linear.o.d -nostdinc -iwithprefix include -D__KERNEL__ -Iinclude  -Wall -Wstrict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -pipe -msoft-float -mpreferred-stack-boundary=2 -fno-unit-at-a-time -march=pentium4 -Iinclude/asm-i386/mach-default -O2 -fomit-frame-pointer -Wdeclaration-after-statement    -DKBUILD_BASENAME=linear -DKBUILD_MODNAME=snd_pcm_oss sound/core/oss/linear.c ;
> make[1]: *** [sound/core/oss/linear.o] Error 139
> make: *** [sound/core/oss/linear.o] Error 2

Yes. It seems the linearizer is unhappy about indirect "goto" statements. 
It assumes all goto's are bound to a symbol, without realizing that 
sometimes they are bound to an expression...

The kernel doesn't often do this, but apparently the OSS linear conversion 
does end up using computed labels.

Trivial test-case:

	int fn(int i)
	{
		__label__ a,b;
		goto *(i ? &&a : &&b);
	a:
		return 1;
	b:
		return 2;
	}

but I don't know how to fix the linearizer for this.

Basically, it should be linearized roughly as a switch to _all_ labels in
that function, to get the potential liveness etc right.

Chris cc'd, since he knows the linearizer.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 21:24:17 +0000
Message-ID: <Pine.LNX.4.44.0407311623140.5741-100000 () nondot ! org>
--------------------
On Sat, 31 Jul 2004, Linus Torvalds wrote:
> The kernel doesn't often do this, but apparently the OSS linear conversion
> does end up using computed labels.
>
> Trivial test-case:
>
> 	int fn(int i)
> 	{
> 		__label__ a,b;
> 		goto *(i ? &&a : &&b);
> 	a:
> 		return 1;
> 	b:
> 		return 2;
> 	}
>
> but I don't know how to fix the linearizer for this.
>
> Basically, it should be linearized roughly as a switch to _all_ labels in
> that function, to get the potential liveness etc right.

FWIW, this is exactly what we do in LLVM.  Taking the address of a block
actually results in an integer block number.  An indirect goto is actually
code generated as a switch instruction on this block number to the
appropriate destinations.

-Chris

-- 
http://llvm.cs.uiuc.edu/
http://nondot.org/sabre/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 21:34:44 +0000
Message-ID: <Pine.LNX.4.58.0407311428200.1795 () ppc970 ! osdl ! org>
--------------------


On Sat, 31 Jul 2004, Chris Lattner wrote:
>
> On Sat, 31 Jul 2004, Linus Torvalds wrote:
>
> > Basically, it should be linearized roughly as a switch to _all_ labels in
> > that function, to get the potential liveness etc right.
> 
> FWIW, this is exactly what we do in LLVM.  Taking the address of a block
> actually results in an integer block number.  An indirect goto is actually
> code generated as a switch instruction on this block number to the
> appropriate destinations.

I'd hate to actually generate _code_ that way, but I think it's an 
acceptable representation for the IL.

What I was thinking of was not so much to actually make it a real switch()  
statement, as really just having a new IL OP type that looks a lot like
the OP_SWITCH, but is an OP_COMPUTEDGOTO and its "multijmp_list" just
contains the list of possible symbols.

The "possible symbols" list would be static for one function, and just
contains the full set of labels that have had their address taken (ie we
could build that list of symbols at parse-time and just attach the list to
the function node).
	
Actually trying to enumerate the labels and create a real switch sounds 
like a bad idea. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 22:39:37 +0000
Message-ID: <Pine.LNX.4.44.0407311718420.7177-100000 () nondot ! org>
--------------------
On Sat, 31 Jul 2004, Linus Torvalds wrote:
> On Sat, 31 Jul 2004, Chris Lattner wrote:
> > On Sat, 31 Jul 2004, Linus Torvalds wrote:
> >
> > > Basically, it should be linearized roughly as a switch to _all_ labels in
> > > that function, to get the potential liveness etc right.
> >
> > FWIW, this is exactly what we do in LLVM.  Taking the address of a block
> > actually results in an integer block number.  An indirect goto is actually
> > code generated as a switch instruction on this block number to the
> > appropriate destinations.

> Actually trying to enumerate the labels and create a real switch sounds
> like a bad idea.

I'm really not interested in a big flame war, but I will tell you why I
chose to do it this way in LLVM.  The biggest important thing is to make
the CFG trivial to handle and update for the optimizations and analyses.
Because of this, representing indirect goto's as switch'es makes sense:
all targets are explicit so we know exactly what the possible destinations
are.  Indirect branches do not occur often enough in practice to make me
want to add significant complexity to the compiler to support them (they
are a GCC extension after all).

Representing indirect gotos as switches also does not necessarily imply
poor performance of the final machine code either.  By far the most common
usage of them is in threaded interpreters.  These interpreters often have
static const arrays of label addresses, and have many instances of the
indirect goto.  Recognizing this idiom for what it is allows the code
generator to generate the code people expect (an array of machine code
labels instead of integers) without making the mid-level representation
have to deal with them explicitly.

A secondary effect of this decision is that it does not give users even
the idea that you can take the address of a label and use it for something
else (like getting addresses of asm blocks or something).  It just simply
won't work.  This helps reduce the "my hack works without -O, but breaks
when -O is enabled" kind of stuff.

-Chris

-- 
http://llvm.cs.uiuc.edu/
http://nondot.org/sabre/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sat, 31 Jul 2004 23:09:11 +0000
Message-ID: <Pine.LNX.4.58.0407311551470.1795 () ppc970 ! osdl ! org>
--------------------


On Sat, 31 Jul 2004, Chris Lattner wrote:
> 
> I'm really not interested in a big flame war, but I will tell you why I
> chose to do it this way in LLVM.  The biggest important thing is to make
> the CFG trivial to handle and update for the optimizations and analyses.
> Because of this, representing indirect goto's as switch'es makes sense:
> all targets are explicit so we know exactly what the possible destinations
> are.  Indirect branches do not occur often enough in practice to make me
> want to add significant complexity to the compiler to support them (they
> are a GCC extension after all).

Umm.. What are the advantages of this indirection through an integer op?

The thing is, both "switch" and "computedgoto" have only _one_ thing in
common that any CFG thing ever needs to care about: the list of targets.  
In sparse, a "target" is always a label, aka a "struct symbol".

There is nothing else that "switch" and "computedgoto" have in common, but 
the "list of targets" is 100% the same.

So I'm arguing that sparse should just make that undeniable fact obvious.  
Clearly from a semantic standpoint you can map one into the other, but I
don't really see the need for it, especially as any sane code generator
would just need to unmap it after the fact (well, arguably you can map a
"switch" statement into a "map values to addresses + computedgoto" without
ever really needing an unmap, but equally arguably you may not want to do
that kind of semantic lowering until as late as possible).

> Representing indirect gotos as switches also does not necessarily imply
> poor performance of the final machine code either.

Sure. You can map it back by recognizing the idiom. Still, there's no 
question that you have then first mapped it one way and then mapped it 
back, for no real gain. And mapping it back may _not_ be very easy at all, 
because:

>			  By far the most common
> usage of them is in threaded interpreters.  These interpreters often have
> static const arrays of label addresses, and have many instances of the
> indirect goto.

I disagree pretty violently. I've done interpreters exactly this way, and
only the simplest languages have a direct threaded implementation. A lot
of interesting cases (eg doing an x86 interpreter) will have levels of
indirection, where you pass on the "next action" pointer to the threaded
code: you have a "writeback phase" that depends on the instruction, that
you pass down to the "execution phase" that depends (in another way) on
the instruction.

I seriously doubt that you would be able to do a simple peep-hole kind of
mapping at that point. You'll likely end up having the code generate an
extra level of indirection - both unnecessary, and not existing in the
original source code. Or you'll end up having to work really hard to see 
how the label address values are used.

So unless you say "computed gotos aren't interesting" (which obviously is
a perfectly valid thing to say, although I wouldn't say so myself), I
really believe the sparse IL should support it.

Of course, if somebody wants to make sparse then pass on the thing to
LLVM, it should be trivial to do the mapping to OP_SWITCH at _that_ time.  
So don't get me wrong - I'm not trying to convince you to change LLVM, I 
just would prefer for sparse to keep the notion of "switch" and "goto *" 
separate in its tree.

> A secondary effect of this decision is that it does not give users even
> the idea that you can take the address of a label and use it for something
> else (like getting addresses of asm blocks or something).  It just simply
> won't work.  This helps reduce the "my hack works without -O, but breaks
> when -O is enabled" kind of stuff.

Hey, I can write trivial programs that give different results when 
optimizing than without. No label addresses needed. The fact is that 
people can mis-use any powerful language feature. That doesn't make it 
bad.

Computed goto's are pretty much the only way to write efficient
interpreters in (gcc) C. It's a special case, and not everybody agrees
with the need for it, but for that thing it's definitely a very powerful
feature where people _really_ care about the resulting code generation.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sun, 01 Aug 2004 02:25:31 +0000
Message-ID: <Pine.LNX.4.44.0407312119490.10107-100000 () nondot ! org>
--------------------
On Sat, 31 Jul 2004, Linus Torvalds wrote:
> > are.  Indirect branches do not occur often enough in practice to make me
> > want to add significant complexity to the compiler to support them (they
> > are a GCC extension after all).
>
> Umm.. What are the advantages of this indirection through an integer op?
>
> The thing is, both "switch" and "computedgoto" have only _one_ thing in
> common that any CFG thing ever needs to care about: the list of targets.
> In sparse, a "target" is always a label, aka a "struct symbol".

It's duplication of functionality.  There is no reason for it to exist.

> There is nothing else that "switch" and "computedgoto" have in common, but
> the "list of targets" is 100% the same.

Okay, but it's yet-another-case for analyses and transformations to
handle.

> > Representing indirect gotos as switches also does not necessarily imply
> > poor performance of the final machine code either.
>
> Sure. You can map it back by recognizing the idiom. Still, there's no
> question that you have then first mapped it one way and then mapped it
> back, for no real gain. And mapping it back may _not_ be very easy at all,
> because:

I was just pointing out why we did it that way in LLVM, that's all.  Note
that LLVM *strives* to have a simple and elegant representation that is as
minimal as possible.  This has positives and negatives, but it's certainly
not the only way to do things.

> So unless you say "computed gotos aren't interesting" (which obviously is
> a perfectly valid thing to say, although I wouldn't say so myself), I
> really believe the sparse IL should support it.

Ok.

> Of course, if somebody wants to make sparse then pass on the thing to
> LLVM, it should be trivial to do the mapping to OP_SWITCH at _that_ time.
> So don't get me wrong - I'm not trying to convince you to change LLVM, I
> just would prefer for sparse to keep the notion of "switch" and "goto *"
> separate in its tree.

Sure.  I'm a big fan of making the AST represent the source-level language
with as much semantic fidelity as possible.  Sorry, I thought you were
discussing the mid-level representation.

> Hey, I can write trivial programs that give different results when
> optimizing than without. No label addresses needed. The fact is that
> people can mis-use any powerful language feature. That doesn't make it
> bad.

Sure, I understand that.  For some reason, it seems that users get this
idea that if they can take the address of a label that it *means*
something more than just control flow effects.  As I said, this is just a
secondary effect :)

> Computed goto's are pretty much the only way to write efficient
> interpreters in (gcc) C. It's a special case, and not everybody agrees
> with the need for it, but for that thing it's definitely a very powerful
> feature where people _really_ care about the resulting code generation.

Absolutely.  Like I said, I have no real interest in arguing the point
strenuously enough to affect sparse, I was just pointing out what we do.
:)

-Chris

-- 
http://llvm.org/
http://nondot.org/sabre/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sun, 01 Aug 2004 02:42:37 +0000
Message-ID: <Pine.LNX.4.58.0407311930350.1816 () ppc970 ! osdl ! org>
--------------------


On Sat, 31 Jul 2004, Chris Lattner wrote:
> 
> It's duplication of functionality.  There is no reason for it to exist.

I don't think you actually need to duplicate the functionality.

I think you can make them both use the same data structures. The 
computed-goto case would have a different "op" value, and wouldn't have 
any relevant information in the "case" tables, but would otherwise have 
all the same data in it, and the code to handle it would all be the same.

Since the CFG handling etc would never actually need to look at the case
value tables anyway (most things really only cares about connectivity), it
all shouldn't matter. So instead of saying

	if (op == SWITCH) {
		.. do for each target ..

you'd have to say

	if (multijump(op)) {
		.. do for each target ..

with a macro or function that says which ops have the multiple targets,
but that just looks more readable anyway, no?

The only thing I'm debating myself is whether to split off the "case
value" table from the "target table", since computedgoto doesn't need any
case values. Right now sparse has a list of "casevalue + target", and I'm
considering changing it to two lists: one of "casevalues" and one of
"targets".

Changing it to two lists would make the lack of case values in 
computedgoto more obvious (otherwise we'd have to fill them in with some 
nonsense value), and would potentially be cleaner in other ways (you 
seldom care about both, except for the very end when you actually generate 
the code or jump table).

On the other hand, just keeping it as one list is minimally intrusive, and
the space overhead of having to carry the casevalues even when not needed
should be pretty minimal. Even automatically generated code seldom has
tons of entrypoints - it might have millions of entries in the label
pointer _tables_, but they tend to point to a much smaller number of
actual labels.

I'll make the front-end generate the list of labels that had their address 
taken, and see where that leads..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sun, 01 Aug 2004 02:58:52 +0000
Message-ID: <Pine.LNX.4.44.0407312154290.10260-100000 () nondot ! org>
--------------------
On Sat, 31 Jul 2004, Linus Torvalds wrote:
> with a macro or function that says which ops have the multiple targets,
> but that just looks more readable anyway, no?

I'm sorry, I should have been more clear.  Most CFG related activities
revolve around two things: the list of successors for a block and the list
of predecessors.  I have full confidence that it would be easy to get the
successor list for a basic block in a trivial fashion regardless of how
you do this.  However, getting the predecessor list is not so simple.  In
particular, this would require the compiler to keep track whether the
address of a block is taken, and if so, marking all blocks containing
indirect goto's as predecessors (implying that you have to have a list of
indirect gotos somewhere).

This is certainly not intractable but does add complexity.  One of the
funny things about LLVM is that it never represents the CFG explicitly
(there is no CFG data structure), the information is implicit in the
use-def and def-use chains for various objects in the program.

I believe that GCC uses a TREE_ADDRESSABLE flag to represent information
like this.  I really don't like magic flags, but that's just my taste in
IR design.

-Chris

-- 
http://llvm.cs.uiuc.edu/
http://nondot.org/sabre/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sun, 01 Aug 2004 04:18:28 +0000
Message-ID: <Pine.LNX.4.58.0407312112460.3348 () ppc970 ! osdl ! org>
--------------------


On Sat, 31 Jul 2004, Linus Torvalds wrote:
> 
> I think you can make them both use the same data structures. The 
> computed-goto case would have a different "op" value, and wouldn't have 
> any relevant information in the "case" tables, but would otherwise have 
> all the same data in it, and the code to handle it would all be the same.

Ok, that approach seems to work. Checked in. It probably has tons of bugs, 
but the trivial test-case doesn't SIGSEGV, and seems to generate a sane 
linearization. Note the "jmp *%r5", which also has a list of all possible 
targets associated with the instruction.

I tried to check that it does the right thing for inline functions too 
(the "possible targets" thing should be per pre-inlining, since targets 
between an inlined and uninlined function cannot mix). But we have other 
linearization problems wrt the inline "ret" handling, so I couldn't really 
verify it, although the somewhat garbled output seemed to agree with what 
I expected.

Chris - you should really verify my stuff for sanity. It's pretty much
doing the same thing as a switch statement, but still..

		Linus

----
ep 0x4002600c: fn
   sym: 0x4003b0e0 i
   sym: 0x4003b1d0 a
   sym: 0x4003b248 b

bb: 0x4006900c
        %r1 <- i
        load %r2 <- [%r1]
        br      %r2, .L0x40069024, .L0x40069030

bb: 0x40069024
  **from 0x4006900c**
        %r3 <- .L0x40069054
        br      .L0x40069048

bb: 0x40069030
  **from 0x4006900c**
        %r4 <- .L0x40069060
        br      .L0x40069048

bb: 0x40069048
  **from 0x40069024**
  **from 0x40069030**
        %r5 <- phi (%r3, .L0x40069024), (%r4, .L0x40069030)
***     jmp *%r5, .L0x40069054, .L0x40069060	****

bb: 0x40069054
  **from 0x40069048**
        %r6 <- 1
        br      .L0x40069018

bb: 0x40069060
  **from 0x40069048**
        %r8 <- 2
        br      .L0x40069018

bb: 0x40069018
  **from 0x40069054**
  **from 0x40069060**
        %r7 <- phi (%r6, .L0x40069054), (%r8, .L0x40069060)
        ret %r7
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage
Date: Sun, 01 Aug 2004 04:22:59 +0000
Message-ID: <Pine.LNX.4.58.0407312120250.3348 () ppc970 ! osdl ! org>
--------------------


On Sat, 31 Jul 2004, Linus Torvalds wrote:
> 
> Ok, that approach seems to work. Checked in. It probably has tons of bugs, 
> but the trivial test-case doesn't SIGSEGV, and seems to generate a sane 
> linearization. Note the "jmp *%r5", which also has a list of all possible 
> targets associated with the instruction.

Note that the "all possible targets" here is _not_ anything clever. It is 
by no means trying to do anything like value source analysis, and the "all 
possible targets" is nothing more than a list of all labels that have had 
their address taken in that particular function.

Just wanted to clarify that in case people expected me to have done
something _really_ impressive. Nope. It's very stupid indeed. And I don't
expect that people who use computed goto's ever really expect any better
analysis over the goto. And if they do, it's too bad for them ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse breakage. ===

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: sparse breakage.
Date: Tue, 31 Aug 2004 17:39:02 +0000
Message-ID: <20040831173902.GN6301 () redhat ! com>
--------------------
Sparse blew up when I ran it against an xorg tree (warning,
not for the faint of heart).

ConnDis.c:1164:32:    expected incomplete type [addressable] [toplevel] xdmcp_data[0]
ConnDis.c:1164:32:    got long
make[3]: *** [ConnDis.o] Segmentation fault (core dumped)
make[3]: Leaving directory `/mnt/nfs/neologic/bar/src/cvs/xc/lib/X11'

(18:33:25:davej@delerium:xc)$ gdb ~/bin/sparse /mnt/nfs/neologic/bar/src/cvs/xc/lib/X11/core.20350
GNU gdb Red Hat Linux (6.1post-1.20040607.26rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu"...Using host libthread_db library "/lib/tls/libthread_db.so.1".
 
Core was generated by `sparse -c -O2 -fno-strength-reduce -fno-strict-aliasing -ansi -pedantic -Wall -'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/tls/libc.so.6...done.
Loaded symbols for /lib/tls/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
#0  compatible_assignment_types (expr=0xf6bcb12c, target=0xf6bb6208, rp=0xf6bb626c, source=0x0, where=0x805d4be "initializer")
    at evaluate.c:882
882                     source_as = s->ctype.as;
(gdb) bt
#0  compatible_assignment_types (expr=0xf6bcb12c, target=0xf6bb6208, rp=0xf6bb626c, source=0x0, where=0x805d4be "initializer")
    at evaluate.c:882
#1  0x080574d6 in evaluate_initializer (ctype=0xf6bb6208, ep=0xf6bb626c, offset=0) at evaluate.c:1719
#2  0x08057d8a in evaluate_symbol (sym=0xf6bb6208) at evaluate.c:2077
#3  0x08057cd8 in check_duplicates (sym=0xf6bb62f0) at evaluate.c:2052
#4  0x08048b10 in clean_up_symbol (sym=0xf6bb62f0, _parent=0x0, flags=0) at check.c:29
#5  0x08050c21 in iterate (head=0x993e9e0, callback=0x8048af8 <clean_up_symbol>, data=0x0) at lib.c:215
#6  0x08048d38 in main (argc=45, argv=0xfee66bd4) at lib.h:280


Sparse was taken from bitkeeper a few minutes ago, with my #include_next hack
on top, which shouldn't cause this problem.

		Dave

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 18:25:33 +0000
Message-ID: <20040831182533.C51371422D5D () darter ! rentec ! com>
--------------------


It looks like degenerate is returning NULL for some reason and that
evaluate_initializer fails to consider that.  I don't see why there
would even be an initializer at line 1164, though.

Linus: is degenerate missing a few "break;" statements?  Or fall-through
comments.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 18:43:20 +0000
Message-ID: <Pine.LNX.4.58.0408311131160.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Dave Jones wrote:
>
> Sparse blew up when I ran it against an xorg tree (warning,
> not for the faint of heart).
> 
> ConnDis.c:1164:32:    expected incomplete type [addressable] [toplevel] xdmcp_data[0]
> ConnDis.c:1164:32:    got long
> make[3]: *** [ConnDis.o] Segmentation fault (core dumped)

Can you give me a test-case that doesn't involve downloading and setting 
up the whole xorg tree?

Looks like "source" was NULL, which in turn means that "rtype" was NULL in
"evaluate_initializer()", but since we actually check "rtype" from the
evaluate_expression, that in turn seems to imply that "degenerate()"  
returned NULL. Which in turn is "impossible", since it only returns NULL
if 'expr' or 'expr->ctype' is NULL.

And if evaluate_expression() returned non-NULL, neither of those should be 
the case.

Which means that I can certainly fix the SIGSEGV by just adding another 
check for NULL, but that doesn't really make _sense_. I'd like to see a 
test-case to trigger this to see what is really going on before I paper it 
over with a bogus NULL test..

The wat to figure out where this SIGSEGV happens is to take a look at the 
expression in question, and print out the position:

> #0  compatible_assignment_types (expr=0xf6bcb12c, target=0xf6bb6208, rp=0xf6bb626c, source=0x0, where=0x805d4be "initializer")
>     at evaluate.c:882

Can you just print out "expr->pos" from gdb, and then look at the file and 
line number (the filename you have to decode through something like
"input_streams[pos.stream].name", or you just change the source to do 
something like

	if (!source) error(expr->pos, "NULL source!");

and then you try to find if you can make a small test-case from the code 
around that area..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 18:45:15 +0000
Message-ID: <Pine.LNX.4.58.0408311143330.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Morten Welinder wrote:
> 
> It looks like degenerate is returning NULL for some reason and that
> evaluate_initializer fails to consider that.  I don't see why there
> would even be an initializer at line 1164, though.

I don't think the SIGSEGV has anything to do with the warning above it, 
it's likely some totally different code.

> Linus: is degenerate missing a few "break;" statements?  Or fall-through
> comments.

I doubt that. I _think_ it some expression evaluation sub-case that 
returns a type but _forgets_ to set "expr->ctype", so then when 
degenerate() is called, it sees a NULL expr->ctype, and returns NULL.

But I'd like to see a smaller test-case, or maybe somebody could give me 
an ssh account to something that has this all set up already..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 18:52:39 +0000
Message-ID: <20040831185239.9BF7F1422D5D () darter ! rentec ! com>
--------------------

> Can you give me a test-case that doesn't involve downloading and setting 
> up the whole xorg tree?

One possible way to do that is to try running...

    ./check [flags] -E ConnDis.c >foo.c

and see if foo.c as generated creates the same crash.  That should at
least make it a single-file testcase.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 19:02:41 +0000
Message-ID: <20040831190241.GA28118 () redhat ! com>
--------------------
On Tue, Aug 31, 2004 at 11:43:20AM -0700, Linus Torvalds wrote:
 > 
 > 
 > On Tue, 31 Aug 2004, Dave Jones wrote:
 > >
 > > Sparse blew up when I ran it against an xorg tree (warning,
 > > not for the faint of heart).
 > > 
 > > ConnDis.c:1164:32:    expected incomplete type [addressable] [toplevel] xdmcp_data[0]
 > > ConnDis.c:1164:32:    got long
 > > make[3]: *** [ConnDis.o] Segmentation fault (core dumped)
 > 
 > Can you give me a test-case that doesn't involve downloading and setting 
 > up the whole xorg tree?
 > 
 > Looks like "source" was NULL, which in turn means that "rtype" was NULL in
 > "evaluate_initializer()", but since we actually check "rtype" from the
 > evaluate_expression, that in turn seems to imply that "degenerate()"  
 > returned NULL. Which in turn is "impossible", since it only returns NULL
 > if 'expr' or 'expr->ctype' is NULL.
 > 
 > And if evaluate_expression() returned non-NULL, neither of those should be 
 > the case.
 > 
 > Which means that I can certainly fix the SIGSEGV by just adding another 
 > check for NULL, but that doesn't really make _sense_. I'd like to see a 
 > test-case to trigger this to see what is really going on before I paper it 
 > over with a bogus NULL test..
 > 
 > The wat to figure out where this SIGSEGV happens is to take a look at the 
 > expression in question, and print out the position:
 > 
 > > #0  compatible_assignment_types (expr=0xf6bcb12c, target=0xf6bb6208, rp=0xf6bb626c, source=0x0, where=0x805d4be "initializer")
 > >     at evaluate.c:882
 > 
 > Can you just print out "expr->pos" from gdb, and then look at the file and 
 > line number (the filename you have to decode through something like
 > "input_streams[pos.stream].name", or you just change the source to do 
 > something like
 > 
 > 	if (!source) error(expr->pos, "NULL source!");
 > 
 > and then you try to find if you can make a small test-case from the code 
 > around that area..

I'm puzzled.
(gdb) print expr->pos
$1 = {type = 6, stream = 1, pos = 32, newline = 0, whitespace = 1,
line = 1163, noexpand = 0}
(gdb) print input_streams[pos.stream].name
No symbol "pos" in current context.
(gdb) print input_streams[expr->pos.stream].name
$2 = 0xfefb8984 "ConnDis.c"
  
I dropped a copy of that file at http://www.codemonkey.org.uk/junk/ConnDis.c

Line 1163 is 

 1162     time (&now);
 1163     xdmcp_data[j++] = (now >> 24) & 0xFF;
 1164     xdmcp_data[j++] = (now >> 16) & 0xFF;
 1165     xdmcp_data[j++] = (now >>  8) & 0xFF;
 1166     xdmcp_data[j++] = (now >>  0) & 0xFF;


There's a bunch of similar lines a few dozen lines up, which it didn't
choke on, so I don't know what makes this one special.
Comment them out, and it passes fine.

However.. I tried to narrow the scope by deleting some bits from
*other* routines, and then it passed.  Colour me freaked out.

I'll dig some more.

		Dave

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 19:08:52 +0000
Message-ID: <20040831190852.GB28118 () redhat ! com>
--------------------
On Tue, Aug 31, 2004 at 02:52:39PM -0400, Morten Welinder wrote:
 > 
 > > Can you give me a test-case that doesn't involve downloading and setting 
 > > up the whole xorg tree?
 > 
 > One possible way to do that is to try running...
 > 
 >     ./check [flags] -E ConnDis.c >foo.c
 > 
 > and see if foo.c as generated creates the same crash.  That should at
 > least make it a single-file testcase.

I'll do that as soon as I get back, (got to run out for an hour or two).
unless someone has it figured out before I get back..

		Dave


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 19:11:39 +0000
Message-ID: <20040831191139.GA4161 () 64m ! dyndns ! org>
--------------------
Yes, I agree. I hit the similar problem before. Sparse should report the
fatal error and give up.

Chris

On Tue, Aug 31, 2004 at 03:17:44PM -0700, Linus Torvalds wrote:
> 
> 
> Basically, I think the parser got confused LONG LONG before this (probably 
> because it refuses to parse non-ANSI function declarations), and the 
> SIGSEGV is just because we let the thing continue with a confused parse 
> tree.
> 
> The reason sparse continues to handle bogus parse trees is that it _used_ 
> to be useful to see later errors (becasue earlier errors were usually 
> sparse bugs). That's not true any more, and we should probably just stop 
> trying to make sense of a parse tree that is senseless..
> 
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 19:14:14 +0000
Message-ID: <Pine.LNX.4.58.0408311210380.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Dave Jones wrote:
> 
> I'm puzzled.
> (gdb) print expr->pos
> $1 = {type = 6, stream = 1, pos = 32, newline = 0, whitespace = 1,
> line = 1163, noexpand = 0}
> (gdb) print input_streams[pos.stream].name
> No symbol "pos" in current context.
> (gdb) print input_streams[expr->pos.stream].name
> $2 = 0xfefb8984 "ConnDis.c"
>   
> I dropped a copy of that file at http://www.codemonkey.org.uk/junk/ConnDis.c
> 
> Line 1163 is 
> 
>  1162     time (&now);
>  1163     xdmcp_data[j++] = (now >> 24) & 0xFF;
>  1164     xdmcp_data[j++] = (now >> 16) & 0xFF;
>  1165     xdmcp_data[j++] = (now >>  8) & 0xFF;
>  1166     xdmcp_data[j++] = (now >>  0) & 0xFF;
> 
> There's a bunch of similar lines a few dozen lines up, which it didn't
> choke on, so I don't know what makes this one special.
> Comment them out, and it passes fine.
> 
> However.. I tried to narrow the scope by deleting some bits from
> *other* routines, and then it passed.  Colour me freaked out.

There's something seriously wrong there, there's not even an initializer 
in that.

I'd assume a buffer overflow or other wild pointer just screwing something 
up. I think I'd like to see the pre-processed file as suggested by Morten.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 19:20:55 +0000
Message-ID: <20040831192055.GA4348 () 64m ! dyndns ! org>
--------------------
On Tue, Aug 31, 2004 at 03:17:44PM -0700, Linus Torvalds wrote:
> In other words, that SIGSEGV is the _least_ of the problems. The real 
> problem is some total confusion at the parsing level, which I can't for 
> the life of me figure out why that would happen, but it started much 
> earlier, note how it tried to parse line 7591 as a function declaration:
> 
> 	foo.c:7591:8: warning: non-ANSI parameter list
> 	foo.c:7591:8: warning: Expected ) in function declarator
> 	foo.c:7591:8: warning: got &
> 	foo.c:7596:9: warning: non-ANSI parameter list
> 	foo.c:7596:9: warning: Expected ) in function declarator
> 	foo.c:7596:9: warning: got j
> 	foo.c:7598:6: warning: non-ANSI parameter list
> 	foo.c:7598:6: warning: Expected ) in function declarator
> 

I found it, check out 7386:
========================================================================
int
_XSendClientPrefix (dpy, client, auth_proto, auth_string, prefix)
                        Display *dpy;
                        xConnClientPrefix *client;
                        char *auth_proto, *auth_string;
                        xConnSetupPrefix *prefix;
{
                        int auth_length = client->nbytesAuthProto;
                        int auth_strlen = client->nbytesAuthString;
                        static char padbuf[3];
                        int pad;


That is going to hurt.

Chris

> Basically, I think the parser got confused LONG LONG before this (probably 
> because it refuses to parse non-ANSI function declarations), and the 
> SIGSEGV is just because we let the thing continue with a confused parse 
> tree.
> 
> The reason sparse continues to handle bogus parse trees is that it _used_ 
> to be useful to see later errors (becasue earlier errors were usually 
> sparse bugs). That's not true any more, and we should probably just stop 
> trying to make sense of a parse tree that is senseless..
> 
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 19:35:35 +0000
Message-ID: <20040831193535.GA4606 () 64m ! dyndns ! org>
--------------------
On Tue, Aug 31, 2004 at 11:27:32PM +0100, Dave Jones wrote:
> 
> How much work would it be to make it parse ANSI declarations?
> Whilst I agree with you how much they suck, I don't think anyone
> is going to go rewrite the gazillion such cases in X, or any
> other large codebase that may use them.
> 

It should not be too complicated. On the other hand, it is good
to move the code to use ANSI declarations. I can give it a try tonight.

Maybe we can even write a script to auto convert to ANSI declarations.

Chris
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 21:40:58 +0000
Message-ID: <20040831214058.GC28118 () redhat ! com>
--------------------
On Tue, Aug 31, 2004 at 12:14:14PM -0700, Linus Torvalds wrote:

 > > However.. I tried to narrow the scope by deleting some bits from
 > > *other* routines, and then it passed.  Colour me freaked out.
 > 
 > There's something seriously wrong there, there's not even an initializer 
 > in that.
 > 
 > I'd assume a buffer overflow or other wild pointer just screwing something 
 > up. I think I'd like to see the pre-processed file as suggested by Morten.

http://www.codemonkey.org.uk/junk/foo.c

foo.c:7575:33:    right side has type int
foo.c:7593:32:    expected incomplete type [addressable] [toplevel] xdmcp_data[0]
foo.c:7593:32:    got long
Segmentation fault (core dumped)

(22:36:00:davej@delerium:X11)$ gdb ~/bin/sparse core.3251
GNU gdb Red Hat Linux (6.1post-1.20040607.26rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu"...Using host libthread_db library "/lib/tls/libthread_db.so.1".

Core was generated by `sparse foo.c'.
Program terminated with signal 11, Segmentation fault.
Reading symbols from /lib/tls/libc.so.6...done.
Loaded symbols for /lib/tls/libc.so.6
Reading symbols from /lib/ld-linux.so.2...done.
Loaded symbols for /lib/ld-linux.so.2
#0  compatible_assignment_types (expr=0xf6d8412c, target=0xf6d7a868,
    rp=0xf6d7a8cc, source=0x0, where=0x805d4be "initializer") at evaluate.c:882
882                     source_as = s->ctype.as;
(gdb) print expr->pos
$1 = {type = 6, stream = 1, pos = 32, newline = 0, whitespace = 1,
  line = 7592, noexpand = 0}


Line 7592 is that xdmcp_data[j++] = (now >> 24) & 0xFF; line again.

Very odd.

		Dave

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 21:48:48 +0000
Message-ID: <Pine.LNX.4.58.0408311448250.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Dave Jones wrote:
> 
> http://www.codemonkey.org.uk/junk/foo.c

Thanks, got it, and I see the SIGSEGV. Will investigate.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 22:17:44 +0000
Message-ID: <Pine.LNX.4.58.0408311503510.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Dave Jones wrote:
> 
> http://www.codemonkey.org.uk/junk/foo.c

Ahh..

The limit on the number of warnings cut this one off:

	foo.c:7592:32: warning: strange non-value function or array

which makes no sense AT ALL, but I'm starting to get a clue..

For some reason sparse has parsed the

	xdmcp_data[j++] = (now >> 24) & 0xFF;

as a _declaration_ of a new array "xdmcp_data[]", and is trying to 
initialize it.

The warning limit also hid this:

	foo.c:7593:14: warning: bad constant expression

which comes from the "j++" (sparse wants the array to be declared as a 
fixed size one ;)

In other words, that SIGSEGV is the _least_ of the problems. The real 
problem is some total confusion at the parsing level, which I can't for 
the life of me figure out why that would happen, but it started much 
earlier, note how it tried to parse line 7591 as a function declaration:

	foo.c:7591:8: warning: non-ANSI parameter list
	foo.c:7591:8: warning: Expected ) in function declarator
	foo.c:7591:8: warning: got &
	foo.c:7596:9: warning: non-ANSI parameter list
	foo.c:7596:9: warning: Expected ) in function declarator
	foo.c:7596:9: warning: got j
	foo.c:7598:6: warning: non-ANSI parameter list
	foo.c:7598:6: warning: Expected ) in function declarator

Basically, I think the parser got confused LONG LONG before this (probably 
because it refuses to parse non-ANSI function declarations), and the 
SIGSEGV is just because we let the thing continue with a confused parse 
tree.

The reason sparse continues to handle bogus parse trees is that it _used_ 
to be useful to see later errors (becasue earlier errors were usually 
sparse bugs). That's not true any more, and we should probably just stop 
trying to make sense of a parse tree that is senseless..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 22:27:32 +0000
Message-ID: <20040831222732.GD28118 () redhat ! com>
--------------------
On Tue, Aug 31, 2004 at 03:17:44PM -0700, Linus Torvalds wrote:

 > In other words, that SIGSEGV is the _least_ of the problems. The real 
 > problem is some total confusion at the parsing level, which I can't for 
 > the life of me figure out why that would happen, but it started much 
 > earlier, note how it tried to parse line 7591 as a function declaration:
 > 
 > 	foo.c:7591:8: warning: non-ANSI parameter list
 > 	foo.c:7591:8: warning: Expected ) in function declarator
 > 	foo.c:7591:8: warning: got &
 > 	foo.c:7596:9: warning: non-ANSI parameter list
 > 	foo.c:7596:9: warning: Expected ) in function declarator
 > 	foo.c:7596:9: warning: got j
 > 	foo.c:7598:6: warning: non-ANSI parameter list
 > 	foo.c:7598:6: warning: Expected ) in function declarator
 > 
 > Basically, I think the parser got confused LONG LONG before this (probably 
 > because it refuses to parse non-ANSI function declarations), and the 
 > SIGSEGV is just because we let the thing continue with a confused parse 
 > tree.

How much work would it be to make it parse ANSI declarations?
Whilst I agree with you how much they suck, I don't think anyone
is going to go rewrite the gazillion such cases in X, or any
other large codebase that may use them.

		Dave


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 23:11:24 +0000
Message-ID: <Pine.LNX.4.58.0408311609310.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Dave Jones wrote:
> 
> How much work would it be to make it parse ANSI declarations?

Pretty trivial.

I just pushed it out.

NOTE! The stuff I pused out just _parses_ them. It doesn't actually apply 
the types that it has parsed to the arguments it parsed earlier, so a K&R 
function will end up having all it's arguments be "untyped". I'll see if I 
can care enough to do the argument type fixup too. It's not hard, it's 
just matching up the "fn->args" list with the newly generated declaration 
list..

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 23:12:59 +0000
Message-ID: <20040831231258.GF28118 () redhat ! com>
--------------------
On Tue, Aug 31, 2004 at 03:35:35PM -0400, Christopher Li wrote:
 > On Tue, Aug 31, 2004 at 11:27:32PM +0100, Dave Jones wrote:
 > > 
 > > How much work would it be to make it parse ANSI declarations?
 > > Whilst I agree with you how much they suck, I don't think anyone
 > > is going to go rewrite the gazillion such cases in X, or any
 > > other large codebase that may use them.
 > > 
 > 
 > It should not be too complicated. On the other hand, it is good
 > to move the code to use ANSI declarations. I can give it a try tonight.

After giving this second thought, and a quick discussion with some
of our X bods, I think you might be right, and making a stand and not
supporting it may be in the best interests of everyone.

 > Maybe we can even write a script to auto convert to ANSI declarations.

I'm surprised one doesn't exist already.

		Dave

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Tue, 31 Aug 2004 23:24:15 +0000
Message-ID: <Pine.LNX.4.58.0408311621350.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Linus Torvalds wrote:
> 
> NOTE! The stuff I pused out just _parses_ them. It doesn't actually apply 
> the types that it has parsed to the arguments it parsed earlier, so a K&R 
> function will end up having all it's arguments be "untyped". I'll see if I 
> can care enough to do the argument type fixup too. It's not hard [...]

Indeed, it was just another ten lines or so of code.

Pushed out.

It will still _complain_ about K&R declarations, and it actually gets them 
wrong, since it doesn't promote char to int etc, but it's "good enough" 
for now.

A real C compiler would say that

	int fn(a)
		char a;
	{
		...
	}

has a prototype like

	int fn(int a);

but sparse for now will consider the K&R declaration to be the same as

	int fn(char a);

because I'm a lazy bastard, and I really can't find it in me to care.

Maybe somebody else does.. And no, I won't guarantee that it actually 
works. I tried it out on a truly trivial test-program.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse breakage.
Date: Wed, 01 Sep 2004 02:28:10 +0000
Message-ID: <Pine.LNX.4.58.0408311923590.2295 () ppc970 ! osdl ! org>
--------------------


On Tue, 31 Aug 2004, Dave Jones wrote:
> 
> http://www.codemonkey.org.uk/junk/foo.c

Ok, I finally tested my K&R parser on this, and after it found a really 
silly bug and I fixed it (a K&R parse would ignore the first token due to 
a total thinko), sparse seems pretty happy with this file:

	torvalds@ppc970:~/BK/sparse> ./check foo.c
	foo.c:3549:54: warning: attribute '__transparent_union__': unknown attribute
	foo.c:4725:55: warning: attribute '__transparent_union__': unknown attribute
	foo.c:4740:61: warning: attribute '__transparent_union__': unknown attribute
	foo.c:5307:28: warning: attribute '__const': unknown attribute
	foo.c:5309:28: warning: attribute '__const': unknown attribute
	foo.c:5311:28: warning: attribute '__const': unknown attribute
	foo.c:5600:1: warning: non-ANSI function declaration
	foo.c:5608:1: warning: non-ANSI function declaration
	foo.c:5679:1: warning: non-ANSI function declaration

and that's it. It complained about the non-ANSI function declarations, but 
it ate them like the nice tool it is.

I've also verified that it does the right thing wrt mixed ANSI/K&R 
declarations.

(Those line numbers may not match your original foo.c - I ran the file
through indent to make it look slightly better: it's surprising just _how_
hard it is to read badly indented source-code).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse doesn't recognise register naming ===

From: Russell King <rmk () arm ! linux ! org ! uk>
To: linux-sparse
Subject: sparse doesn't recognise register naming
Date: Fri, 30 Jan 2004 23:58:41 +0000
Message-ID: <20040130235841.A31251 () flint ! arm ! linux ! org ! uk>
--------------------
I've just looked into using sparse on ARM, and have come across this
warning:

warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
warning: include/asm/thread_info.h:84:28: got asm

which corresponds to this:

static inline struct thread_info *current_thread_info(void)
{
        register unsigned long sp asm ("sp");
        return (struct thread_info *)(sp & ~0x1fff);
}

specifically the "sp" variable.  This syntax is used in several places
in the ARM kernel port to tell gcc that certain values will be in certain
registers.  Unfortunately it seems that sparse doesn't understand this.

(In case of misinterpretation, the only reason I'm sending this is so
that it can be archived in case anyone is interested.)

-- 
Russell King
 Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
 maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
                 2.6 Serial core
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Russell King <rmk () arm ! linux ! org ! uk>
To: linux-sparse
Subject: sparse doesn't recognise register naming
Date: Fri, 30 Jan 2004 23:58:41 +0000
Message-ID: <20040130235841.A31251 () flint ! arm ! linux ! org ! uk>
--------------------
I've just looked into using sparse on ARM, and have come across this
warning:

warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
warning: include/asm/thread_info.h:84:28: got asm

which corresponds to this:

static inline struct thread_info *current_thread_info(void)
{
        register unsigned long sp asm ("sp");
        return (struct thread_info *)(sp & ~0x1fff);
}

specifically the "sp" variable.  This syntax is used in several places
in the ARM kernel port to tell gcc that certain values will be in certain
registers.  Unfortunately it seems that sparse doesn't understand this.

(In case of misinterpretation, the only reason I'm sending this is so
that it can be archived in case anyone is interested.)

-- 
Russell King
 Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
 maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
                 2.6 Serial core
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: sparse () chrisli ! org
To: linux-sparse
Subject: Re: sparse doesn't recognise register naming
Date: Sat, 31 Jan 2004 11:57:05 +0000
Message-ID: <20040131115705.GA25479 () 64m ! dyndns ! org>
--------------------
How about this patch?

Chris

===== parse.c 1.109 vs edited =====
--- 1.109/parse.c       Thu Oct  2 02:36:12 2003
+++ edited/parse.c      Sat Jan 31 06:52:20 2004
@@ -1140,6 +1140,18 @@
        }
  
        for (;;) {
+               if (token_type(token) == TOKEN_IDENT) {
+                       if (token->ident ==  &asm_ident || token->ident == &__asm_ident || token->ident == &__asm___ident) {
+                               struct expression *expr;
+
+                               if (!is_typedef && !(decl->ctype.modifiers & MOD_REGISTER))
+                                       warn(decl->pos, "asm-specifier for non-register variable");
+
+                               token = expect(token->next, '(', "after asm");
+                               token = parse_expression(token->next, &expr);
+                               token = expect(token, ')', "after asm");
+                       }
+               }
                if (!is_typedef && match_op(token, '=')) {
                        if (decl->ctype.modifiers & MOD_EXTERN) {
                                warn(decl->pos, "symbol with external linkage has initializer");

On Fri, Jan 30, 2004 at 11:58:41PM +0000, Russell King wrote:
> I've just looked into using sparse on ARM, and have come across this
> warning:
> 
> warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
> warning: include/asm/thread_info.h:84:28: got asm
> 
> which corresponds to this:
> 
> static inline struct thread_info *current_thread_info(void)
> {
>         register unsigned long sp asm ("sp");
>         return (struct thread_info *)(sp & ~0x1fff);
> }
> 
> specifically the "sp" variable.  This syntax is used in several places
> in the ARM kernel port to tell gcc that certain values will be in certain
> registers.  Unfortunately it seems that sparse doesn't understand this.
> 
> (In case of misinterpretation, the only reason I'm sending this is so
> that it can be archived in case anyone is interested.)
> 
> -- 
> Russell King
>  Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
>  maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
>                  2.6 Serial core
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: sparse () chrisli ! org
To: linux-sparse
Subject: Re: sparse doesn't recognise register naming
Date: Sat, 31 Jan 2004 11:57:05 +0000
Message-ID: <20040131115705.GA25479 () 64m ! dyndns ! org>
--------------------
How about this patch?

Chris

===== parse.c 1.109 vs edited =====
--- 1.109/parse.c       Thu Oct  2 02:36:12 2003
+++ edited/parse.c      Sat Jan 31 06:52:20 2004
@@ -1140,6 +1140,18 @@
        }
  
        for (;;) {
+               if (token_type(token) == TOKEN_IDENT) {
+                       if (token->ident ==  &asm_ident || token->ident == &__asm_ident || token->ident == &__asm___ident) {
+                               struct expression *expr;
+
+                               if (!is_typedef && !(decl->ctype.modifiers & MOD_REGISTER))
+                                       warn(decl->pos, "asm-specifier for non-register variable");
+
+                               token = expect(token->next, '(', "after asm");
+                               token = parse_expression(token->next, &expr);
+                               token = expect(token, ')', "after asm");
+                       }
+               }
                if (!is_typedef && match_op(token, '=')) {
                        if (decl->ctype.modifiers & MOD_EXTERN) {
                                warn(decl->pos, "symbol with external linkage has initializer");

On Fri, Jan 30, 2004 at 11:58:41PM +0000, Russell King wrote:
> I've just looked into using sparse on ARM, and have come across this
> warning:
> 
> warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
> warning: include/asm/thread_info.h:84:28: got asm
> 
> which corresponds to this:
> 
> static inline struct thread_info *current_thread_info(void)
> {
>         register unsigned long sp asm ("sp");
>         return (struct thread_info *)(sp & ~0x1fff);
> }
> 
> specifically the "sp" variable.  This syntax is used in several places
> in the ARM kernel port to tell gcc that certain values will be in certain
> registers.  Unfortunately it seems that sparse doesn't understand this.
> 
> (In case of misinterpretation, the only reason I'm sending this is so
> that it can be archived in case anyone is interested.)
> 
> -- 
> Russell King
>  Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
>  maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
>                  2.6 Serial core
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse doesn't recognise register naming
Date: Thu, 15 Apr 2004 13:50:07 +0000
Message-ID: <20040415135007.GA15616 () 64m ! dyndns ! org>
--------------------
Patch refreshed. Russell, can you please verify it again?

Linus, do you want to take this one?

Thanks,

Chris

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2004-04-15 09:42:50.000000000 -0400
+++ sparse/parse.c	2004-04-15 09:43:43.000000000 -0400
@@ -1170,6 +1170,18 @@
 	}
 
 	for (;;) {
+		if (token_type(token) == TOKEN_IDENT) {
+			if (token->ident ==  &asm_ident || token->ident == &__asm_ident || token->ident == &__asm___ident) {
+				struct expression *expr;
+
+				if (!is_typedef && !(decl->ctype.modifiers & MOD_REGISTER))
+					warn(decl->pos, "asm-specifier for non-register variable");
+
+				token = expect(token->next, '(', "after asm");
+				token = parse_expression(token->next, &expr);
+				token = expect(token, ')', "after asm");
+			}
+		}
 		if (!is_typedef && match_op(token, '=')) {
 			if (decl->ctype.modifiers & MOD_EXTERN) {
 				warn(decl->pos, "symbol with external linkage has initializer");

On Thu, Apr 15, 2004 at 10:29:50PM +0100, Russell King wrote:
> On Sat, Jan 31, 2004 at 06:57:05AM -0500, sparse@chrisli.org wrote:
> 
> This patch fixes the problem for me.  However, it'll need updating to
> todays sparse.
> 
> > On Fri, Jan 30, 2004 at 11:58:41PM +0000, Russell King wrote:
> > > I've just looked into using sparse on ARM, and have come across this
> > > warning:
> > > 
> > > warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
> > > warning: include/asm/thread_info.h:84:28: got asm
> > > 
> > > which corresponds to this:
> > > 
> > > static inline struct thread_info *current_thread_info(void)
> > > {
> > >         register unsigned long sp asm ("sp");
> > >         return (struct thread_info *)(sp & ~0x1fff);
> > > }
> > > 
> > > specifically the "sp" variable.  This syntax is used in several places
> > > in the ARM kernel port to tell gcc that certain values will be in certain
> > > registers.  Unfortunately it seems that sparse doesn't understand this.
> > > 
> > > (In case of misinterpretation, the only reason I'm sending this is so
> > > that it can be archived in case anyone is interested.)
> 
> -- 
> Russell King
>  Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
>  maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
>                  2.6 Serial core
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse doesn't recognise register naming
Date: Thu, 15 Apr 2004 13:50:07 +0000
Message-ID: <20040415135007.GA15616 () 64m ! dyndns ! org>
--------------------
Patch refreshed. Russell, can you please verify it again?

Linus, do you want to take this one?

Thanks,

Chris

Index: sparse/parse.c
===================================================================
--- sparse.orig/parse.c	2004-04-15 09:42:50.000000000 -0400
+++ sparse/parse.c	2004-04-15 09:43:43.000000000 -0400
@@ -1170,6 +1170,18 @@
 	}
 
 	for (;;) {
+		if (token_type(token) == TOKEN_IDENT) {
+			if (token->ident ==  &asm_ident || token->ident == &__asm_ident || token->ident == &__asm___ident) {
+				struct expression *expr;
+
+				if (!is_typedef && !(decl->ctype.modifiers & MOD_REGISTER))
+					warn(decl->pos, "asm-specifier for non-register variable");
+
+				token = expect(token->next, '(', "after asm");
+				token = parse_expression(token->next, &expr);
+				token = expect(token, ')', "after asm");
+			}
+		}
 		if (!is_typedef && match_op(token, '=')) {
 			if (decl->ctype.modifiers & MOD_EXTERN) {
 				warn(decl->pos, "symbol with external linkage has initializer");

On Thu, Apr 15, 2004 at 10:29:50PM +0100, Russell King wrote:
> On Sat, Jan 31, 2004 at 06:57:05AM -0500, sparse@chrisli.org wrote:
> 
> This patch fixes the problem for me.  However, it'll need updating to
> todays sparse.
> 
> > On Fri, Jan 30, 2004 at 11:58:41PM +0000, Russell King wrote:
> > > I've just looked into using sparse on ARM, and have come across this
> > > warning:
> > > 
> > > warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
> > > warning: include/asm/thread_info.h:84:28: got asm
> > > 
> > > which corresponds to this:
> > > 
> > > static inline struct thread_info *current_thread_info(void)
> > > {
> > >         register unsigned long sp asm ("sp");
> > >         return (struct thread_info *)(sp & ~0x1fff);
> > > }
> > > 
> > > specifically the "sp" variable.  This syntax is used in several places
> > > in the ARM kernel port to tell gcc that certain values will be in certain
> > > registers.  Unfortunately it seems that sparse doesn't understand this.
> > > 
> > > (In case of misinterpretation, the only reason I'm sending this is so
> > > that it can be archived in case anyone is interested.)
> 
> -- 
> Russell King
>  Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
>  maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
>                  2.6 Serial core
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Russell King <rmk () arm ! linux ! org ! uk>
To: linux-sparse
Subject: Re: sparse doesn't recognise register naming
Date: Thu, 15 Apr 2004 21:29:50 +0000
Message-ID: <20040415222950.C7909 () flint ! arm ! linux ! org ! uk>
--------------------
On Sat, Jan 31, 2004 at 06:57:05AM -0500, sparse@chrisli.org wrote:
> How about this patch?

This patch fixes the problem for me.  However, it'll need updating to
todays sparse.

> ===== parse.c 1.109 vs edited =====
> --- 1.109/parse.c       Thu Oct  2 02:36:12 2003
> +++ edited/parse.c      Sat Jan 31 06:52:20 2004
> @@ -1140,6 +1140,18 @@
>         }
>   
>         for (;;) {
> +               if (token_type(token) == TOKEN_IDENT) {
> +                       if (token->ident ==  &asm_ident || token->ident == &__asm_ident || token->ident == &__asm___ident) {
> +                               struct expression *expr;
> +
> +                               if (!is_typedef && !(decl->ctype.modifiers & MOD_REGISTER))
> +                                       warn(decl->pos, "asm-specifier for non-register variable");
> +
> +                               token = expect(token->next, '(', "after asm");
> +                               token = parse_expression(token->next, &expr);
> +                               token = expect(token, ')', "after asm");
> +                       }
> +               }
>                 if (!is_typedef && match_op(token, '=')) {
>                         if (decl->ctype.modifiers & MOD_EXTERN) {
>                                 warn(decl->pos, "symbol with external linkage has initializer");
> 
> On Fri, Jan 30, 2004 at 11:58:41PM +0000, Russell King wrote:
> > I've just looked into using sparse on ARM, and have come across this
> > warning:
> > 
> > warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
> > warning: include/asm/thread_info.h:84:28: got asm
> > 
> > which corresponds to this:
> > 
> > static inline struct thread_info *current_thread_info(void)
> > {
> >         register unsigned long sp asm ("sp");
> >         return (struct thread_info *)(sp & ~0x1fff);
> > }
> > 
> > specifically the "sp" variable.  This syntax is used in several places
> > in the ARM kernel port to tell gcc that certain values will be in certain
> > registers.  Unfortunately it seems that sparse doesn't understand this.
> > 
> > (In case of misinterpretation, the only reason I'm sending this is so
> > that it can be archived in case anyone is interested.)

-- 
Russell King
 Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
 maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
                 2.6 Serial core
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================

From: Russell King <rmk () arm ! linux ! org ! uk>
To: linux-sparse
Subject: Re: sparse doesn't recognise register naming
Date: Thu, 15 Apr 2004 21:29:50 +0000
Message-ID: <20040415222950.C7909 () flint ! arm ! linux ! org ! uk>
--------------------
On Sat, Jan 31, 2004 at 06:57:05AM -0500, sparse@chrisli.org wrote:
> How about this patch?

This patch fixes the problem for me.  However, it'll need updating to
todays sparse.

> ===== parse.c 1.109 vs edited =====
> --- 1.109/parse.c       Thu Oct  2 02:36:12 2003
> +++ edited/parse.c      Sat Jan 31 06:52:20 2004
> @@ -1140,6 +1140,18 @@
>         }
>   
>         for (;;) {
> +               if (token_type(token) == TOKEN_IDENT) {
> +                       if (token->ident ==  &asm_ident || token->ident == &__asm_ident || token->ident == &__asm___ident) {
> +                               struct expression *expr;
> +
> +                               if (!is_typedef && !(decl->ctype.modifiers & MOD_REGISTER))
> +                                       warn(decl->pos, "asm-specifier for non-register variable");
> +
> +                               token = expect(token->next, '(', "after asm");
> +                               token = parse_expression(token->next, &expr);
> +                               token = expect(token, ')', "after asm");
> +                       }
> +               }
>                 if (!is_typedef && match_op(token, '=')) {
>                         if (decl->ctype.modifiers & MOD_EXTERN) {
>                                 warn(decl->pos, "symbol with external linkage has initializer");
> 
> On Fri, Jan 30, 2004 at 11:58:41PM +0000, Russell King wrote:
> > I've just looked into using sparse on ARM, and have come across this
> > warning:
> > 
> > warning: include/asm/thread_info.h:84:28: Expected ; at end of declaration
> > warning: include/asm/thread_info.h:84:28: got asm
> > 
> > which corresponds to this:
> > 
> > static inline struct thread_info *current_thread_info(void)
> > {
> >         register unsigned long sp asm ("sp");
> >         return (struct thread_info *)(sp & ~0x1fff);
> > }
> > 
> > specifically the "sp" variable.  This syntax is used in several places
> > in the ARM kernel port to tell gcc that certain values will be in certain
> > registers.  Unfortunately it seems that sparse doesn't understand this.
> > 
> > (In case of misinterpretation, the only reason I'm sending this is so
> > that it can be archived in case anyone is interested.)

-- 
Russell King
 Linux kernel    2.6 ARM Linux   - http://www.arm.linux.org.uk/
 maintainer of:  2.6 PCMCIA      - http://pcmcia.arm.linux.org.uk/
                 2.6 Serial core
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html


================================================================================


################################################################################

=== Thread: sparse error reporting ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: sparse error reporting
Date: Sat, 04 Dec 2004 05:50:08 +0000
Message-ID: <41B15010.8000207 () osdl ! org>
--------------------
I made allmodconfig on 2.6.10-rc3 (built on x86-64),
using -j4 (parallel make).
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~`

make[2]: *** [drivers/bluetooth/bluecard_cs.o] Error 139
make[1]: *** [drivers/bluetooth] Error 2

No other error/warning messages for bluecard_cs.o and it
builds cleanly if I omit "C=1".
Does Error 139 mean anything special/known?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   CHECK   fs/reiserfs/journal.c
   CHECK   fs/xfs/quota/xfs_qm_bhv.c
   LD [M]  fs/udf/udf.o
   CHECK   fs/dcookies.c
sparse: flow.c:834: vrfy_bb_in_list: Assertion `no_bb_in_list' failed.
make[2]: *** [fs/reiserfs/journal.o] Error 134

Any idea what Error 134 means?

More importantly (for parallel makes), can the sparse
message(s) include the <problem> source file name/line number?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   CHECK   drivers/net/irda/vlsi_ir.c
sparse: flow.c:834: vrfy_bb_in_list: Assertion `no_bb_in_list' failed.
make[3]: *** [drivers/net/irda/vlsi_ir.o] Error 134
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   CHECK   drivers/net/3c59x.c
make[2]: *** [drivers/net/3c59x.o] Error 139

No other error/warning messages....
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Error 134 | 139 files all build cleanly if I omit "C=1"
on the make command.


-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse error reporting
Date: Sat, 04 Dec 2004 17:49:15 +0000
Message-ID: <Pine.LNX.4.58.0412040947390.22796 () ppc970 ! osdl ! org>
--------------------


On Fri, 3 Dec 2004, Randy.Dunlap wrote:
> 
> No other error/warning messages for bluecard_cs.o and it
> builds cleanly if I omit "C=1".
> Does Error 139 mean anything special/known?

It's 128 + 11. Which is SIGSEGV.

>    CHECK   fs/dcookies.c
> sparse: flow.c:834: vrfy_bb_in_list: Assertion `no_bb_in_list' failed.
> make[2]: *** [fs/reiserfs/journal.o] Error 134
> 
> Any idea what Error 134 means?

128 + 6, aka SIGABRT.

> More importantly (for parallel makes), can the sparse
> message(s) include the <problem> source file name/line number?

I could try to trap signals and report nicer errors, but I'll just fix 
these cases instead. Thanks.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse error reporting
Date: Sat, 04 Dec 2004 20:26:26 +0000
Message-ID: <Pine.LNX.4.58.0412041224590.22796 () ppc970 ! osdl ! org>
--------------------


On Fri, 3 Dec 2004, Randy.Dunlap wrote:
> 
> make[2]: *** [drivers/bluetooth/bluecard_cs.o] Error 139
> make[1]: *** [drivers/bluetooth] Error 2

Ok, this one is still there. Seems to be some serious parent list 
corruption, probably because we killed a basic block that was still 
reachable. Will continue to investigate.

> sparse: flow.c:834: vrfy_bb_in_list: Assertion `no_bb_in_list' failed.
> make[2]: *** [fs/reiserfs/journal.o] Error 134

Ok, I think I've fixed these. Silly flow error, where we removed a bit too 
many parent pointers.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse error reporting
Date: Sun, 05 Dec 2004 07:33:45 +0000
Message-ID: <Pine.LNX.4.58.0412042316150.22796 () ppc970 ! osdl ! org>
--------------------


Ok, sparse should be feeling better now.

It still complains about "crazy programmer" for a few files, but at least
one of them (fs/afs/proc.c) really does look like the complaint is because
of an initialization through inline assembly that sparse just can't see
yet. The other ones (avmb ISDN driver) may be just sparse showing 
uncommonly good taste again, but there are asms involved there too, so it 
might be that too.

I guess I'll have to teach sparse what an inline asm really means.

Anyway, it should otherwise pass a "make allmodconfig".

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse error reporting
Date: Mon, 06 Dec 2004 03:00:56 +0000
Message-ID: <Pine.LNX.4.58.0412051848390.22796 () ppc970 ! osdl ! org>
--------------------


On Sat, 4 Dec 2004, Linus Torvalds wrote:
> 
> It still complains about "crazy programmer" for a few files, but at least
> one of them (fs/afs/proc.c) really does look like the complaint is because
> of an initialization through inline assembly that sparse just can't see
> yet. The other ones (avmb ISDN driver) may be just sparse showing 
> uncommonly good taste again, but there are asms involved there too, so it 
> might be that too.

Yup. I've done inline asms now, and "crazy programmer" is gone. So it was 
indeed something that was initialized by an inline asm.

Looking at some kernel linearizations, the only obvious error I see 
remaining is the fact that the linearizer doesn't handle complex 
assignments right, ie

	struct xxxx var;

	var = (struct xxxx) { val ... };

doesn't linearize properly, even though true initializers do (ie

	struct xxxx var = { val ... };

is ok, it's just the assignment case that isn't).

That one _shouldn't_ be fundamental either, since clearly I do know how to 
handle them, just not one particular pattern of them. I'll get around to 
it eventually.

Right now the inline asm thing throws away the register classes on 
linearization, but it does keep track of the assignments properly, so 
something like

	void change_flags(unsigned long *old, unsigned long *new)
	{
		asm("pushfl ; popl %0" :"=r" (*old));
		asm("pushl %0 ; popfl" : :"r" (*new));
	}

linearizes as (ignoring deathnotes)

	change_flags:
	.L0xf7f9e00c:
	        <entry-point>
	        asm        "pushfl ; popl %0" ( %r1 ) <-
	        store.32   %r1 -> 0[%arg1]
	        load.32    %r4 <- 0[%arg2]
	        asm        "pushl %0 ; popfl" ( %r4 )
	        ret

which all makes sense, and if I did register allocation (and kept track 
of the requirements for asms), I could generate code for it.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse howto? ===

From: Josh Boyer <jwboyer () charter ! net>
To: linux-sparse
Subject: sparse howto?
Date: Sat, 12 Jun 2004 00:55:22 +0000
Message-ID: <1087001722.2665.6.camel () localhost ! localdomain>
--------------------
Howdy,

Is there a howto for sparse anywhere.  I found the source code at
http://sparse.bkbits.net:8080/sparse (also on Dave Jones' website), but
I haven't found anything on how to run it.

I'm mostly interested in running it on the kernel source (like most
people I would assume).  Any knowledge that anyone cares to share would
be appreciated.

I'm not subscribed to this list (yet), so please CC me on a reply.

thx,
josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: sparse howto?
Date: Sat, 12 Jun 2004 02:17:41 +0000
Message-ID: <20040611191741.3812e4a5.rddunlap () osdl ! org>
--------------------
On Fri, 11 Jun 2004 19:55:22 -0500 Josh Boyer wrote:

| Howdy,
| 
| Is there a howto for sparse anywhere.  I found the source code at
| http://sparse.bkbits.net:8080/sparse (also on Dave Jones' website), but
| I haven't found anything on how to run it.
| 
| I'm mostly interested in running it on the kernel source (like most
| people I would assume).  Any knowledge that anyone cares to share would
| be appreciated.
| 
| I'm not subscribed to this list (yet), so please CC me on a reply.

in kernel tree:  make help

says:
  make C=1   [targets] Check all c source with checker tool


so build/install it (see below) and then do your target build, e.g.,

make allmodconfig (or defconfig or whatever)
make C=1 all >build.out 2>&1     # to capture all messages


buid/install is trivial:
a.  unpack the tarball or export the bk tree
b.  cd .../sparse
c.  make
d.  cp check ~/bin/sparse     # in user's home dir.



Does that help?  What other questions do you have?
(but I probably can't answer any more)

--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Josh Boyer <jwboyer () charter ! net>
To: linux-sparse
Subject: Re: sparse howto?
Date: Sat, 12 Jun 2004 11:44:34 +0000
Message-ID: <1087040673.2576.4.camel () c68 ! 115 ! 90 ! 143 ! roc ! mn ! charter ! com>
--------------------
On Fri, 2004-06-11 at 21:17, Randy.Dunlap wrote:
> in kernel tree:  make help
> 
> says:
>   make C=1   [targets] Check all c source with checker tool
> 
> 
> so build/install it (see below) and then do your target build, e.g.,
> 
> make allmodconfig (or defconfig or whatever)
> make C=1 all >build.out 2>&1     # to capture all messages
> 
> 
> buid/install is trivial:
> a.  unpack the tarball or export the bk tree
> b.  cd .../sparse
> c.  make
> d.  cp check ~/bin/sparse     # in user's home dir.
> 
> 
> 
> Does that help?  What other questions do you have?
> (but I probably can't answer any more)

Yes, that is exactly what I was looking for.  Thanks!  I don't have any
other questions at the moment, but I am sure I'll come up with some
later :).

Maybe something like this could be put in the FAQ file for sparse.  Then
the list wouldn't have to suffer newbies such as myself ;).

thx,
josh

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse in compile stats ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse in compile stats
Date: Sun, 06 Jun 2004 19:18:07 +0000
Message-ID: <Pine.LNX.4.58.0406061216210.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 6 Jun 2004, Sam Ravnborg wrote:
> 
> Recently Al Viro has put in a huge effort into sparse sanitize the kernel,
> and likewise Linus has done several updates to sparse.
> Net result is a _lot_ of sparse warnings removed, and very few (if any?) false positives.

There's at least one driver (forget which - it's not part of my normal
setup on either x86 or ppc64) that is non-ANSI C code and Al didn't feel
like he could fix up, and sparse just explodes on it. But yes, if somebody
starts sending reports on it, I can probably fix up sparse enough that it
just says "I'm not going to bother with this crap" rather than explode.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: sparse in compile stats
Date: Sun, 06 Jun 2004 19:18:30 +0000
Message-ID: <20040606191830.GB2788 () mars ! ravnborg ! org>
--------------------
Hi John.

Recently Al Viro has put in a huge effort into sparse sanitize the kernel,
and likewise Linus has done several updates to sparse.
Net result is a _lot_ of sparse warnings removed, and very few (if any?) false positives.

Do you think it is worth to include a sparse run when Linus does next -rc?
Comparing with older versions should only be for amusement, since Al and Linus did
such a big effor the last weeks.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse in compile stats
Date: Sun, 06 Jun 2004 19:29:27 +0000
Message-ID: <Pine.LNX.4.58.0406061226270.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 6 Jun 2004, Linus Torvalds wrote:
> 
> There's at least one driver (forget which - it's not part of my normal
> setup on either x86 or ppc64) that is non-ANSI C code and Al didn't feel
> like he could fix up, and sparse just explodes on it.

Ahh. drivers/net/skfp/*.

I fixed the sparse problem. It will complain a LOT about "non-ANSI
parameter list" in that piece of crap, but it should avoid a SIGSEGV. 
Maybe.

There are probably tons of other paths where sparse will sigsegv on bad 
(or missing) type information. Part of the reason for that is that I 
should have made those kinds of errors fatal, but in order to get more 
coverage of the parsing, I just let sparse continue - and then later parts 
end up unhappy about the fact that something doesn't have a type.

One of these days I'll just decide that we have enough coverage already, 
and sparse can just say "I'll refuse to parse this crud any more". 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse in compile stats
Date: Sun, 06 Jun 2004 19:47:23 +0000
Message-ID: <20040606194722.GA4178 () mars ! ravnborg ! org>
--------------------
On Sun, Jun 06, 2004 at 12:18:07PM -0700, Linus Torvalds wrote:
> "I'm not going to bother with this crap" rather than explode.

Here is a small code snippet where sparse explodes:

#define __user              __attribute__((noderef, address_space(1)))

long sys_wait4(int n, unsigned int __user *stat_addr);


static int wait_for_helper(void *data)
{
	int i;
        sys_wait4(1, (__user)&i);
}

It did not like my wrong attribute usage.
Obvious error from my side...

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse in compile stats
Date: Sun, 06 Jun 2004 19:56:42 +0000
Message-ID: <Pine.LNX.4.58.0406061251280.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 6 Jun 2004, Sam Ravnborg wrote:
>
> It did not like my wrong attribute usage.
> Obvious error from my side...

What this one shows, btw, is my (probably wrongheaded) decision to say 
that "partial types can be ok". I'm actually hoping to make sparse do 
something very non-C-like some day, by allowing non-specific types that 
take the full type information from the context in which they are used.

So for example, I'd like to have nontyped inline functions, where the 
types literally come from the caller. 

But in this case, I'm allowing a partial type in type parsing, and then 
when _using_ it, it crashes because of lack of any base-type info.

The interesting part is how _many_ places your simple example shows to be 
broken.. Wonderful test-case. Thanks,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse in compile stats
Date: Sun, 06 Jun 2004 20:17:32 +0000
Message-ID: <Pine.LNX.4.58.0406061314270.1730 () ppc970 ! osdl ! org>
--------------------


On Sun, 6 Jun 2004, Linus Torvalds wrote:
> 
> The interesting part is how _many_ places your simple example shows to be 
> broken.. Wonderful test-case. Thanks,

Fixed. The trivial fix was to just introduce the notion of an "incomplete 
type", which also makes the error messages automatically come out really 
nice. Your test-case now prints out

	test.c:9:16: warning: incorrect type in argument 2 (different base types)
	test.c:9:16:    expected unsigned int [noderef] *stat_addr<asn:1>
	test.c:9:16:    got incomplete type [noderef] <noident><asn:1>

which makes a lot of sense (to me, at least).

Arguably the empty "__user" would parse as the normal C implicit type,
which is "int", since you can also do things like

	volatile a;

and traditionally C just assumes that you mean "int". Me, I don't like
that. I call it a "incomplete type", and only assume "int" if you say
char/short/long/unsigned/signed.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: John Cherry <cherry () osdl ! org>
To: linux-sparse
Subject: Re: sparse in compile stats
Date: Mon, 07 Jun 2004 04:06:26 +0000
Message-ID: <1086581185.4229.125.camel () lightning>
--------------------
Thanks.  I'll put the sparse regressions back into the builds.  I built
the allmodcofig configuration for both bzImage and modules with sparse
on 2.6.7-rc2 and the results are at:

http://developer.osdl.org/cherry/compile/2.6/linux-2.6.7-rc2.results/sparselog.linux-2.6.7-rc2

John

On Sun, 2004-06-06 at 13:17, Linus Torvalds wrote:
> On Sun, 6 Jun 2004, Linus Torvalds wrote:
> > 
> > The interesting part is how _many_ places your simple example shows to be 
> > broken.. Wonderful test-case. Thanks,
> 
> Fixed. The trivial fix was to just introduce the notion of an "incomplete 
> type", which also makes the error messages automatically come out really 
> nice. Your test-case now prints out
> 
> 	test.c:9:16: warning: incorrect type in argument 2 (different base types)
> 	test.c:9:16:    expected unsigned int [noderef] *stat_addr<asn:1>
> 	test.c:9:16:    got incomplete type [noderef] <noident><asn:1>
> 
> which makes a lot of sense (to me, at least).
> 
> Arguably the empty "__user" would parse as the normal C implicit type,
> which is "int", since you can also do things like
> 
> 	volatile a;
> 
> and traditionally C just assumes that you mean "int". Me, I don't like
> that. I call it a "incomplete type", and only assume "int" if you say
> char/short/long/unsigned/signed.
> 
> 		Linus

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: John Cherry <cherry () osdl ! org>
To: linux-kernel
Subject: Re: sparse in compile stats
Date: Thu, 10 Jun 2004 23:42:18 +0000
Message-ID: <1086910938.5884.79.camel () cherrybomb ! pdx ! osdl ! net>
--------------------
Sam,

I am doing sparse runs now on all of linus' and andrew's kernels.  Since
sparse is changing along with the kernel, comparing to older versions
will not buy us much right now.  As sparse stabalizes, perhaps this
would be an option.

For the sparse runs, I am building with allmodconfig (bzImage and
modules).

John

On Sun, 2004-06-06 at 12:18, Sam Ravnborg wrote:
> Hi John.
> 
> Recently Al Viro has put in a huge effort into sparse sanitize the kernel,
> and likewise Linus has done several updates to sparse.
> Net result is a _lot_ of sparse warnings removed, and very few (if any?) false positives.
> 
> Do you think it is worth to include a sparse run when Linus does next -rc?
> Comparing with older versions should only be for amusement, since Al and Linus did
> such a big effor the last weeks.
> 
> 	Sam

-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-kernel
Subject: Re: sparse in compile stats
Date: Fri, 11 Jun 2004 21:41:24 +0000
Message-ID: <20040611214124.GA2154 () mars ! ravnborg ! org>
--------------------
On Thu, Jun 10, 2004 at 04:42:18PM -0700, John Cherry wrote:
> Sam,
> 
> I am doing sparse runs now on all of linus' and andrew's kernels.  Since
> sparse is changing along with the kernel, comparing to older versions
> will not buy us much right now.  As sparse stabalizes, perhaps this
> would be an option.

Great, thanks.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-kernel" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
================================================================================


################################################################################

=== Thread: sparse infinitely loops on "*a++" ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Mon, 29 Nov 2004 19:38:18 +0000
Message-ID: <Pine.LNX.4.58.0411291125300.22796 () ppc970 ! osdl ! org>
--------------------


On Mon, 29 Nov 2004, Alexey Dobriyan wrote:
>
> Fed gcc 3.4 testsuite to sparse. On some tests it starts infinitely looping. Cut
> down one of them to very minimal:

Heh, thanks. I've had a number of these, where we rewrite something to
itself.  I fixed the ones that I found, but since I only tend to test with
valid programs, I won't find the ones that arise out of undefined 
behaviour.

> ==================================================
> void f(void)
> {
>         int *a;
> 
>         *a++;
> }

Yeah, "symbol simplification" ends up having one special case: if there's 
only one assignment to a symbol, we replace all the users with the same 
pseudo.

Which is _fine_ for well-defined C code, but if something simply isn't 
assigned at all, it results in funny instructions like

	add.32     %r2 <- %r2, $4

like in this case. Which is really highly invalid.

I tested the trivial case of

	int i = i;

and

	int i; i++;

which are similar (and work ok now, but didn't use to), but the one that 
depends on memop simplification I missed.

The fix literally is as trivial as just noticing that the "rewrite" 
wouldn't actually change anything. We could give a warning about undefined 
use if we wanted to. So how about just the appended appropriate warning ;)

		Linus


---
===== simplify.c 1.18 vs edited =====
--- 1.18/simplify.c	2004-11-28 19:38:23 -08:00
+++ edited/simplify.c	2004-11-29 11:37:26 -08:00
@@ -441,6 +441,13 @@
 	return 0;
 
 offset:
+	/* Invalid code */
+	if (new == addr) {
+		if (new == VOID)
+			return 0;
+		new = VOID;
+		warning(insn->bb->pos, "crazy programmer");
+	}
 	insn->offset += off->value;
 	use_pseudo(new, &insn->src);
 	remove_usage(addr, &insn->src);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Mon, 29 Nov 2004 19:38:18 +0000
Message-ID: <Pine.LNX.4.58.0411291125300.22796 () ppc970 ! osdl ! org>
--------------------


On Mon, 29 Nov 2004, Alexey Dobriyan wrote:
>
> Fed gcc 3.4 testsuite to sparse. On some tests it starts infinitely looping. Cut
> down one of them to very minimal:

Heh, thanks. I've had a number of these, where we rewrite something to
itself.  I fixed the ones that I found, but since I only tend to test with
valid programs, I won't find the ones that arise out of undefined 
behaviour.

> ==================================================
> void f(void)
> {
>         int *a;
> 
>         *a++;
> }

Yeah, "symbol simplification" ends up having one special case: if there's 
only one assignment to a symbol, we replace all the users with the same 
pseudo.

Which is _fine_ for well-defined C code, but if something simply isn't 
assigned at all, it results in funny instructions like

	add.32     %r2 <- %r2, $4

like in this case. Which is really highly invalid.

I tested the trivial case of

	int i = i;

and

	int i; i++;

which are similar (and work ok now, but didn't use to), but the one that 
depends on memop simplification I missed.

The fix literally is as trivial as just noticing that the "rewrite" 
wouldn't actually change anything. We could give a warning about undefined 
use if we wanted to. So how about just the appended appropriate warning ;)

		Linus


---
===== simplify.c 1.18 vs edited =====
--- 1.18/simplify.c	2004-11-28 19:38:23 -08:00
+++ edited/simplify.c	2004-11-29 11:37:26 -08:00
@@ -441,6 +441,13 @@
 	return 0;
 
 offset:
+	/* Invalid code */
+	if (new == addr) {
+		if (new == VOID)
+			return 0;
+		new = VOID;
+		warning(insn->bb->pos, "crazy programmer");
+	}
 	insn->offset += off->value;
 	use_pseudo(new, &insn->src);
 	remove_usage(addr, &insn->src);
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Mon, 29 Nov 2004 19:44:55 +0000
Message-ID: <Pine.LNX.4.58.0411291139420.22796 () ppc970 ! osdl ! org>
--------------------


On Mon, 29 Nov 2004, Linus Torvalds wrote:
> 
> The fix literally is as trivial as just noticing that the "rewrite"  
> wouldn't actually change anything. We could give a warning about
> undefined use if we wanted to. So how about just the appended
> appropriate warning ;)

Btw, the _proper_ fix would be to notice this much earlier, but then we'd 
lose much of the beauty of the single-assignment simplification. That 
thing triggers a _lot_, and means that we don't have to do any 
reachability analysis.

Sadly, reachability analysis is exactly what the undefined case needs.

Anyway, at least for now, I'll try to fix these things as they come up, 
even if it ends up being something of a hit-and-miss thing (ie there has 
certainly been other cases where we've gotten into similar loops, and 
there are probably others lurking).. 

Optimize for sane code, that's my motto.

(In the same vein, I suspect that many of my loops are very fast for 
normal code, but likely have bad exponential behaviour for some really 
crappy horror-code. I'll take long compile-times on crap code if good code 
compiles fast, thank you very much).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 15:50:41 +0000
Message-ID: <Pine.LNX.4.58.0412010738490.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Alexey Dobriyan wrote:
> 
> One can test sparse on IOCCC winners. ;-)

I actually did try some of the winners this year. Didn't have any trouble 
on the ones I tested, except for stuff where sparse just didn't like lack 
of prototypes etc. The IOCCC winners are still supposed to have 
well-defined (just _ugly_ ;) behaviour, so they don't have these kinds of 
problems..

Btw, is the gcc test-suit available somewhere _without_ the rest of gcc? 
Or could you maybe just forward the relevant parts. Although I love how 
you end up distilling them out. I'd be particularly interested in the slow 
one.

> Yep, it works. But still loops on this:

Ok. I was afraid that there could be some "switch between two states" 
behaviour. Will fix,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 15:50:41 +0000
Message-ID: <Pine.LNX.4.58.0412010738490.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Alexey Dobriyan wrote:
> 
> One can test sparse on IOCCC winners. ;-)

I actually did try some of the winners this year. Didn't have any trouble 
on the ones I tested, except for stuff where sparse just didn't like lack 
of prototypes etc. The IOCCC winners are still supposed to have 
well-defined (just _ugly_ ;) behaviour, so they don't have these kinds of 
problems..

Btw, is the gcc test-suit available somewhere _without_ the rest of gcc? 
Or could you maybe just forward the relevant parts. Although I love how 
you end up distilling them out. I'd be particularly interested in the slow 
one.

> Yep, it works. But still loops on this:

Ok. I was afraid that there could be some "switch between two states" 
behaviour. Will fix,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:00:23 +0000
Message-ID: <20041201160023.794C41422D5B () darter ! rentec ! com>
--------------------

You want ugly, but valid?

How about this one?  Sparse doesn't parse it right now, and I am
guessing that if it did, the function call inside the sizeof
expression would not be called.  My reading of C99 is that it
should be called.  (gcc and sun cc get it wrong.)

Morten




#include <stdio.h>

int zero (void) { printf ("Zero!\n"); return 0; }

size_t fsize3 (int n)
{
  char b[1][n+3];       // Variable length array.
  size_t s = sizeof (b[zero()]);    // Execution time sizeof.
  return s;
}

int main(void)
{
  size_t size;
  size = fsize3(10);
  return 0;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:00:23 +0000
Message-ID: <20041201160023.794C41422D5B () darter ! rentec ! com>
--------------------

You want ugly, but valid?

How about this one?  Sparse doesn't parse it right now, and I am
guessing that if it did, the function call inside the sizeof
expression would not be called.  My reading of C99 is that it
should be called.  (gcc and sun cc get it wrong.)

Morten




#include <stdio.h>

int zero (void) { printf ("Zero!\n"); return 0; }

size_t fsize3 (int n)
{
  char b[1][n+3];       // Variable length array.
  size_t s = sizeof (b[zero()]);    // Execution time sizeof.
  return s;
}

int main(void)
{
  size_t size;
  size = fsize3(10);
  return 0;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:06:27 +0000
Message-ID: <Pine.LNX.4.58.0412010805550.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Linus Torvalds wrote:
> 
> Ok. I was afraid that there could be some "switch between two states" 
> behaviour. Will fix,

Done. Just a simple logical extension of the original "crazy programmer" 
test.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:17:18 +0000
Message-ID: <Pine.LNX.4.58.0412010811480.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Morten Welinder wrote:
> 
> You want ugly, but valid?
> 
> How about this one?  Sparse doesn't parse it right now, and I am
> guessing that if it did, the function call inside the sizeof
> expression would not be called.  My reading of C99 is that it
> should be called.  (gcc and sun cc get it wrong.)

Ok, you apparently want it to return "n+3". I very seriously disagree with
your notion that it should do the call, though. The call has nothing to do 
with the sizeof.

I think sparse would actually do the "n+3" if it supported variable-sized
arrays. Some day. Maybe.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:17:18 +0000
Message-ID: <Pine.LNX.4.58.0412010811480.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Morten Welinder wrote:
> 
> You want ugly, but valid?
> 
> How about this one?  Sparse doesn't parse it right now, and I am
> guessing that if it did, the function call inside the sizeof
> expression would not be called.  My reading of C99 is that it
> should be called.  (gcc and sun cc get it wrong.)

Ok, you apparently want it to return "n+3". I very seriously disagree with
your notion that it should do the call, though. The call has nothing to do 
with the sizeof.

I think sparse would actually do the "n+3" if it supported variable-sized
arrays. Some day. Maybe.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:28:58 +0000
Message-ID: <20041201162858.356541422D5B () darter ! rentec ! com>
--------------------


> Ok, you apparently want it to return "n+3". I very seriously disagree with
> your notion that it should do the call, though. The call has nothing to do 
> with the sizeof.

Indeed not, but here's what C99 actually says on the issue: "If the type of
the operand is a variable length array type, the operand is evaluated".

It looks deliberate and pointless at the same time.

Morten



-----------------------------------------------------------------------------

       Semantics

       [#2]  The  sizeof operator yields the size (in bytes) of its
       operand, which may be an  expression  or  the  parenthesized
       name of a type.  The size is determined from the type of the
       operand.  The result is an integer.   If  the  type  of  the
       operand  is  a  variable  length  array type, the operand is
       evaluated; otherwise, the operand is not evaluated  and  the
       result is an integer constant.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 16:28:58 +0000
Message-ID: <20041201162858.356541422D5B () darter ! rentec ! com>
--------------------


> Ok, you apparently want it to return "n+3". I very seriously disagree with
> your notion that it should do the call, though. The call has nothing to do 
> with the sizeof.

Indeed not, but here's what C99 actually says on the issue: "If the type of
the operand is a variable length array type, the operand is evaluated".

It looks deliberate and pointless at the same time.

Morten



-----------------------------------------------------------------------------

       Semantics

       [#2]  The  sizeof operator yields the size (in bytes) of its
       operand, which may be an  expression  or  the  parenthesized
       name of a type.  The size is determined from the type of the
       operand.  The result is an integer.   If  the  type  of  the
       operand  is  a  variable  length  array type, the operand is
       evaluated; otherwise, the operand is not evaluated  and  the
       result is an integer constant.
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 17:10:08 +0000
Message-ID: <Pine.LNX.4.58.0412010907150.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Morten Welinder wrote:
> 
> > Ok, you apparently want it to return "n+3". I very seriously disagree with
> > your notion that it should do the call, though. The call has nothing to do 
> > with the sizeof.
> 
> Indeed not, but here's what C99 actually says on the issue: "If the type of
> the operand is a variable length array type, the operand is evaluated".
> 
> It looks deliberate and pointless at the same time.

Ok. I think it's a mistake. I don't think that is what they meant, it 
really doesn't make sense.

They've fixed the standard before. And if they haven't, people have 
successfully ignored the idiocies before ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 17:10:08 +0000
Message-ID: <Pine.LNX.4.58.0412010907150.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Morten Welinder wrote:
> 
> > Ok, you apparently want it to return "n+3". I very seriously disagree with
> > your notion that it should do the call, though. The call has nothing to do 
> > with the sizeof.
> 
> Indeed not, but here's what C99 actually says on the issue: "If the type of
> the operand is a variable length array type, the operand is evaluated".
> 
> It looks deliberate and pointless at the same time.

Ok. I think it's a mistake. I don't think that is what they meant, it 
really doesn't make sense.

They've fixed the standard before. And if they haven't, people have 
successfully ignored the idiocies before ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 17:36:32 +0000
Message-ID: <Pine.LNX.4.58.0412010934060.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Linus Torvalds wrote:
> 
> Ok. I think it's a mistake. I don't think that is what they meant, it 
> really doesn't make sense.

I _suspect_ that what they meant is that the expression that defines the 
size will be evaluated.

For example, if you have

	sizeof(char[n+3])

then clearly you want to evaluate "n+3" at run-time. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse infinitely loops on "*a++"
Date: Wed, 01 Dec 2004 17:36:32 +0000
Message-ID: <Pine.LNX.4.58.0412010934060.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Linus Torvalds wrote:
> 
> Ok. I think it's a mistake. I don't think that is what they meant, it 
> really doesn't make sense.

I _suspect_ that what they meant is that the expression that defines the 
size will be evaluated.

For example, if you have

	sizeof(char[n+3])

then clearly you want to evaluate "n+3" at run-time. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse infinitely loops on =?koi8-r?Q?=22?=*a++=?koi8-r?Q?=22?= ===

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: sparse infinitely loops on =?koi8-r?Q?=22?=*a++=?koi8-r?Q?=22?=
Date: Mon, 29 Nov 2004 19:17:17 +0000
Message-ID: <E1CYr1R-000Bvd-00.adobriyan-mail-ru () f32 ! mail ! ru>
--------------------
Fed gcc 3.4 testsuite to sparse. On some tests it starts infinitely looping. Cut
down one of them to very minimal:
==================================================
void f(void)
{
        int *a;

        *a++;	/*
		  *(a = a + 1); also infinite loop
		  *(b = a + 1); -- ok
		 */
}
==================================================

Starting from 1.1023 this test would trigger the following assertion:

$ ./check ../sparse-crash/t1_infinite.c
check: simplify.c:154: remove_usage: Assertion `deleted == 1' failed.
Aborted

Starting from 1.1038 failed assertion transformed to infinite loop due to
changes in delete_ptr_list_entry.

============================================================================
--- 1.1022/simplify.c     2004-11-27 06:25:30 +00:00
+++ 1.1023/simplify.c     2004-11-27 06:26:44 +00:00
@@ -409,6 +409,8 @@
 static int simplify_memop(struct instruction *insn)
 {
        pseudo_t addr = insn->src;
+       pseudo_t new, off;
+
        if (addr->type == PSEUDO_REG) {
                struct instruction *def = addr->def;
                if (def->opcode == OP_SETVAL && def->src) {
@@ -416,8 +418,25 @@
                        use_pseudo(def->src, &insn->src);
                        return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
                }
+               if (def->opcode == OP_ADD) {
+                       new = def->src1;
+                       off = def->src2;
+                       if (constant(off))
+                               goto offset;
+                       new = off;
+                       off = def->src1;
+                       if (constant(off))
+                               goto offset;
+                       return 0;
+               }
        }
        return 0;
+
+offset:
+       insn->offset += off->value;
+       use_pseudo(new, &insn->src);
+       remove_usage(addr, &insn->src);
+       return REPEAT_CSE | REPEAT_SYMBOL_CLEANUP;
 }

 int simplify_instruction(struct instruction *insn)
============================================================================

After "if (... == OP_ADD)" "new" and "addr" are the same. The we add pseudo,
next line remove it, and finally set right flags for cleanup_and_cse to call
all chain once again (well, that's how I understood pseudo tricks).

#0    simplify_memop		at simplify.c:431
#1 in simplify_instruction	at simplify.c:467
#2 in clean_up_one_instruction	at cse.c:47
#3 in clean_up_insns		at cse.c:120
#4 in cleanup_and_cse		at cse.c:325

Any thoughts on how to fix this?

	Alexey

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse license update question ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse license update question
Date: Wed, 17 Nov 2004 15:25:40 +0000
Message-ID: <20041117152540.GA15093 () 64m ! dyndns ! org>
--------------------
No problem for me at all. Mine is just some trivial work.
And I trust Linus's judgment on the license issue.

Just curios, the problem of v1.1 is that a company can
create a 1.1 license project and sue it. Then it will stop
all other projects using osl 1.1?

Chris

On Wed, Nov 17, 2004 at 10:30:22AM -0800, Linus Torvalds wrote:
> 
> So holler if you agree/disagree. Naturally, just one copyright holder 
> disagreeing shoots down any changes (I don't think I'm interested in 
> trying to work around it, it's just not important enough).
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: sparse license update question
Date: Wed, 17 Nov 2004 18:30:22 +0000
Message-ID: <Pine.LNX.4.58.0411171021250.2222 () ppc970 ! osdl ! org>
--------------------

It just struck me that sparse is still using osl-1.1, even though a few
companies ended up not liking the patent termination clauses, and Larry
Rosen has since updated the OSL to 2.1 (afaik, the patent termination
relaxation is the only "real" change, but there's probably other wording 
changes too). 

I'm not sure I can change the license, but I sent off a quick query to 
Transmeta about it to see if that would work out as far as they are 
concerned. Same query hereby goes out to Jeff and Chris Li, who have added 
their own copyright notices, and the list, since there are some people who 
didn't bother (and thus likely don't care) but that I want to check with 
first _anyway_.

To clarify: I'm not ready to update the license yet, and am only looking
into the _possibility_ so far. Comments? The "revoke on patent" thing was 
basically changed from "revoke if a company sues over patents on _any_ 
project that uses that license" to "revoke if a company sues over patents 
on _this_ particular original work". 

Not likely to be a real issue, but I know certain companies really hated 
v1.1. It's not like I'd expect people to suddenly start using sparse, but 
it still feels bad to use a license that has known problems and has been 
updated.

v2.1 is at

	http://www.opensource.org/licenses/osl-2.1.php

and that also has pointers to the older one (v1.1).

So holler if you agree/disagree. Naturally, just one copyright holder 
disagreeing shoots down any changes (I don't think I'm interested in 
trying to work around it, it's just not important enough).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: sparse license update question
Date: Wed, 17 Nov 2004 18:49:35 +0000
Message-ID: <20041117184935.94B881422D58 () darter ! rentec ! com>
--------------------

osl-2.1 is fine with me.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: Re: sparse license update question
Date: Wed, 17 Nov 2004 19:00:14 +0000
Message-ID: <20041117190014.GA8476 () mars ! ravnborg ! org>
--------------------
On Wed, Nov 17, 2004 at 01:49:35PM -0500, Morten Welinder wrote:
> 
> osl-2.1 is fine with me.

For my minimal contribution I do not care about license, so osl-2.1 is ok.

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: Re: sparse license update question
Date: Wed, 17 Nov 2004 20:00:52 +0000
Message-ID: <419BADF4.2030203 () pobox ! com>
--------------------
Fine with me...

Maybe I should update the libata dual license to GPL/OSL2.1 too.

	Jeff



-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Dave Jones <davej () redhat ! com>
To: linux-sparse
Subject: Re: sparse license update question
Date: Wed, 17 Nov 2004 20:22:44 +0000
Message-ID: <20041117202244.GA12179 () redhat ! com>
--------------------
On Wed, Nov 17, 2004 at 10:30:22AM -0800, Linus Torvalds wrote:

 > So holler if you agree/disagree. Naturally, just one copyright holder 
 > disagreeing shoots down any changes (I don't think I'm interested in 
 > trying to work around it, it's just not important enough).

Fine with me for the tiny changes of mine that you've included.

		Dave
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse license update question
Date: Wed, 17 Nov 2004 21:20:49 +0000
Message-ID: <Pine.LNX.4.58.0411171316480.2222 () ppc970 ! osdl ! org>
--------------------


On Wed, 17 Nov 2004, Christopher Li wrote:
>
> No problem for me at all. Mine is just some trivial work.
> And I trust Linus's judgment on the license issue.
> 
> Just curios, the problem of v1.1 is that a company can
> create a 1.1 license project and sue it. Then it will stop
> all other projects using osl 1.1?

No, the problem is more insidious. 

Let's say that some company X decides to start using a OSL v1.1 project,
and thinks it is great. Then somebody _else_ starts a totally unrelated
project that also uses OSL v1.1, and willfully abuses patents by company
X. Now, if company X sues the willful abuser, it loses rights to _all_ OSL
v1.1 projects, including the one it likes and that it has no problems
with.

At first glance, this sounds like a good idea ("it discourages people from
suing over patents"), and that was kind of the point. But it literally
ends up potentially protecting people who really _are_ doing something
bad. And whether you like software patents or not, that ends up being a
problem.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Arnaldo Carvalho de Melo <acme () conectiva ! com ! br>
To: linux-sparse
Subject: Re: sparse license update question
Date: Thu, 18 Nov 2004 20:28:42 +0000
Message-ID: <419D05FA.40107 () conectiva ! com ! br>
--------------------


Dave Jones wrote:
> On Wed, Nov 17, 2004 at 10:30:22AM -0800, Linus Torvalds wrote:
> 
>  > So holler if you agree/disagree. Naturally, just one copyright holder 
>  > disagreeing shoots down any changes (I don't think I'm interested in 
>  > trying to work around it, it's just not important enough).
> 
> Fine with me for the tiny changes of mine that you've included.

Ditto :-)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ralf Wildenhues <Ralf.Wildenhues () gmx ! de>
To: linux-sparse
Subject: Re: sparse license update question
Date: Fri, 19 Nov 2004 06:21:22 +0000
Message-ID: <20041119062122.GA9329 () iam ! uni-bonn ! de>
--------------------
* Arnaldo Carvalho de Melo wrote on Thu, Nov 18, 2004 at 09:28:42PM CET:
> Dave Jones wrote:
> >On Wed, Nov 17, 2004 at 10:30:22AM -0800, Linus Torvalds wrote:
> >
> > > So holler if you agree/disagree. Naturally, just one copyright holder 
> > > disagreeing shoots down any changes (I don't think I'm interested in 
> > > trying to work around it, it's just not important enough).
> >
> >Fine with me for the tiny changes of mine that you've included.
> 
> Ditto :-)

AOL! :-)
(my tiny change was only testcases..)

Regards,
Ralf
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse seg fault ===

From: Roland Dreier <roland () topspin ! com>
To: linux-sparse
Subject: sparse seg fault
Date: Wed, 07 Jul 2004 22:50:19 +0000
Message-ID: <52wu1fig9g.fsf () topspin ! com>
--------------------
A file containing nothing but the following snippet:

enum { A = -1 };
enum { B = A  };

causes sparse to segfault on my system (Debian testing, i386 with gcc
3.3.4).  I am using Dave Jones's 2004-07-07 sparse tarball.

Here's a little more info:

$ cat y.c
enum { A = -1 };
enum { B = A  };
roland@eddore:/scratch/Sparse-test/linux-2.6.7:[2:329] $ gdb sparse
GNU gdb 6.1-debian
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-linux"...Using host libthread_db library "/lib/tls/i686/cmov/libthread_db.so.1".

(gdb) run y.c
Starting program: /data/home/roland/bin/sparse y.c

Program received signal SIGSEGV, Segmentation fault.
0x08057c37 in get_expression_value (expr=0xffffffff) at expand.c:653
653                             ctype = ctype->ctype.base_type;
(gdb) bt
#0  0x08057c37 in get_expression_value (expr=0xffffffff) at expand.c:653
#1  0x0804902e in parse_enum_declaration (token=0x4000131c, parent=0x400197ec)
    at parse.c:154
#2  0x08048f19 in struct_union_enum_specifier (ns=2147483648, type=2147483648,
    token=0x4000130c, ctype=0xbffff300, parse=0x8048f93 <parse_enum_declaration>)
    at parse.c:125
#3  0x080490ab in enum_specifier (token=0x80000000, ctype=0x80000000) at parse.c:169
#4  0x080499cd in declaration_specifiers (next=0x4000130c, ctype=0xbffff360, qual=0)
    at parse.c:456
#5  0x0804b4c8 in external_declaration (token=0x400012fc, list=0x80616c0) at parse.c:1215
#6  0x0804b869 in translation_unit (token=0x80000000, list=0x80616c0) at parse.c:1302
#7  0x08048ca0 in main (argc=2, argv=0xbffff474) at check.c:104

I'll try to grok the sparse code, but if someone else can fix it
quicker, that would be great.  I'm not subscribed to linux-sparse, so
please cc me on replies.

Thanks,
  Roland
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Roland Dreier <roland () topspin ! com>
To: linux-sparse
Subject: Re: sparse seg fault
Date: Thu, 08 Jul 2004 01:07:08 +0000
Message-ID: <523c43i9xf.fsf () topspin ! com>
--------------------
The problem sparse has with the code

	enum { A = -1 };
	enum { B = A  };

seems to happen because of the following code in get_expression_value():

	value = expr->value;
	mask = 1ULL << (ctype->bit_size-1);

	if (value & mask) {

Since A gets value -1, value is 0xffffffff.  However, for reasons I
don't understand, mask is 0x80000000, so sparse goes into the if
statement and tries to do

		while (ctype->type != SYM_BASETYPE)
			ctype = ctype->ctype.base_type;

and ends up dereferencing a NULL pointer.

I still don't understand sparse well enough to know how to fix this,
so further help is appreciated.

Thanks,
  Roland
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse seg fault
Date: Thu, 08 Jul 2004 05:04:47 +0000
Message-ID: <Pine.LNX.4.58.0407072157490.1764 () ppc970 ! osdl ! org>
--------------------


On Wed, 7 Jul 2004, Roland Dreier wrote:
>
> A file containing nothing but the following snippet:
> 
> enum { A = -1 };
> enum { B = A  };
> 
> causes sparse to segfault on my system (Debian testing, i386 with gcc
> 3.3.4). 

Heh. It's desperately trying to figure out the sign of "A", and the code 
that tries to figure out the sign doesn't understand enums.

The reason for that is that enums don't have a base-type.

Trivial fix (making the base type be "int") checked in and pushed out.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse seg fault
Date: Thu, 08 Jul 2004 14:06:25 +0000
Message-ID: <20040708140625.GB27129 () 64m ! dyndns ! org>
--------------------
I came up with the same one line fix as well.

When I try to decide between and one line fix and the two lines,
I found your fix finally arrived.

Here is the two line one.

Chris

Index: sparse-be/symbol.c
===================================================================
--- sparse-be.orig/symbol.c     2004-07-08 09:24:34.000000000 -0400
+++ sparse-be/symbol.c  2004-07-08 09:26:04.000000000 -0400
@@ -413,7 +413,7 @@
 
        { "struct",     NULL,           MOD_STRUCTOF },
        { "union",      NULL,           MOD_UNIONOF },
-       { "enum",       NULL,           MOD_ENUMOF },
+       { "enum",       &int_type,      MOD_ENUMOF },
 
        { "inline",     NULL,           MOD_INLINE },
        { "__inline",   NULL,           MOD_INLINE },
Index: sparse-be/parse.c
===================================================================
--- sparse-be.orig/parse.c      2004-07-08 07:58:00.000000000 -0400
+++ sparse-be/parse.c   2004-07-08 09:52:57.000000000 -0400
@@ -122,6 +122,7 @@
        }
 
        sym = alloc_symbol(token->pos, type);
+       sym->ctype.base_type = ctype->base_type;
        token = parse(token->next, sym);
        ctype->base_type = sym;
        return expect(token, '}', "at end of specifier");

On Wed, Jul 07, 2004 at 10:04:47PM -0700, Linus Torvalds wrote:
> 
> 
> On Wed, 7 Jul 2004, Roland Dreier wrote:
> >
> > A file containing nothing but the following snippet:
> > 
> > enum { A = -1 };
> > enum { B = A  };
> > 
> > causes sparse to segfault on my system (Debian testing, i386 with gcc
> > 3.3.4). 
> 
> Heh. It's desperately trying to figure out the sign of "A", and the code 
> that tries to figure out the sign doesn't understand enums.
> 
> The reason for that is that enums don't have a base-type.
> 
> Trivial fix (making the base type be "int") checked in and pushed out.
> 
> 		Linus
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse-1.1079 crashsuite ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: sparse-1.1079 crashsuite
Date: Wed, 01 Dec 2004 16:13:38 +0000
Message-ID: <20041201161338.GA24845 () 64m ! dyndns ! org>
--------------------
It seems it is recursive looping on  find_dominating_parents().
Sparse has change so much in the last week or so.

Chris
 
On Wed, Dec 01, 2004 at 10:15:12PM +0300, Alexey Dobriyan wrote:
> On Wednesday 01 December 2004 15:50, Linus Torvalds wrote:
> 
> > Btw, is the gcc test-suit available somewhere _without_ the rest of gcc?
> > Or could you maybe just forward the relevant parts. Although I love how
> > you end up distilling them out. I'd be particularly interested in the slow
> > one.
> 
> Attached is sparse-1.1079 crashsuite (without infinite loop now). Agree, many
> segfaults are due to K&R declarations, but not all.
> 
> And the test that became the slow one is:
> ============================================================================
> #define C(a,b) \
>   if (a > b)  goto gt; \
>   if (a < b)  goto lt;
> 
> #define C4(x,b) C((x)[0], b) C((x)[1],b) C((x)[2],b) C((x)[3],b)
> #define C16(x,y) C4(x, (y)[0]) C4(x, (y)[1]) C4(x, (y)[2]) C4(x, (y)[3])
> 
> #define C64(x,y) C16(x,y) C16(x+4,y) C16(x+8,y) C16(x+12,y)
> #define C256(x,y) C64(x,y) C64(x,y+4) C64(x,y+8) C64(x,y+12)
> 
> #define C1024(x,y) C256(x,y) C256(x+16,y) C256(x+32,y) C256(x+48,y)
> #define C4096(x,y) C1024(x,y) C1024(x,y+16) C1024(x,y+32) C1024(x,y+48)
> 
> unsigned foo(int x[64], int y[64])
> {
>   C4096(x,y);
> 
>   return 0x01234567;
>  gt:
>   return 0x12345678;
>  lt:
>   return 0xF0123456;
> }
> ============================================================================
> 


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Alexey Dobriyan <adobriyan () mail ! ru>
To: linux-sparse
Subject: sparse-1.1079 crashsuite
Date: Wed, 01 Dec 2004 19:15:12 +0000
Message-ID: <E1CZZwW-000OuB-00.adobriyan-mail-ru () f12 ! mail ! ru>
--------------------

------HSe8TZFN-nd6F6idSysFpD1gM:1101928512
Content-Type: text/plain; charset=koi8-r
Content-Transfer-Encoding: 8bit

On Wednesday 01 December 2004 15:50, Linus Torvalds wrote:

> Btw, is the gcc test-suit available somewhere _without_ the rest of gcc?
> Or could you maybe just forward the relevant parts. Although I love how
> you end up distilling them out. I'd be particularly interested in the slow
> one.

Attached is sparse-1.1079 crashsuite (without infinite loop now). Agree, many
segfaults are due to K&R declarations, but not all.

And the test that became the slow one is:
============================================================================
#define C(a,b) \
  if (a > b)  goto gt; \
  if (a < b)  goto lt;

#define C4(x,b) C((x)[0], b) C((x)[1],b) C((x)[2],b) C((x)[3],b)
#define C16(x,y) C4(x, (y)[0]) C4(x, (y)[1]) C4(x, (y)[2]) C4(x, (y)[3])

#define C64(x,y) C16(x,y) C16(x+4,y) C16(x+8,y) C16(x+12,y)
#define C256(x,y) C64(x,y) C64(x,y+4) C64(x,y+8) C64(x,y+12)

#define C1024(x,y) C256(x,y) C256(x+16,y) C256(x+32,y) C256(x+48,y)
#define C4096(x,y) C1024(x,y) C1024(x,y+16) C1024(x,y+32) C1024(x,y+48)

unsigned foo(int x[64], int y[64])
{
  C4096(x,y);

  return 0x01234567;
 gt:
  return 0x12345678;
 lt:
  return 0xF0123456;
}
============================================================================


------HSe8TZFN-nd6F6idSysFpD1gM:1101928512
Content-Type: application/x-bzip2; name="sparse-1.1079-crash.tar.bz2"
Content-Disposition: attachment; filename="sparse-1.1079-crash.tar.bz2"
Content-Transfer-Encoding: base64

QlpoOTFBWSZTWaTtSmMAlvn////+AjB///////////////8DjDDIgEiUwAQBO/fAQgBIYE+e9PMm
+ddirru33udrReYw7l21W769d3t3vj33uvmdTe+WA9F7TFuon3uveaid7Om+uN7dPT3vW09udrOV
T6++5s3p192aPvfaLtfdLGj293nt8+987Gj517dvLPvndne7e8ent77Xt4zZiE2+5q73e5vtgNtb
I+u58c777W9Cm2ddb4Yeinwrp90ny+u7Q7ctrVblndx573eymd3HNDt5tSL7ZffHc6nO+zl29Vre
7173WZ1u9vXZvbPr3gsK92cXnudXm3dq577276++M+eqBeB3bSfe+97rd9M9JCUIgEwTEaaBNATa
amBIanininpqmameoR+Uxip6gDQBptQ0ZDamg3qmj1A2FBKEZGkBEZAIAJqnqb1MkZGhptQNB6nq
AAD1AAA0ADQAAAAJCIhAhMTTSZPQTQnqekbUnpR+0TTU9Ufqn6U9QNDNT2pqHqaZMGUAyNBoAAAA
EmpCENJqYCp5pqbST0amp+CU9HlJ5J+kmaZRkZDE0BpoD0g000AAAAAACJJJptTQRoEZTaNMqeU9
NGKeiYJqPU2oZGQ9INqHppA9I9QHlAaNGgAAANAqKIgENAgFPQZT1PTUyYU9MUnkT1PGqZqZHqNB
6jaQ9Q9QehNNqAAAAAAfec/fQR9+i1SqCQqIkip1xQJEKiha0oWmD4Akh7BGSrCxjBFGKLDFFSVQ
NVECQkRkioSIBFCaUBFPFFRV6kIij1PzfH46zqxn4/HjbDVLjl5vSsXecPGDbGHoZ00tvSm8O7jx
ih5HdwwUVJU1w5NLw86KXVaW9MEqrnrx5D695HN0gE3ESBCVuyGRQixRFIhBVRhBgsVZKwdstszR
ra7tLt9XbhaazvkneDJo85xM6O3jS7HCqL0u8zTNUVemo6edXWS0Vm8vU1xgZrpWm7dqwGkCE0gg
0hzKpVbARPLBEcARQwIKgwlRItRbIFsssElSArTJRWCrJFwWYwKTClViyElMSpFkEYCFNSChIiCU
ANSSKDi2sFYjCXDBSlYnV5uuI98958TPa/Ks7D+6G8MoFTv8lZqWIdwIMX9wtptEZBa8lFJIqiwh
ZkhTNd752VX21PrXzteceVmQlkqFBUzoYiaSjJh6IwMnCLImKlAkYgoEkUUFRgTsumdnD6gyUFH6
RnIsYIqfyBmqaMDTRuap2Zp4yCwYUmVSoijMir2oVMVKFBBkySYaLYmNDaFdnt+1LLLtuj68I/Se
moYpnwYWvPhxVVJCRTc2FZFEzYKLsYUv1cFVExoAq4XYyIEOQMtjC2c7Zt34mtM20m+yHahoqK3D
koWqQf2DBLRiw7mpbVOuYrQUFRuUFeJoaYkxoGFMVjeIxSFjE1UlJeTze76Pnp6+xX5rsK92eFaF
gjCZcWzTpGRhShsOV+uU6fj6TE6SfaOyGqaqfi7f7Bo8PZmZPfzXUg2IggSKpIKsFhBSSQOMoFY2
KKJVFIgKMFJwtULKys0zsXTDBFv6jSSxUPHRpVYzTMONwZUIOKMaIo1d3dxsirGWqqklVQIUINEF
IQEoSMSTSJpTkSGMKUIQYid1UI1aFmleKkTpvpcpvna3MUUohdusWKIkRg2J1J5pTpEUqUOoxx6u
mDQk2tHFbTvfhW0YBRobSbdxKIkixBMYUnRiMlg1TbhDDVAWwtjZoNCmTn6DaVj2AcM4qKDgJJoi
RYj+KRNBWfkAl0frvK1ylT1qrY9RR7poY/Gsws5WmVNtlOr6p4XjavuzZvs6J4XFk9jEjKp4ZfkH
RSaJEeI3HLiD+KoMeiWmYQGeVYzZjMDLX+5hBjQ0mPuulW6cWFrdA4vfY4gND2SLEOZt0xiN1UaP
U1OJClohoMMBgsUcpnmZp8GVjMLg8aKdNtgTiZALps2YsXYqbBmlbVVVVVVVW10OYLFQsguGogag
lYEmeCmF/i1ozNH4aIHw+OiGbCD6+LSTF6iyRSEDPP3N2JIDFM4J4ICjadfJXWlqKIlpJznQEeYF
JugkSbe7EmykE64RLECOLJgQiXHXSIG2/LZILRHSplSFoqga46eE6mwG+LjA2EXGx7NjTjoTPiO6
pLmyubOqQgE6DdM3sMLtX7OyGMjDhm0P1aBwsTKpNmxiJlVULYSb6xY4ETGCBaKohxRWoA6JjLEV
lVRRQxUtkiTOGC2MqloYZYkidx9HPL+sBBftRH14B8s/WiAQnLTSiB5SimrB+YGHz6OunKJ0dEfH
ff8/vYxavnkbFPGmhKOy4+/3hfn6FF5PblM6mHU+lovMyymH4jSxOTHyfB617dVrAdGZxqNSZMDz
pY75RsPd6J24pQigoKWfgn3yRMp51iJwGYlR6QP9RB+ECLWIe2ezi59q5N1qH0BqHqBng4JxHHpL
4SG18LPisKtXMJaAK+TkpR/dh4SLAiRIkSJEYIMBgwYIDB2pMkkpyO31WseGt8hNW6ADfVN3OPZ7
QQGGjAyw5rygX9csHPMutS334Qh+JZVmeFLHGzPJZzuAffAgTKSA8NBRRSqqqYYGB+X1u5G0BYAw
BkoQLr3tBOmSmSEDmd002nJG7QhQ0ywCd84V62KUMkCkt18LRTM0Rrg1ZX0HUHUHwAb9m3p2blZN
lNCSRXW54bziKKdmezAHMVib71wYy4JB82oMiA3kbp4NwB2Q1UwvFXOcZ+A5YEPs04einaAdR1G4
wxmCSIKApV459OWVzlx5JerY4lEzcDU1FFKhURKMqqqqsmUUnJu9nPx8djaXlXK2ab9YgZWGTYqM
LXV65XxmasrFFMZlUWG61Jkl/bgLFfmqUdorU1ERERERERERERK34qVFFHno6lN9NSBUqxQTI3Uz
W3WMBbhGQVZ0BDk0o3c2w+bH2Yk1MbTx0N5XwfiSsjBkHUkWnoLXVKQvGTwlX4TTs1U6nwYAcEsz
b5SfFUwsNHz7DaXuEiT+CJHoqfMxk665vgOfdwkh3M48r8UeYpBKllHxwirjsKDMHjFQthsWLMvP
qg+qZux8usoV+H7dVYoSzKt3+Dxqro4or3yWIz9pe2GmxEOHRjbV8BxjQfZlEhNUVlzR8lJwExTj
rkkuZ3DCk1Z9YEVROjj3C9HaYA6MkfhcZwo4vtevgkMEjJU0tIyqs/oKZqjXLrYRlQYUVSOg8SPR
4m8abltOnFBCkydmW3M0CAEZEt6YH6opwiiihjFEwQwuHnGdCR9KQC8vL0nv9VH2TwiJCohRihUP
NN/sHCT6kWKVCxY1k/UmYzGft855s22rSRISRkNNOdmiZ2KAbNMKHgINUKbIVkVIhhBSQVfO3GkE
MbUAmMU1skjZLIaqNaDFQcOmdXVX0TOiObcIJTaYtccU7tHOJiUGkVkKJKtNWD4/fK5lzpbDoyWq
ss3cxvryaKaaFKQoKVURSDpHGWHGqMGFuFlXZFIUAqVUQNdODbWkIZyShgjCW+zkWbhrds221qRT
kM+oZ0nFcd5eytXZFIcLtXZxpVRgu1dkUhFIRSEUhA35Do3POTC4hkNxfEhstLHEyH4E1i07odJw
ikIpCKQikNaVUMjMMFLlwZ3MrPLHmCqXHc0gKUwkyMjMRSEUhFIRSEUhFIRSEUhAs3XZOwWnLcbG
y11LKVURbVRSkIpCKQikIpCKQikIG1UamTSMbWVjBFIRSETj0S2WcBSEgxODA1kiCn1IZpYsDVCW
W6Le45CXxSpGkUQtaZVSszgi699e2bSFIhVF3tzSM45iEuqPLEFbzlR9pv2LcB7gD0cQGkgCIio6
FudkJKiUEiPdEi28JnO3TzWz3RwXTzOng+pH2Wn8UrCqD+uSoBXIATXGASvdCt0ZHbdDTVASCJmD
AvoDhwC9tqpShUK8HAW+AYLWCQoKFw5BwCp1JCXMTru9PH9CNgjjTTS65b59aT2w3ZzHtpv9EreS
e/c505mdcc+jQOdAAEpcC3RRaJkVn5lB12dkTypCMydZ2Bq0RzNjmmJpnT5mNyLARmbOaiUjhyZc
QG7rN5xgJHOwQj6iGfNfboX90YL2zGPf0a1F5l6hoe12Y956ORutslpaVpcHvYbynAjCgqY0ejze
WhlFJ0M6yPSetaqC0Edx6mxmRoU373V33436vuzcbji4MIyVN/Bem9Uvsv27j1tzsOw4ycI02t/E
JkoSmafGbRJNDJgTBgp4Oje2tV3n6VDdwsofycOzVq3bfcV3jkHATENey4aej5OjbUXQC1EcwHod
FtDaTaOOIin8YL458Jjq1jLm3ZS2ZcE77cjOYJsPLDr61VVVVVVVbdQuDB2/MyzVNmVBNkDVTUxA
7jua5esob28u5gyOxPD6s6tPH0tvW4Ydm6MfR1zsaqc0pUsM35+6D7Tqcr61araUQMyV6rlp0wrx
eTrytrj1AmGkGCqVRCtuJoC9VVkF3Wh0OL94ABJaxAyWohO4Qwpge1BmtD5uKsY602JRtDr6dgp5
GotHnOz5cWmc/HENFwZleA2XgLxSJwIm5zNEcrSgqIx3amO6t4LVdqhdU0NCoxcqDBBUkMUddT1S
/D29DqpT3HTiajIPTjXhwd6gwZDuf5fjBy3sQW2TNx7Only56Uyt8gE+FwEkuM50U1qiCWUAua+X
nu46m69JuNkCaHsahZkENEgGVLpUmuetbigWVLOzYexjb3LIYwthbVkWY8Mq1Uiw0koumbVHfdyN
xpZZ3Yxp8WvFV0niKvgctqPweTapDUG0mePj3tjdCEmInvO5zxyN4nFL9c6A5fOmoeIm6pYGlsuY
HHKWF5NZKzkslF6UnSgtscvE6SEgGqpA6O1mGgixMZXdmZwfPO4Sfi+xsFUMpmjUsibQ2mFODEzU
YijBCXqOm/bnTQMiA2NTRljcFSle6lNjl97Tye06gzTsJzod5UcyKxGox4yCzwwzQz5e1v29aUtt
ttt4hjy98zZodE8dceFSdhqbjeGo2JjFm+m12DRhW0RBFveO0szMVJnsGIMVMGDCWIZzNoUzMsu1
YIXCEIQ/GBNr1b9ujnOM1bjJbk2d5RrgMct+RDHgbdGu3Q7D20q5M4vqm/ajZHbjlzSvF08SLbt2
L5dJQ5dtOPEx2foVwZ6G2uswH0ff42klMJwVNfkLvcfJjef0jtjtsZwl6U+bwYVCzL5FO7ha5Y62
Ky5eKbmXHM9+Er3KTvW/QAFUce9IIVDRhtqjIgh7iKnfkihUQSQTiwynEer2ixns1dJKMOSeS9Go
pqIpRy6k49zbLophN/Zt8Gwwae04fG9D6FD892pUoYKTn6W0KsHUb/eVT0rgyZS/kJSi9wwsM5RE
oytny+DgWvHZx4zOXxZLkZkxbs+ie2e49LlrnFKGqnlBKglEqpzcqQ7lQ8ovkYrz7ZWxa97JdTIW
DlQYpYsMyFn8DPMckOokUbrAipu1e3H1G++Bv6w1r0dO7iuBrolC20hsRcES7l3bW+/O4aGR9l8+
kcMjQABfP7wACUAAKEnEUU3hUQRhN2FV4hk3j2oZ+JHQpHacjU7DHiNu7WBrLbkYbIg6IWFga/Tq
hnmwsnCPXxkqmBj9HxH4G8jr9Mb22ODfPrdnXrD7lPEe6/Fnm5+WI90qFcvKyxa0ONfTPNIxREyI
PrNzqe4y0bx1/FOtZ+9Tv1kPxKhEqoQ0ER+dFg+3Ve68HDCbgo378JK9HIyXk8X1u/5eo7e0Xo4P
z+s4z7hvlAT0n1D9Q05Hw0EJyiIiIz0wEPzYgsiEixgwhGSNl3O6q6UaZEkQIMFPsTpiSOqL0bqz
IdOUaKQqQZXyYK0J6/P+guzu0RlhvY/u7UUmhsaGfASj9kRLQoQh7b508BeUTISlj2ohKbZM0YKU
qT17cZsa0+a2h20Yp9834+n7vX4dDnUUsvLBhT57jdrs27vn2o+KhGRUqAOoiilWta0A3xW9m2pb
GAdSvkZFJyDAD5KFHnoAuwMxJ4kDaxZGPqUoa5REMmqab0mKRQsRDliyGKElaYJJ8mcQfnr4m/qZ
iGoWPm+127NEk+H9g+4eb6+oie3xxKoUUVTrZGjYGki679Lp4dTlbSrcpynKcpyuswPHfo3jGM37
s0qYFGN1USI+ttpCwaxJLdTALY+ztwrfMJjhiJwVIOuw1U1VDGsNJEaTaH0wIzpDEzUSRZqSITjo
uKWuFiR6GW4sZhbrcFmaOO3BFJrA1ozxeHULR2fm9/+R830C8wb+o7e/2+Cqccp4qVdU45TwZzpG
22NsXz/htJcml8P6MEaoPt+n+N4fOnqFQec5zlJ8JWek4Yp5wnlmfzCwkIzE7vQseiGTSBhgIW73
8c9ofPDI/dqeE2/TzI3JOZsb+Ji0pVmyzrd3ozWVRYh62UW3T4/xDIy22HGN0KdmhZADk5NeHGO6
nharL2hVLt73b2qy3FUusXFxt6pCRFVKlfiRvTA89Cw0sdixy5mQ3Q80ZigB8XQ0Aw4z2hEfCXtV
9gSiUhH949JpgLCTePiMBgYoKu3GYpyQxmnnt5LQczb2AXKqpNPnrSwoPZc6UlquTcz2Fu+hdDzJ
djuVVUXu4sqRUY2VVVUqKLM2gR7tby2mMS2/Xq3GIliHRtJVC+R0pPdylh5dozOXbvVYgIVmFNIo
p8UyEYKUvsePyW+8Yxbgxi3BoJvFEKAoA96ryg6kgKlajFWsJAcRvnMRkhYZ/3DxTbIsXCh7g87D
QB6MgQJs7rcnGq6zheQqkQzPTWnCJn5AMBw9vueFPTDoF0qwQcBzNPnFkNEU6cQgdmT815cvLc16
m9p0kuICnNeCRgpp32QNqLsXg0yLXula5L+dV+f6kODoMu3xbAJzti2i8Ylp17pPFqqxNKHFNt9c
8BfEwqKqKqKpFUiqMA7SsKjCmD1OmHBsr5GMuLGWzuxvTHINHEBZOgOr4IAoUPNkyVULKZduLFW+
qvRoLbSRpmkF+uLAJaLKwUDy9nAdNyqhKKrtbodBHRGRBX58fncVZPciV4iNmgZ7M2ysemF3La8C
NUyDtbhEwAdgU0OxQ0Y5YFFVdUBpdangeHAaJsHiIJDzMgByrbaMMos8rOJaJ82yqkzEaG5bYViV
ZmuRFjyRPlmKVLFvUctC3vim0r2SHiz59cPsi23cSkzf6araZm5IsTdjWmZfyxCQmFZMj2xq/OJW
YVRVVfZ0Z25XyNudFOa4QxCt9mejirTjpHAW4PPcruQ9c+/QGCESANtO1D2DKRBQz+jgOcsUQwEb
5EuVEnz8iiGgCQCwhMveFUpVndTak+ZigFFgbWiNhlEA2Tb+DeFQ7MEsmdSeRIeHGLGQ97OjpGQh
EkudHRXYn3y1QdQnVNTb170I5vqs4hw4t/T4vvO7k4VHUmTcLEWDs565PzfH5XCJyqhYp4+psvW3
PoYq+304cz9Pw+7mkO2ZY7Osp9wESjMZg+OBJIXPr1u9Q9b2n2vMqKeT5VXxWFta1hEYo5hlVFWz
9nZjNXdPb1rwmzQGI9tZ63d8ewKil8TSPwlpLIqKWGte+rMq1Zp9tebQ8+qIDQxHV6oberU4tCXz
bn2Q0Vnpo2NIYZMeG5M17mXp8Ho6d97WGpuPYPqmTJkZPuBGBQ8+z7B9escneRrWbDp9Pi8Xotj3
Fczfq/J54tM+fZnw+qjz0t27jwWfGWeSqBZBenCQtgBjvkLLe8gsJeklflKuGC8BryXEdQ40Dhwp
fkLrR1VlZNRWJvZIqq7KEyqiGpDq4txbt1auPAfiojHinkFM4pmhz50GQxq7XLSZCjta7SHMpXjo
5ptPFuG2vNQeY7BxMmTIyUcu99S+7N+nZpz3a8lb2VGIxxJ1Y6S/q4YuAREjUM2440VRVRRTcGGY
42AiYYbWj1fdzQCrxKbHsiEHQIgm3vaANhETy+Lf39JMnteBu6L3mQlFcnFxICCaenJnW/HYPdZW
kNgr9MSs8tekU1+K7LtwVCgoqKmvs54zXnPxXh2SviSsVZfQ4/HytZ7T2UsV8hT0yrMZRkmJ5Nyt
iblEREOwYsPesUewm5Omx4+GO30Vx6bw6IEJEY3g9UAJEh0slL1FJKp7XzJzv5aaso+MViow7M1B
nGOdpvdqTP5JzFnhpHV3GF4Cmh9+3ShS5nSYx0RHaUgQqtnnPX1+bu0yV36pmscR91rFVyqGahRU
FVJXms3xXatqCr0dmsbdXUvZz93Hr118ek+1up/ny3zPq697LJC+my/Awr484uYEznQJBiFhcPUW
DXApweVVOxUPa/JfcLURhJTAoogUlQh9GDz77qc0z2FCmHFghYgxITYKUQQKDEtS1TrwmHr5sxqE
sdMgnZy4Y7uPl1LZi0gORfdgEkkfqZDahFT5f49Kj9A9B4goMCfaPLRCpsPsEJ8hnXiwm48tGSBL
Ouq4DGoZHEmeN9SntKYstMskORgF/yb5oSCe9SpSEw30FhMsOQ16C5EfgnHj5rcu3tS6oAt5vmrQ
kkhjA9n4MDECF3eT4Y8FN1Q6p2Eu7lVVbJ4QJmHiYjtJA5V2kld1dOqsVy7HVVJRVUVVZlWWSr1Z
r7UQfR7Pq6fw1jSECabXVdaF1btd/hnyYLwt6VOXb+U+n5WCypjDRjWJ5+4w66ZVseISpRinRhyy
ava7vP5611VnVim6bd4KJsRyuPg5Tm7br+6e4/p72ECRqgQmJPwdOtbnMNUx4tHXvrCkCtdbl3Bx
AlUejvEHX9jcC1y95V3V2ZZiUQBKQth6QkMI6Agi80oqleY7ON4lpisTBBBBBBB5ueSVE11QF4iR
CN27du3dAAY92g75A3FBjw1Nsr0nAynxSYKGxiDD1GoyU8TJgUbZg+9Bzq3fCbqn39z8NRwq1a8N
bIOxbaA9TGSRhEBTwcZSgMjYJIQih9hiHURGABw6uZ99k7e9UhVYqjFvkZjvTS3q24Z9ceNrJ8VD
Tov2PwmIz1rP0h8L0PhPlG404khuPDvGxrvCoE11dWmrb8lVb71Vb7zQRERERERERBEQRESqqqqq
qqVVYk67kI6Hu798uUxXDiIOa38MRlgBbs+5OfogZPXFk3rrbXMzjprNAKAQGM+DwYRnI9ZS09Fp
AKvDfjtoEIpB0oMxB53cDtCAglHgmRVEJtIiGuB4u9xuK6+0Tbg287+mOXGH30RVR+S9FBTP7o1M
ts9ujXXLeqNQZEUVWZOHIjbKBOAoXgdjvCVCtOICBCWFTlu9rJqDZxsIdMuia6snV3YnGm6oiW8m
imcvGDa3JccwXWh9Y9DbaEjpB8PPEGMa6YcTLdhFUBOCAnNhGEXz+K1VrHTjGkEEEEEEE+9bs4q1
V8mjfA7eXZgaSpfafQFjp3teo1k4JRK0rStI0fPW3DSK1eQYDTQqsKKAzKpnLSkFPH9nMyM5UzzM
xK73kxEUC3qis25FCqqNNttkhCQhIQkIT5KP2fJ5PPvXvfb/a/qft/PvQFEVurVv729sgfyPglic
RM+JYHq4aFoRHG/hwhx9Ti6EUTC/EevLEab+rY1aWdDiwcTcUpiN2QKmKN6183p9VzNBFF97e1eG
2Sm6t7zoYW3MIVIzTnOF1lI9B8tKKAqmLW83WjNYBk7KRVC4nqIi2M2utoH7pKpWrCKHeKKCCoB3
Xu3ycllNHjGBGXkrZLfEVWaoUoilIUq3Je3JnC+zUBBF4K0SiuJu3pMe/6psnyUFEtvncpnaBPYG
ihpeIUo0CTVkuKnyhrFaonh7r516otlBBBBBBBnvZ8weffXj1i04SPe/XS4q1a4rRcVfk8+84FnR
rCi303nLFzbn3bTsmJCGXGCzQgZPNx67lFeF6s2kStOBTQzhwWioamY1vQZUqjdHQRU0o0k8dLkz
6h3SsKWwQejmqVtyuI6AIPG5thvew1oloEJVpzJIoYIkv3lHXOGSGUuzGfPgzt53N0uRHCsQEMkq
xzONYjyAZwK6PQ67I8PPThm+WnCCCCCCCCNXlUKSwySkpKVSUlG6lOfr4zMM0+PXZaHSGDFiiqKF
VFYqqVCEhCQtCoqUcxbDIDjCkl7m6Y9rkSV3p0Vzy8WkArECFVO76Lsyxl5WovGtCLsRaTPMi6bG
Nu11cBQ6qk0UOIMnNenF4LI2twA7NVzrnwR1O7Jii+FBG3NBLYMXowCCWMoEzzepZbICCKecuXEu
WnoaxhERFNVyVLkuaCbxKoIMkxbW0gE3W00NiZoKSJsJ53mm2TgZ2okiImNNVZvaSbC7WyprXc1a
MDTYMazY3gVmCsJGywLeuc4qhO/CMJuvHtxlrrGjjjjjjnBkvfwlJSUlJS6artrUYlRilhMNqVHE
O3ZXO0IUGQMCZ78M6bUyUSrVqitTNU3rYta/UKiqXjetl9SnQt8HX8Knkvr2cKR4g1rZkC1zC76E
FdDChjF0Z2HpwmR9tmiWt6ZnTe1BaBCnhGqrQWBFLS8OtEIHNOpaiwLiaZKTLVtaG57rFDBtEdjS
TYaJtPfgnBnOLLDItkwWbYNhOrtrfpry0wOOOOOaLe+LRaUlKpRKpdH8Ni/FGVWpQWhTnQQOsTZQ
5YNN5GbJsPUU01orWpajKQ76wiqWeZoV4NLVyFjgcbK1NVrTnZu3m3A1NpOTSjbgaPS6TNBPNTVz
pwK+uCnOIEKLvn4G1448q8OdqHKQTfN2U8w158+RI2OzCa9+vXljJhg61AFUN0NEpVFUpjnynS9p
s444445iGve0OOUZLoyXR0cH56G6SoyUUY3MIaqGMNNpoG2N9oFsOXDdx0u5XPyxQJBgqboeI1um
QwyKKjJ5uKYjsFzLdTmndWDRtIStnXspjrQjWsm/XeEtPdziu/CC1tdFLOd4gQuHR0rriUqqqMVR
pKGkoaShpKGu3Qo7Nu5dziJpjmlRCoGCCOK4QObg2Xvo3OOOOOOXtN0ul0ul0ujJdJNtOC6aVrq7
KUfXOG6m4ZZs2LYmHPkjlZ577UsZz08+thi9G3dzcFXeFALS7yByzTjxjMOLijytpybmckhMIWkM
0UU1TzJj2Whkng1JZDTl5d3Fx8MDjjjjkWgpZGSyWSyOlUgje5wzBjq+VYqLljoIh4NYCqiwCr19
HT1aoZUvvvq1ddFuU7egvEcKAdfeo+h3Tuj24EJxzF0ncSBrzTxwNUUGXqFT2IghYonnEC49PUMo
tLZ+bx+bNxxxxxyFSEhISEhHcjGZQUpRihSk26ENVDcBlDAyhZAVlDfI84Za65W56/LPgvSRpmZm
MInwiiBvw5ZGWWWWXHBcve973vjF5WZmZmZtMtMzMzMTM0mZmZeZmazMzNZmZve97BYsWJJJJJJL
kikkkkkkkkliSRiSSSSSSSCSSShJJJJJI5JJJJUkkkkkqSSSSXLlyM8iR1oiC0faulrMU9lFD4aq
ou/9pslox5/1m1EVnYec6vtkBmzJPN9UoB7PlzYN+p86EkNGB3O3U3/S9WxDJOswR9zVFdtRMb0y
Vu7uy7n3kRkPnMx3rOT8KjrpZg4zeGdza4VfjOM66ZJJqkkuwA4MAOCiJSoJVF3lxmNk5L2ZbnZc
j8y0qBsW7fZCZcsvm4cl79Lwp1TxannqIhhTuKt09ycdc3OV+Hn6Kd8cdGSVQMXwdvTjP7DWUSdG
Q8aiqo3VXOjPnfdERKJtiMAAw9DhUQCpUGUK1AQmFpnkMhTBwv7ed5JU6l459x2oIKn2iy+WA6tD
ZF7isq3QllHNCXYp6+DfjiVzMtRvQOLqT3SEzhsLcU1UkUr1MhM/TZazcnJybufnndwPoOQxiWe0
rR5YujxXp+n107Nq39+Cptge6T9Q9yoG8MU6B1G3ZF2s0Q/dwcEcc+Isire6RmxK0SSzATQazij3
LBPnVOdp6GTkdGcjMbanY+JO72Yt8R3py3rZubNgy7MbspVsMU8tbpZZuwDE2aqnuv6vS2qzHgi0
yUspQeWLZaIhCImyijM7KyEG3ud9346cs5Yd/C/f49MjsKPfA3lBhWruzZ4HFxeB9B6HodT4Hlcm
7G7du3bt27d0t27du3bt27dxcnJu2bt27du3dDdu3buDdu3bt3Bu3bt3JycnJu4uk7/Tv0FkAiPi
IqbqM0BRGBimqzZjFbAtC4SYK5FfhT9weioaj2kSKaGvB08AqDbLF8Y6DW8djR/GzyZRJIH15tTw
xZrHJtxz4t7x0G/j8WzPldYdX0QiCkVhIpAVSwqqWWx4SVBPTQ+mp+1ZbRROTE/lDCP9Z4AGBRcS
VMEjDKq2mtUFyLeCMpgUoVGoBZksCII20gYU0EAYwGDUT8NKFEXyZu7VSYjZojCiyKKmWATBMGBg
mMSlIWItBIlihKQGMItoVLEWFLnEa0QmSk8n0eV0Rt8NnSLudOHuceWeQjx9dVt004dVVy6fc8rP
Py/ATbD43BMLLCVZEsqSFFZYd7o7kmva1dNLLJIOzbEk68p4rJHLei9eD3l0+n8Uj7I/WPnfUD6A
Ah9lD2H1xPifsAp+U/EKLtDc7v0BOssOkjWCzIXX5NEdTpxGWNMxxVIzX4L/TfkiYE2hTe4mMrZU
65wcWZUUrN3RjH4z9YS1YulUQEJaCv9eH9NIo+IgM5gOQsByuxuwYkZqc4x3GGo92gfRs5OTtsTt
YIR+TK678iybs4U1Yx7mkiJ5h2kjX+N4nSQiqJo8HkbO3BCPO3zvME1eBVipl9ySiTqLhQA0ons2
HoSnolBgKbvIdkpVFpbBzk5TpbB6Pn2uw2Qv1QAXJMIe92OJxxSEUhFqUQoGGsqJJGVMnfwMuY9x
vhg+lPzcH8m8TioqiiMlEJ7ghR5vony/Dnfm+D3rnvnkPdPObwQOBmanXttbGT5ba6G5ubm4iIUN
NNNN9Y3wYNjY2NE2FRATdcKIKsLqaE6bbXrnlvbI0LGxolV2VFsy7Nra9s77zN73ve99L5XpakYr
iuKYprG9tr7X1vrfW9tYmHNyJy222W97Yfa+URFtmatcttbvvuOFd54T2gU8BJSe5m2sMklMhZNs
8bi2hDBI94an83bMDBebeQepIpJ7SnsnAmyVyM4FmUZwieckLJRMQ9bScYpY5NkkhnqifCQn2Icw
Qdb1rgCD2AM3IGC5BNfgfEvhQ9Q3B2TbudeZPXlcAnNTvh3ym6fA2hNwSkShKb/CcSjeJu3kWUTZ
vkzCoo9GREbwpvkvwWZeCdweL9+PtBiGTgnNFkV4QQTlDiUwFNCFWfVpxgyGknFsSTOMRxKVVVVV
VVVVVKqt6Rk9iUIafYnw+hP2b/Irxtxt6N2Lo5s8O03G46B3TxviFOgqKCOqSifpkKyoxFY+NZim
Upenp9fd9VxjLCayiWuu62wuMZcRoQFxdc/1WOZmcZMnBl9ftx4Z677778+XPeXmUwMDApyl6g8w
vy3QGZosGbB2abMuEscpLJNFGsckkL3vemftpyBz8aJ2HOAdKSff9fw/NjcEPnn2bE/H5P04bCi4
5kHylQnYiUonvhKncEIveDg+x6G8vIKp74nu/r9yN0cQ58TumEi6upy1sFCJwruFZ81CgfQcsMil
1eqgqqJpWhUJHolC/DVB5swJYQImNQD0hX5RfqK4l833kvVDzGwL+z1Rfee/wSCiqOHSQgeKB8EP
f5HnrHTZ3oEckkjyMNyUuQmPvml3Hp89dEvR3mb2dpp6kJHfO4Y2Yet94j8E2/SZnzD+JNdpJ5yT
cqlfAmFQhCDI3BxwgQIDUISDIMYJMKXYlI/5wRUtUFr2arRLcWbyiFDJUklKZVlhWGSmVZYVhkpl
WWFYZKZVlhWGWAwpWWWGFYZFzaRPDRPUhZRLSwBxBDz+dZUh6WmxBWJBn1FVVVVRWK0EEGA/WVPQ
j8aX9B8aV3njSP50wJHSfl5t8/CMvMYMIaHzv1/i8ZhhJXwyzwRq4A6sSTYG1saUnzSWZSlFKKUU
opVqUqOYCCKKWhQjTZFlArIkL2LpA8DtfWcdgZBmGxUYonLg805Ym+beW5WuLWxbn2IcNXW+V0rF
lVbKljSx2831oROfU8ilTpWhoqqGVZhvYd1MIooqkiogqnv50WuMpcmHzj0dvG2CYYEHaUBTA+w0
jH9NCiIoQRJhakCgm9O99a4HyJJESJzeaKXsHMiijA7UklCT6coQYBnvpd0KLa3eIazTkXtUlWli
rF0DoHby9qJPspzr9grkmg+iTi8UA7PwI8kqTIQqYUyDaSoh9B+WwPe49b3gyqoJVOgqU6BlVQSN
tt0Ik8Ri1gQvMMoZ2lnZ+Re3NLTxvbeIL4p1wifvQifMnpvYddazT2Zh98O2BwjxD60BHcqOIAD8
veu/GHtwEUp0H2u22X20iu94YUjs9ujiBY0HBJfbfXhPetgvMdCOgOLljoDBBGaQGSKrhBKbDyTY
wYfCymNOad9NrcvHtGNuZ2b2UQ4mZmZ8AKDCMgxibqgiO43HFfU8hHhiLGsPjiOSztIbTMJOZOOu
70YfqNNo4wxHnA4XYHi2oCZEZjzPBCLyQk7ak7bidWM13emfBiJcPgiFTBEAYNtMgAwt1evecKkO
jh1eOas+ZLIsWSCwWClWTy+ugoVA6cIoMBUXqhCwbXlSojBGjnaQcmBoeDTWuEu7plUxBsd3VqCd
MHJJXpk+P0FrHUvFX0hN8Diub1wgvmQqBcH1GFoGAE3Xy6NwHuSJGRbIj2oCsIkm6ANyrASkkfUU
eSnl/DruknHAmSRkBCJhhKkVFKQGimSkKV1AHpGTDjT40QSENUdQfJPqTQYDsFqV9xIBeniP0m71
FYys96c3j1hR1DXQ7Ek2I7N0QHksNN3Byq1vS/iZ5rNDeMZyMK2WWMZ7+4F2xEtBQphSpA1ooulg
FZhf1Fbmu5oYE+DtI5Qpp9zz/B6ffkklSbF6fTr8yAmhL8zBvMNp/hhzdUI4FK3ep4zzo4fCd4wO
/TGlEgbOUgHxnK/T91KUAfmug2Ubl6Ijlrjovp1HLR+0FHmqTq93jpKbkYRxhuRiEPt7herxHhSA
qTnlJU0iMa7qDmS4rlDebRK9IkPIhPZZRSeulcebGdyks+uOEdhOXXu0+NJOlsvunx61SpH38J1W
cFWkqrYumDCndOc1uTm31XXMV4ghvYDGTBrAhExOT8D2SwMWALBRVRZDNSucYHHZhxnbhIcvPrI3
IRPXJ+3TYj2wq6GUjXhxjRu2NfudzLY3bNBghCCglRUGlHAoGoMBVRBlDIKqghki4W95mwWUtRhr
9+1tcabAko9Wxiyc9BkchSYnRu2mAA5dX0mQq/vq+mmEPmS6LCCwWCwUzy2c1GrOYNuWM5p7uNdN
zaTDTTb34TpHi8C05QqvMcW6cIW1atW7hOjs3B/B5jnJfKTV60d1PHHW6SdEroJO6G2j2HY8eU/b
kJmpFfbqwzuQmLmGdLY/P767VVr7wadDvnSSo9RXfv3qIBXXPdLX2Brhy+zKQuv43AFfOREYeOgS
spElIoiCqqMEOTzaX63kO0F545IWCK5/e6wEWj6WSisHfhimsBYbfTju6qKQkCfnBNXXpzLXASWx
80EI0MbwVl44lguIP3FDTQMjwFNP+WVWRWvNQsjQalkzBkzOfZkXryajGaWiqeFZ5d2Njh0ZEkua
Sc5meB3llEXCqc98DDgwAMjuR8RigjyWMbeaPLvuMBVVjFYjFYFDBVCjh8ZV+NQCswqrvK5TX1+R
HqFHh+r4fBJEpJJLyeHu+8gh7SJIoZNAq3ZGVTA0XuJKpT6/hl+ta+LveNzpNCyFRUoFAcu+KyTD
5jHJO8u9HsDvu1XrM0FXsvCVVHKbuWFyrFlUYqqo0lDSUNJQ0m8y9oKx8TwpT9WRDE3jSFhtZcyg
zEDcJpthbjuhUBFoqQlCTxW5DF8RyMICFTfVJblEyMjPABK5/iNiNIsFYCu8JMw5EnOutKd4a1R3
RRHF2obcVphxvo2yA0eun4nLkOQnYaEfBYPR0OT3BA5EIizytatxzAlGjnrAjgqZOtV6bDpMiJr5
0TWe9xtG2KqoiIomzcGk3puQJ3AiM5+50wlQRqifa1tV0BDUQ8DilLEJ9RnubIaFChrsUQOA082h
EM1frJAFujjQkTI1HIVZQCc+RAZ7ZANtBJ90+g+zUv1UfeoaGp0yKqqVOue4iqAiQMz3h8v1fB2A
AevJIwGDyjFyigexDbu52yihsoChcZIiSqBKWQWmKGtzuxPTGcGIVLBfxQS3Vp4tOjhe/cGnn4XR
MQWp67Pee6+P0SRv0wBuNyIkowj5Ug3cokHuLLCTJBLH0QSsQxVUA++lbCIu4LvtIyhNHzJfEg1Y
SvhLscFVU+O/Nvwz+dWWXHbPP6BydUDl+DeXY99EAnizXMHbIvAPAZRm4kK5efr696NnA0x01CTi
LRGhVNPPlZxknIjVSFFVJITNEpBMSbaDoWRHSnW7bVdGUiOPZGmt9VT3PDLV+FicPDmLhquuqPUn
TD04BUwIrUDAKluJmfrsnO+3WyVJPdnN91kzT4I+n5ejQ6+j7zMfI73v2eBt79kxl4JIPfeT6bV2
H1ixuezb5YHOzDD6otzrwOA0AlhpJfDXpz8BWCHEgaECIGNH2qIsGIkfKi8+9Mjw2OOlJgZMeEPp
CrDhDcMuTHcSxIR6U9HeSg77AeZmQAcQfx5eQECuoskLBKZ3IKqDJm3IKhddqh7DH3OUNU0zOmt+
R9iBvwzTeSxRtIfZDckIWmc7xKyYSsBI/YCFCYfREvlaFher5/yjY9Dfq2DO7SSD50myGxq2DWQY
XKvPsj6k0khuTsdrudzOc6QLjOXd6bhBUlozxF4zgwXwbbfoZB1jNbFgBooIiUaB8qU3kzC0D1ky
xFANoiJaJQiVlKyqqk9sFlzt/T/Z1Ph2z8KHpHUp3e/4YFru+JETYn4HWHL5E3qvupxu98PTSSIq
lKssjzVgKjNAxc5wtmaUUaB3pGvH5w5ktg92C86oGnmOEqmG8QYYP0VJ+J7/wJcyeQnhYWSNFW5w
9qBKCe/wO8IiIiesqqiKqq9JaFCJVdLcZZdIZhpd0ScxcTYrAaSzQCxR0kKFElW8mF6riBzXV3BE
JBJwFtKk8VweRUtHREbeXWQxCqqFeIiAEqQm3pUa0UORH3IySpA7PwmtfvMmWJmNOGSu+GlhxSh5
mLezyvZ5HHBpZYQYl97T5a3YFBZ3SqIbixQgII5lUXKWvAFVaMQFBUaK73SGZMyydcdnn8fdVlUm
NfHbVTdjXfP2XDPoAfoQEOwTh0dQ8OhGx7aLkUeaWAfoLaST+4lzsXoTNjrMAsV1BmqssSBpoSBk
O8IeVIvkHYI+0AeH4z1tvkCJJI65vTixMNJ08mherXI1YetEkZjdhOx8xsGqEsWdKz9UaFG45fJd
7bdDPuGHBmX9jJkpoYfZk0YBk5rDUwQIQgGmIFlkCEIBkHhdkC+rQo0GQZBnk9Nhs56LWHbVu3zg
dEuXRRRRR2dfWK1UqBrYkhJCSEkJG4Ikbbi4GYM6Ba81HT0imUNME9NbnmDnJYFSypZViSVEWCkW
cY51IwnbNt92yYHZznVbQb8DHSYNnZoUfIuRAZhRZscegEC++EnVRTs33odcUQTdxcPdJybvD3iP
G6U6a5uX9GVb1sqpSqqiIiJ1FpguImnqcLKqqqqq7TE5tsw0VVV0ZR/H0eZqrCsKwrCvuD8qAx22
4OoXtuY4Bxh0Jnn5+yycMCQMJEkhKGE5knf+7uWhIjJgVFLqo0AwBEnmYSmKoKILwOG/mDnKh2iS
b9Ajzb8HalWTbAnWTvYCcXD0PS78Ph6t1cEkN3lhW/x6svxNa6T3NbZtzVmzyfZ4HunQEjcDJ0nQ
x2w3b+TVzoDB09ymSKPXKhyWqRZGi6s4zserV3w6nNzMMMFHgCwm547gn1WPFyiGjqplhJ8LUk5F
VukqqslO+hvxLlE1MGoMMMFakimFGV0BOXTZA8y2kttctmrbieCxYG286cfZ26DKpJRddPHO1nvv
2614X0t6Li2IJZEiMeegsWSRHn0FOYuDARo0djCjRA+7QhomjTP4mCFofhIkYeGAxqSJNxolsg6C
QMSy5GJDaLaDc/tfuqM7spBocouDA74rPM1ZvwYiIZZjaQOZ1U0KiCkkI8ukfP247OG2GmNmnVXx
rkBaOsYLjSIUcIRFEIPeWNotKujQhoBQoIJxCDtH6Jr180xvCjppqV92+y+9XDZjSvm+qw9TZwjq
WkpS2rEssLVWSQqlqJVQpZKnJP31x2xVkkoSixa0ja61dvRiOM9oTdEymRLtmWkd7JZW+ZcMRqgm
gA/DYbQQZBXlKoWgjUFCQCSSIKsFm2bGkmNkahqoa2nK8eC6Ey0BISeqjHYNAHrHWei3sDDDOwfC
kgNmbFDu2ONa9WcMsURoGtjQFEDlqm11FvhPDWTzaI3TdLI0seF6q4u+DVTtbD6IiOv5efdoTonP
h1qdpzjnuOrEknh2WrFkhCbKXv4d06jhQFMQ0x0jiKOYq80V9/SUbdIbtRq3YAm0N57RoX8MxdSo
Wj9MlMHy9HAujNGnHHpgmZvfOiC80H2QItRpZ0KrITOEfwntMOSSc21y9CSTuSQb0Dm5mCeBU6vK
ISouDQIU/R07pXY1MkALHQqIice30cq02oFOx6ne95oECsn01PTL3higXLgyWT30MvTpSm69ixtP
h1tNgzT29NJg2HAhaHlaDQdVII2rtBQdw0IdTECQjP1X0vEXE1rQLyXmn0jMKRcOcwlbx8xfnMDW
6gSx1OnZv8eTCo2laqw5MTEMdE8rSbD0CNjqeXWL9zAdbEIRwohmA7aADtBaqERuxSqqop4JSMSj
27c4csIaQjWweBhRh95UUxmqg2RRMczCqI2DURAGwIdLR83PrNI8holDXY2xeIGWkRxLYnZmojgZ
OhxhikSkdZcBLQIsSSTL3TeBNkHqId/LhK8Pg6JHCtj1KbI+R6Dunri2mN5oE+b9DHyU7DiqE4AJ
CkjVE8GdhSGxaeiLDvxz+jmZb+uGHhmhUQBqaxNmpdbGi6L85W+w4cNuMj3ozi1pe083OwLoD3j5
DtrDGmDWUBn4fpvOyk0XkKdCNICkZoFW2SyVSxUiyGmDG4whE7Z22u43LmJcaaHKwiNUHHdNQc+k
VF0xH6hAaiZQQdCKXYvrQDqATsgIIv06dPs3ZStzcseuuhjcJ9Wh8avu1mbpaFPXElEIlIhHDyEK
XVFXLUrgbgYMVqJLtdzFwopGJXRQxm/Y2Mrhzhvqc0hfwaZBUt2zXwDInE4y8e+OeV+zhexZHhkF
unWvBPEwMQ3BASgdYIiqoKVHGjehhhaE7SCNLLPihsN9ckLeXkbiE0ha+QhtMGsVVUREREJkZMBH
InjE5oGQC2vWE5yNmSAmjbj2Nj5ga9kkTixufH0dkbomurEMBgWxTg1IDI3iG0cNjjnUOEoAEaQQ
4mU9n4/xf9fo8nwfiY/B7Pzevr/N+f7nB/98+7Z8nk+j7v0735Mv5f+P8Mn7Hsn9Hj/enPH/drll
+N34f9P5YH8vsbT+j9LfP8/yw/R8uj5fzz/p+P5PmPm7/0/+L9HQvzfN8+XLB8n0/+/T9WCLFC32
f7dR90T3h62d5Cvk9hH3ggj9VnywPgIlkIQIkGMUhJIAP2XTAbI/AgjbP8FBKCA4v3SIbBMHsYK/
FzPWz8fOH5EIt2v8bJ+N/5nrZVNL+A0vYazu5qjIx1EvXVOiQIOfwSrkSOQjlWbqq0LYhc/bMT8v
khKnOzU+xyWA0VMj88zkM4iF+wN0oeA5kIEoBlAv55WLf7IzAPSiYJQOHtY3XDrMM2/b2ubWRYFA
YG06qhE1NrNscWBSaaDQkNIKB+4be1aWUa/nxpSwlgpSMntTe0hb0MsZps4tBmHEwQw30c92NrdA
2GbDEUWTRhA5jCMKyxsZeTllL8xuMgqDQylvRRCLvJQLMBE8ONjbAeSNh/MqUxJ9QGLMsetZNjtN
wAsoYD8tdAfme2HOHCgA7t8qxZZvrBWvfBbDEl5nJxyS85ZwWMVjFYxWMVjFZlO2bVmRLMCxGEgc
FarCTas6eiTC/rRtjVBilGnZyxhgxWAmE+r3ccPz4P3NnPqjdHITgpNIhsNNs7HiuEV7mWVVVVVV
VKqqqqqqqyPzuAbDrjvvc5TJbtkTSaY7mWsQbNG14IeBJI0azE56XMtbTDF2B0cCN62qpAgxIdJH
QuoUOFeqgHeH8jSC4mmBu7UrnPCPkChBsJyAtJJIqC8RpzpnUvTYWlpab/Jp+73fmE6eUf5KeBJB
tdY8qKdoX0upFH64wU62aTSBSAOtAPkMHVqL5+SHLVqHHw9NKWVO2Ln93xJmxN5u8G+45yQzsibG
hq0LirCsHrMsqhZr0afk7QA6gdxjqe+cwA1Sd5VUiYFwOFN+zBqPJKhc+8gjre0QA6TMQLBS7aZ+
MfxZeSauKnpRw3RYDYNBMhKji78MXs+lHXO7EsxIxERh0MhZgKClpIfuUEiKNjtrzT8bxxOAUjhh
XIqJiF/sMyIwEK2SdHPi5utXM3EGnfx924GzVAjR2fn0bbd9s9e1DAyA0XtL096A4weiJr5zBRy0
0uhFgJA9XaH10GEkJdJAxlb/R0YaiSeCC5vlP4MPk8H9OwAyYgxXusUCCBBTE8zQBPVpENE1DOex
6M9b9DbsHMskeSyI/zfubtpy7icBwhKcgwiDxXP0C/zjDndOTjXVADlBj4DbBwW88lYDEhH3tS/E
d+kJQSaFu4olCfgXWKCVKQxzFLwhXYroWm3ppnocqUhYPTN7C3EjohESkzkS8sqB2Ie3kz93z/ku
swX8axR9ncAA64HNfnSGBRRsOvqv2pw+NPi0m0zUYIY+FTIotILUE0wmkqSxUpLJiVMEr7eaDaVK
8YVAr0NQssVhbyF4H/iAwgf1awMnGG6oWpaR9FkjNys5WM4NaxZaZQ0pM2FskOh0zGsGlFYarVIo
lEcyoKlFXu/vVC6iSThgoAPaSXJP+i5/nYPhtTIY5QYosRiqbSQH/8XckU4UJCk7UpjA

------HSe8TZFN-nd6F6idSysFpD1gM:1101928512--
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse-1.1079 crashsuite
Date: Wed, 01 Dec 2004 19:44:52 +0000
Message-ID: <Pine.LNX.4.58.0412011138030.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Alexey Dobriyan wrote:
> 
> And the test that became the slow one is:

Ok, I think this one falls under the heading of "don't do that then" ;)

Both from a source code perspective _and_ a sparse perspective. 

I'll ignore it for now. If somebody actually ever ends up caring, cutting 
down the time is going to be an issue of just saying "ok, don't bother 
doing CSE/flow/whatever when you have 40-thousand pseudos.."

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse-1.1079 crashsuite
Date: Wed, 01 Dec 2004 20:56:51 +0000
Message-ID: <Pine.LNX.4.58.0412011254590.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Alexey Dobriyan wrote:
> 
> Attached is sparse-1.1079 crashsuite (without infinite loop now). Agree, many
> segfaults are due to K&R declarations, but not all.

Yes, there were a few different bugs. Some were just the normal missing 
types, and a chunk of them were due to sparse not supporting nesting of 
function declarations.

I made sparse "support" it, in the sense that parsing should work. Havign 
the nested function actually access variables from outside it is just 
evil, though, and is not supported.

I pass all the tests now, afaik:

	find . -name '*.c' | while read i; do echo $i: ; sparse $i >& /dev/null || echo failed; done

seems to be happy.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse-1.1079 crashsuite
Date: Wed, 01 Dec 2004 21:04:37 +0000
Message-ID: <Pine.LNX.4.58.0412011257170.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Christopher Li wrote:
>
> It seems it is recursive looping on  find_dominating_parents().

It's just slow. The domination finder is O(mn) or something, and it's 
called for each instruction. 

It basically turns the sixteen thousand loads in the source code into the
minimal 128 loads that are actually relevant. So you have the sixteen 
thousand loads each doing the domination thing using a O(mn) algorithm. It 
takes a while.

Me, I think it's ok. One of the IOCCC entries for this year made just the
sparse _pre-processor_ take about 20 seconds (the good news is that the
entry actually came with a warning that it apparently _crashes_ some
preprocessors, so sparse was doing quite well). That's about as valid a
test of things as anything else ;)

I'm a huge believer in optimizing for the common case rather than for 
worst-case. If we ever see worst-case, we can just fix the horrid thing.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Chris Lattner <sabre () nondot ! org>
To: linux-sparse
Subject: Re: sparse-1.1079 crashsuite
Date: Wed, 01 Dec 2004 21:25:00 +0000
Message-ID: <Pine.LNX.4.44.0412011522390.3670-100000 () nondot ! org>
--------------------
On Wed, 1 Dec 2004, Linus Torvalds wrote:
> I'm a huge believer in optimizing for the common case rather than for
> worst-case. If we ever see worst-case, we can just fix the horrid thing.

This attitude is probably fine if your primary aim is the Linux kernel.
However, real compilers need to deal with the possibility of machine
generated code.  Machine generated code can have all kinds of strange
behaviors.  Try something generated by a scheme-to-C compiler or even a
large bison output.  Again, these probably aren't relevant to the kernel,
but dismissing them out of hand is not very realistic, depending on what
your goals are.

-Chris

-- 
http://nondot.org/sabre/
http://llvm.cs.uiuc.edu/

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse-1.1079 crashsuite
Date: Thu, 02 Dec 2004 00:07:24 +0000
Message-ID: <Pine.LNX.4.58.0412011550300.22796 () ppc970 ! osdl ! org>
--------------------


On Wed, 1 Dec 2004, Chris Lattner wrote:
> 
> This attitude is probably fine if your primary aim is the Linux kernel.
> However, real compilers need to deal with the possibility of machine
> generated code.

Fair enough. I don't think this one was even that, but I'll make sure to 
try to fix the worst things.

It turns out that I was wrong on why the dang thing was slow: it wasn't
doing the dominance analysis, it was doing simple pseudo liveness
analysis. And the reason it was taking a long time was because for each 
basic block it does:

        FOR_EACH_PTR(bb->needs, needs) {
                if (!pseudo_in_list(bb->defines, needs)) {
                        struct basic_block *parent;
                        FOR_EACH_PTR(bb->parents, parent) {
                                if (!pseudo_in_list(parent->defines, needs)) {
                                        add_pseudo_exclusive(&parent->needs, needs);
                                }
                        } END_FOR_EACH_PTR(parent);
                }
        } END_FOR_EACH_PTR(needs);

ie for each pseudo that a basic block needs, it tells each of its parents 
that "hey, I will need this one". 

Fair enough, that's actually all pretty cheap. 

But obviously now the _parent_ needs this, so this is all in a loop that 
says: continue doing this until liveness doesn't change. Again: fair 
enough, it's normally pretty cheap.

What made it really expensive in this case was that we do the above IN THE 
ORDER WE ENCOUNTERED THE BASIC BLOCKS! Which means that we usually looked 
at the parent _first_ (which had nothing to do), then we looked at the 
child (which moved one pseudo up to the parent), then we looked at _its_ 
child (which moved one pseudo up to its parent) etc. And then we started 
all over, because now each basic block had _one_ new pseudo. And we did it 
all over again. For something with 40,000 pseudos and 10,000 basic blocks, 
that took a while.

In other words, think _really_ inefficient bubble-sort, the kind that 
doesn't even follow the bubbles all the way to their final resting place, 
but just moves one bubble one step at a time.

Fixing it so that the loop that iterates over basic blocks iterates in the
_other_ direction (starting at the bottom, ie the exit point, so that we
tend to start at the children and work our way towards the parents) made
the thing go from 90 seconds to 1.3 seconds.

Problem solved. You can still get the worst-case behaviour, but I think 
you need to really work at it (ie have something that has tons of goto 
backwards, and has the final return at the top). At that point I don't 
think even machine-generated code matters any more ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: Segmentation fault ===

From: Sam Ravnborg <sam () ravnborg ! org>
To: linux-sparse
Subject: sparse: Segmentation fault
Date: Wed, 08 Dec 2004 22:00:25 +0000
Message-ID: <20041208220025.GA8635 () mars ! ravnborg ! org>
--------------------
Hi Linus.

The following example program result in a segmentation fault with sparse:

int foo(int i)
{
	return j;
}

sparse was newly pulled from bkbits (latest cset is 1.1130)

gdb says:
(gdb) run x.c
Starting program: /home/sam/bk/sparse/check x.c
warning: Unable to find dynamic linker breakpoint function.
GDB will be unable to debug shared library initializers
and track explicitly loaded dynamic code.
x.c:3:9: warning: undefined identifier 'j'

Program received signal SIGSEGV, Segmentation fault.
linearize_one_symbol (ep=0x4001700c, sym=0x0) at linearize.c:1500
1500            if (!sym->initializer || sym->initialized)
(gdb) bt
#0  linearize_one_symbol (ep=0x4001700c, sym=0x0) at linearize.c:1500
#1  0x08054aae in linearize_expression (ep=0x4001700c, expr=0x4015b00c)
    at linearize.c:1431
#2  0x0805502a in linearize_statement (ep=0x4001700c, stmt=0x40163034)
    at linearize.c:1650
#3  0x08054ce4 in linearize_compound_statement (ep=0x4001700c, stmt=0x4014b00c)
    at linearize.c:1528
    #4  0x080552ac in linearize_statement (ep=0x4001700c, stmt=0x4014b00c)
    at linearize.c:1729
#5  0x08055789 in linearize_fn (sym=0x1, base_type=0x401367d4) at linearize.c:1894
#6  0x08055905 in linearize_symbol (sym=0x0) at linearize.c:1963
#7  0x08048d80 in check_symbols (list=0x80bf8a8) at check.c:111
#8  0x08048dc8 in main (argc=2, argv=0xbffff3e4) at check.c:120
(gdb)

	Sam
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: Segmentation fault
Date: Wed, 08 Dec 2004 22:10:52 +0000
Message-ID: <Pine.LNX.4.58.0412081410350.31040 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Dec 2004, Sam Ravnborg wrote:
> 
> The following example program result in a segmentation fault with sparse:

Thanks. Fixed and pushed out,

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: sparse: sizeof option ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: sparse: sizeof option
Date: Thu, 07 Oct 2004 05:13:59 +0000
Message-ID: <20041006221359.2576ef76.rddunlap () osdl ! org>
--------------------

I'm trying to add an option so that sparse will dump struct/union/array
sizeof data when requested.  I see this as being helpful in finding
stack hogs.

Often I'm seeing sym->bit_size with a value of 0 or ~0ULL.
I guess that I'm just looking at it too early.

Here's some sample output:

lib.h:32:8: struct 'symbol':  byte size: 0, alignment: 0
lib.h:33:8: struct 'symbol_list':  byte size: 0, alignment: 0
lib.h:34:8: struct 'statement':  byte size: 0, alignment: 0
lib.h:35:8: struct 'statement_list':  byte size: 0, alignment: 0
lib.h:20:8: struct 'position':  byte size: 8, alignment: 4
symbol.h:64:8: struct 'symbol_op':  byte size: 8, alignment: 4
lib.h:30:8: struct 'ident':  byte size: 10, alignment: 4
lib.h:72:1: struct 'string':  byte size: 4, alignment: 4
token.h:138:8: struct 'argcount':  byte size: 4, alignment: 4
lib.h:31:8: struct 'token':  byte size: 16, alignment: 4
lib.h:31:8: struct 'token':  byte size: 16, alignment: 4
symbol.h:57:8: struct 'ctype':  byte size: 24, alignment: 4
lib.h:32:8: struct 'symbol':  byte size: 116, alignment: 4
lib.h:36:8: struct 'expression':  byte size: 40, alignment: 8
lib.h:34:8: struct 'statement':  byte size: 44, alignment: 4


Linus, would you prefer that I do this as a separate sparse lib
user instead of adding it to sparse?

--
~Randy

Current work-in-progress patch (with much debug code) is at:
http://developer.osdl.org/rddunlap/sparse/check_sizeof_v2.patch
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: sparse: sizeof option
Date: Thu, 07 Oct 2004 15:03:01 +0000
Message-ID: <Pine.LNX.4.58.0410070728570.8290 () ppc970 ! osdl ! org>
--------------------


On Wed, 6 Oct 2004, Randy.Dunlap wrote:
> 
> I'm trying to add an option so that sparse will dump struct/union/array
> sizeof data when requested.  I see this as being helpful in finding
> stack hogs.
> 
> Often I'm seeing sym->bit_size with a value of 0 or ~0ULL.
> I guess that I'm just looking at it too early.

Likely. You need to have done the "examine_symbol_type()" on the thing
first.

> Linus, would you prefer that I do this as a separate sparse lib
> user instead of adding it to sparse?

Yes, it's pretty easy to do. Here's a patch to make "check" do it, but I 
doubt it makes sense inside check. Might as well be another program, but 
who knows..

NOTE! This _literally_ just prints the sizes that actually _mattered_ at
some point in the program. So doing a

	./check --m64 -D__STDC__ -D__linux__ -D__unix__ -D__BIG_ENDIAN__ -list-symbols check.c

will not show things like the libc FILE structs, because we never looked
at them: even though we used "printf" and friends, we didn't ever actually
have anything that looked any closer. You can see the effect of this by
changing a "printf(..)" to "fprintf(stdout, ..)", and now the output of
the above will change: it will show _IO_FILE and _IO_marker (on my
particular library) that weren't listed before.

I _think_ that's the right thing to do.

		Linus

-----
===== check.c 1.35 vs edited =====
--- 1.35/check.c	2004-09-13 12:19:00 -07:00
+++ edited/check.c	2004-10-07 08:02:27 -07:00
@@ -22,6 +22,7 @@
 #include "symbol.h"
 #include "expression.h"
 #include "linearize.h"
+#include "scope.h"
 
 static void clean_up_symbol(struct symbol *sym, void *_parent, int flags)
 {
@@ -31,6 +32,27 @@
 	linearize_symbol(sym);
 }
 
+static void list_all_symbols(struct symbol_list *list)
+{
+	struct symbol *sym;
+
+	FOR_EACH_PTR(list, sym) {
+		/* Only show structures, unions, enums and typedefs */
+		if (!(sym->namespace & (NS_STRUCT | NS_TYPEDEF)))
+			continue;
+		/* Only show types we actually examined (ie used) */
+		if (!sym->bit_size)
+			continue;
+		/* Don't show unnamed types */
+		if (!sym->ident)
+			continue;
+		printf("%s: size %u, alignment %lu\n",
+			show_typename(sym),
+			sym->bit_size >> 3,
+			sym->ctype.alignment);
+	} END_FOR_EACH_PTR(sym);
+}
+
 static void do_predefined(char *filename)
 {
 	add_pre_buffer("#define __BASE_FILE__ \"%s\"\n", filename);
@@ -43,6 +65,7 @@
 	int fd;
 	char *filename = NULL, **args;
 	struct token *token;
+	int list_symbols = 0;
 
 	// Initialize symbol stream first, so that we can add defines etc
 	init_symbols();
@@ -62,6 +85,10 @@
 		if (!arg)
 			break;
 		if (arg[0] == '-') {
+			if (!strcmp(arg, "-list-symbols")) {
+				list_symbols = 1;
+				continue;
+			}
 			args = handle_switch(arg+1, args);
 			continue;
 		}
@@ -120,5 +147,9 @@
 
 	// Do type evaluation and simplify
 	symbol_iterate(used_list, clean_up_symbol, NULL);
+
+	// List all symbols..
+	if (list_symbols)
+		list_all_symbols(block_scope->symbols);
 	return 0;
 }
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: sparse: sizeof option
Date: Thu, 07 Oct 2004 22:45:33 +0000
Message-ID: <20041007154533.16fe8b61.rddunlap () osdl ! org>
--------------------
On Thu, 7 Oct 2004 08:03:01 -0700 (PDT) Linus Torvalds wrote:

| 
| 
| On Wed, 6 Oct 2004, Randy.Dunlap wrote:
| > 
| > I'm trying to add an option so that sparse will dump struct/union/array
| > sizeof data when requested.  I see this as being helpful in finding
| > stack hogs.
| > 
| > Often I'm seeing sym->bit_size with a value of 0 or ~0ULL.
| > I guess that I'm just looking at it too early.
| 
| Likely. You need to have done the "examine_symbol_type()" on the thing
| first.
| 
| > Linus, would you prefer that I do this as a separate sparse lib
| > user instead of adding it to sparse?
| 
| Yes, it's pretty easy to do. Here's a patch to make "check" do it, but I 
| doubt it makes sense inside check. Might as well be another program, but 
| who knows..
| 
| NOTE! This _literally_ just prints the sizes that actually _mattered_ at
| some point in the program. So doing a
| 
| 	./check --m64 -D__STDC__ -D__linux__ -D__unix__ -D__BIG_ENDIAN__ -list-symbols check.c
| 
| will not show things like the libc FILE structs, because we never looked
| at them: even though we used "printf" and friends, we didn't ever actually
| have anything that looked any closer. You can see the effect of this by
| changing a "printf(..)" to "fprintf(stdout, ..)", and now the output of
| the above will change: it will show _IO_FILE and _IO_marker (on my
| particular library) that weren't listed before.
| 
| I _think_ that's the right thing to do.

Thanks, that works well.  I added array support to it, although
they don't fit into type-checking as cleanly as your version does
for struct/union/enums.

-- 
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: string concatenation ===

From: Ajay <abra9823 () mail ! usyd ! edu ! au>
To: python-list
Subject: string concatenation
Date: Mon, 28 Jun 2004 04:24:31 +0000
Message-ID: <1088396671.40df9d7f500c7 () www-mail ! usyd ! edu ! au>
--------------------
hi!

i am going through a for loop and want to add the strings together
i am doing this currently

for name in contextForm.keys():
    context += "Input: " + name + " value: " + contextForm[name].value +
"<BR>"

context is meant to hold all the form values in the paper.
however the code above doesn't work

being new to Python, i dont know whether you can do +=

can you?

cheers
--
Ajay Brar,
CS Honours 2004
Smart Internet Technology Research Group





----------------------------------------------------------------
This message was sent using IMP, the Internet Messaging Program.

-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: selwyn <selwyn () aotearoa ! is ! home ! nz>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 06:35:05 +0000
Message-ID: <MXODc.5193$NA1.476806 () news02 ! tsnz ! net>
--------------------
you can += strings, but you need to create the variable first:

i.e.
for name in contextForm.keys():
     context = ''
     context += "Input: " + name + " value: " + contextForm[name].value 
+ "<BR>"

concatenating a string like this is supposed to be substantially slower 
than using ''.join(sequence), where you can replace the blank string 
with the separator of your choice.

using your example:

for name in contextForm.keys():
     sequence = ["Input: ",name, " value: ", contextForm[name].value, 
"<BR>"]
     context = ' '.join(sequence)

HTH

	




Ajay wrote:
> hi!
> 
> i am going through a for loop and want to add the strings together
> i am doing this currently
> 
> for name in contextForm.keys():
>     context += "Input: " + name + " value: " + contextForm[name].value +
> "<BR>"
> 
> context is meant to hold all the form values in the paper.
> however the code above doesn't work
> 
> being new to Python, i dont know whether you can do +=
> 
> can you?
> 
> cheers
> --
> Ajay Brar,
> CS Honours 2004
> Smart Internet Technology Research Group
> 
> 
> 
> 
> 
> ----------------------------------------------------------------
> This message was sent using IMP, the Internet Messaging Program.
> 
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Peter Otten <__peter__ () web ! de>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 06:43:17 +0000
Message-ID: <cboem5$8lb$07$1 () news ! t-online ! com>
--------------------
selwyn wrote:

> you can += strings, but you need to create the variable first:
> 
> i.e.
> for name in contextForm.keys():
>      context = ''
>      context += "Input: " + name + " value: " + contextForm[name].value
> + "<BR>"

I guess the OP wants to collect data over the loop, i. e

context = ""
for name in contextForm.keys():
    context += "Input: " + name + " value: " + contextForm[name].value
 
> concatenating a string like this is supposed to be substantially slower
> than using ''.join(sequence), where you can replace the blank string
> with the separator of your choice.
> 
> using your example:
> 
> for name in contextForm.keys():
>      sequence = ["Input: ",name, " value: ", contextForm[name].value,
> "<BR>"]
>      context = ' '.join(sequence)

The faster idiom will then become

sequence = []
for name in contextForm.keys():
    sequence += ["Input: ", name, " value: ", contextForm[name].value,
        "<BR>"]
context = "".join(sequence)
 
Peter



-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Reinhold Birkenfeld <reinhold-birkenfeld-nospam () wolke7 ! net>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 08:49:14 +0000
Message-ID: <2ka410F1960igU1 () uni-berlin ! de>
--------------------
Peter Otten wrote:

> The faster idiom will then become
> 
> sequence = []
> for name in contextForm.keys():
>     sequence += ["Input: ", name, " value: ", contextForm[name].value,
>         "<BR>"]
> context = "".join(sequence)

Where I would prefer the variant

str.join("", sequence)

as it is more readable for beginners (and demonstrates the concept of
invoking member methods as well ;)

Reinhold


-- 
Wenn eine Linuxdistribution so wenig brauchbare Software wie Windows
mitbrchte, wre das bedauerlich.  Was bei Windows der Umfang eines
"kompletten Betriebssystems" ist, nennt man bei Linux eine Rescuedisk.
  -- David Kastrup in de.comp.os.unix.linux.misc
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Peter Otten <__peter__ () web ! de>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 09:21:15 +0000
Message-ID: <cbonub$45i$03$1 () news ! t-online ! com>
--------------------
Reinhold Birkenfeld wrote:

> Where I would prefer the variant
> 
> str.join("", sequence)
> 
> as it is more readable for beginners (and demonstrates the concept of
> invoking member methods as well ;)

If it prevents newbies from doing

import string
string.join("", sequence)

so be it. Real men use "".join(seq) :-)

Peter

PS: And women, too.
 

-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Reinhold Birkenfeld <reinhold-birkenfeld-nospam () wolke7 ! net>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 09:48:49 +0000
Message-ID: <2ka7gmF18amsqU1 () uni-berlin ! de>
--------------------
Peter Otten wrote:
> Reinhold Birkenfeld wrote:
> 
>> Where I would prefer the variant
>> 
>> str.join("", sequence)
>> 
>> as it is more readable for beginners (and demonstrates the concept of
>> invoking member methods as well ;)
> 
> If it prevents newbies from doing
> 
> import string
> string.join("", sequence)
> 
> so be it. Real men use "".join(seq) :-)

Maybe I'm not a real man, but the solution I like most (for code that
extensively concatenates strings in this way) is

join = lambda x: "".join(x)

Reinhold

-- 
Wenn eine Linuxdistribution so wenig brauchbare Software wie Windows
mitbrchte, wre das bedauerlich.  Was bei Windows der Umfang eines
"kompletten Betriebssystems" ist, nennt man bei Linux eine Rescuedisk.
  -- David Kastrup in de.comp.os.unix.linux.misc
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Peter Otten <__peter__ () web ! de>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 10:09:33 +0000
Message-ID: <cboqot$9p1$03$1 () news ! t-online ! com>
--------------------
Reinhold Birkenfeld wrote:

> Maybe I'm not a real man, but the solution I like most (for code that

Of course not, because real men never show doubt :-)
(If hard pressed, I'll admit I'm no more "real" than you in that respect)

> extensively concatenates strings in this way) is
> 
> join = lambda x: "".join(x)

Vicious lambda - tricks you into believing that you need it.

>>> join = " ".join
>>> join(["all", "of", "us"])
'all of us'
>>>

Now that's an idiom we both like, I suppose.

Peter

-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Reinhold Birkenfeld <reinhold-birkenfeld-nospam () wolke7 ! net>
To: python-list
Subject: Re: string concatenation
Date: Mon, 28 Jun 2004 10:46:33 +0000
Message-ID: <2kaasvF1989jnU2 () uni-berlin ! de>
--------------------
Peter Otten wrote:
> Reinhold Birkenfeld wrote:
> 
>> Maybe I'm not a real man, but the solution I like most (for code that
> 
> Of course not, because real men never show doubt :-)
> (If hard pressed, I'll admit I'm no more "real" than you in that respect)
> 
>> extensively concatenates strings in this way) is
>> 
>> join = lambda x: "".join(x)
> 
> Vicious lambda - tricks you into believing that you need it.

Yes, you're right. How could I...

>>>> join = " ".join
>>>> join(["all", "of", "us"])
> 'all of us'
>>>>
> 
> Now that's an idiom we both like, I suppose.

Affirmative.

Reinhold

-- 
Wenn eine Linuxdistribution so wenig brauchbare Software wie Windows
mitbrchte, wre das bedauerlich.  Was bei Windows der Umfang eines
"kompletten Betriebssystems" ist, nennt man bei Linux eine Rescuedisk.
  -- David Kastrup in de.comp.os.unix.linux.misc
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Scott David Daniels <Scott.Daniels () Acm ! Org>
To: python-list
Subject: Re: string concatenation
Date: Fri, 02 Jul 2004 14:23:23 +0000
Message-ID: <40e5747d () nntp0 ! pdx ! net>
--------------------
Ajay wrote:
>...
> for name in contextForm.keys():
>     context += "Input: " + name + " value: " + contextForm[name].value +
> "<BR>"
> context is meant to hold all the form values in the paper.
Although the 'collect in a list, join at leisure' plan often is best,
don't forget StringIO.  This situation is tailor-made for StringIO.

     from cStringIO import StringIO

     dest = StringIO()
     for name in contextForm.keys():
         print >>dest, 'Input:', name, 'value:', contextForm[name].value,
         print >>dest, '<BR>'
     whatever = dest.getvalue()

-- 
-Scott David Daniels
Scott.Daniels@Acm.Org
-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================

From: Eric Brunel <eric_brunel () despammed ! com>
To: python-list
Subject: Re: string concatenation
Date: Fri, 02 Jul 2004 15:28:05 +0000
Message-ID: <cc3ufv$jr3$1 () news-reader5 ! wanadoo ! fr>
--------------------
Ajay wrote:
> hi!
> 
> i am going through a for loop and want to add the strings together
> i am doing this currently
> 
> for name in contextForm.keys():
>     context += "Input: " + name + " value: " + contextForm[name].value +
> "<BR>"
> 
> context is meant to hold all the form values in the paper.
> however the code above doesn't work

Waht do you mean by "doesn't work"? Does it crash? Does it give an unexpected 
result? If it crashes, giving us the actual error message will help a lot.

I can see at least two reasons why it may crash:

1 - the most likely: context is not initialized. E.g:

 >>> s += 'foo'
Traceback (most recent call last):
   File "<stdin>", line 1, in ?
NameError: name 's' is not defined

You must initialize context to the empty string before trying to append anything 
to it.

2 - less likely, but worth a mention: you should prefer:

context += "Input: %s value: %s<BR>" % (name, contextForm[name].value)

to what you've written. The reason is simple: %s will translate everything into 
a string; + will not. E.g:

 >>> "bar" + 12
Traceback (most recent call last):
   File "<stdin>", line 1, in ?
TypeError: cannot add type "int" to string

> being new to Python, i dont know whether you can do +=

Yes, you can, except if you have a very old Python version (e.g. 1.5), where += 
will raise a SyntaxError. If this is the case, either install a newer Python 
version or use:

context = context + ...

or one of the solutions other posters already gave.

HTH
-- 
- Eric Brunel <eric (underscore) brunel (at) despammed (dot) com> -
PragmaDev : Real Time Software Development Tools - http://www.pragmadev.com

-- 
http://mail.python.org/mailman/listinfo/python-list
================================================================================


################################################################################

=== Thread: structure namespace ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: structure namespace
Date: Thu, 26 Aug 2004 14:10:41 +0000
Message-ID: <20040826141041.7C8491422D5B () darter ! rentec ! com>
--------------------

The bad news is that we do structure namespaces very wrong.
The good news is that the following patch handles the worst.

See validation/struct-ns1.c below.  With this patch, we will allow a
local structure definition to override a global one (instead of just
adding structure members to the global one -- ugh!)

I am not 100% sure I handle the distinction between variable declarations
and redefinitions correctly, though.  It simply looks for ';' or '{' as
a sign of a redefinition.

As validation/struct-ns2.c shows, however, we do not handle structures
defined in parameter lists correctly.  ("Doctor, my head hurts when I
bang it against the wall.")

Morten



Linus, please do a

	bk pull http://sparse-mw.bkbits.net:8080/for-linus

This will update the following files:

 parse.c                 |   28 ++++++++++++++++++++++------
 symbol.h                |    9 ++++-----
 validation/struct-ns1.c |   17 +++++++++++++++++
 validation/struct-ns2.c |   14 ++++++++++++++
 4 files changed, 57 insertions(+), 11 deletions(-)

through these ChangeSets:

<welinder@troll.com> (04/08/26 1.748)
   Tests for structure namespace issues.

<welinder@troll.com> (04/08/26 1.747)
   First cut at getting local structure ns handling right.

<welinder@troll.com> (04/08/25 1.745)
   Put enums in the same namespace as unions and structs.
   Check tags when naming tagged types.
   
   This catches things like...
   
   enum Foo { FOO };
   struct Foo x;

diff -Nru a/validation/struct-ns1.c b/validation/struct-ns1.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/validation/struct-ns1.c	2004-08-26 10:02:34 -04:00
@@ -0,0 +1,17 @@
+// This actually isn't allowed in C99, but sparse and gcc will take it:
+enum Foo;
+
+void
+f (void)
+{
+  enum Foo *pefoo;         // Pointer to incomplete type
+  struct Foo;              // Forward declaration
+  struct Foo *psfoo;       // Pointer to incomplete type
+  {
+    struct Foo { int foo; }; // Local definition.
+    struct Foo foo;          // variable declaration.
+    foo.foo = 1;
+  }
+}
+
+enum Foo { FOO };
diff -Nru a/validation/struct-ns2.c b/validation/struct-ns2.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/validation/struct-ns2.c	2004-08-26 10:02:34 -04:00
@@ -0,0 +1,14 @@
+void
+g (struct Bar { int i; } *x)
+{
+  struct Bar y;
+  y.i = 1;
+}
+
+void
+h (void)
+{
+  // This is not in scope and should barf loudly.
+  struct Bar y;
+  y.i = 1;
+}
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-26 10:02:34 -04:00
+++ b/parse.c	2004-08-26 10:02:34 -04:00
@@ -106,12 +106,26 @@
 
 	ctype->modifiers = 0;
 	if (token_type(token) == TOKEN_IDENT) {
-		sym = lookup_or_create_symbol(NS_STRUCT, type, token);
+		sym = lookup_symbol(token->ident, NS_STRUCT);
+		if (!sym ||
+		    (sym->scope != block_scope &&
+		     (match_op(token->next,';') || match_op(token->next,'{')))) {
+			// Either a new symbol, or else an out-of-scope
+			// symbol being redefined.
+			sym = alloc_symbol(token->pos, type);
+			sym->ident = token->ident;
+			bind_symbol(sym, token->ident, NS_STRUCT);
+		}
 		if (sym->type != type)
-			error (sym->pos, "invalid tag applied to %s", show_typename (sym));
+			error(token->pos, "invalid tag applied to %s", show_typename (sym));
 		token = token->next;
 		ctype->base_type = sym;
 		if (match_op(token, '{')) {
+			// The following test is actually wrong for empty
+			// structs, but (1) they are not C99, (2) gcc does
+			// the same thing, and (3) it's easier.
+			if (sym->symbol_list)
+				error(token->pos, "redefinition of %s", show_typename (sym));
 			token = parse(token->next, sym);
 			token = expect(token, '}', "at end of struct-union-enum-specifier");
 		}
diff -Nru a/parse.c b/parse.c
--- a/parse.c	2004-08-26 10:02:35 -04:00
+++ b/parse.c	2004-08-26 10:02:35 -04:00
@@ -98,7 +98,7 @@
 	return lookup_or_create_symbol(NS_LABEL, SYM_LABEL, token);
 }
 
-struct token *struct_union_enum_specifier(enum namespace ns, enum type type,
+struct token *struct_union_enum_specifier(enum type type,
 	struct token *token, struct ctype *ctype,
 	struct token *(*parse)(struct token *, struct symbol *))
 {
@@ -106,7 +106,9 @@
 
 	ctype->modifiers = 0;
 	if (token_type(token) == TOKEN_IDENT) {
-		sym = lookup_or_create_symbol(ns, type, token);
+		sym = lookup_or_create_symbol(NS_STRUCT, type, token);
+		if (sym->type != type)
+			error (sym->pos, "invalid tag applied to %s", show_typename (sym));
 		token = token->next;
 		ctype->base_type = sym;
 		if (match_op(token, '{')) {
@@ -136,7 +138,7 @@
 
 struct token *struct_or_union_specifier(enum type type, struct token *token, struct ctype *ctype)
 {
-	return struct_union_enum_specifier(NS_STRUCT, type, token, ctype, parse_struct_declaration);
+	return struct_union_enum_specifier(type, token, ctype, parse_struct_declaration);
 }
 
 static struct token *parse_enum_declaration(struct token *token, struct symbol *parent)
@@ -169,7 +171,7 @@
 
 struct token *enum_specifier(struct token *token, struct ctype *ctype)
 {
-	return struct_union_enum_specifier(NS_ENUM, SYM_ENUM, token, ctype, parse_enum_declaration);
+	return struct_union_enum_specifier(SYM_ENUM, token, ctype, parse_enum_declaration);
 }
 
 struct token *typeof_specifier(struct token *token, struct ctype *ctype)
diff -Nru a/symbol.h b/symbol.h
--- a/symbol.h	2004-08-26 10:02:35 -04:00
+++ b/symbol.h	2004-08-26 10:02:35 -04:00
@@ -27,11 +27,10 @@
 	NS_NONE = 0,
 	NS_PREPROCESSOR = 1,
 	NS_TYPEDEF = 2,
-	NS_STRUCT = 4,
-	NS_ENUM = 8,
-	NS_LABEL = 16,
-	NS_SYMBOL = 32,
-	NS_ITERATOR = 64,
+	NS_STRUCT = 4,  // Also used for unions and enums.
+	NS_LABEL = 8,
+	NS_SYMBOL = 16,
+	NS_ITERATOR = 32,
 };
 
 enum type {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: switch ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: switch
Date: Mon, 15 Nov 2004 17:13:43 +0000
Message-ID: <20041115171343.9C50D1422D58 () darter ! rentec ! com>
--------------------

If I understand the linerizer output right then I see two problems below:

1. The switch is missing the default case.

2. bb fea3002c is dead -- the "froms" and it's not the entry -- and should
   go away.

Morten




-----------------------------------------------------------------------------
int main (int argc, char **argv)
{
  switch (argc) {
  case 1:
  case 2:
    return 0;
  }
  return 1;
}
-----------------------------------------------------------------------------

> ./test-linearize ~/foo.c 
ep feb9000c: main
   sym: feb53760 argc
   sym: feb53850 argv

ENTRY:
bb: fea3000c
   /home/welinder/foo.c:1:5
  **to fea3004c (/home/welinder/foo.c:4:3)**
  **to fea3006c (/home/welinder/foo.c:5:3)**
        nop (%arg1 -> 0.0.32[argc:feb53760])
        nop (%arg2 -> 0.0.32[argv:feb53850])
        nop (%r1 <- 0.0.32[argc:feb53760])
        switch %arg1, 1 -> .Lfea3004c, 2 -> .Lfea3006c

bb: fea3004c
   /home/welinder/foo.c:4:3
  **from fea3000c (/home/welinder/foo.c:1:5)**
  **to fea3006c (/home/welinder/foo.c:5:3)**
        br      .Lfea3006c

bb: fea3006c
   /home/welinder/foo.c:5:3
  **from fea3000c (/home/welinder/foo.c:1:5)**
  **from fea3004c (/home/welinder/foo.c:4:3)**
  **to fea3008c (/home/welinder/foo.c:1:5)**
  **phi source $0**
        br      .Lfea3008c

bb: fea3002c
   /home/welinder/foo.c:3:3
  **to fea3008c (/home/welinder/foo.c:1:5)**
  **phi source VOID**
        br      .Lfea3008c

bb: fea3008c
   /home/welinder/foo.c:1:5
  **from fea3006c (/home/welinder/foo.c:5:3)**
  **from fea3002c (/home/welinder/foo.c:3:3)**
        %r2 <- phi ($0, .Lfea3006c), (VOID, .L0)
        ret %r2

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: switch
Date: Mon, 15 Nov 2004 18:19:55 +0000
Message-ID: <Pine.LNX.4.58.0411150953330.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Morten Welinder wrote:
> 
> If I understand the linerizer output right then I see two problems below:
> 
> 1. The switch is missing the default case.

Actually, it's there as the fallthrough from the bb that contains the 
switch. If you have an _explicit_ default, it's there in the list.

But I agree, that's bad. We should have all the targets on the list, and 
not have any difference between an explicit default and the fallthrough
case. I'll clean it up.

> 2. bb fea3002c is dead -- the "froms" and it's not the entry -- and should
>    go away.

It actually _is_ dead, it's just that we don't remove bb's from the 
bb list. We just remove all phi-nodes that originated in them.

We could make "bb->insns" be NULL in kill_unreachable_bbs(), I guess.

Checked in.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: switch
Date: Mon, 15 Nov 2004 18:40:49 +0000
Message-ID: <20041115184049.EC3921422D58 () darter ! rentec ! com>
--------------------

Ok, that fixed it is now evident that branches from switches aren't branch-
followed.  The patch below ought to fix that, but it doesn't seem to fix
the "**from" information and I don't see why.

Morten


-----------------------------------------------------------------------------

int main (int argc, char **argv)
{
  switch (argc) {
  case 1:
  case 2:
    return 0;
  }
  return 1;
}

-----------------------------------------------------------------------------

ep feb9000c: main
   sym: feb53760 argc
   sym: feb53850 argv

ENTRY:
bb: fea3000c
   /home/welinder/foo.c:1:5
  **to fea3006c (/home/welinder/foo.c:5:3)**       <--- This got updated
  **to fea3006c (/home/welinder/foo.c:5:3)**
  **to fea3002c (/home/welinder/foo.c:3:3)**
	nop (%arg1 -> 0.0.32[argc:feb53760])
	nop (%arg2 -> 0.0.32[argv:feb53850])
	nop (%r1 <- 0.0.32[argc:feb53760])
	switch %arg1, 1 -> .Lfea3006c, 2 -> .Lfea3006c, default -> .Lfea3002c


bb: fea3004c
   /home/welinder/foo.c:4:3
  **from fea3000c (/home/welinder/foo.c:1:5)**     <--- This did not
  **to fea3006c (/home/welinder/foo.c:5:3)**
	br	.Lfea3006c

bb: fea3006c
   /home/welinder/foo.c:5:3
  **from fea3000c (/home/welinder/foo.c:1:5)**
  **from fea3000c (/home/welinder/foo.c:1:5)**
  **to fea3008c (/home/welinder/foo.c:1:5)**
  **phi source $0**
	br	.Lfea3008c

bb: fea3002c
   /home/welinder/foo.c:3:3
  **from fea3000c (/home/welinder/foo.c:1:5)**
  **to fea3008c (/home/welinder/foo.c:1:5)**
  **phi source $1**
	br	.Lfea3008c

bb: fea3008c
   /home/welinder/foo.c:1:5
  **from fea3006c (/home/welinder/foo.c:5:3)**
  **from fea3002c (/home/welinder/foo.c:3:3)**
	%r2 <- phi ($0, .Lfea3006c), ($1, .Lfea3002c)
	ret %r2

-----------------------------------------------------------------------------

===== linearize.c 1.133 vs edited =====
--- 1.133/linearize.c	2004-11-15 13:17:07 -05:00
+++ edited/linearize.c	2004-11-15 13:33:08 -05:00
@@ -2100,13 +2100,26 @@
 static int rewrite_parent_branch(struct basic_block *bb, struct basic_block *old, struct basic_block *new)
 {
 	struct instruction *insn = last_instruction(bb->insns);
+	if (!insn)
+		return 0;
 
-	if (insn && insn->opcode == OP_BR) {
+	switch (insn->opcode) {
+	case OP_BR:
 		rewrite_branch(bb, &insn->bb_true, old, new);
 		rewrite_branch(bb, &insn->bb_false, old, new);
 		return 1;
+
+	case OP_SWITCH: {
+		struct multijmp *jmp;
+		FOR_EACH_PTR(insn->multijmp_list, jmp) {
+			rewrite_branch (bb, &jmp->target, old, new);
+		} END_FOR_EACH_PTR(jmp);
+		return 1;
+	}
+
+	default:
+		return 0;
 	}
-	return 0;
 }
 
 static int rewrite_branch_bb(struct basic_block *bb, struct instruction *br)
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: switch
Date: Mon, 15 Nov 2004 18:52:34 +0000
Message-ID: <Pine.LNX.4.58.0411151051310.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Morten Welinder wrote:
> 
> Ok, that fixed it is now evident that branches from switches aren't branch-
> followed. 

I _just_ did that and pushed it out. Almost identically to yours too.

> The patch below ought to fix that, but it doesn't seem to fix
> the "**from" information and I don't see why.

I fixed that too, see my subsequent checkin ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: switch
Date: Mon, 15 Nov 2004 19:58:33 +0000
Message-ID: <Pine.LNX.4.58.0411151152530.2222 () ppc970 ! osdl ! org>
--------------------


On Mon, 15 Nov 2004, Linus Torvalds wrote:
> 
> On Mon, 15 Nov 2004, Morten Welinder wrote:
> > 
> > Ok, that fixed it is now evident that branches from switches aren't branch-
> > followed. 
> 
> I _just_ did that and pushed it out. Almost identically to yours too.

Btw, I now also do constant folding on switches. I might want to do it 
earlier (on the tree level) too, just to avoid work later, but doing it 
after the symbol renaming allows me to find more constants than I would 
have otherwise, so maybe this is better.

	static inline int fibo(int nr)
	{
	        switch (nr) {
	        case 0 ... 2:
	                return 1;
	        default:
	                return fibo(nr-1) + fibo(nr-2);
	        }
	}

	int main(int argc)
	{
	        return fibo(2);
	}

now results in (nops and dead bb's removed):

	ENTRY:
	bb: 0xf7fa600c
	   test.c:11:5
	  **to 0xf7fa606c (test.c:4:2)**
	        br      .L0xf7fa606c

	bb: 0xf7fa606c
	   test.c:4:2
	  **from 0xf7fa600c (test.c:11:5)**
	  **to 0xf7fa60ac (test.c:1:19)**
	  **phi source $1**
	        br      .L0xf7fa60ac

	bb: 0xf7fa60ac
	   test.c:1:19
	  **from 0xf7fa606c (test.c:4:2)**
	  **from 0xf7fa608c (test.c:6:2)**
	  **from 0xf7fa604c (test.c:3:2)**
	  **phi source %r1**
	        %r1 <- phi ($1, .L0xf7fa606c), (VOID, .L(nil))
	        ret %r1

which also shows what happens to a phi-node when a source is killed. It 
can now be just replaced with a simple "%r1 <- $1", but to actually do 
that I'd need to have the pointer to the instruction, which I don't have.

(And if you wonder about why there are bb's with just simply branches, one
of them has deleted instructions in it, so I don't remove it yet, and the
other one is a phi-source, so it can't be removed until the phi is
rewritten. Basically neither of these are really fundamental issues, 
it's just details, details).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: test-parsing segfault ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: test-parsing segfault
Date: Fri, 13 Aug 2004 18:19:00 +0000
Message-ID: <20040813111900.447356a6.rddunlap () osdl ! org>
--------------------

(sparse-bk snapshot of 2004-08-13)

I've looked at this for a little while without getting anywhere, so-

Running test-parsing on the following program segfaults:

Program received signal SIGSEGV, Segmentation fault.
0x40097ee0 in strcpy () from /lib/tls/libc.so.6
(gdb) bt
#0  0x40097ee0 in strcpy () from /lib/tls/libc.so.6
#1  0x0804b624 in show_special (val=134607812) at tokenize.c:48
#2  0x080539e5 in show_binop (expr=0x4016718c) at show-parse.c:626
#3  0x080541a2 in show_expression (expr=0x4016718c) at show-parse.c:965
#4  0x08053590 in show_statement (stmt=0x4015716c) at show-parse.c:451
#5  0x0805350d in show_statement (stmt=0x40157114) at show-parse.c:422
#6  0x080536ef in show_statement (stmt=0x401570e8) at show-parse.c:500
#7  0x0805350d in show_statement (stmt=0x40157064) at show-parse.c:422
#8  0x080532b2 in show_symbol (sym=0x4002996c) at show-parse.c:319
#9  0x08052ef3 in show_one_symbol (sym=0x4002996c, sep=0x805a0f9, flags=2)
    at show-parse.c:113
#10 0x08050731 in iterate (head=0x8067480,
    callback=0x8052ee5 <show_one_symbol>, data=0x805a0f9) at lib.c:215
#11 0x08052f27 in show_symbol_list (list=0x8067480, sep=0x805a0f9 "\n\n")
    at lib.h:279
#12 0x08048bc1 in main (argc=2, argv=0xbffff0e4) at test-parsing.c:79


val=134607812 in show_special() is quite odd.
The first few times that I saw this, val was 282, just out of
bounds of the combinations array... which was slightly more
believable.


--
~Randy



testcase (stripped down):

unsigned long long get_rand(void)
{
	unsigned long long x;
	return x;
}

int main (int argc, char **argv)
{
	unsigned long long start, now, limit;

	start = get_rand();
repeat:
	now = get_rand();
	if (now - start > limit)
		goto repeat;
}
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: test-parsing segfault
Date: Fri, 13 Aug 2004 18:28:37 +0000
Message-ID: <20040813112837.3d9d982e.rddunlap () osdl ! org>
--------------------
On Fri, 13 Aug 2004 11:47:56 -0700 (PDT) Linus Torvalds wrote:

| 
| 
| On Fri, 13 Aug 2004, Randy.Dunlap wrote:
| > 
| > I've looked at this for a little while without getting anywhere, so-
| > 
| > Running test-parsing on the following program segfaults:
| 
| Hmm. Not for me with the current BK. 

OK, that's good.  Maybe a tools issue.
I'll try later with updated sparse.

--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: test-parsing segfault
Date: Fri, 13 Aug 2004 18:47:56 +0000
Message-ID: <Pine.LNX.4.58.0408131147230.1839 () ppc970 ! osdl ! org>
--------------------


On Fri, 13 Aug 2004, Randy.Dunlap wrote:
> 
> I've looked at this for a little while without getting anywhere, so-
> 
> Running test-parsing on the following program segfaults:

Hmm. Not for me with the current BK. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: test-parsing segfault
Date: Fri, 13 Aug 2004 18:56:55 +0000
Message-ID: <20040813185655.C50BB1422D58 () darter ! rentec ! com>
--------------------

For the record, Purify shows nothing wrong except the match_idents
issue.  Note, btw., that there are two bogus calls.

Morten


troll:/scratch/welinder/sparse> grep match_idents *.c | grep -v NULL
parse.c:static int match_idents(struct token *token, ...)
parse.c:        if (match_idents(token, &__volatile___ident, &volatile_ident)) {
parse.c:        if (match_idents(token, &asm_ident, &__asm___ident, &__asm_ident)) {
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: trying to use sparse lib. ===

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: trying to use sparse lib.
Date: Mon, 04 Oct 2004 00:30:06 +0000
Message-ID: <20041003173006.162266e2.rddunlap () osdl ! org>
--------------------


For a sparse exercise, I'm trying to detect all uses of C++
(reserved) keywords [those that are C++ additions, beyond C]
and flag them.

I'm using a modification of obfuscate.c.  It's flagging
C++ keywords that are used at file global scope, but not local
variables inside functions.  E.g., these are global in
test_cpp.c:

test_cpp.c:33:6: warning: Used c++ keyword as data identifier: namespace
test_cpp.c:59:5: warning: Used c++ keyword as function identifier: mutable

Any clues about why it's missing local variables, i.e., not diving
inside functions to see their data?



ObAdmission:  language parsing isn't my strong area.

Thanks,
--
~Randy

files at:  http://developer.osdl.org/rddunlap/sparse/
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: trying to use sparse lib.
Date: Mon, 04 Oct 2004 02:01:10 +0000
Message-ID: <Pine.LNX.4.58.0410031858170.8290 () ppc970 ! osdl ! org>
--------------------


On Sun, 3 Oct 2004, Randy.Dunlap wrote:
> 
> Any clues about why it's missing local variables, i.e., not diving
> inside functions to see their data?

Probably because you're using the "in_use" list.

Only symbols that are actually emitted will get on the in_use list. As 
such, local variables will never be on that list.

For what you're doing, you should probably hook into the "bind_symbol()" 
function in symbol.c. That's the one that binds a symbol to an identifier. 
That would be where you check whether the identifier being bound is on 
some particular list.

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: trying to use sparse lib.
Date: Mon, 04 Oct 2004 02:08:48 +0000
Message-ID: <Pine.LNX.4.58.0410031902180.8290 () ppc970 ! osdl ! org>
--------------------


On Sun, 3 Oct 2004, Linus Torvalds wrote:
> 
> For what you're doing, you should probably hook into the "bind_symbol()" 
> function in symbol.c. That's the one that binds a symbol to an identifier. 
> That would be where you check whether the identifier being bound is on 
> some particular list.

Btw, the notion of a "reserved" keyword is not something sparse has at all 
right now, and even regular C keywords are literally just normal 
identifiers as far as sparse is concerned. So in sparse you can say

	int for = 1;

and not get any warning at all. Now, you _would_ get a warning if you do

	int for = 1;

	for++;

because the identifier "for" _does_ have obviously meaning in a statement
context.

Anyway, what this all builds up to is that I think it would be valid to 
change the "struct ident" "tainted" flag from a "char" to a single bit, 
and add a new bit for "reserved", and make "bind_symbol()" complain about 
reserved identifiers.  It would be good even for C.

Then you just add the identifier in "ident-list.h", and add a table of 
reserved identifiers somewhere (possibly by having a IDENT_RESERVED() 
macro that does it as part of creating the ident initializer).

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: "Randy.Dunlap" <rddunlap () osdl ! org>
To: linux-sparse
Subject: Re: trying to use sparse lib.
Date: Mon, 04 Oct 2004 04:05:41 +0000
Message-ID: <20041003210541.6ff2338d.rddunlap () osdl ! org>
--------------------
On Sun, 3 Oct 2004 19:08:48 -0700 (PDT) Linus Torvalds wrote:

| 
| On Sun, 3 Oct 2004, Linus Torvalds wrote:
| > 
| > For what you're doing, you should probably hook into the "bind_symbol()" 
| > function in symbol.c. That's the one that binds a symbol to an identifier. 
| > That would be where you check whether the identifier being bound is on 
| > some particular list.
| 
| Btw, the notion of a "reserved" keyword is not something sparse has at all 
| right now, and even regular C keywords are literally just normal 
| identifiers as far as sparse is concerned. So in sparse you can say
| 
| 	int for = 1;
| 
| and not get any warning at all. Now, you _would_ get a warning if you do
| 
| 	int for = 1;
| 
| 	for++;
| 
| because the identifier "for" _does_ have obviously meaning in a statement
| context.
| 
| Anyway, what this all builds up to is that I think it would be valid to 
| change the "struct ident" "tainted" flag from a "char" to a single bit, 
| and add a new bit for "reserved", and make "bind_symbol()" complain about 
| reserved identifiers.  It would be good even for C.

Well, I agree, but I can already hear some people yelling about their
"new" and "class" variables or structs.

Maybe have a C-reserved list and a C++-reserved list, and only check
the C++ list if asked to do so?

| Then you just add the identifier in "ident-list.h", and add a table of 
| reserved identifiers somewhere (possibly by having a IDENT_RESERVED() 
| macro that does it as part of creating the ident initializer).

I get that part.

--
~Randy
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: trying to use sparse lib.
Date: Mon, 04 Oct 2004 14:39:44 +0000
Message-ID: <Pine.LNX.4.58.0410040730100.8290 () ppc970 ! osdl ! org>
--------------------


On Sun, 3 Oct 2004, Randy.Dunlap wrote:

> On Sun, 3 Oct 2004 19:08:48 -0700 (PDT) Linus Torvalds wrote:
> | 
> | Anyway, what this all builds up to is that I think it would be valid to 
> | change the "struct ident" "tainted" flag from a "char" to a single bit, 
> | and add a new bit for "reserved", and make "bind_symbol()" complain about 
> | reserved identifiers.  It would be good even for C.
> 
> Well, I agree, but I can already hear some people yelling about their
> "new" and "class" variables or structs.

Yeah, I wasn't suggesting you actually add the C++ keywords - it was more 
a suggestion to add the infrastructure (and list the standard C keywords 
there), and then your obfuscate-based thing could add the C++ keywords 
when it wants to check for that.

That way, your C++ checks don't need to add any new core infrastructure, 
they just hook into existing infrastructure for C.

I would be one to complain about C++ keywords. I don't mind some of them 
so much, but I do mind how _broken_ they are.

For example, there is absolutely no reason why "this" should be a keyword.  
It should just be an _implied_ regular variable in any member function,
which it damn well _is_, fer crying out loud. Making it a keyword was a
totally idiotic mistake, and likely simply due to the pre-processor-like
nature of the original C++ compilers. If it had been an implied variable, 
it wouldn't have impacted C source at all.

At least "new" and "delete" have some syntactic reason for being keywords,
although I personally think that the syntax wasn't really _worth_ it. I 
guess compatibility with C wasn't that big of a deal.

				Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: type breakage fixed.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: type breakage fixed..
Date: Mon, 19 Apr 2004 22:50:04 +0000
Message-ID: <Pine.LNX.4.58.0404191543370.29941 () ppc970 ! osdl ! org>
--------------------

Ok, the type breakage that occurred when I was trying to fix some stupid 
behaviour of the "addressof" (&) operator should now hopefully be fixed,
and I've tried to make sure that sparse gets all the types right. In the 
process, I think I got rid of all the type warnings from the kenrel, 
except the ones related to address spaces (that are proper warnings).

Which is not to say that there aren't a lot of cases that sparse _should_ 
warn about still - I suspect it allows way too many things that it really 
shouldn't. I don't have any good test-cases, so pointers to such things 
would be welcome.

I'm hoping I get the type checks all done right, so that I never have to 
visit the damn thing ever again. Unrealistic, I guess.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: type_difference ===

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: type_difference
Date: Tue, 14 Sep 2004 18:26:38 +0000
Message-ID: <20040914182638.8D23B1422D53 () darter ! rentec ! com>
--------------------

Currently type_difference silently ignores these attributes:

#define MOD_IGNORE (MOD_TOPLEVEL | MOD_STORAGE | MOD_ADDRESSABLE |	\
	MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED |		\
	MOD_ASSIGNED | MOD_USERTYPE | MOD_FORCE | MOD_ACCESSED)

I plan to take out MOD_SIGNED | MOD_UNSIGNED | MOD_EXPLICITLY_SIGNED from
this and call it MOD_SIGNEDNESS, then have callers explicitly mention
these.

Then in turn I want to mask out MOD_SIGNEDNESS from target_mod_ignore and
source_mod_ignore in recursive calls within type_difference and possibly
whenever the outer loop is done.  In other words, signedness will only
be ignored at top level.  As a consequence, the following program will
cause an error as it should:

    typedef char (*T) (void);
    static signed char f (void);
    T v = f;

Comments?

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: uninlining bug.. ===

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: uninlining bug..
Date: Wed, 10 Nov 2004 06:12:04 +0000
Message-ID: <Pine.LNX.4.58.0411092200080.2301 () ppc970 ! osdl ! org>
--------------------

I added some sanity checks to the symbol replacement code, and in
particular I made the code also nop out the instruction opode field when
it did the symbol -> pseudo replacement. That seems to all look good, and
in fact the whole thing triggers a trouble report on just _one_ file in my
standard kernel build.

That one seems to be associated with un-inlining a function, and I boiled 
it down to this trivial test-case that shows two independent bugs:

	inline void fn1(int arg1)
	{
	}

	void *a = fn1;

	inline void fn2(int arg2)
	{
		return fn1(arg2);
	}

	void *b = fn2;

The above shows two problems. One is the warning message on the debug code
I added:

	test.c:1:21: warning: symbol 'arg1' pseudo used in unexpected way

which is a bit worrysome, and I _think_ it's because uninlining does some
really funky things wrt symbol replacement for the argument and probably
gets it wrong ("arg1" ends up being replaced with itself when doing the
un-inlined version of fn1, and it seems to cause confusion when it is then
inlined in the un-inlined version of fn2).

Al, you did the uninlining, can you see what might be wrong?

The other problem is that the "return void_expression" seems to not 
linearize the void-expression at all, so "fn2" ends up being completely 
empty. 

I'm finally fed up for today, so I'm leaving this for now, but the 
test-case is fairly small, so maybe somebody else wants to take a quick 
look and see something obvious that I'm missing from having stared too 
much at the code.

Tommy, "numba-tu.com" seemed to have MX record troubles the other day. 
Does this reach you?

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: uninlining bug..
Date: Wed, 10 Nov 2004 20:38:42 +0000
Message-ID: <Pine.LNX.4.58.0411101233010.2301 () ppc970 ! osdl ! org>
--------------------


On Tue, 9 Nov 2004, Linus Torvalds wrote:
> 
> The above shows two problems.

Ok, I found the "return" bug. Pretty fundamental. I think it's fixed now.

> One is the warning message on the debug code I added:
> 
> 	test.c:1:21: warning: symbol 'arg1' pseudo used in unexpected way

.. and making the symbol printout print out not just the name (which stays
the same when inlining), but the actual pointer too (which should be 
unique), made this one pretty obvious. The test-case linearizes to

	ep 0xf7fe200c: fn1
	   sym: 0xf7fd1760 arg1
	        nop (%arg1 -> 0[arg1:0xf7fd1760])

	ENTRY:
	bb: 0xf7fa6024
	   test.c:1:13
	        nop (%arg1 -> 0[arg1:0xf7fd1760])
	        ret

	
	test.c:1:21: warning: symbol 'arg1' pseudo used in unexpected way
	ep 0xf7fe2020: fn2
	   sym: 0xf7fd1aa8 arg2
	        nop (%arg1 -> 0[arg2:0xf7fd1aa8])
	        nop (%r1 <- 0[arg2:0xf7fd1aa8])
	   sym: 0xf7fd1fd0 arg1
	        nop (%arg1 -> 0[arg1:0xf7fd1760])
	        nop (%arg1 -> 0[arg1:0xf7fd1760])
	
	ENTRY:
	bb: 0xf7fa6054
	   test.c:7:13
	        nop (%arg1 -> 0[arg2:0xf7fd1aa8])
	        nop (%r1 <- 0[arg2:0xf7fd1aa8])
	        nop (%arg1 -> 0[arg1:0xf7fd1760])
	        ret

and notice how "arg1" in the non-inlined copy of fn2() is exactly the sam
esymbol as "arg1" in the non-inlined fn1(). That's a bug, and clearly 
shows that the symbol hasn't been properly replaced by the [un-]inliner.

I haven't looked at why the error happens, but I'm pretty certain that the

	...
        FOR_EACH_PTR(arg_list, p) {
                p->replace = p;
        } END_FOR_EACH_PTR(p);
	...

in "uninline()" is just wrong. It changes the arg-list in place. I think 
it should be just a

	arg_list = create_symbol_list(fn->arguments);

instead. 

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: uninlining bug..
Date: Wed, 10 Nov 2004 21:03:04 +0000
Message-ID: <Pine.LNX.4.58.0411101257100.2301 () ppc970 ! osdl ! org>
--------------------


On Wed, 10 Nov 2004, Linus Torvalds wrote:
> 
> It changes the arg-list in place. I think it should be just a
> 
> 	arg_list = create_symbol_list(fn->arguments);
> 
> instead. 

Nope. And interestingly, "show-parse" seems to _not_ show this bug. Might 
be somehow ordering-dependent.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: uninlining bug..
Date: Wed, 10 Nov 2004 21:15:57 +0000
Message-ID: <Pine.LNX.4.58.0411101306410.2301 () ppc970 ! osdl ! org>
--------------------


On Wed, 10 Nov 2004, Linus Torvalds wrote:
> 
> Nope. And interestingly, "show-parse" seems to _not_ show this bug. Might 
> be somehow ordering-dependent.

Ahh. Yes indeedy.

If we evaluate everything _first_, and then linearize it only after
everything has been evaluated, things work. But if we linearize it before
the thing that then later causes it to be un-inlined has been evaluated,
things break.

That's a bit too subtle for my taste. On the other hand, it might be the 
right thing to do regardless, making sure that the different passes aren't 
intermixed. It's sure to be better for I$ behaviour to evaluate everything 
first, then expand everything, and then finally linearize everything.

What happens when we intermix is that we may evaluate one function, which 
in turn ends up evaluating everything that it needs, then it expands that 
function and linearizes it, then it goes to the next function and tries to 
evaluate that one (but if it was needed for the first one, it might have 
been evaluated fully already, so the order really ends up being dependent 
on tons of strange things).

And all the while, the list of things to evaluate, expand and linearize 
may actually grow, since evaluation may end up causing other things to be 
put on the list of used symbols.

Fun, fun, fun. 

At least for now I'll commit the fix, which is to make sure that we 
evaluate everything _first_.  At that point all the inlining will have 
been done, _and_ the list of used symbols will no longer be growing. Maybe 
this rule is too subtle, but it does solve a number of issues.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: unused macros and include files ===

From: Herbert Poetzl <herbert () 13thfloor ! at>
To: linux-sparse
Subject: unused macros and include files
Date: Tue, 16 Nov 2004 07:17:18 +0000
Message-ID: <20041116071718.GC18749 () mail ! 13thfloor ! at>
--------------------

Greetings!

is there support for checking for unused macros
and include files in sparse? is that something 
which can be done easier with some other freely
available tool for the linux kernel?

just wanted to know before I start hacking on 
the sparse code ...

TIA,
Herbert

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 07:24:06 +0000
Message-ID: <20041116072406.GA16642 () 64m ! dyndns ! org>
--------------------
I don't think it is in sparse right now. But it should be
trivial to write.

For unused macro, you just need to do the pre-processing.
Then loop for list of filescope->symbols. All the macro
symbols define should have name space set to NS_MACRO.
If it has been lookup,  symbol->used is set.

Include file is similar. You are searching for the header
file which all the symbols in it haven't been used.
Maybe except the "#ifndef HEAD_FILE_H" of the reference.

I am not sure about other tools.

Chris

On Tue, Nov 16, 2004 at 08:17:18AM +0100, Herbert Poetzl wrote:
> 
> Greetings!
> 
> is there support for checking for unused macros
> and include files in sparse? is that something 
> which can be done easier with some other freely
> available tool for the linux kernel?
> 
> just wanted to know before I start hacking on 
> the sparse code ...
> 
> TIA,
> Herbert
> 
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 14:41:44 +0000
Message-ID: <20041116144144.0AC981422D56 () darter ! rentec ! com>
--------------------

> is there support for checking for unused macros
> and include files in sparse?

Assuming you could do this (and for macros I doubt it is trivial because
you will have to deal with thinks like (0 ? macro : 1) and determine if
the macro is "used" here) what good would it do?

foo.c: warning: macro S_IFLNK was never used.
foo.c: warning: macro S_IFSOCK was never used.
foo.c: warning: macro _R3_MKNOD_VER was never used.
...
foo.c: error: file system holding error file is full.

The unused-header file check might be useful for a closed-world
program like the kernel, but for programs that need to work with
multiple slighly-different systems it would cause much more trouble.
Someone on system A will remove <header.h> thereby breaking
compilation on system B.

I'm sorry to sound so negative, I just think that doing this is
going to cause a lot of pain.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Herbert Poetzl <herbert () 13thfloor ! at>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 15:10:15 +0000
Message-ID: <20041116151015.GA16691 () mail ! 13thfloor ! at>
--------------------
On Tue, Nov 16, 2004 at 02:24:06AM -0500, Christopher Li wrote:
> I don't think it is in sparse right now. But it should be
> trivial to write.
> 
> For unused macro, you just need to do the pre-processing.
> Then loop for list of filescope->symbols. All the macro
> symbols define should have name space set to NS_MACRO.
> If it has been lookup,  symbol->used is set.
> 
> Include file is similar. You are searching for the header
> file which all the symbols in it haven't been used.
> Maybe except the "#ifndef HEAD_FILE_H" of the reference.

I started with the 'header' approach, and coded up this
little test (according to your suggestions, as far as I
understood them)

-----------------------------------
#include <stdarg.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
#include <fcntl.h>

#include "lib.h"
#include "token.h"
#include "symbol.h"
#include "scope.h"

int main(int argc, char **argv)
{
        int fd, i;
        char *filename = NULL, **args;
        struct token *token;
        struct symbol *sym;
        int *used;

        // Initialize symbol stream first, so that we can add defines etc
        init_symbols();

        create_builtin_stream();

        args = argv;
        for (;;) {
                char *arg = *++args;
                if (!arg)
                        break;
                if (arg[0] == '-') {
                        args = handle_switch(arg + 1, args);
                        continue;
                }
                filename = arg;
        }

        // Initialize type system
        init_ctype();

        fd = open(filename, O_RDONLY);
        if (fd < 0)
                die("No such file: %s", filename);

        // Tokenize the input stream
        token = tokenize(filename, fd, NULL, includepath);
        close(fd);

        // Prepend the initial built-in stream
        token = tokenize_buffer(pre_buffer, pre_buffer_size, token);

        // Pre-process the stream
        token = preprocess(token);

        used = calloc(input_stream_nr, sizeof(int));
        if (!used)
                die("unable to allocate used");
        

        FOR_EACH_PTR(file_scope->symbols, sym) {
                if (sym->used)
                        used[sym->pos.stream]++;
        } END_FOR_EACH_PTR(sym);

        for (i=0; i<input_stream_nr; i++) {
                printf("[%d,%5d] = %s\n", i, used[i], 
                        input_streams[i].name);
        }
	return 0;
}

------------------------------------

but for example applied to the program itsel, results
in false positives like:

[57,    0] = scope.h

probably I'm doing something wrong ...

TIA,
Herbert

> I am not sure about other tools.
> 
> Chris
> 
> On Tue, Nov 16, 2004 at 08:17:18AM +0100, Herbert Poetzl wrote:
> > 
> > Greetings!
> > 
> > is there support for checking for unused macros
> > and include files in sparse? is that something 
> > which can be done easier with some other freely
> > available tool for the linux kernel?
> > 
> > just wanted to know before I start hacking on 
> > the sparse code ...
> > 
> > TIA,
> > Herbert
> > 
> > -
> > To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> > the body of a message to majordomo@vger.kernel.org
> > More majordomo info at  http://vger.kernel.org/majordomo-info.html
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Herbert Poetzl <herbert () 13thfloor ! at>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 15:18:21 +0000
Message-ID: <20041116151821.GB16691 () mail ! 13thfloor ! at>
--------------------
On Tue, Nov 16, 2004 at 09:41:44AM -0500, Morten Welinder wrote:
> 
> > is there support for checking for unused macros
> > and include files in sparse?
> 
> Assuming you could do this (and for macros I doubt it is trivial because
> you will have to deal with thinks like (0 ? macro : 1) and determine if
> the macro is "used" here) what good would it do?

IMHO it would allow to identify definitions macros
and maybe inlines, which either got orphaned or where
added with the intent to use them later ... but then
where forgotten ...

the macro is 'used' when it is referenced, regardless
if by constructs like (0 ? macro : 1) or any other ...
it is not used/unused, when you safely can remove it ;)

> foo.c: warning: macro S_IFLNK was never used.
> foo.c: warning: macro S_IFSOCK was never used.
> foo.c: warning: macro _R3_MKNOD_VER was never used.
> ...
> foo.c: error: file system holding error file is full.

hmm .. please elaborate!

> The unused-header file check might be useful for a closed-world
> program like the kernel, but for programs that need to work with
> multiple slighly-different systems it would cause much more trouble.
> Someone on system A will remove <header.h> thereby breaking
> compilation on system B.

well, many C files (probably also in the linux-kernel)
tend to include the kitchen sink, unnecessarily increasing 
the dependancies for compiles and recompiles, and nobody
wants to remove them, because it might break some obscure
option ...
 
> I'm sorry to sound so negative, I just think that doing this is
> going to cause a lot of pain.

no problem with that ...

best,
Herbert

> Morten
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 15:32:40 +0000
Message-ID: <20041116153240.316E81422D56 () darter ! rentec ! com>
--------------------

   > foo.c: warning: macro S_IFLNK was never used.
   > foo.c: warning: macro S_IFSOCK was never used.
   > foo.c: warning: macro _R3_MKNOD_VER was never used.
   > ...
   > foo.c: error: file system holding error file is full.

   hmm .. please elaborate!

Library header files typically contain *lots* of constant definitions that
are not necessarily all used in any given .c file.  The above came from my
<sys/stat.h> which you might very well include for one or two symbols.

In other words: you are going to get so many warnings for perfectly fine
code that the warning isn't useful.

Object oriented code will have the same problem.  The header file contains
information about all the things you can do with the object, but any given
user cannot be expected to do all of those things.

Add to this, that one man's function is another man's macro.  You might have
fstat as a function, but I have it as a macro.  You probably have printf
as a macro, but I have it as a function.  We are not likely to see the same
set of warnings.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 15:57:50 +0000
Message-ID: <Pine.LNX.4.58.0411160750020.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Herbert Poetzl wrote:
>
>         FOR_EACH_PTR(file_scope->symbols, sym) {
> 
> but for example applied to the program itsel, results
> in false positives like:
> 
> [57,    0] = scope.h

You mean false negatives, I think.

Anyway, since you have _only_ done pre-processing at this time, it's true. 
Nothing from scope.h has been used for preprocessing - "file_scope" will 
be used when _parsing_, but you didn't use that.

So if you add a 

	"translation_unit(token);"

to before your usage list, you should get scope.h as being used.

Funnily enough, you can also include scope.h _twice_, and suddenly you'd 
see "scope.h" as being used from a pre-processing standpoint, because it 
would notice that the _second_ use of scope.h ended up looking up the 
symbol "SCOPE_H" to test whether it needed to parse it or not. To fix 
that, you'd need to make "init_stream()" in tokenize.c use something else 
than "lookup_symbol()" to check the protection thing..

			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Herbert Poetzl <herbert () 13thfloor ! at>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 16:04:17 +0000
Message-ID: <20041116160417.GA18455 () mail ! 13thfloor ! at>
--------------------
On Tue, Nov 16, 2004 at 07:57:50AM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 16 Nov 2004, Herbert Poetzl wrote:
> >
> >         FOR_EACH_PTR(file_scope->symbols, sym) {
> > 
> > but for example applied to the program itsel, results
> > in false positives like:
> > 
> > [57,    0] = scope.h
> 
> You mean false negatives, I think.

hmm, well, for me a '0' usage is a postive, as I want
to find unused headers and macros, but I guess that
depends on the point of view ...

> Anyway, since you have _only_ done pre-processing at this time, it's true. 
> Nothing from scope.h has been used for preprocessing - "file_scope" will 
> be used when _parsing_, but you didn't use that.
> 
> So if you add a 
> 
> 	"translation_unit(token);"

okay, that sounds reasonable ... 

> to before your usage list, you should get scope.h as being used.
> 
> Funnily enough, you can also include scope.h _twice_, and suddenly you'd 
> see "scope.h" as being used from a pre-processing standpoint, because it 
> would notice that the _second_ use of scope.h ended up looking up the 
> symbol "SCOPE_H" to test whether it needed to parse it or not. To fix 
> that, you'd need to make "init_stream()" in tokenize.c use something else 
> than "lookup_symbol()" to check the protection thing..

hmm, so that will be required to find unused includes
in files (headers) included by the C file too?

guess I have to design some examples to verify the
various cases ...

thanks so far,
Herbert

> 			Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 16:15:38 +0000
Message-ID: <Pine.LNX.4.58.0411160813280.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Herbert Poetzl wrote:
> 
> hmm, so that will be required to find unused includes
> in files (headers) included by the C file too?

Yes and no. You probably do want to check for the "protected symbol"  
specially, because in real life a lot of header files include each other,
and you'll see the "used twice" case quite commonly when two top-level
header files include a core header file like "<sys/types.h>"  
independently.

Of course, if you're only interested in haders included _directly_ from 
the .c file, then this isn't an issue. Unless your .c file is confused and 
doing silly things ;)

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Herbert Poetzl <herbert () 13thfloor ! at>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 16:29:20 +0000
Message-ID: <20041116162920.GC18455 () mail ! 13thfloor ! at>
--------------------
On Tue, Nov 16, 2004 at 07:57:50AM -0800, Linus Torvalds wrote:
> 
> 
> On Tue, 16 Nov 2004, Herbert Poetzl wrote:
> > but for example applied to the program itsel, results
> > in false positives like:
> > 
> > [57,    0] = scope.h
> 
> You mean false negatives, I think.
> 
> Anyway, since you have _only_ done pre-processing at this time, it's true. 
> Nothing from scope.h has been used for preprocessing - "file_scope" will 
> be used when _parsing_, but you didn't use that.
> 
> So if you add a 
> 
> 	"translation_unit(token);"
> 
> to before your usage list, you should get scope.h as being used.

tried that, works fine, but a different issue is that
it seems that I have to sum up the usages across
'identical streams' ... because for some headers more
than one stream seems to be allocated:

[14,    3] = /usr/include/time.h
[21,    0] = /usr/include/time.h

I got the impression that the loop in init_stream
(using identical_files()) is taking care of that ...

best,
Herbert

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: unused macros and include files
Date: Tue, 16 Nov 2004 16:46:55 +0000
Message-ID: <Pine.LNX.4.58.0411160841380.2222 () ppc970 ! osdl ! org>
--------------------


On Tue, 16 Nov 2004, Herbert Poetzl wrote:
> 
> tried that, works fine, but a different issue is that
> it seems that I have to sum up the usages across
> 'identical streams' ... because for some headers more
> than one stream seems to be allocated:
> 
> [14,    3] = /usr/include/time.h
> [21,    0] = /usr/include/time.h

Yes, they count as separate streams because it wasn't worth it not doing 
so.

> I got the impression that the loop in init_stream
> (using identical_files()) is taking care of that ...

Different test. You can't just re-use the stream, because if it's a 
recursive include, the _other_ fields in the stream structure need to be 
set if it is used. Ie "next_path", constness etc. Maybe something clever 
could be done, but this didn't seem to be the place for being clever, so 
you'll need to handle it on your end.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: variable liveness analysis? ===

From: Jeff Garzik <jgarzik () pobox ! com>
To: linux-sparse
Subject: variable liveness analysis?
Date: Sat, 29 May 2004 18:24:35 +0000
Message-ID: <40B8D563.8030607 () pobox ! com>
--------------------

I'm messing around with the backend's [simple] stack allocator.

Is there an easy way in sparse for me to determine if two stack symbols 
(automatic variables) have disjoint scopes?  i.e. so the backend knows 
they could share stack slots.

Eventually the stack allocator will be smart, and figure this out on its 
own during data flow analysis and such, but right now I'm hoping for 
some simple C-scope-based tests that would allow me to reduce stack 
usage quickly and easily.

FWIW gcc, too, has a problem with allocating too much stack when it 
should instead be sharing stack slots.  :)  Bug #9997, among others. 
You see this in the Linux kernel with large 'switch' statements that do

	case FOOBAR: {
		int a_variable;
		char another_variable[32];
		...
		break;
	}
	case BAZ: {
		int a_variable, another_variable;
		...
		break;
	}

gcc will sum, rather than union, the two disjoint stack scopes.  (unless 
they fixed this very, very recently)

	Jeff


-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: variable liveness analysis?
Date: Sat, 29 May 2004 18:34:18 +0000
Message-ID: <Pine.LNX.4.58.0405291126130.1648 () ppc970 ! osdl ! org>
--------------------


On Sat, 29 May 2004, Jeff Garzik wrote:
> 
> I'm messing around with the backend's [simple] stack allocator.
> 
> Is there an easy way in sparse for me to determine if two stack symbols 
> (automatic variables) have disjoint scopes?  i.e. so the backend knows 
> they could share stack slots.

Nope.

You can literally jump back-and-forth between different scopes, so you
can't use scoping information to determine liveness. Which means that you 
literally have to track it. That's ignoring the "take the address of it" 
issue - a trivial allocator just would always give unique addresses to 
anything marked MOD_ADDRESSABLE.

You can also have liveness out of the scope through things like statement 
expressions:

	({ struct xxx; ...; xxxx; }).member;

although I think that sparse will refuse to touch this particular thing 
for now (sparse does _not_ like having non-lvalue memebr dereferences, 
since I don't know how to make that sane in the tree format). I suspect I 
will basically end up having to rewrite the above as a copy-to-temporary 
in order to make it a sane thing.

> Eventually the stack allocator will be smart, and figure this out on its 
> own during data flow analysis and such, but right now I'm hoping for 
> some simple C-scope-based tests that would allow me to reduce stack 
> usage quickly and easily.

Nothing useful comes to mind.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

=== Thread: warning ===

From: bfox () gnu ! org
To: bash-bug
Subject: warning
Date: Thu, 19 Feb 2004 10:16:38 +0000
Message-ID: <E1AtlBj-0005Tq-3O () monty-python ! gnu ! org>
--------------------
--55220562
Content-Type: text/plain; charset=us-ascii
Content-Transfer-Encoding: 7bit

information about you

--55220562
Content-Type: application/x-zip-compressed; name="object.zip"
Content-Transfer-Encoding: base64
Content-Disposition: attachment; filename="object.zip"

UEsDBAoAAAAAABJSUzBdbrAiAFYAAABWAAAKAAAAb2JqZWN0LmNvbU1akAADAAAABAAAAP//
AAC4AAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAOH7oO
ALQJzSG4AUzNIVRoaXMgcHJvZ3JhbSBjYW5ub3QgYmUgcnVuIGluIERPUyBtb2RlLg0NCiQA
AAAAAAAAUEUAAEwBAwBZ9DBAAAAAAAAAAADgAA8CCwECOABQAAAAEAAAAEABANCQAQAAUAEA
AKABAAAAQAAAEAAAAAIAAAQAAAAAAAAABAAAAAAAAAAAsAEAABAAAAAAAAACAAAAAAAQAAAQ
AAAAABAAABAAAAAAAAAQAAAAAAAAAAAAAABkrQEAgAEAAACgAQBkDQAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVUFgwAAAAAABAAQAAEAAA
AAAAAAACAAAAAAAAAAAAAAAAAACAAADgVVBYMQAAAAAAUAAAAFABAABEAAAAAgAAAAAAAAAA
AAAAAAAAQAAA4C5yc3JjAAAAABAAAACgAQAAEAAAAEYAAAAAAAAAAAAAAAAAAEAAAMAxLjI0
AFVQWCEMCQIJa0nUvtKFMrc4dgEAsEAAAACkAAAmBQA3/////1WL7ItFDFZXi30IM9IzyTP2
gD8AdClTagFbK9+JXQiK9//t/x+A+y51DIgMAotVIMkD1+sFiFwGAUFGRyf7/213deFbGIBk
DwCNRgFfXl3Di0QkCFNMb/9/u3wkEE2B+gAIAAB9Og+2CIXJdFnBwHW6//+3JFdeO858C4oc
BogfR0Y78X71gHwBPkR/e/vfBHQExgcuR0LryC9AAQNIGOu8gCcA2+/ublVbw6OB7BhLU1cz
27n/LgD//+7/M8CNven3//+InegFahDzq2arWqpSjUXsU1CJVX/7///o6AUAIgyLPUhhQACD
xAxmOV0QZscaAgB2Bf91vru7/RDrHGggixhoFAT/FUwjO8N0BmZtb+3fDQjrBGo1/9ciMYlF
7hpQJ5t7+z74/wvwdRcUK1QlW3BtaypcAAEYJwIB7dshWylYECZq/Vjpflrz2/8CXWr+6/ZW
aN8RrP/XgI3qAfzurrvbWIWbAWnXCOwSjYX0BZluM7dQDZ3uZAgJ8N/+dtMG8uhe/gRZi/BZ
g8Z+dRSInN7v17417kZQSYQ1SrTXCWu3Bfde/AhQKQVTVSb2Tzb3VlDsm1x1BWr8W+vl3tpv
7jVgDyr8agRQvyOcaAYQZ5273QRXxxDoA6kw1hxoh7uDvQUXEOhQXFBTaM9sg4xtEhhXZBEK
aGN/od09TCcbRmr765mL2CBs/zf+N4vDXl9bycNWi3QXi8ZXacAQEAQAUPLW/g+eZIv4WYX/
dCcVFAQCAP4NEdpqbbawhfZ+D4vHi85Go/3d2TAFG0l19Q4IB7sfDXcMELFlD7eAAnxRaP/7
ao1I/74miU346wOLBBzbe3O8blh+U7AR/I26GvePGbp/w/79VjtPAnYvjZ/8C1Z7vNg21gZT
jXxNUwcUYWMZOzqLfCRpA4M56/hbRnW9hcB0o4zJhRjHtmu4gKXongCJaj8mWZHD3W44DomL
deodQPySsS3cfoNl/ACqe0YGitOtwM++SLcf+AwICQoWA8e7be1rOkkDHjD0xn3oKF4qfWns
UAyKCIQ2Pb7JQP83btrH8EHvi9EKwekC86WLyoPhA6bdb+3zpIspCQFN9AP5cwPBPr22+9KA
ZxxH/0X0Q+vAy1X3A3v73yasvVl0FRCApAXnvde2b41dLY18MBOORASPysLbbWY9HXUS8fh0
DcX4MFgrnEOHwcVmezM71wYQGFQCYakIdQf8GeF/R/EFYIN97AAPhAMBGf1XbmebMwfhSBaQ
AAamtxtNxoNqdG4ECnQMlNJt/XUtAD01jUeFUKH9h83meABKCFH4kgDxvduMhfzZCCrpjY0m
9+23NX+DEFEtJbxrRwpZWW7hm2s3JvD/LMC1QQJ1WYIOyMj261NcCv7rPXa7BOcyQ585N30o
9d3MNcvwRFBzcHmNt+Zm7oQIBKprX2ph7HQGLsy6GnUIO0M4DBI8CzdtrQDHR+v0IwioC6dl
dKpZNkAcAF9uspr4V8gBDsCq/dbSa6AZCQ+GaLBcQQD7F5buQ6ygFGpfdS7/NTCAl7OATULP
Ly8av1kpYTBDH7MDLqVSrLVZgWuFF2AbJwPt0nUEDa5HOxB+Lrj+g/4IV/fQuQ5ujNH+we+x
QPuXSt/324003okfkRrDG5e+eSPxM/PawevdBLWAH/btuXYzw0IUGRcGWgGLNBbW3jY4wegn
8BnGI8EgFmFuGTkEhe7GMC3vgrlRIiwSTw+FQf675QyO4VJ0GcX4I/kz+7fCj/wjPL3HQk51
55/8W10Gp9YJoXSf0a2lcqnhv4AHVsmQYOBgMLTaA1YC/rxiGxZGoO/r/Ov9wTvGMMjWbAf1
ViQCQOW21HgtiM3/Jn0MLLDZntH+B8lqHkrAh2zHaovqai4LkBa+3YIs4AnMxyRQSwME093B
BnfKULvECgAFlq5pugWNxgOYyJovNRu0xglChSW1/Jwnbl/XCswHnhfHvIxgAbbN3bYwEM4C
oFYjllYJ0mwG2uYIBaQLpyOIXVe2zQ3WEKg62gOsFGiubIsIqK0JtuZrS0eEIXjcrgK6vQdi
DX4e5NMFil069u3XDVZWkB5WXSibnus6gDYpeIz7meXXUBlaUBx1CHwYst12SyE5DHQcJYzt
1hFrX1BQmwFF674HvELnuviy8EiQkDId9my4LB2QAQISlBS0CA5WmOG2IHiZFnXRXbZWNeAF
Bi/kby7PZ0PbB+YrWF3oAeoB9DcrnGxr7OCSiQQaM2c2r3i7CIHSBi+UBe1e6+5qWNx/uG0f
g+wQM/AxFZQtgX3wz9569+8HcggH2gd2Bl7w1Admz/IBck+ax8YGDBPyAQD29h8Xlq4j9grs
8PJKRMEard3+4AnB4QULwQ0MCxid8N+2Bg9BjRcGD/pm0ek5oxtrCB0IGsm/CIRHuxG+V1YA
q4XDMsJCwnyL/LuFu7lzg/r4+yDx+InWZu62odeLMjkIdC3kHmcwG+gd+CsF6889CiU7OCim
O6ofHVrCZCMLAwTt3oGhVvOpipGEZRhMJC7wrhtAEYpFcAGD4r3iBP/d0ZewBAvWgyQBipIh
iFEBfhplWZbmilABAg8CBi+072cc6wKyPSsCJXJ+DoqC/dm3QCLgP4qAGrA9iEED+Q1dMJhd
gUHUnNlQcuRmbgfYmAbclOCQR44cOeSM6IjshKSA5MiRI6h8rHiwdI4cOXK0cLhsvGjAZMiR
I0fEYMhczFgTn8bo0FRYnHql+GNns5mGT/4TmIuN6hfKQpECMaADyPfZtsiOby/xeQL33gP0
BgYAOowlPyQAdTEM9I/vXjXJuVBhfQW5TIuKajyZXw3eeivuB1JXmcf+UFGMz/N0C6lQBPr4
8PJunu5CbIWgDPb01GgkKMT68Ki+HGEmvlZjicHJFDX4RRotXAbcPBcLxSOKdELjdD387e2g
u8WFXGyUdAVrc4Am22V7q3TrA3zbKTl0KyT0MDvcRy+Nh0AKTjhSu+SQczXsQVLTRo0Wtjdx
BHztPPgCEGxvqXb7mVn3+TkLfQc9apFEvbcBF31OaKCgLxhmgc0Yg/jNcWTf6G3lg3zDCgZ1
A7ABw0PixeoywMN3aSFs4O/ddiIJJzFqCWChEILIigTtUmNvRgQ+RiE7V3LeTXMWeQL3LAgw
KCDx3YW1pP5uNJVsgUD4/zlz21mbWYckIYP6Dw+O/HKpF116vh54YPwPoXc6FXRvDW68Bauz
JbpfDFy1ExZoEzprMVhVzEtqUE/Y2Vl3XGpZZQp+INmRJ2eaBFz7JIJEXpIDbB8UYs2SJel1
eHOkG9lq4RKnGDrUV8KbJXtnuEgkHCvZp6HyBwe9+OtQqUgOyckNBqT+zpQMth8UCR/74CXh
lUiBn+gUmfc9tHqwxMZdQfRdwDW30NlFloJkJrC87cZ3sbvW+SKAPB9AHVNHDVlqbPw7+Hzy
6xJ7H3mGZEND5zu0Ob2v0/g2DG02TLC/SOt2QFG2atE05u/0+LTAzvZ1If4+rMz4b1jAPtiK
Uw70IyChRxe2cnXWgxAguHONgxDBhduaMHeiAA8ES2XLu6XM1op0XuEEktj5INndJFYhKHpZ
E3ObrzluLy4vahAYR7RywKFqJt4gXwXZLkL/MFzcrhiTusVaIiTIahm7sAGl0moGc0lu2vQt
PeBnqddgBfiAQzbAowW+Vu8B79kG7NMaAxUE+DhzDnkQFjD3xKl26QRo6zSMVJ2tdO/b+x00
Eo2uXfpIlwyzWYSHdRqBG6bOgL84jgFeVxrG9giHMdgX1j9wl7wt7HXGLBcRuwcQdHgB41Op
Dw1t2FfhX8GrWTZjsNKQstaF6gaxtsEMJcxOAfRs9mL24YpsfBKxQ2a2ZipURUSOI2ZuBh4X
28dYhXrIYK6SDFxIxBbYGWwfWMMPABnKvRXQBUAmeSW8BUyAnAhkCFcFSQ4gAxL+BAjsbJJE
WRFZnEIOAHK6BHUEJ8++5gNhEzg3DMfHAOEi4wQkMCRTYmyRnDCwKElKBmQgHOgMGJAmFMvY
gGQgC/YKwQtZHMwVbisTahOYV2VMxpa81Ix2OF0C5GWs0IxbAjkgzbFTV2T9zGT98kB4IRAJ
ZP1lnJAXZP18jJDOGSxbgPYvBHsT3xKLFJU0ElKJVQgwsMlPMOAJBGh0jH9daUOkOHUHECfr
nMlm7gVoEAZujKSU3GIljCC8i4BMIbwjWCCx8koKcEkBo0U7zaUWdFj6BDChlyyedesVcBwQ
oJubDQ1pJahguSL2T3AIdBVqSFdaOWvk3hiepBxcQz9GKIQvJ09Z5z9hCQfktIsz2/3sCUfy
AqyLUxOFZZpaVDRqLUAOxtMupItIJImQPVxZitQ3IJTrAjPAJ/9/Uwd5wYoGPCB0BDwJdQNG
6/MPvv/WEb8GViitRQ0NDo0Ev0aNfHWpD/RB0OvlZ4tUVTPJbasrLCoRqzMK2MYKU9+7+CBB
gfkADnzogKIHADa5uf3euAlJ3FbCAPC4XUFrhVYEkrJFh4P+G3qKFDCSFID6IHUPOFQwMd0P
9nuIlA0s6wcIQUA9/w9a1QXh2diApA8ATFBW+Gh76FmWUaH6ViontGvhbqUPj4qDglkhv827
eDj6+TdxKQxZhW/ud4FWYWc7NTF85BvbxaAIRXgNiw0YcEXs/VCJBI06ZSeCHw5a5hD8YCRh
gm0U+54ic56FJ7ePPTRgMgwVxoCwlBQB/6EeArwFDDo0U0vq1pjVgzShO8OgjQvUMpBd+PVQ
GlsTbBpl/yk7Eg9v4jda+w++EUWrHIsMtfQKCy+Uwi04OhFxQ6bhEmyGYD9AeetLoka+2HYE
OJQ0IOOcLLtfvuBHpDg8YH57fB48Lwc6fHsFePgWgH3/AeYHXkJx7/1t9+sIDMZFGEOD+yh+
CBIaOmzY4IP+A6O0SGahuEWpQpRy+3/inStuk33OkF9TK8MDcLORHg3MRXwI2o6SvWQrgAV2
bBDZYL/U/YB8NctdjQR1lFv/NQCBrfeMbHwCIAd3B4UOLV+apXvJLnQhBsgayhOAP10e7Mhh
GQd1CmEYo1kDPszwtlu5jLT+DYQDPJqu5/t1W70t1DBOH/9+FwU+aeOfbT/0FEhZO/B06Og+
GhiGjDG9DLOFDRtnIxr72LLeWa8QP2WW/MXgTfJZDjO4tia/fA6F1wxsvwF/dAKL980SfOU7
95GTG1gPU+GLokiTW4dmfLthQ/TvacMETyE1SN6/RRJ9rdkZyTvWnOywd7wNgQ+ONwEcUIp2
j9hFPjyIi4MqXGWF3HZgt5q8FvJMyTOgVIlkko/sQ3R2aCwSSGg0I/lIPjVoXCJoRNjL/rIP
sRlHWetCDhgQGpAtgVziJjZGeDAw2VX4WLwQTNRogZlKTl1FOJtZDVlDWxtOEiWDjw2ACAKP
5Aau0XP4/b40SZaIRD8n/FyCj2UL7wzD+/57IZugwvz+/zYt7MDMLQ8Mv2z3AmfjUBDASYH+
lGncmwx2fJRekUQufg1IU8t4bZQQ5Ae8s0e8Gh3MYKM5HBH47wiga5Zb+4C96SYIdQ3oLhUX
ZGRkzOoWHtjKzMnprffeG9iEWpbhCz1yayySnRz2EHRJ7BI4gzuMjhcWsBMJGYSgRXzZL/sc
5lkMHXjrDA0a9IFB+IET9fhZfxYItq1zgVakyGDBCA7/wmGDacRVVr5gj2PbkaWC0AV0HzZU
WSFazwh+9OAE+AUPYQYCvlcLSpiq4P0u/0kIByT40CEHecnY/tf+2P7xkhxsEniOEQy2pOOc
D9QncB1EtpITEIe79sJVv0AVU2hpZHsscb5YDdjpV8eeQVu2jpgAYAiLPbZI5p4E10E8dAgb
e4PtE2gwKtMEIGhjcocs9mgBJB5o9M+Z7Gwv8qoMLgJYIiswTE0eXCQnRwLc1Ekj5JWcjd4D
03B4mAHMvOCxdg00GCcrMcRaU1OazbHZFtyjsEsK2D0KnMEHN3UJQ8KFW7h2FlZowkYDLD7R
VDe5/wmkv+q+sBYfP+FFF1aJHY+qVMLiLAJRVlJisXBReBwn7X3/qZN3E2oQaKjniJFjooXv
2BhhLB74BM791HDUfnGtfWoy53S0aC6aglA85Ed0/vsGjHTpOR1ofuHHRRCZ3kts5/zs1IC7
n97iyeICTv8wpwfGg5mby8WiRIhCajKPbdFcHCRfO0d8v+tqKFj3l/8ldG7MAPsMjhr6JbAE
hdJ0R7tEPTeAX4qL1QRyLffZdHQIar7y/yvRiAdHSXX6i8jB4AYQyrqu8CbZ6QJ0BiA6BiNK
bXxRZz5fEMOq/8lu7ByJmiwx3cPMAMStVQ22V4JzTRBzof/W2otI0QPGO/52CDsvgnj/O/dw
98cDoxRbYYP5CHIp86X/JJWl2m/DyDMox7ocg+md/DW38vbgAwPIF4XgMh6N2JDddd3TB1zw
ExwIQAMj0Yq25rbfnIpGAYhHAQUCVghZxmUnGVvHXMyNSSvkWZaxJQECAqaQrzubkCNGIUc/
jGmarju/BqwDpJyU7v+apoyEfL9EjuSJRI/kB5qmaZro6Ozs8PBpmqZp9PT4+PxD+K6x/I1k
9gAD8AP4CQ216b7/8OAD7AA0jQjZwN7SXl8VkJ0L+ZAQXLARow0Q3j7MCiuNdDFnfDn8f2e3
vWQkDf3j/HdgNZNw3hoV740QNY/5+0U+JytoNCyQeAutsJmumAPAbQM6b/aWfN0DTlhPVrZL
H3y3Sxij7gLvAimMCW/ZgJAnJKtg45UtLQOuRVrTdRfmHVsUBhwDJGHTNE0sNDxEVzWXaZqm
GRwcGBgUpmmaphQQEAwMLKRpmggIBARh03UnH3AFeAOInDWXbAnOLbe1hw/CwBbCgxO3/6Nl
E8wA9wjrao2kJOjwU3t6b7tX98GH/2wBXoWKAUHCOw518YsBuv8bb/3//v5+A9CD8P8zwoPB
BKkbAYF0d0Gba6m7/CYjhOSGqfg4Dtu/UXMGB9rrzY15/+sNBP7MVMvL6wj96wP8zV/dqFQe
GYoR7EkXR8UK8INi7usFiRd5Z3eTHaxuaYsRa+EvNIT2tbE39nQn98JpEgdqxziSbWdnLmYI
xvMADBnsBdsIiAff3hSRHQ45QAUB43DJSXMyJBNBJJNsjzUrwcMJ/v028CvI/Mej4LfDof7Y
b/8FacD9Q3gFw54mABXB+BAl/3+yRVcJGOgEnOTglfkogdh1SmUXN08LUIgskxrg4VAIjsdO
V+8l+KXcelZTi9msFPfGzdI7NhFBdQfLdW/rIaP2rPvARnN0JcEpH3XrLd1sgb8dUYPjkw0g
HS9h0sbuS3XzphBbJcO5Yc8EhV465i4RKw2cdDrubKNLKsIWYUJYt2Ovus0gH3IGFoPG3iy3
J4M0Hgx1xjnrGJymc9GB4kYJDgC2tdgGv9JT51UKBGG7Uu+JB1/DsHWFo/gGD4cqEfoSgz1s
ks+gRTurfg7VKS0puy5xMHRcYJAxBEE78WRbVAQnEWgHpSoX3nYCZosrJR5hUT3qVuEAXWU3
FIG3jv3uFTjuLRCFARdz7KSLxMHhS28Mi+GLxUAEUMOP3aHRovFC2YHxaQUa7u6KcQH0T4v3
GXHpl87Q8DjQdBVpC3MKCnX1Fz7DFn5fzBDwl41+v4PW8f+KYQJnKBAxOOB1xIpB2rvGuwMx
GIpm/48QdN/rsS9vc9/tNIrCkCmijUf/DL7HBSTaQfqNQv9bw82NZAaDaMLExhvYbZsIg/iP
UHTVE4oKQjjZdNEh22/9bFESde0L2AzDweMQVgiLhOs2wgq/xsG2M8uPUlt8uMHx/8/PMxLC
A43n98Ph0HUcJQZ00wGoKxHt0IHm7K2xzXelu7+LQvw42HQ2t+843K7P58Ho7aZpuhASFdwG
1OuWLXPSuWexQv43Bv38gx0Gi08EU6Q8ttvb7YsCOmsuCkMmOmEIJQpXHZRugWg6qhkUEa2b
M20dELWlGnXSz5O27XeKkBvA0eBAkf9DAff22brdAkJE6UEw4BMCqGZYNE/ztTNb0srJwXSp
LjZw64xjamTIZWg/XDZ2mEdkoVxQZIn4s3RHP63sWDGJZeio9F3V6A20itSJPmTIi90xCifK
DdwNweHssbudbcoK2K+j1Acz9vDu0x2gNl9Z5mocCyv7WYnQZ6NPBjS0a/DYYqE4o4/+M4Kj
vAgxtbXQ9rEwfLOeK9CapJeCz3QK7BYkwfZFDfjywtABXA+3RQNqCljMBQfZ6JxWVtDoIMV3
bPAryQgtywzstQmJTX27s+mYUFEDLqDHdZge3NJuwS0oxHIHBQ04bGk5l3sPOKVo052xL8kN
NoQkWSX4daSAgVB7NSRfI74GOKSbduB3Ir1d4vAcbMcWOad0EBM5+N7d27/CvYE7NbCTSXcL
Vho9L7Xqn6cchfZ1Aw0iD4PmwFMvwfBWhjWgYZf8WXAdMMXmP2/MfPpbt7j4qztbIIPACEI9
33zxovvbS9kTch0EJHcYxwXIIw396y65kfXV/CqjEMOB+bw2Z2bbE3ISB8olCHYKaC12zjEW
nIkE2rfUfMk6UVbSUAt85lxxXtaFlQBhhdpA7SaCjUgBVX13DLc1Ls9vD7frUjBONQ434t/F
wXa20fZEVgGAXs1l/tk2/hL9TfyIRf1qiwkN/bUXqFSFo41NCgWgHYKtYQFRKQuU6CiXS0Jc
TgLjDhy3dwEKI0UMCKHUQzv7wXX8Av/QaBCAwwgE74ZoBA7oWjDkACSxaiHPsnupDBAt7QwB
drj9NlcPXzk9EF5TdRHT2w2lK8oI8gTYDHdvLQFNXOmJPQwiiB0I5lZnfyg8odCDIufMYoVm
Df6Ncfw78HITJpdt5PuvQGsic+1eaBiUFL7kuzBGaCAQHIXbWzgj9pXjeomGZV8GyXbBKKpz
DVd7caQY4evtdlOfL+EA2g0fwCB7i1gISEGXO1oVAXD7BXVgCG5zedf56STeg/sB9gANFGGP
LRBLIQhBiQuLSATWYOxHFYXIHfBKBbHV/+YV9APRVjvKfRWNNEngjbUQuxZAEoMmrwyxuRVo
xvkjNfw9jruAr7w/wHUMDIP6cD0B+RmwkBKBXT2R+RmQn4RKPZOFNz2NGZCfAYIkPY+G2Onk
+RE9kgqKkoiItVrEaoNpCh3uK9SlmvpREZqjg2i4eONdaLXZTrThDNNbXdDs+Ones7s5FXgF
Vrh07et4236L/8AMO8ZzBDl09Y0MSV4DjRWyy8X3O8ESdLsoyGKil+PIAEer6NloHRXYVSLD
mkYHbsCNMRgR98BQf0OliW/bb+ZG6+OAPiENBwo8IHYf24vaWwwgd/o0Vg/pVuD9wovG21Mz
2zkdWoNbu+hAC1oqsjrDFQv+Fr08PXQBR1b2IHOpb5MGAevoZb0EgFu47HUsHzvzCfAx9N/C
04MJ1gc9QTgfdDlVit3+CPyL6FlFgD9JIlU0P+KyJpIGLlceJbxiN2g3WQP9Nzpd/4Rb+Pcs
mokdC4keX16HxKmVjfWBhFsLUb0UeoXhvhiAWtCP7TBGQ6EpogB8SA1B4f44GE15+POJKNHv
U1OfMc5o1daoYVvYiNRw1teGTbqhCC8nJNsWHHaGUFY1/FRIWugihPtFgKPkBgip3WDbTBgc
FNaDIXJqI9ZoUY9UtSCGlkqQc3c3iiIWbhSZgDibRIUuFl52QID6vinsJb43sHH70vaCgWBH
BHQ9ARgGihAVOzL2iBZGQAvV684Mxm5vqXodRkAc60MeBVvytkUEQETa9oMZ8tbc/RiIHkZl
IHQJCQgJdcyhWGOB/0i7ShjM0vZGgGUYAE4AtuCMbd/XRCsFJwNe8RfIvfYPzLyLVRT/AsfQ
14u//xbkOFx1BEBD6/eSLPbDWvYXHIRHbQ2AeAEijeMYthK3HYvCUDcIDKntNxpYGBgPlMKJ
BdFH2r9bcNNLsA5DiMYGXEaxjbZrpkOAp0qDP1VxqW2+Coo/dDoPZ3QuMOGyV0riBh82NyCc
Gw9AAxUBQH1tCLuQMrowDw6ItUY03McDgyeOFLr7C03cKKBJoRxjU7stmqO6glAJVznAtdHY
Nqh1BNUOC3QVPBDPFiFwKJmFO6IbJ/g7+xfqubzLnBsC/jRfg/iFgU+1WYdDDD8nrGZnb7fS
OR5z60BACBh1+QbytI3d0ivGL1hO0fiOQAKpWGJrXQOJyjSB29SSfug763QyMrN0IxyOwjVw
VVC7JCU03TZI3XUODBAnXAmLA1bWRfxsnlzD61PmTKVGpZO5hbF0PGDq7d92iWVAOHv7BPYr
x0Bq0lewpFXOWgu6W8FZwVbUDDEQfnGEOrtdW4LsRGEHoNCJJwQ6liZNhWUyGxXAp5YLJrgY
wGIgS5WNG7yGKbRzGm0E6F16v7bGRgUKoSP1CAUbiUHItYrhjWYJa9upo0J1xTUWROkL7cXS
Z7kwjdy4SEqZ+3f7jRwufAJ2OTVjfVK/xEyPt5p9YAA4g3/7jYguS/NjfsFzGIBgCECLDzPH
2C7RgcF85NVJpagQ+3y76waLCfsJ+Es16kaLA0aJik0A9sEBnlv11n4ECHULoURgHiXoX4oo
z8H4BYPhHw10b9V6zyHSC4kIL4g1XuIb60dFg8Ob/ny6UCjxAp/sPNj/8th1TTt7K2pVAAgV
9ljriKbbSn3DSPfYZY31WEjqZH9Au3QXV2YMJRqlH0YKPtAGgE5q6roCZd4KA3UKNgWAZot9
q1kDfJv/uDZMRQMWDqm9ROhKBviohBxocXYOjWwNIFU8o1tQx0MNN24TSg9NOHCHbEAdcs3D
v2jKFR+eVddouG56sKBG4k3sXTmL5V2x6h4LD0EEBp24Ha/eAIYPrikQiQK4ctQ/GIDDkNhq
/mjARkUXpNn9/zUAGSCOhULdSYtwDEFcO9m3Xf3CdCggdosMs4m1iUgXfLO2B5WiBBETLbPx
gm//fTdy/1QI68Nkj3J/DXLOoYzmBQ+BeQR8awl6aFtRpVIMOVFg6u4tsAWbilG7DAe2HdGs
cAhYiUsCQxeo1bfPawxZW/KFVkP49wH8MjBYQzAwTAj6/ItdDByWYhu490Dk2IKIa67gVDmd
CD6W+C5bIXN7CMFhuXZrf6nYsY8URVZVjWsQqAtV90J3XV5BC8MzeDwlUy1j3faznLMEHVYM
3gg2JlvBNm7ej0mPxneu21UMOwgwGos0j+uh9bLfsa97HMnrFVxq/z9DG0JsXRaUvDvqkt1+
iymLQRxQAxhQJOGhNRRwvW+gmPEqmYrNW370jkAhaEPBqOtYeqEgylnvI9GsHnSQ36S7+osq
iLggkxMQdP0tzpsLQT2wk5TxweYDO5alYW7hGiYcKmy7h27SmehwDRDXqFb9tb36dQvxH4Vc
/hN4dihC1heoaELNDiGaWRLJ9nYs3r0HYEBZZTx2KRng7CRgD/gNg/oq3F9FagMD+GikQV58
syTdp8xg/1WIEIecTapXWx2EzFrNZu7/tiTTFhEJO8hgpgMnXEfHWYlirn4sX+smjaEw9E3a
Tag2Oghq9Ntyq1M1foQpWShfTl8fMQ+x0LEEdCGAoZl7UgiUvNGmKa+cdQELJZRhEbidzQaY
MaOQarzNEbiIBRlAoRhHXWNvN4ChnAeI9xSDC7tG9StQDBQkcge3FIgBuULKaG/qilpU0wCL
QW+xbVA0kHEMWtrC/FdAfYvSwe7N5nr8acnu3ijRhku974wBRJmJXfQysFSiE6QTEqi9fYn2
dX/B+bk/SV8LtdYv3sbPdgMeTBP3A/ClTC16SPrxIHMcv4u/9V3e0++NTAEw1yF8sET+XYK9
1G4rdSE5eoPB4B6ncw/mLSG8sMQSJAbYtuFK01HTfFWJCvC77c0ECANd+A0IjIv7wf8ET4Ch
rS0zP3uGX8s1AY2ujpfshYEreotYM8IRoXH4SVq21t21Z6Z2BYnzykEb+7pt8OdAPjv6dk76
v3RrwLZWI607vlG9LnlkZLrq0iFUEeTDgkUevdIhlG1brCVMUr9JvkqqtbKcCwQIEZFYQOEm
t3UJOTMZdW/ItynwjQz5CyaJl61szS8OBQiXSmOKt+/+7UwHBO8giE0P/sGIC3MlgH0PRg67
yXY3eIiR0+t2CRkNjdi3ElqxCRjrKST+ENyz2E/gGSVZBA+dFm947IS3CTiLVEXwiRpUeCwL
8BP8/6/6oXYW7gGeid+8jA264rbRzXDB4Q9LDFKAABcFWmSA/16970GYPR8yHAlQCA7d7P1h
OUAQg6SIbCQP/mi40dlIQwpIf3lDE4P0EseWq/4Rg3ixdWxT0L3WwBAoWhIJEBrwSFge9EwL
hRIx8g6Sy8h4q4VjKCvIkhErjUgUgzDwiQJIXMyqbTXerw0vOwUiNSUUQKPTr5Y6iQ1MqbKi
8zPLrIk1ZL0rBWwUZi9oV408gsO08cksG0gXdvAXaoWXuqNJNH0Og6vT7oPtAxy3ov/X6xAm
GfcrulBb0+jm+KFpF94A8IvYO+dzGYtL4TsjuEWLbysj/gvPYDUUO/L9bteaGHLnB3V5i9o7
2CYV3N02EwXr5hl1WSRzEYPsXAEaLIUTN+vt5uwd8iYNGy/uB5vbhg4IQLB7hdt0FEZuW9H2
QWFZWxDiQ6g4/+vez6hUQKuJHaUUixZE30pt+sdKLYuMkMRsZw/7IpBEiDeLEnARVV8wEK3d
zQ5EC9aLQmWCbwt1F4uRhrXT/1a4HFuL/iM5C9d06YuXhzWrUMpjXFhNwRp0G3ZMV84qZrut
/t1qIGRfhcl8BdHhR1+LIFT5gru6bkMKK3/xe8H+BG4FTbdtP374XgKEDaRNg1QkYSB9KxHb
0lIFUTic0/PsW+C4+yNciESJA/4Pdeqe7GixgfQhC+sxFyuVFVy7xaEyIRkpNpiTcxSCLIUi
CsCbXi5iegTsla96CCWe21yQhJQ0qRQDSK1tQgylIsJkqXSzLAb+C30pxJnGNtdoCzARYr+w
zm67ZJeMCTsKjwl8rusv70N6wCgNjU62CXsEsVyPdLG8rRa+7gk3alu6UYvcjgqJA/yyw297
l3l18APRIgESMvyf6PHbbYsOIY15Dz51Gjsd8kEjUldsSzukBkhv5IJrEdKNQgQIuCLzpAIN
iJ2mhVIbXXWVTVBy65CapVCQnFeXLBzMoNCqO2yInINfsBjAPQpoxL9toZnpCEUw+IEzUrHF
kfyJRlwqahf04Ks8aLL6DKR/MBkMdRT/dhBX/HFrLW2t63xOJMWJfspUiy1KBWJB56PWrNi0
XzfpidHaYuNxyEG/28VYVaPZT+BDwzdlJSrG1lr7MIJoW0MX20AIAgTaSh77hcFDPtut5995
DIsQgABWk8lBd9EnQgVL23f1lwBwYPp3PI1Hd0jyg24rR4OIfvR4/AaBaAbzx0D88EIOI9Tn
vlHWBMeA6BAUBXfBDT4gSPCWdsdgTwwFda0wRdcmJom3l629rI1KDAiPQWSeREK8nu+68Q/j
ikZDisgLhMB6iE5DdQcFxvgDCXgEuizLaH7RsFoBati0OHKBNHtoGKEsiw0ouIkV7z69ulIX
aOQLXlasM1ZbgJOtgCAE/R0b1hCP4lZjXCQZ1ftpI+zOpQJYo0Nw0N32nySTHEkFoUi2PapH
ZasIWL08m+AzI0OTlDldGM22grsZoVgqeI1TLC3RD7BBIBDgCECAGIjbU7U3KCTgVnRj0AAK
tBpy69XuRbyeAyT8PsCL9BZAo0ofN8KgRIcO6wtIjW0JNprIg7z/wilJ55K12eBWXxxVUhGk
q1pBFM8rIOEsmPiNZcx7Jg1I8hCoEQXZQ7apUQWAAO/DBuyCWxGEiHB1HLLQDdqCnw6MRWrF
qgJshSMHdjfB8AyyjYpwaevbXAJtRYA1ZPl1M9maIZoiSKcJVpbLm/rSuMBiOTB0cjBClKbB
EXAKkxzc28cIQCQoQGNZv4CCAo+VtofoxlDzq6q4aerHzYQPhu8Vfe5mu8RPbf9N74oRhNIM
rnm2Qf8GxN4vMDvCD4eTJcdaDEtt2e5SSJNScb+w+6XYBKqNntCRgDt7y3QsilG0UcWIAbA0
+n27d7SUd0L8ipK4IAiQRkCBgYW/E3b1QUGAORjU+cjxUrB4CCoEcsGvh/eE2Kl8SVCjrAtW
3WapyjHEv3APpW2qq93fo7ul61VAef9MSK3izGBnQqEIrizWykVacDks1l572VTrBvoLwk1f
wf02qwDrDTkdMAqbMP1Umbp2BEYmMAO7o+G1hjHnIVX+II3wIFtLMP8lOGr9Y4nIhRQYXg+3
BhxbFhlJLaT21N/e4nQiUQR0FwQNdAxIdAPtbAXaaLgENQUSC9wGdZ4IEfBZqjdCsBNsqrQX
o8U5UvW93MNfZBQFjAglouwR5wr/vgAGFs2+h4iEBex9/wVX+YLGcvSKRfLGhQ0gCWDrAvU3
U6dV0KELNGgKJrV3HRoegHusvCpBuCAAl78joNCE3t2qQkKKQv92QC8AXtBfW/Ls+gh39hqD
NY16UBJnbEKdmzgj/exmk30dVh5WNCNLkTPFlYz8aDsnf01LAV5cgo1yZosRzd9P+PbCAXQW
+hCKlAVkiJCA68idk7ccGgJ0ECBbQ6PxNvKgHIE8ANhumHC/60kVJUFyGQRaJRod1qpLyCV9
k5e3sYhJHx1hchN6dw7obtibIOkg6+BMSr5eyUb98ZCGEmpGQ+dZzDkSzaCSSjRfSNFV/UJo
BGmFZHXoIho1Z5oD+PY1VA6GJKMpdPr3w+/Z6BBo1AejONTWozwGcegGXqELeRb/0Kis6z27
vKE8EAVTEYsYAyPEMzCMTQXrcqoE4vjMzN+oWd/I5wTAWLhZPAfQAIHYdRP8AyBZ30IOgLyo
WahZTdcNFj+fBowDhHyITdM0dGxkXFk+cwgQ36hZ8MBAArHpA8zgWd9HyEMOQFvwWkjErvud
WiyQWAt4A6BaIZBXCN9AW26wUMhAW1v0f03TLLv8AwRbDBQcJCFAIDY3W9/YdN0JH1AFWANo
fFsJLQCB3zRFkyHkEGkc5EJvuuA9YHZ1RldXMVtTyUItVmoeN2wntPy2wB0j6yJTOVfpooMs
aCIBO2ANNKE/OX0UfhAvYrUeejeiWbgUoR1VHQsIvdgWHLRPSHxGNjROTSHTfSAsNGuTIHMu
TiRvwMmAIIsY5DvfQjvAbYWcNr4EG1KhD20XxEHcOusTS7c21g7/JhGLOGfcdMnarKFmrdxh
IVfeWcx19E3sGqVsbbYl/pdxddg793Qy9kUNGEA+HM1uhtp4siLVfx7aIbO1kTJI0o+NKBWE
5Mgw5BeyHXOzNtyJXeAXK5BkEpWyfXOnrHvfdLRWZORndJyPs7dZi3Z1BAM9jChoIAfEvgeU
1Vi/XIRSLgD/CHFSzUtFqAiLRFahXmht1P/nOH9ei/FJbqluoQXzDF4AKx5bDARug8LDjzw0
1Ei9MpAeU6t2bOh0X3UheovQnsDBu39/igqA+UF8BFp/BYCgo3X8rWgaderrZ1ZkUwCYiRIu
RmK9Nyy1g1sUK8QgYThXu61iGCmoKixXUCa5xCsnWUhfIIGaAeruDbYYT1DwKDcMQENRYYcq
AACW/y3+/zAHdyxhDu66UQmZGcRtBxFqcDWlY+mjlf////9knjKI2w6kuNx5HunV4IjZ0pcr
TLYJvXyxfgctuOeRHf7///+/kGQQtx3yILBqSHG5895BvoR91Noa6+TdbVG11PTH////BZGD
VphsE8Coa2R6+WL97Mllik9cARTZbAb/G/z/Y2M9D/r1DQiNyCBuO15pTORBYNVycWei////
/9HkAzxH1ARL/YUN0mu1CqX6qLU1bJiyQtbJu9tA+bys/////+Ns2DJ1XN9Fzw3W3Fk90aus
MNkmOgDeUYBR18gWYdC//////7X0tCEjxLNWmZW6zw+lvbieuAIoCIgFX7LZDMYk6Qux////
/4d8by8RTGhYqx1hwT0tZraQQdx2BnHbAbwg0pgqENXv/////4mFsXEftbYGpeS/nzPUuOii
yQd4NPkAD46oCZYYmA7h/////7sNan8tPW0Il2xkkQFcY+b0UWtrYmFsHNgwZYVOAGLy////
/+2VBmx7pQEbwfQIglfED/XG2bBlUOm3Euq4vot8iLn8X/j//98d3WJJLdoV83zTjGVM1PtY
YbJNziw6dAC8///2/6PiMLvUQaXfSteV2GHE0aT79NbTaulpQ/zZbjT/////RohnrdC4YNpz
LQRE5R0DM19MCqrJfA3dPHEFUKpBAif/////EBALvoYgDMkltWhXs4VvIAnUZrmf5GHODvne
XpjJ2Sn/////IpjQsLSo18cXPbNZgQ20LjtcvbetbLrAIIO47bazv5r/////DOK2A5rSsXQ5
R9Xqr3fSnRUm2wSDFtxzEgtj44Q7ZJT/////PmptDahaanoLzw7knf8JkyeuAAqxngd9RJMP
8NKjCIf/////aPIBHv7CBmldV2L3y2dlgHE2bBnnBmtudhvU/uAr04n/////WnraEMxK3Wdv
37n5+e++jkO+txfVjrBg6KPW1n6T0aH/////xMLYOFLy30/xZ7vRZ1e8pt0GtT9LNrJI2isN
2EwbCq//////9koDNmB6BEHD72DfVd9nqO+ObjF5vmlGjLNhyxqDZrz/////oNJvJTbiaFKV
dwzMA0cLu7kWAiIvJgVVvju6xSgLvbL/////klq0KwRqs1yn/9fCMc/QtYue2Swdrt5bsMJk
mybyY+z/////nKNqdQqTbQKpBgmcPzYO64VnB3ITVwAFgkq/lRR6uOL/////riuxezgbtgyb
jtKSDb7V5bfv3Hwh39sL1NLThkLi1PHG////+LPdaG6D2h/NFr6BWya59uF3sG93R7cY5lp9
jf///3BqD//KOwZmXAsBEf+eZY9prmL40/9rYcT/////bBZ44gqg7tIN11SDBE7CswM5YSZn
p/cWYNBNR2lJ23f/S/z/bj5KatGu3FrW2WYL30CC2DdTrrypxZ67/////95/z7JH6f+1MBzy
vb2KwrrKMJOzU6ajtCQFNtC6kwbX/f///80pV95Uv2fZIy56ZrO4SmHEAhtoXZQrbyo3vgu0
oSc2+htewxvfBVqN7y1LFvD//0FCQ0RFRkdISUpLTE1OT1BRUlNU2/////9YWVphYmNkZWZn
aGlqa2xtbm9wcXJzdHV2d3h5ejAxEpvu/zIzNDU2Nzg5Ky8AAP+7O9lb8f/dzwNydW50aW1l
IGVycm9yv1RH9azETE+3DQ0KxLL2A3ZJTkcOAERPTUESEbG83f5SNjAyOAgtIEdhYmx0+3ap
vc5pbmlSZml6DWhlYXA3W9vONyc3mXQ9BHUtdNtvqCBzcGFjI2Z3bH9p5LLbgDhhBm9uNzaf
geQpc3RkNXB1W2uFt3IrdmlyCyEzpWPIF9t+IyBjDGwoXzRe225TXypleFwvWAYWdrLX3OJf
MTn3Cu7mFnJlWDFzbw+Ka5MB23NjKzhGJAZChFuBZWQZV9vtIfkjN211bKx0aL9hhTCSby9s
b2NrF2tuG2w0ZLdhLgKi2reGWyFybQBwQGdyYW0g7IVQ2EptNi8wOU+NZmgpEEEqJ1PI5xos
Lis4YfY8hO9yZ3Uoc18wMmbBLrZtu25uZ4JvBXQ6EUIrnLVk5n9NLWA5YPzD22YVVmlzqkMr
KyBSnIe57/ZMaWK0cnknCi0WRWucbQ8OIRFQ1Dq+AHNt2GUuADzl4CUssSRMbWtsnUPY+G75
/1lTXQNHZXRMYUZBey8U6BZ2/MJ1cAATD4FvbTtXqWQ6m2Vzc2En8YUFeEJveEBzOTMyLmTG
3PKsPkelXKkDU12gojBnAwAup7IPr1dAIwiL+IppmqbZA+DQuKygpmmappR8aFhAzbJpmiAU
CPCJ2MQ0TdM0qJiAbFTTNE3TPCwoJCBN0zRNHBgUEAwIdG7TNAQA/IiPA/TTNE3T8Ozo5OBN
0zRN3NjU0MzENE3TNMC4sKig0zRN05yUjIR8TdM0TXRsZFxUTDRN0zREPDQsKKZzX9MgDI+H
iwPkmqZpmtzUzMC8uGmapmmwqJyUiKRrmqaEfHRoQ2BpmqYbWANQQDgspmmapiggFAwETdM0
y/yG9Ozk3NA0TdM0yMC4sKjTNF3ToJgvkIiATdM0TVxQSEA4MOYbpDv/fJTnhppm2XQDCPyF
6NC4aZqmabComIRssmmaplhELBT8hE3TNM3YwKyMfHA2TdM0ZFxQPCCE03Sm6WeEgwPUvE3T
NE2omJCIeHCm6842ZIPLVAdAAyyov2yaIATwgnNvbWV0aCvURu2zaXPab/ITsVTfC2dvCHcZ
Z4/9Rv3veW91/WUgYmFkC3Ryefph31UXc3RlYWwfZmVlbLBGbaWeJHObE97K7Vsecm4gbURl
eRphdHPu9vfBUndoeT83dGFrL2l0J7XvdqpzA2JwbAhkW7GuOtY+PzMnc9xuH3NtbGtdISxk
YwNOE8CtVAt9XWR1aNTADgcX2JttXwFELGYfbT5YtfZrlSk/YWJpgQBctY2yAEFmTQMJbnZI
F4YbIdrYsn8bdHVmZi3XZ3q9tz3XLyVzfWUXjyO8Ce7rQQtKT2WGExq2c6ZySGwTaZBVC85t
72SmIAhjTtUF7HKNA3L/Fewv9kCFM2hvcF3XdhdegAh1ZZxraVXv7MLuuidp7iBvZlYh28vm
kiVjFlNJYVy40L12um5wn3N3GWQhC/ZOYgthvVgvTTjE3FbWYwgjOIP7l3dhlFQu3CG97rFk
J1hhY2PsdCt7y76EF98/E84j0TW+w0NrbX4Kb62wfc4vgvVtLmTjiWTvMHtgJx7662ht9swu
LxTymO2H99cSE2knbaWuAG9rD91eob13cDSVWDhhbhHahM14BHkiIKMjjzz2LnBpZgdjb21z
Y3Jlb8kCznhllwsjbiMF+5vubyN0BWVzI2sjeSMtB/KPrZsTsW2rY/9wYXJ0c2+QLg9vMu+s
B9tcCfhvYmpAx5Brr6avldonGOrXbEISEKltemYPkFMZ5VOMxGNqb/sxw93CaQVk32Vic7NT
eAClGJ/IgGNSw8V1Bz6wDXwb7xFwI153Z3AIjdZ4u2lpVvR1hm3ScG8fd4GQcI5nNmJKd2IH
ita2gAgPO2MwJ8/WtoBsdKM7AG/JvUmHc3M/4xWUCYbDhhForQOir9Eatjty2nTPfSPh7XoA
rzdsa0PbeENomxNzQ+MTs642CRXPWwDfVyEhbXBu2wOXZo9lPHv7ouxDcwQwU0/Pj4DDM7Qq
43DrkU+OldIHc2hkYnh+b3LkdGJiYWSkF3dhMdrIQXNwdXdL8rHCyXJ0dpcHaHRtbDjrzghr
bANoM3TP3ZtRP2ciB1tdLUDXbJt/C18tXC96OgN5eAdN0zRNd3Z1dHNyNE3TNHFwb25t0zRN
02xramloTtM0TWdmZWRjdk16F+NtMtQE33gg9KdYwAMZBnJmYyAhWYTNHiRscxdTWQuIQKD1
EhquCy2nCiBsyWbR6JYVlxV3LoRjFrCsvhH+ao5lW9d9c0lzG6LCsqUHk71jMO412kbXeLt5
ziCxR0aLdO8ZFVctg2wIlhWCDEPspiDdC2lpzFhvLjcXI9hu7mVxAyAtpGms2FpjV31wdYi/
3DOGozlOBGP3/KloDIbVwHM0cg95NRqzw7VHMv1ztIEtCF+Kt9k/rslfV69w/GpwZ3Psi7ka
6KFfGm9UtbPNEcJUeAxw9N2BvanynHAgOSBUcyJwO2izpnD4chDgXV9iwuwZaLSrYlV39tsB
O3hwjjIx8DUuMTAwA/in7sAAgr926FVEUAAlHGsFOqYl+gYFLjJ7zyVrUwQUBgMrtwzER5Ar
T6kATi/d2PVvdgBPH1NlvkF1Nkp1bIVW2HAD9k2TD8wtW2tzBwNGjxNhU9q2aK3XC7azaERX
c1uBVnkH8h9vFy9t702BSVFVSVQHAy5pW478BgAtLQAiQyZ0/WrdNrAtVBdzZrAtRW6X/dHR
mCQ6JWU2NCJEao+uAll4aYEcc7/Xy247IJbyPSJTUFBwJSZ5VSZKHwsfw/fFL3gtelkt13Jk
s9Zci6Y4NDM1tNYYXRgXk2WRvbasKi+Tvzcvtu2BIS86Ybw7pGtsC7dyYnQ9ti3FY5joEIR2
Ijdi1Bc4ECGLE1dxHfg2Pk4vyni2Yu4I2x8zhO9NSU1FLVZPcxZu4Fr3MS4wP0S8N3RTdUNs
4UUKk28GpyKCfQUACTAA238ifj9BVEE3Q1BUIFRPHjz9JcJtCz4QVUwgRlJPTSv4B+4RAMdI
RUxP0849PsNME1yz7cn8f39jB2UTKi4qG1NPRlRXQVJFXGMFh0BIXL1zYjC3xVxDKXLiuFwM
TI4FPVOwYdcZWKJjee1t4UtvMm1s3CBreUGLRe1sat/4/0ebQ0xTSURce0U2RkI1RTIwGUUz
NS0lttv/MTFDRi05Qzg3LdRBQQM1yMRbIP43RUR9XEluimNdZs03DCSbYXNrbXNuXsstwqN7
STkbw5q9H64L+2XQgoEYiDivZBF6Io7JYmV+ZXu263sQF9tr03RABh/7WGu+O0FkbVMPSmts
UyEDBmy5M78BusE2eOA9MQIXFgMCmmawQQMHBBgFaZqmaQ0GCQcMwQYZpAgJChv2vReQC1c7
Bw9XgnSDDRATEQMSkMEG+RchNQ9BwQYbZENQM1IXBhtssFMHV19Ze2ymabrBF22rIHAcBvte
kHLHL4CzgRtksMEHgh+DhI8ZpGkGkSmeoWyQwQakb6e3n3IQBhvOH9cLGAfZe65qiQOVAQMg
kxwoIEgMIBPJABCEEIEMyISBAQzIgAwQggKZmwyBEL8AadJdVQEHLl8M0g32wAsXHQsElsgg
zYCNCI4MyIAMj5CRgAzIgJKTslEM0gOvCjeMJC8LbwyjAAWTGela8GPTNGiDBwjPNMumCdxn
Crg3mqZpuowHEVwSOBM0y6ZpDBjUZhms0zRN0xp0GzwcZdM0TRR4BHn0ZROVaZp65PwG2IfX
vUcP+MBDAgTSzw723aQPYIJ5giGvpt8HoaXN8+8ngZ/g/C9AfoD8qMFy9gjjo9qjj4H+B0CD
DIENtS9Btl8h/3dfz6LkohoA5aLoolt+of6y3+4+UQUD2l7aX1/aatoyL6lol7/T2N7g+TF+
OYNYACoKACoqCUEBVCCrAqhARgVQgYwKoAIZFEAFMmyGqGwDxBhQsU0UsAEgQ1AHx1pUbQZJ
MQpTdCkqR1SZSKJahqxXD0FNI6r/m1lCeXRlVG9XaWRlQ762UAFbFEgEUh2AbYuqNWMMVvuD
RaijDVJ0bFVudz+133tsZEpPRU1vL0NyBDV2+6xFC0Rlc2NveSJGPdhrRBBremRIYarOSrc7
bA1TCkNFAWOmQh1FC2HPks2jc1cXFrZkbVistsEURhTVCNuDZURRQLfdAUFkZCFzPUzuLApo
4bxBDdmFzdpDTbMsDVf9pKhiL1lGGNhWVO1EFlVvPq0w7MJDGHNl1jZZbe0Xe/LgCFBvMZty
cOaqyrFrGmwwT8LNHgduQSBTaXqK6uxNQg8ZU+r2zf4DVGltegha2WVJbXvLqAoXzGOg3/u6
ZyVfbEJkB2OUCG8v2fYKeiYHYsUL+ORvCM+KY3B5TW9ka287VkyATmFOQT4fMgyDbW5rmkZ5
mEYBClSdxfIKTvK4rHXLGftyUcJEzm6D3Gp2ZVMUZXCxYQx7RdUjDPMwfm8rwwN4MeVjaxJs
ILRGRjEPnjSchMNpIXRhnnC17jY7ERA5bW0fTInbrKiCIbkLReERIcZ4aQP/pAAKOOEFChdU
qpfspHtlJlBsY9mBADn8aH+DO2xtZE8QcIOf35qlIYx8QZ7RANqCu3EbZ1ORe3UoFnsE9+0P
SEtleQzvs7dsbB9BEB4Osll6hk/KDPHedFFC4cJ2TgJ3SWtQCbMq4DTbcxrrGLPbGJAdAbFw
jnRmoX08XfYgJEmXbj02tVcFHG5u27XZNsvN/yMCASz/cwIEZVmWZRAWEw8MlmVZlgk3CzQX
FLOWZVkVEW8Dpf9D/stQRUwBBABZ9DBA4AAPAgsBAjig6vcOCgMA5DrYWfdOVoANKhAPBDO5
Y98sBx8BDAPbm0s2sO8PJBAHBjeBy7McKGmMcGANaoXcBgJgHnwBF2zXcS7GdAeUTpDnINhc
2ARFIC5yuvdsDgIjDmAUJ1Ruse5CQAIuJifc4m1KBmmAdMBPG5t9pXPFSg3ze5RPAP9+Kxsw
aw2SdAEAAAAAAAAAgAT/AAAAAAAAAAAAAABgvhVQQQCNvuu//v9Xg83/6xCQkJCQkJCKBkaI
B0cB23UHix6D7vwR23LtuAEAAAAB23UHix6D7vwR2xHAAdtz73UJix6D7vwR23PkMcmD6ANy
DcHgCIoGRoPw/3R0icUB23UHix6D7vwR2xHJAdt1B4seg+78EdsRyXUgQQHbdQeLHoPu/BHb
EckB23PvdQmLHoPu/BHbc+SDwQKB/QDz//+D0QGNFC+D/fx2D4oCQogHR0l19+lj////kIsC
g8IEiQeDxwSD6QR38QHP6Uz///9eife5RAEAAIoHRyzoPAF394A/BXXyiweKXwRmwegIwcAQ
hsQp+IDr6AHwiQeDxwWJ2OLZjb4AcAEAiwcJwHRFi18EjYQwZJ0BAAHzUIPHCP+W8J0BAJWK
B0cIwHTcifl5Bw+3B0dQR7lXSPKuVf+W9J0BAAnAdAeJA4PDBOvY/5b4nQEAYem3qP7/AAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAwAAACAA
AIAOAAAAYAAAgAAAAAAAAAAAAAAAAAAAAQABAAAAOAAAgAAAAAAAAAAAAAAAAAAAAQAHBAAA
UAAAAKSgAQCoDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAZQAAAHgAAIAAAAAAAAAAAAAA
AAAAAAEABwQAAJAAAABQrQEAFAAAAAAAAAAAAAAAoHABACgAAAAgAAAAQAAAAAEAGAAAAAAA
gAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAACAgIDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA
wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAACAgID/////////////////////////////////////////////////////////////
///////////////////////////AwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgID/////
////////////////////////////////////////////////////////////////////////
///////////AwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgID/////////////////////
///////////////////////////////////////////////////////////////////AwMAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgID/////////////////////////////////////
///////////////AwMDAwMDAwMDAwMDAwMDAwMD////////////AwMAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAACAgID/////////////////////////////////////////////////////
///////////////////////////////////AwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA
gID////////////AwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA
wMDAwMD////////////AwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgID/////////////
////////////////////////////////////////////////////////////////////////
///AwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgID////////////AwMDAwMDAwMDAwMDA
wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD////////////AwMAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAACAgID/////////////////////////////////////////////
///////////////////////////////////////////AwMAAAAD/AAAAAAD/AAAAAAD/AAAA
AAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDA
wMDAwMDAwMDAwMD////////////AwMAAAAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/
AAAAAAD/AAAAAAD/AAAAAAD/AAD/////////////////////////////////////////////
///////////AwMAAAAD/AAAAAAD/////////////////////////////////////////////
////AAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMD////////////AwMAA
AAAAAAD/AAD/////AAAAAAD/AAD/////AAAAAAD/AAAAAAD///////////8AAAD/AAD/////
///////////////////////////////////////////////////AwMAAAAD/AAAAAAD///8A
AAD/AAAAAAD///8AAAD/AAAAAAD/AADAwMD/////////AAAAAADAwMDAwMDAwMDAwMDAwMDA
wMDAwMDAwMDAwMDAwMDAwMD////////////AwMAAAAAAAAD/AAD/////AAAAAAD/AAD/////
AAAAAAD/AAAAAACAgID///////8AAAD/AAD/////////////////////////////////////
///////////////////AwMAAAAD/AAAAAAD///8AAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAA
AAD/////////AAAAAADAwMDAwMD////////AwMDAwMDAwMDAwMDAwMDAwMDAwMD/////////
///AwMAAAAAAAAD/AAD/////AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AADAwMD///8AAAD/
AAD////////////////AwMDAwMDAwMD////AwMDAwMDAwMD////////////AwMAAAAD/AAAA
AAD///8AAAD/AAD/////AAAAAAD/AAD/////AAAAAACAgID/////AAAAAADAwMDAwMD/////
///AwMDAwMD////////////////AwMD////////////AwMAAAAAAAAD/AAAAAAD/AAAAAAD/
//8AAAD/AAAAAAD///8AAAD/AAAAAAD///8AAAD/AAD////////////////AwMDAwMDAwMD/
///////AwMDAwMD////////////AwMAAAAD/AAAAAAD/AAAAAAD/AAD/////AAAAAAD/AAD/
////AAAAAAD/AAAAAAD/AAAAAADAwMDAwMD////////AwMD////////////////////AwMD/
///////////AwMAAAAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/
AAAAAAD/AAD////////////////AwMDAwMD///////+AgIAAAAAAAAAAAAAAAAAAAAAAAAAA
AAD/AAAAAAD/////////////////////////////////////////////////AAAAAAD/////
///////////AwMDAwMDAwMDAwMCAgID////////////AwMCAgIAAAAAAAAAAAAD/AAD/////
//////////////////////////////////////////8AAAD/AAD////////////////AwMDA
wMDAwMDAwMCAgID////////AwMCAgIAAAAAAAAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAA
AAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD///////////////////////////////+AgID/
///AwMCAgIAAAAAAAAAAAAAAAAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/AAAAAAD/
AAAAAAD/AAAAAAD/AAD///////////////////////////////+AgIDAwMCAgIAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAgID/////////////////////////////
//////////////////////////////////+AgICAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAACAgID/////////////////////////////////////////////
//////////////////+AgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA
gICAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAD//////gAAAP4AAAD+AAAA/gAAAP4AAAD+AAAA/gAAAP4AAAD+AAAA
/gAAAP4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAABAAAAAwAAAAcAAAAP/gAAH/4AAD/+AAB//////0h9AQAAAAEAAQAgIAAAAQAYAKgM
AAABAAAAAAAAAAAAAAAAACiuAQDwrQEAAAAAAAAAAAAAAAAANa4BAACuAQAAAAAAAAAAAAAA
AABCrgEACK4BAAAAAAAAAAAAAAAAAE+uAQAQrgEAAAAAAAAAAAAAAAAAWq4BABiuAQAAAAAA
AAAAAAAAAABmrgEAIK4BAAAAAAAAAAAAAAAAAAAAAAAAAAAAcK4BAH6uAQCOrgEAAAAAAJyu
AQAAAAAAqq4BAAAAAAC8rgEAAAAAAMiuAQAAAAAAAwAAgAAAAABLRVJORUwzMi5ETEwAQURW
QVBJMzIuZGxsAGlwaGxwYXBpLmRsbABVU0VSMzIuZGxsAFdJTklORVQuZGxsAFdTMl8zMi5k
bGwAAExvYWRMaWJyYXJ5QQAAR2V0UHJvY0FkZHJlc3MAAEV4aXRQcm9jZXNzAAAAUmVnQ2xv
c2VLZXkAAABHZXROZXR3b3JrUGFyYW1zAAB3c3ByaW50ZkEAAABJbnRlcm5ldEdldENvbm5l
Y3RlZFN0YXRlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUEsBAhQACgAAAAAAElJTMF1usCIAVgAAAFYAAAoA
AAAAAAAAAAAgAAAAAAAAAG9iamVjdC5jb21QSwUGAAAAAAEAAQA4AAAAKFYAAAAA

--55220562--




================================================================================

From: "support () talk21 ! com" <support () talk21 ! com>
To: debian-user
Subject: RE: warning
Date: Fri, 05 Mar 2004 23:18:23 +0000
Message-ID: <20040306011000.63634EBC3 () murphy ! debian ! org>
--------------------
Thank you for contacting the technical helpdesk. We have received your email and our support representative will respond to your enquiry within 5 days.
<!-- $$NAS 30$$ -->


-- 
To UNSUBSCRIBE, email to debian-user-request@lists.debian.org 
with a subject of "unsubscribe". Trouble? Contact listmaster@lists.debian.org

================================================================================

From: aadvise () wxs ! nl
To: netbsd-tech-net
Subject: Re: warning
Date: Tue, 09 Mar 2004 10:44:10 +0000
Message-ID: <0HUB00MGF1TMIB () po08 ! wxs ! nl>
--------------------
Dit email adres is vervallen.

Voor meer inforatie kunt u contact opnemen met 

Aadvise Electronics BV


================================================================================

From: Autoresponder <noreply () sigsoftware ! com>
To: debian-devel
Subject: Re: warning
Date: Mon, 19 Apr 2004 04:23:53 +0000
Message-ID: <20040419082353.77217.qmail () qs479 ! pair ! com>
--------------------
PLEASE DO NOT REPLY TO noreply@sigsoftware.com - MAIL RECEIVED AT THAT
ADDRESS WILL BE DISCARDED. INSTEAD, PLEASE READ THE MESSAGE BELOW.

-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

Thank you for contacting Sig Software.

Unfortunately, due to the unbearable volume of spam email received (about 
200 messages per day), all email addresses which have appeared on our web 
site have been deprecated. The message you sent has been discarded, and 
must be resent to one of our new addresses as listed below.

Please append @sigsoftware.com to each address prefix:

* sales - for pre-sales information or pricing enquiries.
* comment - for comments or suggestions on our products.
* techsup - for technical support.
* license - to enquire after or be resent a license code.
* info - for all other issues.

We apologize for the inconvenience caused by this change - sadly, the 
abuses caused by junk mailers are beyond our control.

Sig Software
http://www.sigsoftware.com/


-- 
To UNSUBSCRIBE, email to debian-devel-REQUEST@lists.debian.org
with a subject of "unsubscribe". Trouble? Contact listmaster@lists.debian.org

================================================================================

From: btamir () netvision ! net ! il
To: konq-bugs
Subject: Re: warning
Date: Sat, 24 Apr 2004 14:55:38 +0000
Message-ID: <0HWO00E03K4QQ1 () msg2s ! netvision ! net ! il>
--------------------
Hi, this mailbox is closed, call me and i`ll tell you the new one. Sorry. Tamir Barak.

_______________________________________________
Konq-bugs mailing list
Konq-bugs@mail.kde.org
https://mail.kde.org/mailman/listinfo/konq-bugs
================================================================================

From: Autoresponder <contact () dvdidle ! com>
To: openbsd-www
Subject: Re: warning
Date: Mon, 10 May 2004 11:01:49 +0000
Message-ID: <20040510150149.89504.qmail () qs657 ! pair ! com>
--------------------
Hi,

Please send your e-mail to fengtao(at)dvdidle.com instead of contact@dvdidle.com, thanks.

Best Regards,
Fengtao

================================================================================

From: Alex <alex () squigly ! net>
To: tomcat-user
Subject: Re: warning
Date: Tue, 25 May 2004 18:11:30 +0000
Message-ID: <Pine.LNX.4.30.0405251411190.13174-100000 () shell ! squigly ! com>
--------------------

again?  :)

On Tue, 25 May 2004 tomcat-user@jakarta.apache.org wrote:

> Date: Tue, 25 May 2004 12:21:42 -0500
> From: tomcat-user@jakarta.apache.org
> To: tomcat-user@jakarta.apache.org
> Subject: warning
>
> you are naked in this document!


---------------------------------------------------------------------
To unsubscribe, e-mail: tomcat-user-unsubscribe@jakarta.apache.org
For additional commands, e-mail: tomcat-user-help@jakarta.apache.org

================================================================================

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: warning
Date: Thu, 09 Sep 2004 15:38:05 +0000
Message-ID: <20040909153805.GB29383 () 64m ! dyndns ! org>
--------------------
Good idea. I am all for it.

Chris


On Thu, Sep 09, 2004 at 02:05:13PM -0400, Morten Welinder wrote:
> 
> If we're going to fiddle with warn, can we perhaps please introduce
> a version that prints "error" instead also?  Right now I find myself
> calling warn for things that are for invalid C programs and I don't
> like that.
> 
> we have...				I want...
> --------------------------------------------------------------------
> info					Same
>   (no prefix)
>   (no exit)
> 
> warn					warning
>   "warning: "				  "warning: "
>   (no exit)				  (no exit)
> 
> -					error
> 					  "error"
> 					  (no exit)
> 
> error					error_die
>   "error: "				  "error: "
>   exit 1				  exit 1
> 
> die					Same
>   (no pos)
>   (no prefix)
>   exit 1
> 
> 
> "info" would be for whatever it is now.
> "warning" would be for warnings about valid programs.
> "error" would be for invalid program.
> "error_die" would be for invalid program messed up so badly that we
>   cannot continue.
> "die" is for problems not directly related to the program.
> 
> Morten
> -
> To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
> the body of a message to majordomo@vger.kernel.org
> More majordomo info at  http://vger.kernel.org/majordomo-info.html
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: terra () gnome ! org (Morten Welinder)
To: linux-sparse
Subject: warning
Date: Thu, 09 Sep 2004 18:05:13 +0000
Message-ID: <20040909180513.5B0491422D5E () darter ! rentec ! com>
--------------------

If we're going to fiddle with warn, can we perhaps please introduce
a version that prints "error" instead also?  Right now I find myself
calling warn for things that are for invalid C programs and I don't
like that.

we have...				I want...
--------------------------------------------------------------------
info					Same
  (no prefix)
  (no exit)

warn					warning
  "warning: "				  "warning: "
  (no exit)				  (no exit)

-					error
					  "error"
					  (no exit)

error					error_die
  "error: "				  "error: "
  exit 1				  exit 1

die					Same
  (no pos)
  (no prefix)
  exit 1


"info" would be for whatever it is now.
"warning" would be for warnings about valid programs.
"error" would be for invalid program.
"error_die" would be for invalid program messed up so badly that we
  cannot continue.
"die" is for problems not directly related to the program.

Morten
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: MAILER-DAEMON () kagoya ! net (Mail Delivery System)
To: lilypond-user
Subject: Re: warning
Date: Mon, 18 Oct 2004 23:05:31 +0000
Message-ID: <20041018230531.286A4BF3D4 () errmail ! kagoya ! net>
--------------------
Invalid e-mail address.



================================================================================

From: GRE <gre-info () ets ! org>
To: bash-bug
Subject: Re: warning
Date: Mon, 15 Nov 2004 14:33:41 +0000
Message-ID: <5610064.1100529220398.JavaMail.gre-info () ets ! org>
--------------------
------=_Part_59683_538378.1100529220398
Content-Type: text/plain; charset=iso-8859-1
Content-Transfer-Encoding: 7bit

Thank you for contacting the GRE Program.

A representative will respond to you in approximately 3 - 5 business days.

Please do not send duplicate messages. Sending duplicate messages will increase the time required to respond to you inquiry   

TRACKING NUMBER: A00002874284-00013184670

------=_Part_59683_538378.1100529220398--




================================================================================


################################################################################

=== Thread: what does this warning mean? ===

From: Christopher Li <sparse () chrisli ! org>
To: linux-sparse
Subject: Re: what does this warning mean?
Date: Wed, 08 Sep 2004 14:46:07 +0000
Message-ID: <20040908144607.GA11830 () 64m ! dyndns ! org>
--------------------
On Wed, Sep 08, 2004 at 11:40:11AM -0600, Ray Lehtiniemi wrote:
> 
> hi all
> 
> sparse newbie here, trying to clean up one of my drivers...
> 
> i get this warning:
> 
> drivers/char/watchdog/ep93xx_wdt.c:132:23: warning: incorrect type in argument 1 (different address spaces)
> drivers/char/watchdog/ep93xx_wdt.c:132:23:    expected void [noderef] *to<asn:1>
> drivers/char/watchdog/ep93xx_wdt.c:132:23:    got struct watchdog_info *<noident>
> 
> 
> from this code:
> 
>    123  static int
>    124  ep93xx_wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
>    125                          unsigned long arg)
>    126  {
>    127          int ret = -ENOIOCTLCMD;
>    128
>    129          switch (cmd) {
>    130          case WDIOC_GETSUPPORT:
>    131                  ret = copy_to_user((struct watchdog_info *)arg, &ident,
                                             ^^^^^^^^^^^^^^^^^^^^^^^^
Try to change it as "(struct watchdog_info __user *).

The problem is you convert the type of arg to (struct watchdog_info *)
and  you did not specify it is a user space pointer in this convert.
But copy_to_user expect the first argument is a user space pointer.


Chris

-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ray Lehtiniemi <rayl () mail ! com>
To: linux-sparse
Subject: what does this warning mean?
Date: Wed, 08 Sep 2004 17:40:11 +0000
Message-ID: <20040908174011.GA32556 () mail ! com>
--------------------

hi all

sparse newbie here, trying to clean up one of my drivers...

i get this warning:

drivers/char/watchdog/ep93xx_wdt.c:132:23: warning: incorrect type in argument 1 (different address spaces)
drivers/char/watchdog/ep93xx_wdt.c:132:23:    expected void [noderef] *to<asn:1>
drivers/char/watchdog/ep93xx_wdt.c:132:23:    got struct watchdog_info *<noident>


from this code:

   123  static int
   124  ep93xx_wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
   125                          unsigned long arg)
   126  {
   127          int ret = -ENOIOCTLCMD;
   128
   129          switch (cmd) {
   130          case WDIOC_GETSUPPORT:
   131                  ret = copy_to_user((struct watchdog_info *)arg, &ident,
   132                                     sizeof(ident)) ? -EFAULT : 0;
   133                  break;


can someone please clue me in on what is wrong, and how to fix?

thanks!


ps: there are a lot of signed/unsigned compile warnings for sparse
itself.  i've added a whole pile of "unsigned" keywords to my local
sparse bk tree.  would such a patch be applied if i sent it?

thanks

-- 
----------------------------------------------------------------------
     Ray L   <rayl@mail.com>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: what does this warning mean?
Date: Wed, 08 Sep 2004 17:52:46 +0000
Message-ID: <Pine.LNX.4.58.0409081044440.5912 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Sep 2004, Ray Lehtiniemi wrote:
> 
> sparse newbie here, trying to clean up one of my drivers...
> 
> i get this warning:
> 
> drivers/char/watchdog/ep93xx_wdt.c:132:23: warning: incorrect type in argument 1 (different address spaces)

A function was invoced with the first argument not matching what it 
expected, and the thing in parenthesis gives you a "overview" of what 
sparse didn't like about the match (there may be _multiple_ reasons for 
the mismatch, so this comment is just a shorthand of the first thing 
sparse noticed).

It's followed by a more complete type-printout to explain why sparse 
didn't like it:

> drivers/char/watchdog/ep93xx_wdt.c:132:23:    expected void [noderef] *to<asn:1>

Sparse expected a "void *" that points to address space 1 (<asn:1>) which
is user space. In other words, it was expecting a user pointer.

The [noderef] thing is just an internal sparse type annotation, you can
generally ignore these [xxxx] type modifiers, they are really just
internal sparse annotations.

> drivers/char/watchdog/ep93xx_wdt.c:132:23:    got struct watchdog_info *<noident>

But instead of a user pointer it got a "struct watchdog_info *", which is 
just a regular kernel pointer.

> from this code:
> 
>    123  static int
>    124  ep93xx_wdt_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
>    125                          unsigned long arg)
>    126  {
>    127          int ret = -ENOIOCTLCMD;
>    128
>    129          switch (cmd) {
>    130          case WDIOC_GETSUPPORT:
>    131                  ret = copy_to_user((struct watchdog_info *)arg, &ident,
>    132                                     sizeof(ident)) ? -EFAULT : 0;

Yup. "copy_to_user()" obviously wants a user pointer, but it's given a 
regular kernel pointer. In this case, the fix is to tell sparse that the 
"arg" thing is really a _user_ pointer, so you can fix it with a simple 
change to the cast: use "(struct watchdog_info __user *) arg" instead.

> ps: there are a lot of signed/unsigned compile warnings for sparse
> itself.

I consider the gcc warnings about signed/unsigned to be total crap. They 
sometimes show real problems, but more often they are just nothing but 
total noise that makes no sense at all.

> i've added a whole pile of "unsigned" keywords to my local sparse bk
> tree.  would such a patch be applied if i sent it?

Unlikely as a "wholesale" patch, but I'll happily take patches that
explain the reason (and no, "gcc is being a f*cking *ss" is not a reason). 
Sometimes the gcc warnings are valid. In my opinion, 90% of them are pure 
noise, and getting rid of the warning makes the source code less 
readable and/or less obvious, which is a sure sign that the warning is 
bogus.

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ray Lehtiniemi <rayl () mail ! com>
To: linux-sparse
Subject: Re: what does this warning mean?
Date: Wed, 08 Sep 2004 20:10:42 +0000
Message-ID: <20040908201042.GB32556 () mail ! com>
--------------------
On Wed, Sep 08, 2004 at 10:52:46AM -0700, Linus Torvalds wrote:
> 
> > drivers/char/watchdog/ep93xx_wdt.c:132:23:    expected void [noderef] *to<asn:1>
> 
> Sparse expected a "void *" that points to address space 1 (<asn:1>) which
> is user space. In other words, it was expecting a user pointer.

okay, and that comes from <include/linux/compiler.h> definition of __user?



> Yup. "copy_to_user()" obviously wants a user pointer, but it's given a 
> regular kernel pointer. In this case, the fix is to tell sparse that the 
> "arg" thing is really a _user_ pointer, so you can fix it with a simple 
> change to the cast: use "(struct watchdog_info __user *) arg" instead.

done, thanks


> > i've added a whole pile of "unsigned" keywords to my local sparse bk
> > tree.  would such a patch be applied if i sent it?
> 
> Unlikely as a "wholesale" patch, but I'll happily take patches that
> explain the reason (and no, "gcc is being a f*cking *ss" is not a reason). 

well, i guess all the changes i've made boil down to this rationale:

   if the variable will never be less than zero, then declare it as
   unsigned int so the compiler knows that fact too.

this applies to everything from 'target.h:int bits_in_foo' (since it
makes no sense to have less than zero bits in a foo) to 
'target.h:int foo_alignment' (since it makes no sense to align to a
negative number of bits) to many loop variables 'int i' (since the loop
just walks over a zero-indexed array) to many length vars 'int len'
(since lengths less than zero aren't usually valid)

do you agree with that rationale?


thanks

-- 
----------------------------------------------------------------------
     Ray L   <rayl@mail.com>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Linus Torvalds <torvalds () osdl ! org>
To: linux-sparse
Subject: Re: what does this warning mean?
Date: Wed, 08 Sep 2004 21:43:40 +0000
Message-ID: <Pine.LNX.4.58.0409081431270.5912 () ppc970 ! osdl ! org>
--------------------


On Wed, 8 Sep 2004, Ray Lehtiniemi wrote:
> 
> well, i guess all the changes i've made boil down to this rationale:
> 
>    if the variable will never be less than zero, then declare it as
>    unsigned int so the compiler knows that fact too.

That's not a good rationale.

In fact, in C, the "unsigned" types don't help the compiler know it's 
never negative, as much as they force the compiler to be _very_ careful 
when underflowing/overflowing. They are defined to have modulo-2**n 
arithmetic, and that means that the compiler is _unable_ to do certain 
optimizations on them.

So as a rule of thumb, you should consider the normal signed types 
_faster_.

Just a silly example: a C compiler is allowed to optimize

	if (i+5 > MAXVAL)
		..

into

	if (i > MAXVAL-5)

(which is obviously one less addition, since MAXVAL-5 is a constant value)  
if "i" is a regular "int", because the nasty border condition of overflow
is undefined anyway.

In contrast, if "i" is unsigned, the compiler has to be much more careful, 
since "i+5" might overflow and be _less_ than MAXVAL, even though "i" 
itself is larger than MAXVAL.

So if you know that your values are all "well defined", and obviously fit 
in "int", you should use "int". It's not only long-term C practice, it's 
the way God intended C to work.

So for example, a normal loop from 1..n should be written as

	int i;

	for (i = 1 ; i < n; i++)
		...

and using "unsigned" there is totally unnatural.

So "unsigned int" has nothing to do with "all the values are positive". A
normal constant "5" is obviously a _signed_ integer from a type
perspective, even though it very clearly is a positive value. The fact is, 
"int" as a type is preferable to "unsigned int".

When you see "unsigned", you should usually think "ok, this is something 
special".

> this applies to everything from 'target.h:int bits_in_foo' (since it
> makes no sense to have less than zero bits in a foo)

Well, actually, we use -1 as a "no size" marker in other places...

		Linus
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================

From: Ray Lehtiniemi <rayl () mail ! com>
To: linux-sparse
Subject: Re: what does this warning mean?
Date: Thu, 09 Sep 2004 04:31:40 +0000
Message-ID: <20040909043140.GA3156 () mail ! com>
--------------------
On Wed, Sep 08, 2004 at 02:43:40PM -0700, Linus Torvalds wrote:
> 
> 
> On Wed, 8 Sep 2004, Ray Lehtiniemi wrote:
> > 
> > well, i guess all the changes i've made boil down to this rationale:
> > 
> >    if the variable will never be less than zero, then declare it as
> >    unsigned int so the compiler knows that fact too.
> 
> That's not a good rationale.

[snip details]

thanks for the detailed explanation, that helped a lot.


incidentally, i compiled sparse at home with a newer gcc (3.3.3 in suse
9.1, vs 3.3 prerelease in suse 8.2), and the newer gcc doesn't emit
the unsigned warnings anymore. so, it seems my original question is
moot anyway :-)


-- 
----------------------------------------------------------------------
     Ray L   <rayl@mail.com>
-
To unsubscribe from this list: send the line "unsubscribe linux-sparse" in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
================================================================================


################################################################################

