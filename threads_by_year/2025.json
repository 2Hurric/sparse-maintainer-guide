{
  "year": "2025",
  "stats": {
    "total_threads": 63,
    "total_messages": 580,
    "categories": {
      "sparse_internals": 16,
      "compiler_compat": 19,
      "type_system": 10,
      "general": 11,
      "rfc_proposals": 3,
      "kernel_integration": 2,
      "address_space": 2
    }
  },
  "threads": [
    {
      "subject": "[PATCH v2] sparse/dissect: don't miss inline functions when !dissect_show_all_symbols",
      "normalized_subject": "sparse/dissect: don't miss inline functions when !dissect_show_all_symbols",
      "message_count": 1,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-12-31T16:16:19+00:00",
      "last_date": "2025-12-31T16:16:19+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176720057022664.mbox",
          "message_id": "<aVVMU0Vu-t6SN4g- () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH v2] sparse/dissect: don't miss inline functions when !dissect_show_all_symbols",
          "date": "2025-12-31 16:16:19+00:00",
          "date_str": "Wed, 31 Dec 2025 16:16:19 +0000",
          "body": "parse_function_body() doesn't do add_symbol(decl) if MOD_INLINE, this\nmeans that dissect/semind can't see the definitions of inline functions\nin translation_unit_used_list.\n\nThis change is not really needed if dissect_show_all_symbols == 1, in\nthis case do_file() inspects file_scope/global_scope.\n\nTest-case:\n\n\t$ cat -n INLINE.c\n\t     1\tstatic inline void i_func1(void)\n\t     2\t{\n\t     3\t\tunkown();\n\t     4\t}\n\t     5\tstatic inline void *i_func2(void)\n\t     6\t{\n\t     7\t\treturn i_func1;\n\t     8\t}\n\t     9\n\t    10\tvoid func(void)\n\t    11\t{\n\t    12\t\ti_func2();\n\t    13\t}\n\nBefore this patch:\n\n\t$ ./test-dissect INLINE.c\n\n\t  10:6                    def   f func                             void ( ... )\n\t  12:9   func             --r   f i_func2                          void *( ... )\n\nWith this patch:\n\n\t$ ./test-dissect INLINE.c\n\n\t  10:6                    def   f func                             void ( ... )\n\t   5:21                   def   f i_func2                          void *( ... )\n\t   1:20                   def   f i_func1                          void ( ... )\n\t   3:9   i_func1          --r   f unkown                           bad type\n\t   7:16  i_func2          r--   f i_func1                          void ( ... )\n\t  12:9   func             --r   f i_func2                          void *( ... )\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n dissect.c | 9 ++++++++-\n 1 file changed, 8 insertions(+), 1 deletion(-)\n\ndiff --git a/dissect.c b/dissect.c\nindex a825bb30..b9d4adc4 100644\n--- a/dissect.c\n+++ b/dissect.c\n@@ -59,6 +59,7 @@ static void do_sym_list(struct symbol_list *list);\n \n static struct symbol\n \t*base_type(struct symbol *sym),\n+\t*do_symbol(struct symbol *sym),\n \t*do_initializer(struct symbol *type, struct expression *expr),\n \t*do_expression(usage_t mode, struct expression *expr),\n \t*do_statement(usage_t mode, struct statement *stmt);\n@@ -225,6 +226,12 @@ static void examine_sym_node(struct symbol *node, struct symbol *parent)\n \n \t\tcase SYM_FN:\n \t\t\tnode->kind = 'f';\n+\t\t\tif (node->ctype.modifiers & MOD_INLINE) {\n+\t\t\t\tstruct symbol *dctx = dissect_ctx;\n+\t\t\t\tdissect_ctx = NULL;\n+\t\t\t\tdo_symbol(node);\n+\t\t\t\tdissect_ctx = dctx;\n+\t\t\t}\n \t\t\tnode = base;\n \t\t\tbreak;\n \n@@ -621,7 +628,7 @@ static inline bool is_typedef(struct symbol *sym)\n \treturn (sym->namespace == NS_TYPEDEF);\n }\n \n-static inline struct symbol *do_symbol(struct symbol *sym)\n+static struct symbol *do_symbol(struct symbol *sym)\n {\n \tstruct symbol *type = base_type(sym);\n \tstruct symbol *dctx = dissect_ctx;\n-- \n2.52.0\n\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH] sparse/dissect: change do_file() to use __sparse()",
      "normalized_subject": "sparse/dissect: change do_file() to use __sparse()",
      "message_count": 1,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-12-28T12:55:15+00:00",
      "last_date": "2025-12-28T12:55:15+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176692934128522.mbox",
          "message_id": "<aVEos-vrx34olo6s () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/dissect: change do_file() to use __sparse()",
          "date": "2025-12-28 12:55:15+00:00",
          "date_str": "Sun, 28 Dec 2025 12:55:15 +0000",
          "body": "rather than do sparse_keep_tokens/clear_token_alloc by hand.\n\ndissect/semind doesn't need/use tokens, we can safely do\ndrop_all_allocations(token_allocator) after parsing.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n dissect.c | 16 ++++------------\n 1 file changed, 4 insertions(+), 12 deletions(-)\n\ndiff --git a/dissect.c b/dissect.c\nindex 62f927c5..55e76846 100644\n--- a/dissect.c\n+++ b/dissect.c\n@@ -681,14 +681,10 @@ static inline bool valid_namespace(enum namespace ns)\n \treturn (ns == NS_TYPEDEF || ns == NS_MACRO || ns == NS_UNDEF || ns == NS_STRUCT || ns == NS_SYMBOL);\n }\n \n-static void do_file(char *file)\n+static void do_file(struct symbol_list *res)\n {\n-\tstruct symbol_list *res = sparse_keep_tokens(file);\n-\n-\tif (!dissect_show_all_symbols) {\n-\t\tdo_sym_list(res);\n-\t\tgoto end;\n-\t}\n+\tif (!dissect_show_all_symbols)\n+\t\treturn do_sym_list(res);\n \n \tDO_LIST(file_scope->symbols, sym,\n \t\tif (input_streams[sym->pos.stream].fd != -1 && valid_namespace(sym->namespace)) {\n@@ -719,10 +715,6 @@ static void do_file(char *file)\n \t\t\tdo_symbol(sym);\n \t\t}\n \t);\n-\n-end:\n-\t/* Drop the tokens for this file after parsing */\n-\tclear_token_alloc();\n }\n \n void dissect(struct reporter *rep, struct string_list *filelist)\n@@ -730,5 +722,5 @@ void dissect(struct reporter *rep, struct string_list *filelist)\n \tdissect_mode = 1;\n \treporter = rep;\n \n-\tDO_LIST(filelist, file, do_file(file));\n+\tDO_LIST(filelist, file, do_file(__sparse(file)));\n }\n-- \n2.52.0\n\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH 2/2] sparse/semind: robustify parse_cmdline_add()",
      "normalized_subject": "sparse/semind: robustify parse_cmdline_add()",
      "message_count": 2,
      "participants": [
        "Alexey Gladkov",
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-12-26T14:32:24+00:00",
      "last_date": "2025-12-27T15:58:08+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176676234411713.mbox",
          "message_id": "<aU6ceAt7RhlwGJ9- () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH 2/2] sparse/semind: robustify parse_cmdline_add()",
          "date": "2025-12-26 14:32:24+00:00",
          "date_str": "Fri, 26 Dec 2025 14:32:24 +0000",
          "body": "\"semind add -ftabstop=8 ...\" works as expected, but (for example)\n\"semind add --param=dissect-show-all-symbols ...\" doesn't, this\narg is not passed to sparse_initialize().\n\nBecause in the latter case getopt_long() increments optind when it\nsees --param=dissect-show-all-symbols. I have no idea if getopt_long()\nis correct or not, but lets change parse_cmdline_add() so that it doesn't\ndepend on getopt_long()'s behaviour.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n semind.c | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/semind.c b/semind.c\nindex fa084e04..e9708444 100644\n--- a/semind.c\n+++ b/semind.c\n@@ -298,7 +298,7 @@ static void parse_cmdline_add(int argc, char **argv)\n \t\t{ \"help\", no_argument, NULL, 'h' },\n \t\t{ NULL }\n \t};\n-\tint c;\n+\tint parsed = optind, c;\n \n \topterr = 0;\n \n@@ -315,6 +315,7 @@ static void parse_cmdline_add(int argc, char **argv)\n \t\t\tcase '?':\n \t\t\t\tgoto done;\n \t\t}\n+\t\tparsed = optind;\n \t}\n done:\n \tif (optind == argc) {\n@@ -327,9 +328,8 @@ done:\n \tdissect_show_all_symbols = 1;\n \n \t// step back since sparse_initialize will ignore argv[0].\n-\toptind--;\n-\n-\tsparse_initialize(argc - optind, argv + optind, &semind_filelist);\n+\tparsed--;\n+\tsparse_initialize(argc - parsed, argv + parsed, &semind_filelist);\n }\n \n static void parse_cmdline_rm(int argc, char **argv)\n-- \n2.52.0\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176685388326621.mbox",
          "message_id": "<aVACEIgAFSJgUJYj () example ! org>",
          "author_name": "Alexey Gladkov",
          "author_email": "legion () kernel ! org",
          "subject": "Re: [PATCH 2/2] sparse/semind: robustify parse_cmdline_add()",
          "date": "2025-12-27 15:58:08+00:00",
          "date_str": "Sat, 27 Dec 2025 15:58:08 +0000",
          "body": "On Fri, Dec 26, 2025 at 03:32:24PM +0100, Oleg Nesterov wrote:\n> \"semind add -ftabstop=8 ...\" works as expected, but (for example)\n> \"semind add --param=dissect-show-all-symbols ...\" doesn't, this\n> arg is not passed to sparse_initialize().\n> \n> Because in the latter case getopt_long() increments optind when it\n> sees --param=dissect-show-all-symbols. I have no idea if getopt_long()\n> is correct or not, but lets change parse_cmdline_add() so that it doesn't\n> depend on getopt_long()'s behaviour.\n> \n> Signed-off-by: Oleg Nesterov <oleg@redhat.com>\n\nHm. This behavior seems very strange to me. I couldn't find an explanation\nfor it in getopt_long(3) man page. But I tried this sample with glibc and\nmusl, and the behavior was the same and does not depend on POSIXLY_CORRECT\n\n  #include <stdio.h>\n  #include <getopt.h>\n  \n  int main(int argc, char **argv)\n  {\n          char c;\n          opterr = 0;\n  \n          while ((c = getopt_long(argc, argv, \"\", NULL, NULL)) != -1) {\n                  if (c != '?')\n                          printf(\"unexpected known option: %c\\n\", c);\n                  break;\n          }\n          printf(\"optind=%d\\n\", optind);\n          return 0;\n  }\n\nHere are the results from both libc:\n\n  for o in --f \"--f f\" -f -ff \"-f f\"; do printf '%s\\t' \"args='$o'\"; ./z-musl $o; done\n  args='--f'\toptind=1\n  args='--f f'\toptind=1\n  args='-f'\toptind=2\n  args='-ff'\toptind=1\n  args='-f f'\toptind=2\n\nSo it seems that this is common behavior for different libc's.\nThank you so much for finding this and fixing it!\n\nAcked-by: Alexey Gladkov <legion@kernel.org>\n\n> ---\n>  semind.c | 8 ++++----\n>  1 file changed, 4 insertions(+), 4 deletions(-)\n> \n> diff --git a/semind.c b/semind.c\n> index fa084e04..e9708444 100644\n> --- a/semind.c\n> +++ b/semind.c\n> @@ -298,7 +298,7 @@ static void parse_cmdline_add(int argc, char **argv)\n>  \t\t{ \"help\", no_argument, NULL, 'h' },\n>  \t\t{ NULL }\n>  \t};\n> -\tint c;\n> +\tint parsed = optind, c;\n>  \n>  \topterr = 0;\n>  \n> @@ -315,6 +315,7 @@ static void parse_cmdline_add(int argc, char **argv)\n>  \t\t\tcase '?':\n>  \t\t\t\tgoto done;\n>  \t\t}\n> +\t\tparsed = optind;\n>  \t}\n>  done:\n>  \tif (optind == argc) {\n> @@ -327,9 +328,8 @@ done:\n>  \tdissect_show_all_symbols = 1;\n>  \n>  \t// step back since sparse_initialize will ignore argv[0].\n> -\toptind--;\n> -\n> -\tsparse_initialize(argc - optind, argv + optind, &semind_filelist);\n> +\tparsed--;\n> +\tsparse_initialize(argc - parsed, argv + parsed, &semind_filelist);\n>  }\n>  \n>  static void parse_cmdline_rm(int argc, char **argv)\n> -- \n> 2.52.0\n> \n> \n\n-- \nRgrds, legion\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH 1/2] sparse/semind: add the new --param=dissect-show-compiled option",
      "normalized_subject": "sparse/semind: add the new --param=dissect-show-compiled option",
      "message_count": 2,
      "participants": [
        "Alexey Gladkov",
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-12-26T14:31:56+00:00",
      "last_date": "2025-12-27T15:58:45+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176676231611700.mbox",
          "message_id": "<aU6cXFyfwtD9GMYa () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH 1/2] sparse/semind: add the new --param=dissect-show-compiled option",
          "date": "2025-12-26 14:31:56+00:00",
          "date_str": "Fri, 26 Dec 2025 14:31:56 +0000",
          "body": "parse_cmdline_add() sets dissect_show_all_symbols = 1 unconditionally\nand currently it is not possible to clear this option.\n\nWe could simply remove this line; users could use\n\"semind add --param=dissect-show-all-symbols,\" but this would break\nexisting setups.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n options.c | 2 ++\n semind.c  | 4 ++--\n 2 files changed, 4 insertions(+), 2 deletions(-)\n\ndiff --git a/options.c b/options.c\nindex 0f207e80..dbe0349f 100644\n--- a/options.c\n+++ b/options.c\n@@ -976,6 +976,8 @@ static char **handle_param(char *arg, char **next)\n \n \tif (!strcmp(value, \"dissect-show-all-symbols\"))\n \t\tdissect_show_all_symbols = 1;\n+\telse if (!strcmp(value, \"dissect-show-compiled\"))\n+\t\tdissect_show_all_symbols = 0;\n \n \treturn next;\n }\ndiff --git a/semind.c b/semind.c\nindex ad8003ba..fa084e04 100644\n--- a/semind.c\n+++ b/semind.c\n@@ -322,14 +322,14 @@ done:\n \t\tshow_usage();\n \t}\n \n-\t// enforce tabstop\n+\t// enforce defaults\n \ttabstop = 1;\n+\tdissect_show_all_symbols = 1;\n \n \t// step back since sparse_initialize will ignore argv[0].\n \toptind--;\n \n \tsparse_initialize(argc - optind, argv + optind, &semind_filelist);\n-\tdissect_show_all_symbols = 1;\n }\n \n static void parse_cmdline_rm(int argc, char **argv)\n-- \n2.52.0\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176685392026662.mbox",
          "message_id": "<aVACNT1JYz4u3X7h () example ! org>",
          "author_name": "Alexey Gladkov",
          "author_email": "legion () kernel ! org",
          "subject": "Re: [PATCH 1/2] sparse/semind: add the new --param=dissect-show-compiled option",
          "date": "2025-12-27 15:58:45+00:00",
          "date_str": "Sat, 27 Dec 2025 15:58:45 +0000",
          "body": "On Fri, Dec 26, 2025 at 03:31:56PM +0100, Oleg Nesterov wrote:\n> parse_cmdline_add() sets dissect_show_all_symbols = 1 unconditionally\n> and currently it is not possible to clear this option.\n> \n> We could simply remove this line; users could use\n> \"semind add --param=dissect-show-all-symbols,\" but this would break\n> existing setups.\n> \n> Signed-off-by: Oleg Nesterov <oleg@redhat.com>\n\nAcked-by: Alexey Gladkov <legion@kernel.org>\n\n> ---\n>  options.c | 2 ++\n>  semind.c  | 4 ++--\n>  2 files changed, 4 insertions(+), 2 deletions(-)\n> \n> diff --git a/options.c b/options.c\n> index 0f207e80..dbe0349f 100644\n> --- a/options.c\n> +++ b/options.c\n> @@ -976,6 +976,8 @@ static char **handle_param(char *arg, char **next)\n>  \n>  \tif (!strcmp(value, \"dissect-show-all-symbols\"))\n>  \t\tdissect_show_all_symbols = 1;\n> +\telse if (!strcmp(value, \"dissect-show-compiled\"))\n> +\t\tdissect_show_all_symbols = 0;\n>  \n>  \treturn next;\n>  }\n> diff --git a/semind.c b/semind.c\n> index ad8003ba..fa084e04 100644\n> --- a/semind.c\n> +++ b/semind.c\n> @@ -322,14 +322,14 @@ done:\n>  \t\tshow_usage();\n>  \t}\n>  \n> -\t// enforce tabstop\n> +\t// enforce defaults\n>  \ttabstop = 1;\n> +\tdissect_show_all_symbols = 1;\n>  \n>  \t// step back since sparse_initialize will ignore argv[0].\n>  \toptind--;\n>  \n>  \tsparse_initialize(argc - optind, argv + optind, &semind_filelist);\n> -\tdissect_show_all_symbols = 1;\n>  }\n>  \n>  static void parse_cmdline_rm(int argc, char **argv)\n> -- \n> 2.52.0\n> \n> \n\n-- \nRgrds, legion\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH] sparse/dissect: introduce do_inline(struct symbol *sym)",
      "normalized_subject": "sparse/dissect: introduce do_inline(struct symbol *sym)",
      "message_count": 2,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "rfc_proposals"
      ],
      "first_date": "2025-12-24T11:38:23+00:00",
      "last_date": "2025-12-31T16:15:17+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176657911119390.mbox",
          "message_id": "<aUvQr9q1ePtvSwCs () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/dissect: introduce do_inline(struct symbol *sym)",
          "date": "2025-12-24 11:38:23+00:00",
          "date_str": "Wed, 24 Dec 2025 11:38:23 +0000",
          "body": "parse_function_body() doesn't do add_symbol(decl) if MOD_INLINE, this\nmeans that dissect/semind can't see the definitions of inline functions\nin translation_unit_used_list.\n\nTest-case:\n\n\t$ cat -n INLINE.c\n\t     1\tstatic inline void i_func(void)\n\t     2\t{\n\t     3\t\tunknown();\n\t     4\t}\n\t     5\n\t     6\tvoid func(void)\n\t     7\t{\n\t     8\t\ti_func();\n\t     9\t\ti_func();\n\t    10\t}\n\nBefore this patch:\n\n\t$ ./test-dissect INLINE.c\n\n\t   6:6                    def   f func                             void ( ... )\n\t   8:9   func             --r   f i_func                           void ( ... )\n\t   9:9   func             --r   f i_func                           void ( ... )\n\nWith this patch:\n\n\t$ ./test-dissect INLINE.c\n\n\t   6:6                    def   f func                             void ( ... )\n\t   1:20                   def   f i_func                           void ( ... )\n\t   3:9   i_func           --r   f unknown                          bad type\n\t   8:9   func             --r   f i_func                           void ( ... )\n\t   9:9   func             --r   f i_func                           void ( ... )\n\nThis change is not really needed if dissect_show_all_symbols == 1, in\nthis case do_file() uses file_scope/global_scope. do_inline() doesn't\nbother to check dissect_show_all_symbols, it relies on sym->visited.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n dissect.c | 17 +++++++++++++++--\n 1 file changed, 15 insertions(+), 2 deletions(-)\n\ndiff --git a/dissect.c b/dissect.c\nindex 5fed8e22..62f927c5 100644\n--- a/dissect.c\n+++ b/dissect.c\n@@ -59,6 +59,7 @@ static void do_sym_list(struct symbol_list *list);\n \n static struct symbol\n \t*base_type(struct symbol *sym),\n+\t*do_symbol(struct symbol *sym),\n \t*do_initializer(struct symbol *type, struct expression *expr),\n \t*do_expression(usage_t mode, struct expression *expr),\n \t*do_statement(usage_t mode, struct statement *stmt);\n@@ -331,6 +332,16 @@ static struct expression *peek_preop(struct expression *expr, int op)\n \treturn NULL;\n }\n \n+static inline void do_inline(struct symbol *sym)\n+{\n+\tif (sym && !sym->visited && (sym->ctype.modifiers & MOD_INLINE)) {\n+\t\tstruct symbol *dctx = dissect_ctx;\n+\t\tdissect_ctx = NULL;\n+\t\tdo_symbol(sym);\n+\t\tdissect_ctx = dctx;\n+\t}\n+}\n+\n static struct symbol *do_expression(usage_t mode, struct expression *expr)\n {\n \tstruct symbol *ret = &int_ctype;\n@@ -377,8 +388,10 @@ again:\n \t\tret = do_expression(mode, expr->cond_false);\n \n \tbreak; case EXPR_CALL:\n-\t\tif (expr->fn->type == EXPR_SYMBOL)\n+\t\tif (expr->fn->type == EXPR_SYMBOL) {\n \t\t\texpr->fn->op = 'f'; /* for expr_symbol() */\n+\t\t\tdo_inline(expr->fn->symbol);\n+\t\t}\n \t\tret = do_expression(U_R_PTR, expr->fn);\n \t\tif (is_ptr(ret))\n \t\t\tret = ret->ctype.base_type;\n@@ -621,7 +634,7 @@ static inline bool is_typedef(struct symbol *sym)\n \treturn (sym->namespace == NS_TYPEDEF);\n }\n \n-static inline struct symbol *do_symbol(struct symbol *sym)\n+static struct symbol *do_symbol(struct symbol *sym)\n {\n \tstruct symbol *type = base_type(sym);\n \tstruct symbol *dctx = dissect_ctx;\n-- \n2.52.0\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176720052222615.mbox",
          "message_id": "<aVVMFceUqswEPBX7 () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "Re: [PATCH] sparse/dissect: introduce do_inline(struct symbol *sym)",
          "date": "2025-12-31 16:15:17+00:00",
          "date_str": "Wed, 31 Dec 2025 16:15:17 +0000",
          "body": "Please ignore this patch. Cough, as if you didn't ;)\n\nI'll send V2 in reply to this version. It is simpler and more correct.\n\nOleg.\n\nOn 12/24, Oleg Nesterov wrote:\n>\n> parse_function_body() doesn't do add_symbol(decl) if MOD_INLINE, this\n> means that dissect/semind can't see the definitions of inline functions\n> in translation_unit_used_list.\n>\n> Test-case:\n>\n> \t$ cat -n INLINE.c\n> \t     1\tstatic inline void i_func(void)\n> \t     2\t{\n> \t     3\t\tunknown();\n> \t     4\t}\n> \t     5\n> \t     6\tvoid func(void)\n> \t     7\t{\n> \t     8\t\ti_func();\n> \t     9\t\ti_func();\n> \t    10\t}\n>\n> Before this patch:\n>\n> \t$ ./test-dissect INLINE.c\n>\n> \t   6:6                    def   f func                             void ( ... )\n> \t   8:9   func             --r   f i_func                           void ( ... )\n> \t   9:9   func             --r   f i_func                           void ( ... )\n>\n> With this patch:\n>\n> \t$ ./test-dissect INLINE.c\n>\n> \t   6:6                    def   f func                             void ( ... )\n> \t   1:20                   def   f i_func                           void ( ... )\n> \t   3:9   i_func           --r   f unknown                          bad type\n> \t   8:9   func             --r   f i_func                           void ( ... )\n> \t   9:9   func             --r   f i_func                           void ( ... )\n>\n> This change is not really needed if dissect_show_all_symbols == 1, in\n> this case do_file() uses file_scope/global_scope. do_inline() doesn't\n> bother to check dissect_show_all_symbols, it relies on sym->visited.\n>\n> Signed-off-by: Oleg Nesterov <oleg@redhat.com>\n> ---\n>  dissect.c | 17 +++++++++++++++--\n>  1 file changed, 15 insertions(+), 2 deletions(-)\n>\n> diff --git a/dissect.c b/dissect.c\n> index 5fed8e22..62f927c5 100644\n> --- a/dissect.c\n> +++ b/dissect.c\n> @@ -59,6 +59,7 @@ static void do_sym_list(struct symbol_list *list);\n>\n>  static struct symbol\n>  \t*base_type(struct symbol *sym),\n> +\t*do_symbol(struct symbol *sym),\n>  \t*do_initializer(struct symbol *type, struct expression *expr),\n>  \t*do_expression(usage_t mode, struct expression *expr),\n>  \t*do_statement(usage_t mode, struct statement *stmt);\n> @@ -331,6 +332,16 @@ static struct expression *peek_preop(struct expression *expr, int op)\n>  \treturn NULL;\n>  }\n>\n> +static inline void do_inline(struct symbol *sym)\n> +{\n> +\tif (sym && !sym->visited && (sym->ctype.modifiers & MOD_INLINE)) {\n> +\t\tstruct symbol *dctx = dissect_ctx;\n> +\t\tdissect_ctx = NULL;\n> +\t\tdo_symbol(sym);\n> +\t\tdissect_ctx = dctx;\n> +\t}\n> +}\n> +\n>  static struct symbol *do_expression(usage_t mode, struct expression *expr)\n>  {\n>  \tstruct symbol *ret = &int_ctype;\n> @@ -377,8 +388,10 @@ again:\n>  \t\tret = do_expression(mode, expr->cond_false);\n>\n>  \tbreak; case EXPR_CALL:\n> -\t\tif (expr->fn->type == EXPR_SYMBOL)\n> +\t\tif (expr->fn->type == EXPR_SYMBOL) {\n>  \t\t\texpr->fn->op = 'f'; /* for expr_symbol() */\n> +\t\t\tdo_inline(expr->fn->symbol);\n> +\t\t}\n>  \t\tret = do_expression(U_R_PTR, expr->fn);\n>  \t\tif (is_ptr(ret))\n>  \t\t\tret = ret->ctype.base_type;\n> @@ -621,7 +634,7 @@ static inline bool is_typedef(struct symbol *sym)\n>  \treturn (sym->namespace == NS_TYPEDEF);\n>  }\n>\n> -static inline struct symbol *do_symbol(struct symbol *sym)\n> +static struct symbol *do_symbol(struct symbol *sym)\n>  {\n>  \tstruct symbol *type = base_type(sym);\n>  \tstruct symbol *dctx = dissect_ctx;\n> --\n> 2.52.0\n>\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "rfc_proposals"
    },
    {
      "subject": "[PATCH v2 0/4] add variadic format checking",
      "normalized_subject": "add variadic format checking",
      "message_count": 2,
      "participants": [
        "Ben Dooks"
      ],
      "categories": [
        "compiler_compat",
        "sparse_internals"
      ],
      "first_date": "2025-12-22T16:00:30+00:00",
      "last_date": "2026-01-16T17:58:05+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176642436329954.mbox",
          "message_id": "<20251222160034.96188-1-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCH v2 0/4] add variadic format checking",
          "date": "2025-12-22 16:00:30+00:00",
          "date_str": "Mon, 22 Dec 2025 16:00:30 +0000",
          "body": "Second version of this, I think mostly sorting the issues\nidentified in review.\n\nThis series (which was initially sent back in 2020) adds the\nability to deal with __attribute__((format) and checking the\narguments to formatted variadic functions.\n\nI have been considering adding a -Wformat-linux to this as\nthe kernel now has a number of extra formatting options and\nchecking the type of these would be useful. An even nicer\nextension would be some way of informing the compiler/sparse\nof these at compile time (but would need to get agreement on\nhow to do this with the compilers too)\n\nBen Dooks (4):\n  parse: initial parsing of __attribute__((format))\n  add -Wformat\n  evaluate: check variadic argument types against formatting info\n  tests: add varargs printf format tests\n\n Makefile                               |   1 +\n builtin.c                              |   4 +-\n evaluate.c                             |  14 +-\n evaluate.h                             |  10 +-\n options.c                              |   2 +\n options.h                              |   1 +\n parse.c                                |  83 ++++-\n sparse.1                               |   8 +\n symbol.h                               |  10 +-\n validation/varargs-format-addrspace1.c |  36 ++\n validation/varargs-format-bad.c        |  18 +\n validation/varargs-format-checking.c   |  21 ++\n validation/varargs-format-position.c   |  32 ++\n validation/varargs-format-prefix.c     |  19 +\n validation/varargs-format-tests.c      |  55 +++\n validation/varargs-type-formattest.c   | 117 +++++++\n verify-format.c                        | 460 +++++++++++++++++++++++++\n verify-format.h                        |   6 +\n 18 files changed, 887 insertions(+), 10 deletions(-)\n create mode 100644 validation/varargs-format-addrspace1.c\n create mode 100644 validation/varargs-format-bad.c\n create mode 100644 validation/varargs-format-checking.c\n create mode 100644 validation/varargs-format-position.c\n create mode 100644 validation/varargs-format-prefix.c\n create mode 100644 validation/varargs-format-tests.c\n create mode 100644 validation/varargs-type-formattest.c\n create mode 100644 verify-format.c\n create mode 100644 verify-format.h\n\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2026/01/176858939911462.mbox",
          "message_id": "<20260116175809.6849-1-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "add variadic format checking",
          "date": "2026-01-16 17:58:05+00:00",
          "date_str": "Fri, 16 Jan 2026 17:58:05 +0000",
          "body": "Third version with a few minor fixes, the only issues seem to be\nwith the complexities of the linux-kernel which has some printk\nfun locally defined.\n\n\nThis series (which was initially sent back in 2020) adds the\nability to deal with __attribute__((format) and checking the\narguments to formatted variadic functions.\n\nI have been considering adding a -Wformat-linux to this as\nthe kernel now has a number of extra formatting options and\nchecking the type of these would be useful. An even nicer\nextension would be some way of informing the compiler/sparse\nof these at compile time (but would need to get agreement on\nhow to do this with the compilers too)\n\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH] sparse/parse: update decl->pos when direct_declarator() sees TOKEN_IDENT",
      "normalized_subject": "sparse/parse: update decl->pos when direct_declarator() sees TOKEN_IDENT",
      "message_count": 1,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "compiler_compat",
        "sparse_internals",
        "type_system"
      ],
      "first_date": "2025-12-21T14:28:04+00:00",
      "last_date": "2025-12-21T14:28:04+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176633009411268.mbox",
          "message_id": "<aUgD9MIbq4V3JKA1 () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/parse: update decl->pos when direct_declarator() sees TOKEN_IDENT",
          "date": "2025-12-21 14:28:04+00:00",
          "date_str": "Sun, 21 Dec 2025 14:28:04 +0000",
          "body": "Test-case:\n\n\t$ cat -n DECL_POS.c\n\t     1\tvoid\n\t     2\t *       ptr,\n\t     3\t *   (*  fptr  ) (int),\n\t     4\t *       ary[2];\n\t     5\n\t     6\tstruct T {\n\t     7\t void\n\t     8\t  *      mptr1[],\n\t     9\t  *      mptr2[];\n\t    10\t int     dummy;\n\t    11\t};\n\t    12\n\t    13\tstatic void func(struct T *t)\n\t    14\t{\n\t    15\t\t__builtin_offsetof(typeof(*t), dummy);\n\t    16\t}\n\nNote that all variables/members are defined at column 10.\n\nHowever, before this patch\n\n\t$ ./sparse DECL_POS.c\n\tDECL_POS.c:2:2: warning: symbol 'ptr' was not declared. Should it be static?\n\tDECL_POS.c:3:2: warning: symbol 'fptr' was not declared. Should it be static?\n\tDECL_POS.c:4:2: warning: symbol 'ary' was not declared. Should it be static?\n\tDECL_POS.c:8:3: error: flexible array member 'mptr1' is not last\n\tDECL_POS.c:9:3: error: flexible array member 'mptr2' is not last\n\nevery reported position is wrong.\n\nThis is because the users of declarator() do alloc_symbol(token->pos),\nbut the current token is not necessarily the ident found later in the\ndeclarator() paths.\n\nWith this patch:\n\n\t$ ./sparse DECL_POS.c\n\tDECL_POS.c:2:10: warning: symbol 'ptr' was not declared. Should it be static?\n\tDECL_POS.c:3:10: warning: symbol 'fptr' was not declared. Should it be static?\n\tDECL_POS.c:4:10: warning: symbol 'ary' was not declared. Should it be static?\n\tDECL_POS.c:8:10: error: flexible array member 'mptr1' is not last\n\tDECL_POS.c:9:10: error: flexible array member 'mptr2' is not last\n\nSee also the fixes in validation/{function-redecl,reserved}.c, some\nof the old positions in the check-error-start/end blocks were wrong.\n\nTODO: there are more users of users of declarator() which should\nprobably be updated the same way.\n\nNOTE: unlike external_declaration(), declaration_list() doesn't check\nident != NULL, so ./sparse doesn't complain about \"struct { int; };\",\nthis should probably be fixed.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n parse.c                      |   5 ++\n symbol.h                     |   1 +\n validation/function-redecl.c |  16 ++--\n validation/reserved.c        | 144 +++++++++++++++++------------------\n 4 files changed, 86 insertions(+), 80 deletions(-)\n\ndiff --git a/parse.c b/parse.c\nindex 9389079e..1166ab7b 100644\n--- a/parse.c\n+++ b/parse.c\n@@ -1821,6 +1821,8 @@ static struct token *direct_declarator(struct token *token, struct decl_state *c\n \n \tif (ctx->ident && token_type(token) == TOKEN_IDENT) {\n \t\t*ctx->ident = token->ident;\n+\t\tif (ctx->d_pos)\n+\t\t\t*ctx->d_pos = token->pos;\n \t\ttoken = token->next;\n \t} else if (match_op(token, '(') &&\n \t    is_nested(token, &next, ctx->prefer_abstract)) {\n@@ -1945,6 +1947,7 @@ static struct token *declaration_list(struct token *token, struct symbol_list **\n \t\tstruct symbol *decl = alloc_symbol(token->pos, SYM_NODE);\n \t\tctx.cleanup = NULL;\n \t\tctx.ident = &decl->ident;\n+\t\tctx.d_pos = &decl->pos;\n \n \t\ttoken = declarator(token, &ctx);\n \t\tif (match_op(token, ':'))\n@@ -2963,6 +2966,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis\n \t}\n \n \tsaved = ctx.ctype;\n+\tctx.d_pos = &decl->pos;\n \ttoken = declarator(token, &ctx);\n \ttoken = handle_asm_name(token, &ctx);\n \ttoken = handle_attributes(token, &ctx);\n@@ -3089,6 +3093,7 @@ struct token *external_declaration(struct token *token, struct symbol_list **lis\n \t\tdecl = alloc_symbol(token->pos, SYM_NODE);\n \t\tctx.ctype = saved;\n \t\tctx.cleanup = NULL;\n+\t\tctx.d_pos = &decl->pos;\n \t\ttoken = handle_attributes(token, &ctx);\n \t\ttoken = declarator(token, &ctx);\n \t\ttoken = handle_asm_name(token, &ctx);\ndiff --git a/symbol.h b/symbol.h\nindex 3552d439..52f0977a 100644\n--- a/symbol.h\n+++ b/symbol.h\n@@ -107,6 +107,7 @@ struct ctype {\n struct decl_state {\n \tstruct ctype ctype;\n \tstruct ident **ident;\n+\tstruct position *d_pos;\n \tstruct symbol_op *mode;\n \tstruct expression *cleanup;\n \tunsigned long f_modifiers;\t\t// function attributes\ndiff --git a/validation/function-redecl.c b/validation/function-redecl.c\nindex d0d844a5..272d4ac9 100644\n--- a/validation/function-redecl.c\n+++ b/validation/function-redecl.c\n@@ -56,14 +56,14 @@ function-redecl.c:9:11: error: symbol 'ret_const' redeclared with different type\n function-redecl.c:9:11:    int extern const [addressable] [signed] [toplevel] ret_const( ... )\n function-redecl.c:8:5: note: previously declared as:\n function-redecl.c:8:5:    int extern [addressable] [signed] [toplevel] ret_const( ... )\n-function-redecl.c:13:13: error: symbol 'ret_as' redeclared with different type (different address spaces):\n-function-redecl.c:13:13:    void <asn:1> *extern [addressable] [toplevel] ret_as( ... )\n-function-redecl.c:12:6: note: previously declared as:\n-function-redecl.c:12:6:    void *extern [addressable] [toplevel] ret_as( ... )\n-function-redecl.c:17:12: error: symbol 'ret_mod' redeclared with different type (different modifiers):\n-function-redecl.c:17:12:    void const *extern [addressable] [toplevel] ret_mod( ... )\n-function-redecl.c:16:6: note: previously declared as:\n-function-redecl.c:16:6:    void *extern ",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
      "normalized_subject": "minmax: remove useless cast in __is_nonneg()",
      "message_count": 24,
      "participants": [
        "kernel test robot",
        "David Laight",
        "Vincent Mailhol"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-12-19T22:39:48+00:00",
      "last_date": "2025-12-20T12:03:31+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176618684729035.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-4-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-19 22:39:48+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:48 +0000",
          "body": "The function like macro __is_nonneg() casts its argument to (long long)\nin an attempt to silence -Wtype-limits warnings on unsigned values.\n\nBut this workaround is incomplete as proven here:\n\n  $ cat foo.c\n  #include <linux/minmax.h>\n\n  int foo(unsigned int a)\n  {\n  \treturn __is_nonneg(a);\n  }\n  $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n    CALL    scripts/checksyscalls.sh\n    DESCEND objtool\n    INSTALL libsubcmd_headers\n    CC      foo.o\n  foo.c: In function 'foo':\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                  ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                         ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n\nAnd because -Wtype-limits is now globally disabled, such a workaround\nnow becomes useless. Remove the __is_nonneg()'s cast and its related\ncomment.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/minmax.h | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a0158db54a04..3e2e3e539ba1 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -52,9 +52,6 @@\n /*\n  * Check whether a signed value is always non-negative.\n  *\n- * A cast is needed to avoid any warnings from values that aren't signed\n- * integer types (in which case the result doesn't matter).\n- *\n  * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n@@ -65,7 +62,7 @@\n  * but they are handled by the !is_signed_type() case).\n  */\n #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n-#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n+#define __is_nonneg(ux) statically_true((ux) >= 0)\n #else\n #define __is_nonneg(ux) statically_true( \\\n \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618684329031.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-4-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-19 22:39:48+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:48 +0000",
          "body": "The function like macro __is_nonneg() casts its argument to (long long)\nin an attempt to silence -Wtype-limits warnings on unsigned values.\n\nBut this workaround is incomplete as proven here:\n\n  $ cat foo.c\n  #include <linux/minmax.h>\n\n  int foo(unsigned int a)\n  {\n  \treturn __is_nonneg(a);\n  }\n  $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n    CALL    scripts/checksyscalls.sh\n    DESCEND objtool\n    INSTALL libsubcmd_headers\n    CC      foo.o\n  foo.c: In function 'foo':\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                  ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                         ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n\nAnd because -Wtype-limits is now globally disabled, such a workaround\nnow becomes useless. Remove the __is_nonneg()'s cast and its related\ncomment.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/minmax.h | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a0158db54a04..3e2e3e539ba1 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -52,9 +52,6 @@\n /*\n  * Check whether a signed value is always non-negative.\n  *\n- * A cast is needed to avoid any warnings from values that aren't signed\n- * integer types (in which case the result doesn't matter).\n- *\n  * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n@@ -65,7 +62,7 @@\n  * but they are handled by the !is_signed_type() case).\n  */\n #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n-#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n+#define __is_nonneg(ux) statically_true((ux) >= 0)\n #else\n #define __is_nonneg(ux) statically_true( \\\n \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618684229028.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-4-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-19 22:39:48+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:48 +0000",
          "body": "The function like macro __is_nonneg() casts its argument to (long long)\nin an attempt to silence -Wtype-limits warnings on unsigned values.\n\nBut this workaround is incomplete as proven here:\n\n  $ cat foo.c\n  #include <linux/minmax.h>\n\n  int foo(unsigned int a)\n  {\n  \treturn __is_nonneg(a);\n  }\n  $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n    CALL    scripts/checksyscalls.sh\n    DESCEND objtool\n    INSTALL libsubcmd_headers\n    CC      foo.o\n  foo.c: In function 'foo':\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                  ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                         ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n\nAnd because -Wtype-limits is now globally disabled, such a workaround\nnow becomes useless. Remove the __is_nonneg()'s cast and its related\ncomment.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/minmax.h | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a0158db54a04..3e2e3e539ba1 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -52,9 +52,6 @@\n /*\n  * Check whether a signed value is always non-negative.\n  *\n- * A cast is needed to avoid any warnings from values that aren't signed\n- * integer types (in which case the result doesn't matter).\n- *\n  * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n@@ -65,7 +62,7 @@\n  * but they are handled by the !is_signed_type() case).\n  */\n #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n-#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n+#define __is_nonneg(ux) statically_true((ux) >= 0)\n #else\n #define __is_nonneg(ux) statically_true( \\\n \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n\n-- \n2.51.2\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618697329242.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-4-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-19 22:39:48+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:48 +0000",
          "body": "The function like macro __is_nonneg() casts its argument to (long long)\nin an attempt to silence -Wtype-limits warnings on unsigned values.\n\nBut this workaround is incomplete as proven here:\n\n  $ cat foo.c\n  #include <linux/minmax.h>\n\n  int foo(unsigned int a)\n  {\n  \treturn __is_nonneg(a);\n  }\n  $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n    CALL    scripts/checksyscalls.sh\n    DESCEND objtool\n    INSTALL libsubcmd_headers\n    CC      foo.o\n  foo.c: In function 'foo':\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                  ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                         ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n\nAnd because -Wtype-limits is now globally disabled, such a workaround\nnow becomes useless. Remove the __is_nonneg()'s cast and its related\ncomment.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/minmax.h | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a0158db54a04..3e2e3e539ba1 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -52,9 +52,6 @@\n /*\n  * Check whether a signed value is always non-negative.\n  *\n- * A cast is needed to avoid any warnings from values that aren't signed\n- * integer types (in which case the result doesn't matter).\n- *\n  * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n@@ -65,7 +62,7 @@\n  * but they are handled by the !is_signed_type() case).\n  */\n #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n-#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n+#define __is_nonneg(ux) statically_true((ux) >= 0)\n #else\n #define __is_nonneg(ux) statically_true( \\\n \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618687029073.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-4-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-19 22:39:48+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:48 +0000",
          "body": "The function like macro __is_nonneg() casts its argument to (long long)\nin an attempt to silence -Wtype-limits warnings on unsigned values.\n\nBut this workaround is incomplete as proven here:\n\n  $ cat foo.c\n  #include <linux/minmax.h>\n\n  int foo(unsigned int a)\n  {\n  \treturn __is_nonneg(a);\n  }\n  $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n    CALL    scripts/checksyscalls.sh\n    DESCEND objtool\n    INSTALL libsubcmd_headers\n    CC      foo.o\n  foo.c: In function 'foo':\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                  ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                         ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n\nAnd because -Wtype-limits is now globally disabled, such a workaround\nnow becomes useless. Remove the __is_nonneg()'s cast and its related\ncomment.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/minmax.h | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a0158db54a04..3e2e3e539ba1 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -52,9 +52,6 @@\n /*\n  * Check whether a signed value is always non-negative.\n  *\n- * A cast is needed to avoid any warnings from values that aren't signed\n- * integer types (in which case the result doesn't matter).\n- *\n  * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n@@ -65,7 +62,7 @@\n  * but they are handled by the !is_signed_type() case).\n  */\n #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n-#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n+#define __is_nonneg(ux) statically_true((ux) >= 0)\n #else\n #define __is_nonneg(ux) statically_true( \\\n \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618697929248.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-4-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-19 22:39:48+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:48 +0000",
          "body": "The function like macro __is_nonneg() casts its argument to (long long)\nin an attempt to silence -Wtype-limits warnings on unsigned values.\n\nBut this workaround is incomplete as proven here:\n\n  $ cat foo.c\n  #include <linux/minmax.h>\n\n  int foo(unsigned int a)\n  {\n  \treturn __is_nonneg(a);\n  }\n  $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n    CALL    scripts/checksyscalls.sh\n    DESCEND objtool\n    INSTALL libsubcmd_headers\n    CC      foo.o\n  foo.c: In function 'foo':\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                  ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n  ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n     68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n        |                                                         ^~\n  ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n    350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n        |                                                         ^\n  foo.c:5:16: note: in expansion of macro '__is_nonneg'\n      5 |         return __is_nonneg(a);\n        |                ^~~~~~~~~~~\n\nAnd because -Wtype-limits is now globally disabled, such a workaround\nnow becomes useless. Remove the __is_nonneg()'s cast and its related\ncomment.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/minmax.h | 5 +----\n 1 file changed, 1 insertion(+), 4 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a0158db54a04..3e2e3e539ba1 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -52,9 +52,6 @@\n /*\n  * Check whether a signed value is always non-negative.\n  *\n- * A cast is needed to avoid any warnings from values that aren't signed\n- * integer types (in which case the result doesn't matter).\n- *\n  * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n@@ -65,7 +62,7 @@\n  * but they are handled by the !is_signed_type() case).\n  */\n #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n-#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n+#define __is_nonneg(ux) statically_true((ux) >= 0)\n #else\n #define __is_nonneg(ux) statically_true( \\\n \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176622778719465.mbox",
          "message_id": "<20251220100201.26d9b0db () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:02:01+00:00",
          "date_str": "Sat, 20 Dec 2025 10:02:01 +0000",
          "body": "On Fri, 19 Dec 2025 23:39:48 +0100\nVincent Mailhol <mailhol@kernel.org> wrote:\n\n> The function like macro __is_nonneg() casts its argument to (long long)\n> in an attempt to silence -Wtype-limits warnings on unsigned values.\n\nnak.\n\nThe cast is needed for pointer types, not for -Wtype-limits.\nwhich is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\ntest is there.\n\n\tDavid\n\n> \n> But this workaround is incomplete as proven here:\n> \n>   $ cat foo.c\n>   #include <linux/minmax.h>\n> \n>   int foo(unsigned int a)\n>   {\n>   \treturn __is_nonneg(a);\n>   }\n>   $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n>     CALL    scripts/checksyscalls.sh\n>     DESCEND objtool\n>     INSTALL libsubcmd_headers\n>     CC      foo.o\n>   foo.c: In function 'foo':\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                  ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                         ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n> \n> And because -Wtype-limits is now globally disabled, such a workaround\n> now becomes useless. Remove the __is_nonneg()'s cast and its related\n> comment.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/minmax.h | 5 +----\n>  1 file changed, 1 insertion(+), 4 deletions(-)\n> \n> diff --git a/include/linux/minmax.h b/include/linux/minmax.h\n> index a0158db54a04..3e2e3e539ba1 100644\n> --- a/include/linux/minmax.h\n> +++ b/include/linux/minmax.h\n> @@ -52,9 +52,6 @@\n>  /*\n>   * Check whether a signed value is always non-negative.\n>   *\n> - * A cast is needed to avoid any warnings from values that aren't signed\n> - * integer types (in which case the result doesn't matter).\n> - *\n>   * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n>   * But on 32-bit we need to avoid warnings about casting pointers to integers\n>   * of different sizes without truncating 64-bit values so 'long' or 'long long'\n> @@ -65,7 +62,7 @@\n>   * but they are handled by the !is_signed_type() case).\n>   */\n>  #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n> -#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n> +#define __is_nonneg(ux) statically_true((ux) >= 0)\n>  #else\n>  #define __is_nonneg(ux) statically_true( \\\n>  \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n> \n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176622778519459.mbox",
          "message_id": "<20251220100201.26d9b0db () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:02:01+00:00",
          "date_str": "Sat, 20 Dec 2025 10:02:01 +0000",
          "body": "On Fri, 19 Dec 2025 23:39:48 +0100\nVincent Mailhol <mailhol@kernel.org> wrote:\n\n> The function like macro __is_nonneg() casts its argument to (long long)\n> in an attempt to silence -Wtype-limits warnings on unsigned values.\n\nnak.\n\nThe cast is needed for pointer types, not for -Wtype-limits.\nwhich is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\ntest is there.\n\n\tDavid\n\n> \n> But this workaround is incomplete as proven here:\n> \n>   $ cat foo.c\n>   #include <linux/minmax.h>\n> \n>   int foo(unsigned int a)\n>   {\n>   \treturn __is_nonneg(a);\n>   }\n>   $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n>     CALL    scripts/checksyscalls.sh\n>     DESCEND objtool\n>     INSTALL libsubcmd_headers\n>     CC      foo.o\n>   foo.c: In function 'foo':\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                  ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                         ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n> \n> And because -Wtype-limits is now globally disabled, such a workaround\n> now becomes useless. Remove the __is_nonneg()'s cast and its related\n> comment.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/minmax.h | 5 +----\n>  1 file changed, 1 insertion(+), 4 deletions(-)\n> \n> diff --git a/include/linux/minmax.h b/include/linux/minmax.h\n> index a0158db54a04..3e2e3e539ba1 100644\n> --- a/include/linux/minmax.h\n> +++ b/include/linux/minmax.h\n> @@ -52,9 +52,6 @@\n>  /*\n>   * Check whether a signed value is always non-negative.\n>   *\n> - * A cast is needed to avoid any warnings from values that aren't signed\n> - * integer types (in which case the result doesn't matter).\n> - *\n>   * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n>   * But on 32-bit we need to avoid warnings about casting pointers to integers\n>   * of different sizes without truncating 64-bit values so 'long' or 'long long'\n> @@ -65,7 +62,7 @@\n>   * but they are handled by the !is_signed_type() case).\n>   */\n>  #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n> -#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n> +#define __is_nonneg(ux) statically_true((ux) >= 0)\n>  #else\n>  #define __is_nonneg(ux) statically_true( \\\n>  \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n> \n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176622772719421.mbox",
          "message_id": "<20251220100201.26d9b0db () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:02:01+00:00",
          "date_str": "Sat, 20 Dec 2025 10:02:01 +0000",
          "body": "On Fri, 19 Dec 2025 23:39:48 +0100\nVincent Mailhol <mailhol@kernel.org> wrote:\n\n> The function like macro __is_nonneg() casts its argument to (long long)\n> in an attempt to silence -Wtype-limits warnings on unsigned values.\n\nnak.\n\nThe cast is needed for pointer types, not for -Wtype-limits.\nwhich is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\ntest is there.\n\n\tDavid\n\n> \n> But this workaround is incomplete as proven here:\n> \n>   $ cat foo.c\n>   #include <linux/minmax.h>\n> \n>   int foo(unsigned int a)\n>   {\n>   \treturn __is_nonneg(a);\n>   }\n>   $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n>     CALL    scripts/checksyscalls.sh\n>     DESCEND objtool\n>     INSTALL libsubcmd_headers\n>     CC      foo.o\n>   foo.c: In function 'foo':\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                  ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                         ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n> \n> And because -Wtype-limits is now globally disabled, such a workaround\n> now becomes useless. Remove the __is_nonneg()'s cast and its related\n> comment.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/minmax.h | 5 +----\n>  1 file changed, 1 insertion(+), 4 deletions(-)\n> \n> diff --git a/include/linux/minmax.h b/include/linux/minmax.h\n> index a0158db54a04..3e2e3e539ba1 100644\n> --- a/include/linux/minmax.h\n> +++ b/include/linux/minmax.h\n> @@ -52,9 +52,6 @@\n>  /*\n>   * Check whether a signed value is always non-negative.\n>   *\n> - * A cast is needed to avoid any warnings from values that aren't signed\n> - * integer types (in which case the result doesn't matter).\n> - *\n>   * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n>   * But on 32-bit we need to avoid warnings about casting pointers to integers\n>   * of different sizes without truncating 64-bit values so 'long' or 'long long'\n> @@ -65,7 +62,7 @@\n>   * but they are handled by the !is_signed_type() case).\n>   */\n>  #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n> -#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n> +#define __is_nonneg(ux) statically_true((ux) >= 0)\n>  #else\n>  #define __is_nonneg(ux) statically_true( \\\n>  \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n> \n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176622778919468.mbox",
          "message_id": "<20251220100201.26d9b0db () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:02:01+00:00",
          "date_str": "Sat, 20 Dec 2025 10:02:01 +0000",
          "body": "On Fri, 19 Dec 2025 23:39:48 +0100\nVincent Mailhol <mailhol@kernel.org> wrote:\n\n> The function like macro __is_nonneg() casts its argument to (long long)\n> in an attempt to silence -Wtype-limits warnings on unsigned values.\n\nnak.\n\nThe cast is needed for pointer types, not for -Wtype-limits.\nwhich is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\ntest is there.\n\n\tDavid\n\n> \n> But this workaround is incomplete as proven here:\n> \n>   $ cat foo.c\n>   #include <linux/minmax.h>\n> \n>   int foo(unsigned int a)\n>   {\n>   \treturn __is_nonneg(a);\n>   }\n>   $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n>     CALL    scripts/checksyscalls.sh\n>     DESCEND objtool\n>     INSTALL libsubcmd_headers\n>     CC      foo.o\n>   foo.c: In function 'foo':\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                  ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                         ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n> \n> And because -Wtype-limits is now globally disabled, such a workaround\n> now becomes useless. Remove the __is_nonneg()'s cast and its related\n> comment.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/minmax.h | 5 +----\n>  1 file changed, 1 insertion(+), 4 deletions(-)\n> \n> diff --git a/include/linux/minmax.h b/include/linux/minmax.h\n> index a0158db54a04..3e2e3e539ba1 100644\n> --- a/include/linux/minmax.h\n> +++ b/include/linux/minmax.h\n> @@ -52,9 +52,6 @@\n>  /*\n>   * Check whether a signed value is always non-negative.\n>   *\n> - * A cast is needed to avoid any warnings from values that aren't signed\n> - * integer types (in which case the result doesn't matter).\n> - *\n>   * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n>   * But on 32-bit we need to avoid warnings about casting pointers to integers\n>   * of different sizes without truncating 64-bit values so 'long' or 'long long'\n> @@ -65,7 +62,7 @@\n>   * but they are handled by the !is_signed_type() case).\n>   */\n>  #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n> -#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n> +#define __is_nonneg(ux) statically_true((ux) >= 0)\n>  #else\n>  #define __is_nonneg(ux) statically_true( \\\n>  \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n> \n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176622772319418.mbox",
          "message_id": "<20251220100201.26d9b0db () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:02:01+00:00",
          "date_str": "Sat, 20 Dec 2025 10:02:01 +0000",
          "body": "On Fri, 19 Dec 2025 23:39:48 +0100\nVincent Mailhol <mailhol@kernel.org> wrote:\n\n> The function like macro __is_nonneg() casts its argument to (long long)\n> in an attempt to silence -Wtype-limits warnings on unsigned values.\n\nnak.\n\nThe cast is needed for pointer types, not for -Wtype-limits.\nwhich is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\ntest is there.\n\n\tDavid\n\n> \n> But this workaround is incomplete as proven here:\n> \n>   $ cat foo.c\n>   #include <linux/minmax.h>\n> \n>   int foo(unsigned int a)\n>   {\n>   \treturn __is_nonneg(a);\n>   }\n>   $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n>     CALL    scripts/checksyscalls.sh\n>     DESCEND objtool\n>     INSTALL libsubcmd_headers\n>     CC      foo.o\n>   foo.c: In function 'foo':\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                  ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                         ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n> \n> And because -Wtype-limits is now globally disabled, such a workaround\n> now becomes useless. Remove the __is_nonneg()'s cast and its related\n> comment.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/minmax.h | 5 +----\n>  1 file changed, 1 insertion(+), 4 deletions(-)\n> \n> diff --git a/include/linux/minmax.h b/include/linux/minmax.h\n> index a0158db54a04..3e2e3e539ba1 100644\n> --- a/include/linux/minmax.h\n> +++ b/include/linux/minmax.h\n> @@ -52,9 +52,6 @@\n>  /*\n>   * Check whether a signed value is always non-negative.\n>   *\n> - * A cast is needed to avoid any warnings from values that aren't signed\n> - * integer types (in which case the result doesn't matter).\n> - *\n>   * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n>   * But on 32-bit we need to avoid warnings about casting pointers to integers\n>   * of different sizes without truncating 64-bit values so 'long' or 'long long'\n> @@ -65,7 +62,7 @@\n>   * but they are handled by the !is_signed_type() case).\n>   */\n>  #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n> -#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n> +#define __is_nonneg(ux) statically_true((ux) >= 0)\n>  #else\n>  #define __is_nonneg(ux) statically_true( \\\n>  \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n> \n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176622772919424.mbox",
          "message_id": "<20251220100201.26d9b0db () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:02:01+00:00",
          "date_str": "Sat, 20 Dec 2025 10:02:01 +0000",
          "body": "On Fri, 19 Dec 2025 23:39:48 +0100\nVincent Mailhol <mailhol@kernel.org> wrote:\n\n> The function like macro __is_nonneg() casts its argument to (long long)\n> in an attempt to silence -Wtype-limits warnings on unsigned values.\n\nnak.\n\nThe cast is needed for pointer types, not for -Wtype-limits.\nwhich is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\ntest is there.\n\n\tDavid\n\n> \n> But this workaround is incomplete as proven here:\n> \n>   $ cat foo.c\n>   #include <linux/minmax.h>\n> \n>   int foo(unsigned int a)\n>   {\n>   \treturn __is_nonneg(a);\n>   }\n>   $ make CFLAGS_KERNEL=\"-Wtype-limits\" foo.o\n>     CALL    scripts/checksyscalls.sh\n>     DESCEND objtool\n>     INSTALL libsubcmd_headers\n>     CC      foo.o\n>   foo.c: In function 'foo':\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:50: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                  ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n>   ./include/linux/minmax.h:68:57: warning: comparison is always true due to limited range of data type [-Wtype-limits]\n>      68 | #define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n>         |                                                         ^~\n>   ./include/linux/compiler.h:350:57: note: in definition of macro 'statically_true'\n>     350 | #define statically_true(x) (__builtin_constant_p(x) && (x))\n>         |                                                         ^\n>   foo.c:5:16: note: in expansion of macro '__is_nonneg'\n>       5 |         return __is_nonneg(a);\n>         |                ^~~~~~~~~~~\n> \n> And because -Wtype-limits is now globally disabled, such a workaround\n> now becomes useless. Remove the __is_nonneg()'s cast and its related\n> comment.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/minmax.h | 5 +----\n>  1 file changed, 1 insertion(+), 4 deletions(-)\n> \n> diff --git a/include/linux/minmax.h b/include/linux/minmax.h\n> index a0158db54a04..3e2e3e539ba1 100644\n> --- a/include/linux/minmax.h\n> +++ b/include/linux/minmax.h\n> @@ -52,9 +52,6 @@\n>  /*\n>   * Check whether a signed value is always non-negative.\n>   *\n> - * A cast is needed to avoid any warnings from values that aren't signed\n> - * integer types (in which case the result doesn't matter).\n> - *\n>   * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n>   * But on 32-bit we need to avoid warnings about casting pointers to integers\n>   * of different sizes without truncating 64-bit values so 'long' or 'long long'\n> @@ -65,7 +62,7 @@\n>   * but they are handled by the !is_signed_type() case).\n>   */\n>  #if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n> -#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n> +#define __is_nonneg(ux) statically_true((ux) >= 0)\n>  #else\n>  #define __is_nonneg(ux) statically_true( \\\n>  \t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n> \n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623081521100.mbox",
          "message_id": "<664613c5-eee7-4130-8b21-0e47e7024636 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:53:29+00:00",
          "date_str": "Sat, 20 Dec 2025 10:53:29 +0000",
          "body": "On 20/12/2025 at 11:02, David Laight wrote:\n> On Fri, 19 Dec 2025 23:39:48 +0100\n> Vincent Mailhol <mailhol@kernel.org> wrote:\n> \n>> The function like macro __is_nonneg() casts its argument to (long long)\n>> in an attempt to silence -Wtype-limits warnings on unsigned values.\n> \n> nak.\n> \n> The cast is needed for pointer types, not for -Wtype-limits.\n> which is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\n> test is there.\n\nOK. I will remove that fourth patch in v3.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623081721105.mbox",
          "message_id": "<664613c5-eee7-4130-8b21-0e47e7024636 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:53:29+00:00",
          "date_str": "Sat, 20 Dec 2025 10:53:29 +0000",
          "body": "On 20/12/2025 at 11:02, David Laight wrote:\n> On Fri, 19 Dec 2025 23:39:48 +0100\n> Vincent Mailhol <mailhol@kernel.org> wrote:\n> \n>> The function like macro __is_nonneg() casts its argument to (long long)\n>> in an attempt to silence -Wtype-limits warnings on unsigned values.\n> \n> nak.\n> \n> The cast is needed for pointer types, not for -Wtype-limits.\n> which is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\n> test is there.\n\nOK. I will remove that fourth patch in v3.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623081521098.mbox",
          "message_id": "<664613c5-eee7-4130-8b21-0e47e7024636 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:53:29+00:00",
          "date_str": "Sat, 20 Dec 2025 10:53:29 +0000",
          "body": "On 20/12/2025 at 11:02, David Laight wrote:\n> On Fri, 19 Dec 2025 23:39:48 +0100\n> Vincent Mailhol <mailhol@kernel.org> wrote:\n> \n>> The function like macro __is_nonneg() casts its argument to (long long)\n>> in an attempt to silence -Wtype-limits warnings on unsigned values.\n> \n> nak.\n> \n> The cast is needed for pointer types, not for -Wtype-limits.\n> which is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\n> test is there.\n\nOK. I will remove that fourth patch in v3.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623081821112.mbox",
          "message_id": "<664613c5-eee7-4130-8b21-0e47e7024636 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:53:29+00:00",
          "date_str": "Sat, 20 Dec 2025 10:53:29 +0000",
          "body": "On 20/12/2025 at 11:02, David Laight wrote:\n> On Fri, 19 Dec 2025 23:39:48 +0100\n> Vincent Mailhol <mailhol@kernel.org> wrote:\n> \n>> The function like macro __is_nonneg() casts its argument to (long long)\n>> in an attempt to silence -Wtype-limits warnings on unsigned values.\n> \n> nak.\n> \n> The cast is needed for pointer types, not for -Wtype-limits.\n> which is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\n> test is there.\n\nOK. I will remove that fourth patch in v3.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623081821109.mbox",
          "message_id": "<664613c5-eee7-4130-8b21-0e47e7024636 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:53:29+00:00",
          "date_str": "Sat, 20 Dec 2025 10:53:29 +0000",
          "body": "On 20/12/2025 at 11:02, David Laight wrote:\n> On Fri, 19 Dec 2025 23:39:48 +0100\n> Vincent Mailhol <mailhol@kernel.org> wrote:\n> \n>> The function like macro __is_nonneg() casts its argument to (long long)\n>> in an attempt to silence -Wtype-limits warnings on unsigned values.\n> \n> nak.\n> \n> The cast is needed for pointer types, not for -Wtype-limits.\n> which is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\n> test is there.\n\nOK. I will remove that fourth patch in v3.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623081921113.mbox",
          "message_id": "<664613c5-eee7-4130-8b21-0e47e7024636 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 10:53:29+00:00",
          "date_str": "Sat, 20 Dec 2025 10:53:29 +0000",
          "body": "On 20/12/2025 at 11:02, David Laight wrote:\n> On Fri, 19 Dec 2025 23:39:48 +0100\n> Vincent Mailhol <mailhol@kernel.org> wrote:\n> \n>> The function like macro __is_nonneg() casts its argument to (long long)\n>> in an attempt to silence -Wtype-limits warnings on unsigned values.\n> \n> nak.\n> \n> The cast is needed for pointer types, not for -Wtype-limits.\n> which is why the '#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__'\n> test is there.\n\nOK. I will remove that fourth patch in v3.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623503923455.mbox",
          "message_id": "<202512201303.je0bERQn-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 12:03:31+00:00",
          "date_str": "Sat, 20 Dec 2025 12:03:31 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-064204\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-4-2e92b3f566c5%40kernel.org\npatch subject: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()\nconfig: x86_64-rhel-9.4-ltp (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/config)\ncompiler: gcc-14 (Debian 14.2.0-19) 14.2.0\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512201303.je0bERQn-lkp@intel.com/\n\nAll warnings (new ones prefixed by >>):\n\n   In file included from <command-line>:\n   lib/lzo/lzo1x_compress.c: In function 'lzo1x_1_do_compress':\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n         |              ^~~~~~~~~~~\n   include/linux/minmax.h:72:10: note: in expansion of macro '__sign_use'\n      72 |         (__sign_use(ux) & __sign_use(uy))\n         |          ^~~~~~~~~~\n   include/linux/minmax.h:90:27: note: in expansion of macro '__types_ok'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |                           ^~~~~~~~~~\n   include/linux/minmax.h:95:9: note: in expansion of macro '__careful_cmp_once'\n      95 |         __careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n         |         ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:102:25: note: in expansion of macro '__careful_cmp'\n     102 | #define min(x, y)       __careful_cmp(min, x, y)\n         |                         ^~~~~~~~~~~~~\n   lib/lzo/lzo1x_compress.c:65:54: note: in expansion of macro 'min'\n      65 |                         const unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n         |                                                      ^~~\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __i",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623502123434.mbox",
          "message_id": "<202512201303.je0bERQn-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 12:03:31+00:00",
          "date_str": "Sat, 20 Dec 2025 12:03:31 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-064204\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-4-2e92b3f566c5%40kernel.org\npatch subject: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()\nconfig: x86_64-rhel-9.4-ltp (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/config)\ncompiler: gcc-14 (Debian 14.2.0-19) 14.2.0\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512201303.je0bERQn-lkp@intel.com/\n\nAll warnings (new ones prefixed by >>):\n\n   In file included from <command-line>:\n   lib/lzo/lzo1x_compress.c: In function 'lzo1x_1_do_compress':\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n         |              ^~~~~~~~~~~\n   include/linux/minmax.h:72:10: note: in expansion of macro '__sign_use'\n      72 |         (__sign_use(ux) & __sign_use(uy))\n         |          ^~~~~~~~~~\n   include/linux/minmax.h:90:27: note: in expansion of macro '__types_ok'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |                           ^~~~~~~~~~\n   include/linux/minmax.h:95:9: note: in expansion of macro '__careful_cmp_once'\n      95 |         __careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n         |         ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:102:25: note: in expansion of macro '__careful_cmp'\n     102 | #define min(x, y)       __careful_cmp(min, x, y)\n         |                         ^~~~~~~~~~~~~\n   lib/lzo/lzo1x_compress.c:65:54: note: in expansion of macro 'min'\n      65 |                         const unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n         |                                                      ^~~\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __i",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623502823446.mbox",
          "message_id": "<202512201303.je0bERQn-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 12:03:31+00:00",
          "date_str": "Sat, 20 Dec 2025 12:03:31 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-064204\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-4-2e92b3f566c5%40kernel.org\npatch subject: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()\nconfig: x86_64-rhel-9.4-ltp (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/config)\ncompiler: gcc-14 (Debian 14.2.0-19) 14.2.0\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512201303.je0bERQn-lkp@intel.com/\n\nAll warnings (new ones prefixed by >>):\n\n   In file included from <command-line>:\n   lib/lzo/lzo1x_compress.c: In function 'lzo1x_1_do_compress':\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n         |              ^~~~~~~~~~~\n   include/linux/minmax.h:72:10: note: in expansion of macro '__sign_use'\n      72 |         (__sign_use(ux) & __sign_use(uy))\n         |          ^~~~~~~~~~\n   include/linux/minmax.h:90:27: note: in expansion of macro '__types_ok'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |                           ^~~~~~~~~~\n   include/linux/minmax.h:95:9: note: in expansion of macro '__careful_cmp_once'\n      95 |         __careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n         |         ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:102:25: note: in expansion of macro '__careful_cmp'\n     102 | #define min(x, y)       __careful_cmp(min, x, y)\n         |                         ^~~~~~~~~~~~~\n   lib/lzo/lzo1x_compress.c:65:54: note: in expansion of macro 'min'\n      65 |                         const unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n         |                                                      ^~~\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __i",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623503423449.mbox",
          "message_id": "<202512201303.je0bERQn-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 12:03:31+00:00",
          "date_str": "Sat, 20 Dec 2025 12:03:31 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-064204\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-4-2e92b3f566c5%40kernel.org\npatch subject: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()\nconfig: x86_64-rhel-9.4-ltp (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/config)\ncompiler: gcc-14 (Debian 14.2.0-19) 14.2.0\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512201303.je0bERQn-lkp@intel.com/\n\nAll warnings (new ones prefixed by >>):\n\n   In file included from <command-line>:\n   lib/lzo/lzo1x_compress.c: In function 'lzo1x_1_do_compress':\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n         |              ^~~~~~~~~~~\n   include/linux/minmax.h:72:10: note: in expansion of macro '__sign_use'\n      72 |         (__sign_use(ux) & __sign_use(uy))\n         |          ^~~~~~~~~~\n   include/linux/minmax.h:90:27: note: in expansion of macro '__types_ok'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |                           ^~~~~~~~~~\n   include/linux/minmax.h:95:9: note: in expansion of macro '__careful_cmp_once'\n      95 |         __careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n         |         ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:102:25: note: in expansion of macro '__careful_cmp'\n     102 | #define min(x, y)       __careful_cmp(min, x, y)\n         |                         ^~~~~~~~~~~~~\n   lib/lzo/lzo1x_compress.c:65:54: note: in expansion of macro 'min'\n      65 |                         const unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n         |                                                      ^~~\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __i",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623502423441.mbox",
          "message_id": "<202512201303.je0bERQn-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 12:03:31+00:00",
          "date_str": "Sat, 20 Dec 2025 12:03:31 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-064204\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-4-2e92b3f566c5%40kernel.org\npatch subject: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()\nconfig: x86_64-rhel-9.4-ltp (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/config)\ncompiler: gcc-14 (Debian 14.2.0-19) 14.2.0\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512201303.je0bERQn-lkp@intel.com/\n\nAll warnings (new ones prefixed by >>):\n\n   In file included from <command-line>:\n   lib/lzo/lzo1x_compress.c: In function 'lzo1x_1_do_compress':\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n         |              ^~~~~~~~~~~\n   include/linux/minmax.h:72:10: note: in expansion of macro '__sign_use'\n      72 |         (__sign_use(ux) & __sign_use(uy))\n         |          ^~~~~~~~~~\n   include/linux/minmax.h:90:27: note: in expansion of macro '__types_ok'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |                           ^~~~~~~~~~\n   include/linux/minmax.h:95:9: note: in expansion of macro '__careful_cmp_once'\n      95 |         __careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n         |         ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:102:25: note: in expansion of macro '__careful_cmp'\n     102 | #define min(x, y)       __careful_cmp(min, x, y)\n         |                         ^~~~~~~~~~~~~\n   lib/lzo/lzo1x_compress.c:65:54: note: in expansion of macro 'min'\n      65 |                         const unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n         |                                                      ^~~\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __i",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623502523442.mbox",
          "message_id": "<202512201303.je0bERQn-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()",
          "date": "2025-12-20 12:03:31+00:00",
          "date_str": "Sat, 20 Dec 2025 12:03:31 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-064204\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-4-2e92b3f566c5%40kernel.org\npatch subject: [PATCH v2 4/4] minmax: remove useless cast in __is_nonneg()\nconfig: x86_64-rhel-9.4-ltp (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/config)\ncompiler: gcc-14 (Debian 14.2.0-19) 14.2.0\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20251220/202512201303.je0bERQn-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512201303.je0bERQn-lkp@intel.com/\n\nAll warnings (new ones prefixed by >>):\n\n   In file included from <command-line>:\n   lib/lzo/lzo1x_compress.c: In function 'lzo1x_1_do_compress':\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n         |              ^~~~~~~~~~~\n   include/linux/minmax.h:72:10: note: in expansion of macro '__sign_use'\n      72 |         (__sign_use(ux) & __sign_use(uy))\n         |          ^~~~~~~~~~\n   include/linux/minmax.h:90:27: note: in expansion of macro '__types_ok'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |                           ^~~~~~~~~~\n   include/linux/minmax.h:95:9: note: in expansion of macro '__careful_cmp_once'\n      95 |         __careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n         |         ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:102:25: note: in expansion of macro '__careful_cmp'\n     102 | #define min(x, y)       __careful_cmp(min, x, y)\n         |                         ^~~~~~~~~~~~~\n   lib/lzo/lzo1x_compress.c:65:54: note: in expansion of macro 'min'\n      65 |                         const unsigned char *limit = min(ip_end, ip + MAX_ZERO_RUN_LENGTH + 1);\n         |                                                      ^~~\n>> include/linux/minmax.h:65:46: warning: ordered comparison of pointer with integer zero [-Wextra]\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                                              ^~\n   include/linux/compiler_types.h:610:23: note: in definition of macro '__compiletime_assert'\n     610 |                 if (!(condition))                                       \\\n         |                       ^~~~~~~~~\n   include/linux/compiler_types.h:630:9: note: in expansion of macro '_compiletime_assert'\n     630 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n         |         ^~~~~~~~~~~~~~~~~~~\n   include/linux/build_bug.h:39:37: note: in expansion of macro 'compiletime_assert'\n      39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n         |                                     ^~~~~~~~~~~~~~~~~~\n   include/linux/minmax.h:90:9: note: in expansion of macro 'BUILD_BUG_ON_MSG'\n      90 |         BUILD_BUG_ON_MSG(!__types_ok(ux, uy),           \\\n         |         ^~~~~~~~~~~~~~~~\n   include/linux/minmax.h:65:25: note: in expansion of macro 'statically_true'\n      65 | #define __is_nonneg(ux) statically_true((ux) >= 0)\n         |                         ^~~~~~~~~~~~~~~\n   include/linux/minmax.h:50:14: note: in expansion of macro '__is_nonneg'\n      50 |         (2 + __i",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
      "normalized_subject": "overflow: Remove is_non_negative() and is_negative()",
      "message_count": 31,
      "participants": [
        "Miguel Ojeda",
        "kernel test robot",
        "Nicolas Schier",
        "Vincent Mailhol"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-12-19T22:39:47+00:00",
      "last_date": "2026-01-02T22:26:35+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176618685329043.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-3-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 3/4] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-19 22:39:47+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:47 +0000",
          "body": "The is_non_negative() and is_negative() function-like macros just\nexist as a workaround to silence the -Wtype-limits warning. Now that\nthis warning is disabled, those two macros have lost their raison\nd'\u00eatre. Remove them.\n\nThis reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\ncompilation warnings\").\n\nSuggested-by: Nicolas Schier <nsc@kernel.org>\nLink: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: new patch\n---\n include/linux/overflow.h | 10 ++--------\n 1 file changed, 2 insertions(+), 8 deletions(-)\n\ndiff --git a/include/linux/overflow.h b/include/linux/overflow.h\nindex 736f633b2d5f..ab142d60c6b5 100644\n--- a/include/linux/overflow.h\n+++ b/include/linux/overflow.h\n@@ -36,12 +36,6 @@\n #define __type_min(T) ((T)((T)-type_max(T)-(T)1))\n #define type_min(t)\t__type_min(typeof(t))\n \n-/*\n- * Avoids triggering -Wtype-limits compilation warning,\n- * while using unsigned data types to check a < 0.\n- */\n-#define is_non_negative(a) ((a) > 0 || (a) == 0)\n-#define is_negative(a) (!(is_non_negative(a)))\n \n /*\n  * Allows for effectively applying __must_check to a macro so we can have\n@@ -201,9 +195,9 @@ static inline bool __must_check __must_check_overflow(bool overflow)\n \ttypeof(d) _d = d;\t\t\t\t\t\t\\\n \tunsigned long long _a_full = _a;\t\t\t\t\\\n \tunsigned int _to_shift =\t\t\t\t\t\\\n-\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n+\t\t_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;\t\t\\\n \t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n-\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n+\t(_to_shift != _s || *_d < 0 || _a < 0 ||\t\t\t\\\n \t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n }))\n \n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176682822913070.mbox",
          "message_id": "<202512271618.33YepxDC-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-27 08:49:41+00:00",
          "date_str": "Sat, 27 Dec 2025 08:49:41 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: sparc-randconfig-r072-20251227 (https://download.01.org/0day-ci/archive/20251227/202512271618.33YepxDC-lkp@intel.com/config)\ncompiler: sparc64-linux-gcc (GCC) 15.1.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512271618.33YepxDC-lkp@intel.com/\n\nsmatch warnings:\ndrivers/block/nbd.c:1612 __nbd_ioctl() warn: unsigned '_a' is never less than zero.\n\nvim +/_a +1612 drivers/block/nbd.c\n\n55313e92bd17a87 Mike Christie     2019-08-13  1591  \n9442b739207aab6 Josef Bacik       2017-02-07  1592  /* Must be called with config_lock held */\n9442b739207aab6 Josef Bacik       2017-02-07  1593  static int __nbd_ioctl(struct block_device *bdev, struct nbd_device *nbd,\n9442b739207aab6 Josef Bacik       2017-02-07  1594  \t\t       unsigned int cmd, unsigned long arg)\n9442b739207aab6 Josef Bacik       2017-02-07  1595  {\n5ea8d10802ec4c1 Josef Bacik       2017-04-06  1596  \tstruct nbd_config *config = nbd->config;\nfad7cd3310db309 Baokun Li         2021-08-04  1597  \tloff_t bytesize;\n5ea8d10802ec4c1 Josef Bacik       2017-04-06  1598  \n9442b739207aab6 Josef Bacik       2017-02-07  1599  \tswitch (cmd) {\n9442b739207aab6 Josef Bacik       2017-02-07  1600  \tcase NBD_DISCONNECT:\n29eaadc0364943b Josef Bacik       2017-04-06  1601  \t\treturn nbd_disconnect(nbd);\n9442b739207aab6 Josef Bacik       2017-02-07  1602  \tcase NBD_CLEAR_SOCK:\n0c1c9a27ce909e3 Christoph Hellwig 2023-08-11  1603  \t\tnbd_clear_sock_ioctl(nbd);\n29eaadc0364943b Josef Bacik       2017-04-06  1604  \t\treturn 0;\n9442b739207aab6 Josef Bacik       2017-02-07  1605  \tcase NBD_SET_SOCK:\ne46c7287b1c2768 Josef Bacik       2017-04-06  1606  \t\treturn nbd_add_socket(nbd, arg, false);\n9442b739207aab6 Josef Bacik       2017-02-07  1607  \tcase NBD_SET_BLKSIZE:\ndcbddf541f18e36 Christoph Hellwig 2020-11-16  1608  \t\treturn nbd_set_size(nbd, config->bytesize, arg);\n9442b739207aab6 Josef Bacik       2017-02-07  1609  \tcase NBD_SET_SIZE:\n41e76c6a3c83c85 Nick Desaulniers  2021-09-20  1610  \t\treturn nbd_set_size(nbd, arg, nbd_blksize(config));\n9442b739207aab6 Josef Bacik       2017-02-07  1611  \tcase NBD_SET_SIZE_BLOCKS:\n41e76c6a3c83c85 Nick Desaulniers  2021-09-20 @1612  \t\tif (check_shl_overflow(arg, config->blksize_bits, &bytesize))\nfad7cd3310db309 Baokun Li         2021-08-04  1613  \t\t\treturn -EINVAL;\n41e76c6a3c83c85 Nick Desaulniers  2021-09-20  1614  \t\treturn nbd_set_size(nbd, bytesize, nbd_blksize(config));\n9442b739207aab6 Josef Bacik       2017-02-07  1615  \tcase NBD_SET_TIMEOUT:\n55313e92bd17a87 Mike Christie     2019-08-13  1616  \t\tnbd_set_cmd_timeout(nbd, arg);\n9442b739207aab6 Josef Bacik       2017-02-07  1617  \t\treturn 0;\n9442b739207aab6 Josef Bacik       2017-02-07  1618  \n9442b739207aab6 Josef Bacik       2017-02-07  1619  \tcase NBD_SET_FLAGS:\n5ea8d10802ec4c1 Josef Bacik       2017-04-06  1620  \t\tconfig->flags = arg;\n9442b739207aab6 Josef Bacik       2017-02-07  1621  \t\treturn 0;\n9442b739207aab6 Josef Bacik       2017-02-07  1622  \tcase NBD_DO_IT:\n2a852a693f8839b Christoph Hellwig 2022-03-30  1623  \t\treturn nbd_start_device_ioctl(nbd);\n^1da177e4c3f415 Linus Torvalds    2005-04-16  1624  \tcase NBD_CLEAR_QUE:\n4b2f0260c74324a Herbert Xu        2006-01-06  1625  \t\t/*\n4b2f0260c74324a Herbert Xu        2006-01-06  1626  \t\t * This is for compatibility only.  The queue is always cleared\n4b2f0260c74324a Herbert Xu        2006-01-06  1627  \t\t * by NBD_DO_IT or NBD_CLEAR_SOCK.\n4b2f0260c74324a Herbert Xu        2006-01-06  1628  \t\t */\n^1da177e4c3f415 Linus Torvalds    2005-04-16  1629  \t\treturn 0;\n^1da177e4c3f415 Linus Torvalds    2005-04-16  1630  \tcase NBD_PRINT_DEBUG:\nfd8383fd88a2fd8 Josef Bacik       2016-09-08  1631  \t\t/*\nfd8383fd88a2fd8 Josef Bacik       2016-09-08  1632  \t\t * For compatibility only, we no longer keep a list of\nfd8383fd88a2fd8 Josef Bacik       2016-09-08  1633  \t\t * outstanding requests.\nfd8383fd88a2fd8 Josef Bacik       2016-09-08  1634  \t\t */\n^1da177e4c3f415 Linus Torvalds    2005-04-16  1635  \t\treturn 0;\n^1da177e4c3f415 Linus Torvalds    2005-04-16  1636  \t}\n1a2ad21128bb4eb Pavel Machek      2009-04-02  1637  \treturn -ENOTTY;\n1a2ad21128bb4eb Pavel Machek      2009-04-02  1638  }\n1a2ad21128bb4eb Pavel Machek      2009-04-02  1639  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176688890210925.mbox",
          "message_id": "<202512280906.wt7UNpya-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-28 01:41:05+00:00",
          "date_str": "Sun, 28 Dec 2025 01:41:05 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: arm-randconfig-r071-20251224 (https://download.01.org/0day-ci/archive/20251228/202512280906.wt7UNpya-lkp@intel.com/config)\ncompiler: arm-linux-gnueabi-gcc (GCC) 8.5.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512280906.wt7UNpya-lkp@intel.com/\n\nsmatch warnings:\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '*_d' is never less than zero.\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '_a' is never less than zero.\n\nvim +144 fs/xfs/xfs_mount.c\n\n27174203f570b9 Christoph Hellwig 2009-03-30  130  \n4cc929ee305c69 Nathan Scott      2007-05-14  131  /*\n4cc929ee305c69 Nathan Scott      2007-05-14  132   * Check size of device based on the (data/realtime) block count.\n4cc929ee305c69 Nathan Scott      2007-05-14  133   * Note: this check is used by the growfs code as well as mount.\n4cc929ee305c69 Nathan Scott      2007-05-14  134   */\n4cc929ee305c69 Nathan Scott      2007-05-14  135  int\n4cc929ee305c69 Nathan Scott      2007-05-14  136  xfs_sb_validate_fsb_count(\n4cc929ee305c69 Nathan Scott      2007-05-14  137  \txfs_sb_t\t*sbp,\nc8ce540db5f67d Darrick J. Wong   2017-06-16  138  \tuint64_t\tnblocks)\n4cc929ee305c69 Nathan Scott      2007-05-14  139  {\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  140  \tuint64_t\t\tmax_bytes;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  141  \n4cc929ee305c69 Nathan Scott      2007-05-14  142  \tASSERT(sbp->sb_blocklog >= BBSHIFT);\n4cc929ee305c69 Nathan Scott      2007-05-14  143  \ncebf9dacd5c3ce Pankaj Raghav     2024-08-22 @144  \tif (check_shl_overflow(nblocks, sbp->sb_blocklog, &max_bytes))\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  145  \t\treturn -EFBIG;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  146  \nd5cf09baced0ef Christoph Hellwig 2014-07-30  147  \t/* Limited by ULONG_MAX of page cache index */\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  148  \tif (max_bytes >> PAGE_SHIFT > ULONG_MAX)\n2451337dd04390 Dave Chinner      2014-06-25  149  \t\treturn -EFBIG;\n4cc929ee305c69 Nathan Scott      2007-05-14  150  \treturn 0;\n4cc929ee305c69 Nathan Scott      2007-05-14  151  }\n^1da177e4c3f41 Linus Torvalds    2005-04-16  152  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176688890010920.mbox",
          "message_id": "<202512280906.wt7UNpya-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-28 01:41:05+00:00",
          "date_str": "Sun, 28 Dec 2025 01:41:05 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: arm-randconfig-r071-20251224 (https://download.01.org/0day-ci/archive/20251228/202512280906.wt7UNpya-lkp@intel.com/config)\ncompiler: arm-linux-gnueabi-gcc (GCC) 8.5.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512280906.wt7UNpya-lkp@intel.com/\n\nsmatch warnings:\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '*_d' is never less than zero.\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '_a' is never less than zero.\n\nvim +144 fs/xfs/xfs_mount.c\n\n27174203f570b9 Christoph Hellwig 2009-03-30  130  \n4cc929ee305c69 Nathan Scott      2007-05-14  131  /*\n4cc929ee305c69 Nathan Scott      2007-05-14  132   * Check size of device based on the (data/realtime) block count.\n4cc929ee305c69 Nathan Scott      2007-05-14  133   * Note: this check is used by the growfs code as well as mount.\n4cc929ee305c69 Nathan Scott      2007-05-14  134   */\n4cc929ee305c69 Nathan Scott      2007-05-14  135  int\n4cc929ee305c69 Nathan Scott      2007-05-14  136  xfs_sb_validate_fsb_count(\n4cc929ee305c69 Nathan Scott      2007-05-14  137  \txfs_sb_t\t*sbp,\nc8ce540db5f67d Darrick J. Wong   2017-06-16  138  \tuint64_t\tnblocks)\n4cc929ee305c69 Nathan Scott      2007-05-14  139  {\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  140  \tuint64_t\t\tmax_bytes;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  141  \n4cc929ee305c69 Nathan Scott      2007-05-14  142  \tASSERT(sbp->sb_blocklog >= BBSHIFT);\n4cc929ee305c69 Nathan Scott      2007-05-14  143  \ncebf9dacd5c3ce Pankaj Raghav     2024-08-22 @144  \tif (check_shl_overflow(nblocks, sbp->sb_blocklog, &max_bytes))\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  145  \t\treturn -EFBIG;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  146  \nd5cf09baced0ef Christoph Hellwig 2014-07-30  147  \t/* Limited by ULONG_MAX of page cache index */\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  148  \tif (max_bytes >> PAGE_SHIFT > ULONG_MAX)\n2451337dd04390 Dave Chinner      2014-06-25  149  \t\treturn -EFBIG;\n4cc929ee305c69 Nathan Scott      2007-05-14  150  \treturn 0;\n4cc929ee305c69 Nathan Scott      2007-05-14  151  }\n^1da177e4c3f41 Linus Torvalds    2005-04-16  152  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176688889310916.mbox",
          "message_id": "<202512280906.wt7UNpya-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-28 01:41:05+00:00",
          "date_str": "Sun, 28 Dec 2025 01:41:05 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: arm-randconfig-r071-20251224 (https://download.01.org/0day-ci/archive/20251228/202512280906.wt7UNpya-lkp@intel.com/config)\ncompiler: arm-linux-gnueabi-gcc (GCC) 8.5.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512280906.wt7UNpya-lkp@intel.com/\n\nsmatch warnings:\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '*_d' is never less than zero.\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '_a' is never less than zero.\n\nvim +144 fs/xfs/xfs_mount.c\n\n27174203f570b9 Christoph Hellwig 2009-03-30  130  \n4cc929ee305c69 Nathan Scott      2007-05-14  131  /*\n4cc929ee305c69 Nathan Scott      2007-05-14  132   * Check size of device based on the (data/realtime) block count.\n4cc929ee305c69 Nathan Scott      2007-05-14  133   * Note: this check is used by the growfs code as well as mount.\n4cc929ee305c69 Nathan Scott      2007-05-14  134   */\n4cc929ee305c69 Nathan Scott      2007-05-14  135  int\n4cc929ee305c69 Nathan Scott      2007-05-14  136  xfs_sb_validate_fsb_count(\n4cc929ee305c69 Nathan Scott      2007-05-14  137  \txfs_sb_t\t*sbp,\nc8ce540db5f67d Darrick J. Wong   2017-06-16  138  \tuint64_t\tnblocks)\n4cc929ee305c69 Nathan Scott      2007-05-14  139  {\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  140  \tuint64_t\t\tmax_bytes;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  141  \n4cc929ee305c69 Nathan Scott      2007-05-14  142  \tASSERT(sbp->sb_blocklog >= BBSHIFT);\n4cc929ee305c69 Nathan Scott      2007-05-14  143  \ncebf9dacd5c3ce Pankaj Raghav     2024-08-22 @144  \tif (check_shl_overflow(nblocks, sbp->sb_blocklog, &max_bytes))\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  145  \t\treturn -EFBIG;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  146  \nd5cf09baced0ef Christoph Hellwig 2014-07-30  147  \t/* Limited by ULONG_MAX of page cache index */\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  148  \tif (max_bytes >> PAGE_SHIFT > ULONG_MAX)\n2451337dd04390 Dave Chinner      2014-06-25  149  \t\treturn -EFBIG;\n4cc929ee305c69 Nathan Scott      2007-05-14  150  \treturn 0;\n4cc929ee305c69 Nathan Scott      2007-05-14  151  }\n^1da177e4c3f41 Linus Torvalds    2005-04-16  152  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176688889310917.mbox",
          "message_id": "<202512280906.wt7UNpya-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-28 01:41:05+00:00",
          "date_str": "Sun, 28 Dec 2025 01:41:05 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: arm-randconfig-r071-20251224 (https://download.01.org/0day-ci/archive/20251228/202512280906.wt7UNpya-lkp@intel.com/config)\ncompiler: arm-linux-gnueabi-gcc (GCC) 8.5.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512280906.wt7UNpya-lkp@intel.com/\n\nsmatch warnings:\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '*_d' is never less than zero.\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '_a' is never less than zero.\n\nvim +144 fs/xfs/xfs_mount.c\n\n27174203f570b9 Christoph Hellwig 2009-03-30  130  \n4cc929ee305c69 Nathan Scott      2007-05-14  131  /*\n4cc929ee305c69 Nathan Scott      2007-05-14  132   * Check size of device based on the (data/realtime) block count.\n4cc929ee305c69 Nathan Scott      2007-05-14  133   * Note: this check is used by the growfs code as well as mount.\n4cc929ee305c69 Nathan Scott      2007-05-14  134   */\n4cc929ee305c69 Nathan Scott      2007-05-14  135  int\n4cc929ee305c69 Nathan Scott      2007-05-14  136  xfs_sb_validate_fsb_count(\n4cc929ee305c69 Nathan Scott      2007-05-14  137  \txfs_sb_t\t*sbp,\nc8ce540db5f67d Darrick J. Wong   2017-06-16  138  \tuint64_t\tnblocks)\n4cc929ee305c69 Nathan Scott      2007-05-14  139  {\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  140  \tuint64_t\t\tmax_bytes;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  141  \n4cc929ee305c69 Nathan Scott      2007-05-14  142  \tASSERT(sbp->sb_blocklog >= BBSHIFT);\n4cc929ee305c69 Nathan Scott      2007-05-14  143  \ncebf9dacd5c3ce Pankaj Raghav     2024-08-22 @144  \tif (check_shl_overflow(nblocks, sbp->sb_blocklog, &max_bytes))\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  145  \t\treturn -EFBIG;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  146  \nd5cf09baced0ef Christoph Hellwig 2014-07-30  147  \t/* Limited by ULONG_MAX of page cache index */\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  148  \tif (max_bytes >> PAGE_SHIFT > ULONG_MAX)\n2451337dd04390 Dave Chinner      2014-06-25  149  \t\treturn -EFBIG;\n4cc929ee305c69 Nathan Scott      2007-05-14  150  \treturn 0;\n4cc929ee305c69 Nathan Scott      2007-05-14  151  }\n^1da177e4c3f41 Linus Torvalds    2005-04-16  152  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176688891910933.mbox",
          "message_id": "<202512280906.wt7UNpya-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-28 01:41:05+00:00",
          "date_str": "Sun, 28 Dec 2025 01:41:05 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: arm-randconfig-r071-20251224 (https://download.01.org/0day-ci/archive/20251228/202512280906.wt7UNpya-lkp@intel.com/config)\ncompiler: arm-linux-gnueabi-gcc (GCC) 8.5.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512280906.wt7UNpya-lkp@intel.com/\n\nsmatch warnings:\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '*_d' is never less than zero.\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '_a' is never less than zero.\n\nvim +144 fs/xfs/xfs_mount.c\n\n27174203f570b9 Christoph Hellwig 2009-03-30  130  \n4cc929ee305c69 Nathan Scott      2007-05-14  131  /*\n4cc929ee305c69 Nathan Scott      2007-05-14  132   * Check size of device based on the (data/realtime) block count.\n4cc929ee305c69 Nathan Scott      2007-05-14  133   * Note: this check is used by the growfs code as well as mount.\n4cc929ee305c69 Nathan Scott      2007-05-14  134   */\n4cc929ee305c69 Nathan Scott      2007-05-14  135  int\n4cc929ee305c69 Nathan Scott      2007-05-14  136  xfs_sb_validate_fsb_count(\n4cc929ee305c69 Nathan Scott      2007-05-14  137  \txfs_sb_t\t*sbp,\nc8ce540db5f67d Darrick J. Wong   2017-06-16  138  \tuint64_t\tnblocks)\n4cc929ee305c69 Nathan Scott      2007-05-14  139  {\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  140  \tuint64_t\t\tmax_bytes;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  141  \n4cc929ee305c69 Nathan Scott      2007-05-14  142  \tASSERT(sbp->sb_blocklog >= BBSHIFT);\n4cc929ee305c69 Nathan Scott      2007-05-14  143  \ncebf9dacd5c3ce Pankaj Raghav     2024-08-22 @144  \tif (check_shl_overflow(nblocks, sbp->sb_blocklog, &max_bytes))\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  145  \t\treturn -EFBIG;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  146  \nd5cf09baced0ef Christoph Hellwig 2014-07-30  147  \t/* Limited by ULONG_MAX of page cache index */\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  148  \tif (max_bytes >> PAGE_SHIFT > ULONG_MAX)\n2451337dd04390 Dave Chinner      2014-06-25  149  \t\treturn -EFBIG;\n4cc929ee305c69 Nathan Scott      2007-05-14  150  \treturn 0;\n4cc929ee305c69 Nathan Scott      2007-05-14  151  }\n^1da177e4c3f41 Linus Torvalds    2005-04-16  152  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176688890510930.mbox",
          "message_id": "<202512280906.wt7UNpya-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2025-12-28 01:41:05+00:00",
          "date_str": "Sun, 28 Dec 2025 01:41:05 +0000",
          "body": "Hi Vincent,\n\nkernel test robot noticed the following build warnings:\n\n[auto build test WARNING on 3e7f562e20ee87a25e104ef4fce557d39d62fa85]\n\nurl:    https://github.com/intel-lab-lkp/linux/commits/Vincent-Mailhol/kbuild-remove-gcc-s-Wtype-limits/20251220-190509\nbase:   3e7f562e20ee87a25e104ef4fce557d39d62fa85\npatch link:    https://lore.kernel.org/r/20251220-remove_wtype-limits-v3-3-24b170af700e%40kernel.org\npatch subject: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()\nconfig: arm-randconfig-r071-20251224 (https://download.01.org/0day-ci/archive/20251228/202512280906.wt7UNpya-lkp@intel.com/config)\ncompiler: arm-linux-gnueabi-gcc (GCC) 8.5.0\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202512280906.wt7UNpya-lkp@intel.com/\n\nsmatch warnings:\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '*_d' is never less than zero.\nfs/xfs/xfs_mount.c:144 xfs_sb_validate_fsb_count() warn: unsigned '_a' is never less than zero.\n\nvim +144 fs/xfs/xfs_mount.c\n\n27174203f570b9 Christoph Hellwig 2009-03-30  130  \n4cc929ee305c69 Nathan Scott      2007-05-14  131  /*\n4cc929ee305c69 Nathan Scott      2007-05-14  132   * Check size of device based on the (data/realtime) block count.\n4cc929ee305c69 Nathan Scott      2007-05-14  133   * Note: this check is used by the growfs code as well as mount.\n4cc929ee305c69 Nathan Scott      2007-05-14  134   */\n4cc929ee305c69 Nathan Scott      2007-05-14  135  int\n4cc929ee305c69 Nathan Scott      2007-05-14  136  xfs_sb_validate_fsb_count(\n4cc929ee305c69 Nathan Scott      2007-05-14  137  \txfs_sb_t\t*sbp,\nc8ce540db5f67d Darrick J. Wong   2017-06-16  138  \tuint64_t\tnblocks)\n4cc929ee305c69 Nathan Scott      2007-05-14  139  {\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  140  \tuint64_t\t\tmax_bytes;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  141  \n4cc929ee305c69 Nathan Scott      2007-05-14  142  \tASSERT(sbp->sb_blocklog >= BBSHIFT);\n4cc929ee305c69 Nathan Scott      2007-05-14  143  \ncebf9dacd5c3ce Pankaj Raghav     2024-08-22 @144  \tif (check_shl_overflow(nblocks, sbp->sb_blocklog, &max_bytes))\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  145  \t\treturn -EFBIG;\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  146  \nd5cf09baced0ef Christoph Hellwig 2014-07-30  147  \t/* Limited by ULONG_MAX of page cache index */\ncebf9dacd5c3ce Pankaj Raghav     2024-08-22  148  \tif (max_bytes >> PAGE_SHIFT > ULONG_MAX)\n2451337dd04390 Dave Chinner      2014-06-25  149  \t\treturn -EFBIG;\n4cc929ee305c69 Nathan Scott      2007-05-14  150  \treturn 0;\n4cc929ee305c69 Nathan Scott      2007-05-14  151  }\n^1da177e4c3f41 Linus Torvalds    2005-04-16  152  \n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176728303722044.mbox",
          "message_id": "<acdd84b2-e893-419c-8a46-da55d695dda2 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 15:10:36+00:00",
          "date_str": "Thu, 01 Jan 2026 15:10:36 +0000",
          "body": "On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> The is_non_negative() and is_negative() function-like macros just\n> exist as a workaround to silence the -Wtype-limits warning. Now that\n> this warning is disabled, those two macros have lost their raison\n> d'\u00eatre. Remove them.\n> \n> This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> compilation warnings\").\n> \n> Suggested-by: Nicolas Schier <nsc@kernel.org>\n> Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n\nSo at the end, this patch got five kernel test robot reports:\n\n  https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n  https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n  https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n  https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n  https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n\nAll these are the same smatch warning just triggered from a different\nplace. I think it is still too early to undo that workaround in\ninclude/linux/overflow.h, otherwise developers would be getting that\nsmatch report too often.\n\nI will send a v4 in which I will drop this patch. This basically means\nthat the v4 is a revert to v1...\n\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/overflow.h | 10 ++--------\n>  1 file changed, 2 insertions(+), 8 deletions(-)\n> \n> diff --git a/include/linux/overflow.h b/include/linux/overflow.h\n> index 736f633b2d5f..ab142d60c6b5 100644\n> --- a/include/linux/overflow.h\n> +++ b/include/linux/overflow.h\n> @@ -36,12 +36,6 @@\n>  #define __type_min(T) ((T)((T)-type_max(T)-(T)1))\n>  #define type_min(t)\t__type_min(typeof(t))\n>  \n> -/*\n> - * Avoids triggering -Wtype-limits compilation warning,\n> - * while using unsigned data types to check a < 0.\n> - */\n> -#define is_non_negative(a) ((a) > 0 || (a) == 0)\n> -#define is_negative(a) (!(is_non_negative(a)))\n>  \n>  /*\n>   * Allows for effectively applying __must_check to a macro so we can have\n> @@ -201,9 +195,9 @@ static inline bool __must_check __must_check_overflow(bool overflow)\n>  \ttypeof(d) _d = d;\t\t\t\t\t\t\\\n>  \tunsigned long long _a_full = _a;\t\t\t\t\\\n>  \tunsigned int _to_shift =\t\t\t\t\t\\\n> -\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n> +\t\t_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;\t\t\\\n>  \t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n> -\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n> +\t(_to_shift != _s || *_d < 0 || _a < 0 ||\t\t\t\\\n>  \t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n>  }))\n>  \n> \n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176728303222036.mbox",
          "message_id": "<acdd84b2-e893-419c-8a46-da55d695dda2 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 15:10:36+00:00",
          "date_str": "Thu, 01 Jan 2026 15:10:36 +0000",
          "body": "On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> The is_non_negative() and is_negative() function-like macros just\n> exist as a workaround to silence the -Wtype-limits warning. Now that\n> this warning is disabled, those two macros have lost their raison\n> d'\u00eatre. Remove them.\n> \n> This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> compilation warnings\").\n> \n> Suggested-by: Nicolas Schier <nsc@kernel.org>\n> Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n\nSo at the end, this patch got five kernel test robot reports:\n\n  https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n  https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n  https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n  https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n  https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n\nAll these are the same smatch warning just triggered from a different\nplace. I think it is still too early to undo that workaround in\ninclude/linux/overflow.h, otherwise developers would be getting that\nsmatch report too often.\n\nI will send a v4 in which I will drop this patch. This basically means\nthat the v4 is a revert to v1...\n\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/overflow.h | 10 ++--------\n>  1 file changed, 2 insertions(+), 8 deletions(-)\n> \n> diff --git a/include/linux/overflow.h b/include/linux/overflow.h\n> index 736f633b2d5f..ab142d60c6b5 100644\n> --- a/include/linux/overflow.h\n> +++ b/include/linux/overflow.h\n> @@ -36,12 +36,6 @@\n>  #define __type_min(T) ((T)((T)-type_max(T)-(T)1))\n>  #define type_min(t)\t__type_min(typeof(t))\n>  \n> -/*\n> - * Avoids triggering -Wtype-limits compilation warning,\n> - * while using unsigned data types to check a < 0.\n> - */\n> -#define is_non_negative(a) ((a) > 0 || (a) == 0)\n> -#define is_negative(a) (!(is_non_negative(a)))\n>  \n>  /*\n>   * Allows for effectively applying __must_check to a macro so we can have\n> @@ -201,9 +195,9 @@ static inline bool __must_check __must_check_overflow(bool overflow)\n>  \ttypeof(d) _d = d;\t\t\t\t\t\t\\\n>  \tunsigned long long _a_full = _a;\t\t\t\t\\\n>  \tunsigned int _to_shift =\t\t\t\t\t\\\n> -\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n> +\t\t_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;\t\t\\\n>  \t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n> -\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n> +\t(_to_shift != _s || *_d < 0 || _a < 0 ||\t\t\t\\\n>  \t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n>  }))\n>  \n> \n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176728304122048.mbox",
          "message_id": "<acdd84b2-e893-419c-8a46-da55d695dda2 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 15:10:36+00:00",
          "date_str": "Thu, 01 Jan 2026 15:10:36 +0000",
          "body": "On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> The is_non_negative() and is_negative() function-like macros just\n> exist as a workaround to silence the -Wtype-limits warning. Now that\n> this warning is disabled, those two macros have lost their raison\n> d'\u00eatre. Remove them.\n> \n> This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> compilation warnings\").\n> \n> Suggested-by: Nicolas Schier <nsc@kernel.org>\n> Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n\nSo at the end, this patch got five kernel test robot reports:\n\n  https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n  https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n  https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n  https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n  https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n\nAll these are the same smatch warning just triggered from a different\nplace. I think it is still too early to undo that workaround in\ninclude/linux/overflow.h, otherwise developers would be getting that\nsmatch report too often.\n\nI will send a v4 in which I will drop this patch. This basically means\nthat the v4 is a revert to v1...\n\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/overflow.h | 10 ++--------\n>  1 file changed, 2 insertions(+), 8 deletions(-)\n> \n> diff --git a/include/linux/overflow.h b/include/linux/overflow.h\n> index 736f633b2d5f..ab142d60c6b5 100644\n> --- a/include/linux/overflow.h\n> +++ b/include/linux/overflow.h\n> @@ -36,12 +36,6 @@\n>  #define __type_min(T) ((T)((T)-type_max(T)-(T)1))\n>  #define type_min(t)\t__type_min(typeof(t))\n>  \n> -/*\n> - * Avoids triggering -Wtype-limits compilation warning,\n> - * while using unsigned data types to check a < 0.\n> - */\n> -#define is_non_negative(a) ((a) > 0 || (a) == 0)\n> -#define is_negative(a) (!(is_non_negative(a)))\n>  \n>  /*\n>   * Allows for effectively applying __must_check to a macro so we can have\n> @@ -201,9 +195,9 @@ static inline bool __must_check __must_check_overflow(bool overflow)\n>  \ttypeof(d) _d = d;\t\t\t\t\t\t\\\n>  \tunsigned long long _a_full = _a;\t\t\t\t\\\n>  \tunsigned int _to_shift =\t\t\t\t\t\\\n> -\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n> +\t\t_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;\t\t\\\n>  \t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n> -\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n> +\t(_to_shift != _s || *_d < 0 || _a < 0 ||\t\t\t\\\n>  \t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n>  }))\n>  \n> \n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176728305722062.mbox",
          "message_id": "<acdd84b2-e893-419c-8a46-da55d695dda2 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 15:10:36+00:00",
          "date_str": "Thu, 01 Jan 2026 15:10:36 +0000",
          "body": "On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> The is_non_negative() and is_negative() function-like macros just\n> exist as a workaround to silence the -Wtype-limits warning. Now that\n> this warning is disabled, those two macros have lost their raison\n> d'\u00eatre. Remove them.\n> \n> This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> compilation warnings\").\n> \n> Suggested-by: Nicolas Schier <nsc@kernel.org>\n> Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n\nSo at the end, this patch got five kernel test robot reports:\n\n  https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n  https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n  https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n  https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n  https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n\nAll these are the same smatch warning just triggered from a different\nplace. I think it is still too early to undo that workaround in\ninclude/linux/overflow.h, otherwise developers would be getting that\nsmatch report too often.\n\nI will send a v4 in which I will drop this patch. This basically means\nthat the v4 is a revert to v1...\n\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/overflow.h | 10 ++--------\n>  1 file changed, 2 insertions(+), 8 deletions(-)\n> \n> diff --git a/include/linux/overflow.h b/include/linux/overflow.h\n> index 736f633b2d5f..ab142d60c6b5 100644\n> --- a/include/linux/overflow.h\n> +++ b/include/linux/overflow.h\n> @@ -36,12 +36,6 @@\n>  #define __type_min(T) ((T)((T)-type_max(T)-(T)1))\n>  #define type_min(t)\t__type_min(typeof(t))\n>  \n> -/*\n> - * Avoids triggering -Wtype-limits compilation warning,\n> - * while using unsigned data types to check a < 0.\n> - */\n> -#define is_non_negative(a) ((a) > 0 || (a) == 0)\n> -#define is_negative(a) (!(is_non_negative(a)))\n>  \n>  /*\n>   * Allows for effectively applying __must_check to a macro so we can have\n> @@ -201,9 +195,9 @@ static inline bool __must_check __must_check_overflow(bool overflow)\n>  \ttypeof(d) _d = d;\t\t\t\t\t\t\\\n>  \tunsigned long long _a_full = _a;\t\t\t\t\\\n>  \tunsigned int _to_shift =\t\t\t\t\t\\\n> -\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n> +\t\t_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;\t\t\\\n>  \t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n> -\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n> +\t(_to_shift != _s || *_d < 0 || _a < 0 ||\t\t\t\\\n>  \t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n>  }))\n>  \n> \n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176728303422039.mbox",
          "message_id": "<acdd84b2-e893-419c-8a46-da55d695dda2 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 15:10:36+00:00",
          "date_str": "Thu, 01 Jan 2026 15:10:36 +0000",
          "body": "On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> The is_non_negative() and is_negative() function-like macros just\n> exist as a workaround to silence the -Wtype-limits warning. Now that\n> this warning is disabled, those two macros have lost their raison\n> d'\u00eatre. Remove them.\n> \n> This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> compilation warnings\").\n> \n> Suggested-by: Nicolas Schier <nsc@kernel.org>\n> Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n\nSo at the end, this patch got five kernel test robot reports:\n\n  https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n  https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n  https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n  https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n  https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n\nAll these are the same smatch warning just triggered from a different\nplace. I think it is still too early to undo that workaround in\ninclude/linux/overflow.h, otherwise developers would be getting that\nsmatch report too often.\n\nI will send a v4 in which I will drop this patch. This basically means\nthat the v4 is a revert to v1...\n\n> ---\n> Changelog:\n> \n>   v1 -> v2: new patch\n> ---\n>  include/linux/overflow.h | 10 ++--------\n>  1 file changed, 2 insertions(+), 8 deletions(-)\n> \n> diff --git a/include/linux/overflow.h b/include/linux/overflow.h\n> index 736f633b2d5f..ab142d60c6b5 100644\n> --- a/include/linux/overflow.h\n> +++ b/include/linux/overflow.h\n> @@ -36,12 +36,6 @@\n>  #define __type_min(T) ((T)((T)-type_max(T)-(T)1))\n>  #define type_min(t)\t__type_min(typeof(t))\n>  \n> -/*\n> - * Avoids triggering -Wtype-limits compilation warning,\n> - * while using unsigned data types to check a < 0.\n> - */\n> -#define is_non_negative(a) ((a) > 0 || (a) == 0)\n> -#define is_negative(a) (!(is_non_negative(a)))\n>  \n>  /*\n>   * Allows for effectively applying __must_check to a macro so we can have\n> @@ -201,9 +195,9 @@ static inline bool __must_check __must_check_overflow(bool overflow)\n>  \ttypeof(d) _d = d;\t\t\t\t\t\t\\\n>  \tunsigned long long _a_full = _a;\t\t\t\t\\\n>  \tunsigned int _to_shift =\t\t\t\t\t\\\n> -\t\tis_non_negative(_s) && _s < 8 * sizeof(*d) ? _s : 0;\t\\\n> +\t\t_s >= 0 && _s < 8 * sizeof(*d) ? _s : 0;\t\t\\\n>  \t*_d = (_a_full << _to_shift);\t\t\t\t\t\\\n> -\t(_to_shift != _s || is_negative(*_d) || is_negative(_a) ||\t\\\n> +\t(_to_shift != _s || *_d < 0 || _a < 0 ||\t\t\t\\\n>  \t(*_d >> _to_shift) != _a);\t\t\t\t\t\\\n>  }))\n>  \n> \n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176730115631454.mbox",
          "message_id": "<20260101-futuristic-petrel-of-ecstasy-23db5f () lindesnes>",
          "author_name": "Nicolas Schier",
          "author_email": "nicolas () fjasle ! eu",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 19:39:46+00:00",
          "date_str": "Thu, 01 Jan 2026 19:39:46 +0000",
          "body": "\n--0BVVorEFNEq+bZUt\nContent-Type: text/plain; charset=iso-8859-1\nContent-Disposition: inline\nContent-Transfer-Encoding: quoted-printable\n\nOn Thu, Jan 01, 2026 at 04:10:36PM +0100, Vincent Mailhol wrote:\n> On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> > The is_non_negative() and is_negative() function-like macros just\n> > exist as a workaround to silence the -Wtype-limits warning. Now that\n> > this warning is disabled, those two macros have lost their raison\n> > d'=EAtre. Remove them.\n> >=20\n> > This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> > compilation warnings\").\n> >=20\n> > Suggested-by: Nicolas Schier <nsc@kernel.org>\n> > Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> > Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n>=20\n> So at the end, this patch got five kernel test robot reports:\n>=20\n>   https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n>   https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n>   https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n>   https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n>   https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n>=20\n> All these are the same smatch warning just triggered from a different\n> place. I think it is still too early to undo that workaround in\n> include/linux/overflow.h, otherwise developers would be getting that\n> smatch report too often.\n>=20\n> I will send a v4 in which I will drop this patch. This basically means\n> that the v4 is a revert to v1...\n\nthanks!  I think it's a bit sad to keep code only to make some checker=20\ntooling happy, but for now it seems to be the right thing to do.\n\nKind Regards,\nNicolas\n\n--0BVVorEFNEq+bZUt\nContent-Type: application/pgp-signature; name=\"signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0E3p4c3JKeBvsLGB1IKcBYmEmkFAmlWzYIACgkQB1IKcBYm\nEmkv5A/+JGh8gXsgclOmUAW84XlSnEuwIhRXs3PO+BaFvveNaRIkkKUPw6dsHWDR\nVlbsSCp/6fyRrH5A2UQ8i7mAgkaFPrmi76d50HrYsMDFDPcCmmFkQP+6UTSvymZo\nKBiXwBoypXpUzcUaoWPmwhMfWH+0Ov4IMj6Suy808QAaESPPwJORFmd7zTl7ZE3i\nzUibhRVpU3qlgcV0ZcpJAkx4KJFHc0ADv9GTAmWTeBHGMsqWk4xZaFCwLB8bv+IB\n1l1X+7DjY9GzqupPzrfTZxeFZsrG/DVQAtKUutcbvZJPM8XWD9sHtb4oM9BEbQr8\nShaZ3CbtXBGo5MCzQCw/Sb9DGCYm66apPE3NWbcEFKPqLG4slF7PdQ8o1DyyDbjK\nv8icj6elb23wmQGRd47aIVTcsFUeis+nJHAMnlQSMfVgDNB+trggaEHrzhcgP4Ff\nIhouTrsvdLsqzz01Oa+XQfR4GkjBxL6nWZLMbbOlXmHin4iSKqLKiCWrc6lkPJ7I\nd2F1JJoEH4XpbfdTV4YtsU+D3gpjywC7uGWSweHGTs8DihnQ/x5bwBUX3Bo98+pK\nT59NTfnjD02v+802qjCKvOoM90j5dX1FUCqhekc8Nm+TUlC5UHDjtts8SAmf1x9u\nOatEZU2f5zGPJBL91kVMQS7/psD1ZkDNucVtKBKX9gCveWFvVnQ=\n=7eoQ\n-----END PGP SIGNATURE-----\n\n--0BVVorEFNEq+bZUt--",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176730119331472.mbox",
          "message_id": "<20260101-futuristic-petrel-of-ecstasy-23db5f () lindesnes>",
          "author_name": "Nicolas Schier",
          "author_email": "nicolas () fjasle ! eu",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 19:39:46+00:00",
          "date_str": "Thu, 01 Jan 2026 19:39:46 +0000",
          "body": "\n--0BVVorEFNEq+bZUt\nContent-Type: text/plain; charset=iso-8859-1\nContent-Disposition: inline\nContent-Transfer-Encoding: quoted-printable\n\nOn Thu, Jan 01, 2026 at 04:10:36PM +0100, Vincent Mailhol wrote:\n> On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> > The is_non_negative() and is_negative() function-like macros just\n> > exist as a workaround to silence the -Wtype-limits warning. Now that\n> > this warning is disabled, those two macros have lost their raison\n> > d'=EAtre. Remove them.\n> >=20\n> > This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> > compilation warnings\").\n> >=20\n> > Suggested-by: Nicolas Schier <nsc@kernel.org>\n> > Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> > Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n>=20\n> So at the end, this patch got five kernel test robot reports:\n>=20\n>   https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n>   https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n>   https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n>   https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n>   https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n>=20\n> All these are the same smatch warning just triggered from a different\n> place. I think it is still too early to undo that workaround in\n> include/linux/overflow.h, otherwise developers would be getting that\n> smatch report too often.\n>=20\n> I will send a v4 in which I will drop this patch. This basically means\n> that the v4 is a revert to v1...\n\nthanks!  I think it's a bit sad to keep code only to make some checker=20\ntooling happy, but for now it seems to be the right thing to do.\n\nKind Regards,\nNicolas\n\n--0BVVorEFNEq+bZUt\nContent-Type: application/pgp-signature; name=\"signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0E3p4c3JKeBvsLGB1IKcBYmEmkFAmlWzYIACgkQB1IKcBYm\nEmkv5A/+JGh8gXsgclOmUAW84XlSnEuwIhRXs3PO+BaFvveNaRIkkKUPw6dsHWDR\nVlbsSCp/6fyRrH5A2UQ8i7mAgkaFPrmi76d50HrYsMDFDPcCmmFkQP+6UTSvymZo\nKBiXwBoypXpUzcUaoWPmwhMfWH+0Ov4IMj6Suy808QAaESPPwJORFmd7zTl7ZE3i\nzUibhRVpU3qlgcV0ZcpJAkx4KJFHc0ADv9GTAmWTeBHGMsqWk4xZaFCwLB8bv+IB\n1l1X+7DjY9GzqupPzrfTZxeFZsrG/DVQAtKUutcbvZJPM8XWD9sHtb4oM9BEbQr8\nShaZ3CbtXBGo5MCzQCw/Sb9DGCYm66apPE3NWbcEFKPqLG4slF7PdQ8o1DyyDbjK\nv8icj6elb23wmQGRd47aIVTcsFUeis+nJHAMnlQSMfVgDNB+trggaEHrzhcgP4Ff\nIhouTrsvdLsqzz01Oa+XQfR4GkjBxL6nWZLMbbOlXmHin4iSKqLKiCWrc6lkPJ7I\nd2F1JJoEH4XpbfdTV4YtsU+D3gpjywC7uGWSweHGTs8DihnQ/x5bwBUX3Bo98+pK\nT59NTfnjD02v+802qjCKvOoM90j5dX1FUCqhekc8Nm+TUlC5UHDjtts8SAmf1x9u\nOatEZU2f5zGPJBL91kVMQS7/psD1ZkDNucVtKBKX9gCveWFvVnQ=\n=7eoQ\n-----END PGP SIGNATURE-----\n\n--0BVVorEFNEq+bZUt--\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176730116531465.mbox",
          "message_id": "<20260101-futuristic-petrel-of-ecstasy-23db5f () lindesnes>",
          "author_name": "Nicolas Schier",
          "author_email": "nicolas () fjasle ! eu",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 19:39:46+00:00",
          "date_str": "Thu, 01 Jan 2026 19:39:46 +0000",
          "body": "\n--0BVVorEFNEq+bZUt\nContent-Type: text/plain; charset=iso-8859-1\nContent-Disposition: inline\nContent-Transfer-Encoding: quoted-printable\n\nOn Thu, Jan 01, 2026 at 04:10:36PM +0100, Vincent Mailhol wrote:\n> On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> > The is_non_negative() and is_negative() function-like macros just\n> > exist as a workaround to silence the -Wtype-limits warning. Now that\n> > this warning is disabled, those two macros have lost their raison\n> > d'=EAtre. Remove them.\n> >=20\n> > This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> > compilation warnings\").\n> >=20\n> > Suggested-by: Nicolas Schier <nsc@kernel.org>\n> > Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> > Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n>=20\n> So at the end, this patch got five kernel test robot reports:\n>=20\n>   https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n>   https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n>   https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n>   https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n>   https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n>=20\n> All these are the same smatch warning just triggered from a different\n> place. I think it is still too early to undo that workaround in\n> include/linux/overflow.h, otherwise developers would be getting that\n> smatch report too often.\n>=20\n> I will send a v4 in which I will drop this patch. This basically means\n> that the v4 is a revert to v1...\n\nthanks!  I think it's a bit sad to keep code only to make some checker=20\ntooling happy, but for now it seems to be the right thing to do.\n\nKind Regards,\nNicolas\n\n--0BVVorEFNEq+bZUt\nContent-Type: application/pgp-signature; name=\"signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0E3p4c3JKeBvsLGB1IKcBYmEmkFAmlWzYIACgkQB1IKcBYm\nEmkv5A/+JGh8gXsgclOmUAW84XlSnEuwIhRXs3PO+BaFvveNaRIkkKUPw6dsHWDR\nVlbsSCp/6fyRrH5A2UQ8i7mAgkaFPrmi76d50HrYsMDFDPcCmmFkQP+6UTSvymZo\nKBiXwBoypXpUzcUaoWPmwhMfWH+0Ov4IMj6Suy808QAaESPPwJORFmd7zTl7ZE3i\nzUibhRVpU3qlgcV0ZcpJAkx4KJFHc0ADv9GTAmWTeBHGMsqWk4xZaFCwLB8bv+IB\n1l1X+7DjY9GzqupPzrfTZxeFZsrG/DVQAtKUutcbvZJPM8XWD9sHtb4oM9BEbQr8\nShaZ3CbtXBGo5MCzQCw/Sb9DGCYm66apPE3NWbcEFKPqLG4slF7PdQ8o1DyyDbjK\nv8icj6elb23wmQGRd47aIVTcsFUeis+nJHAMnlQSMfVgDNB+trggaEHrzhcgP4Ff\nIhouTrsvdLsqzz01Oa+XQfR4GkjBxL6nWZLMbbOlXmHin4iSKqLKiCWrc6lkPJ7I\nd2F1JJoEH4XpbfdTV4YtsU+D3gpjywC7uGWSweHGTs8DihnQ/x5bwBUX3Bo98+pK\nT59NTfnjD02v+802qjCKvOoM90j5dX1FUCqhekc8Nm+TUlC5UHDjtts8SAmf1x9u\nOatEZU2f5zGPJBL91kVMQS7/psD1ZkDNucVtKBKX9gCveWFvVnQ=\n=7eoQ\n-----END PGP SIGNATURE-----\n\n--0BVVorEFNEq+bZUt--\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176730116131461.mbox",
          "message_id": "<20260101-futuristic-petrel-of-ecstasy-23db5f () lindesnes>",
          "author_name": "Nicolas Schier",
          "author_email": "nicolas () fjasle ! eu",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 19:39:46+00:00",
          "date_str": "Thu, 01 Jan 2026 19:39:46 +0000",
          "body": "\n--0BVVorEFNEq+bZUt\nContent-Type: text/plain; charset=iso-8859-1\nContent-Disposition: inline\nContent-Transfer-Encoding: quoted-printable\n\nOn Thu, Jan 01, 2026 at 04:10:36PM +0100, Vincent Mailhol wrote:\n> On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> > The is_non_negative() and is_negative() function-like macros just\n> > exist as a workaround to silence the -Wtype-limits warning. Now that\n> > this warning is disabled, those two macros have lost their raison\n> > d'=EAtre. Remove them.\n> >=20\n> > This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> > compilation warnings\").\n> >=20\n> > Suggested-by: Nicolas Schier <nsc@kernel.org>\n> > Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> > Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n>=20\n> So at the end, this patch got five kernel test robot reports:\n>=20\n>   https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n>   https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n>   https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n>   https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n>   https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n>=20\n> All these are the same smatch warning just triggered from a different\n> place. I think it is still too early to undo that workaround in\n> include/linux/overflow.h, otherwise developers would be getting that\n> smatch report too often.\n>=20\n> I will send a v4 in which I will drop this patch. This basically means\n> that the v4 is a revert to v1...\n\nthanks!  I think it's a bit sad to keep code only to make some checker=20\ntooling happy, but for now it seems to be the right thing to do.\n\nKind Regards,\nNicolas\n\n--0BVVorEFNEq+bZUt\nContent-Type: application/pgp-signature; name=\"signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0E3p4c3JKeBvsLGB1IKcBYmEmkFAmlWzYIACgkQB1IKcBYm\nEmkv5A/+JGh8gXsgclOmUAW84XlSnEuwIhRXs3PO+BaFvveNaRIkkKUPw6dsHWDR\nVlbsSCp/6fyRrH5A2UQ8i7mAgkaFPrmi76d50HrYsMDFDPcCmmFkQP+6UTSvymZo\nKBiXwBoypXpUzcUaoWPmwhMfWH+0Ov4IMj6Suy808QAaESPPwJORFmd7zTl7ZE3i\nzUibhRVpU3qlgcV0ZcpJAkx4KJFHc0ADv9GTAmWTeBHGMsqWk4xZaFCwLB8bv+IB\n1l1X+7DjY9GzqupPzrfTZxeFZsrG/DVQAtKUutcbvZJPM8XWD9sHtb4oM9BEbQr8\nShaZ3CbtXBGo5MCzQCw/Sb9DGCYm66apPE3NWbcEFKPqLG4slF7PdQ8o1DyyDbjK\nv8icj6elb23wmQGRd47aIVTcsFUeis+nJHAMnlQSMfVgDNB+trggaEHrzhcgP4Ff\nIhouTrsvdLsqzz01Oa+XQfR4GkjBxL6nWZLMbbOlXmHin4iSKqLKiCWrc6lkPJ7I\nd2F1JJoEH4XpbfdTV4YtsU+D3gpjywC7uGWSweHGTs8DihnQ/x5bwBUX3Bo98+pK\nT59NTfnjD02v+802qjCKvOoM90j5dX1FUCqhekc8Nm+TUlC5UHDjtts8SAmf1x9u\nOatEZU2f5zGPJBL91kVMQS7/psD1ZkDNucVtKBKX9gCveWFvVnQ=\n=7eoQ\n-----END PGP SIGNATURE-----\n\n--0BVVorEFNEq+bZUt--\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176730116131458.mbox",
          "message_id": "<20260101-futuristic-petrel-of-ecstasy-23db5f () lindesnes>",
          "author_name": "Nicolas Schier",
          "author_email": "nicolas () fjasle ! eu",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 19:39:46+00:00",
          "date_str": "Thu, 01 Jan 2026 19:39:46 +0000",
          "body": "\n--0BVVorEFNEq+bZUt\nContent-Type: text/plain; charset=iso-8859-1\nContent-Disposition: inline\nContent-Transfer-Encoding: quoted-printable\n\nOn Thu, Jan 01, 2026 at 04:10:36PM +0100, Vincent Mailhol wrote:\n> On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> > The is_non_negative() and is_negative() function-like macros just\n> > exist as a workaround to silence the -Wtype-limits warning. Now that\n> > this warning is disabled, those two macros have lost their raison\n> > d'=EAtre. Remove them.\n> >=20\n> > This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> > compilation warnings\").\n> >=20\n> > Suggested-by: Nicolas Schier <nsc@kernel.org>\n> > Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> > Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n>=20\n> So at the end, this patch got five kernel test robot reports:\n>=20\n>   https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n>   https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n>   https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n>   https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n>   https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n>=20\n> All these are the same smatch warning just triggered from a different\n> place. I think it is still too early to undo that workaround in\n> include/linux/overflow.h, otherwise developers would be getting that\n> smatch report too often.\n>=20\n> I will send a v4 in which I will drop this patch. This basically means\n> that the v4 is a revert to v1...\n\nthanks!  I think it's a bit sad to keep code only to make some checker=20\ntooling happy, but for now it seems to be the right thing to do.\n\nKind Regards,\nNicolas\n\n--0BVVorEFNEq+bZUt\nContent-Type: application/pgp-signature; name=\"signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0E3p4c3JKeBvsLGB1IKcBYmEmkFAmlWzYIACgkQB1IKcBYm\nEmkv5A/+JGh8gXsgclOmUAW84XlSnEuwIhRXs3PO+BaFvveNaRIkkKUPw6dsHWDR\nVlbsSCp/6fyRrH5A2UQ8i7mAgkaFPrmi76d50HrYsMDFDPcCmmFkQP+6UTSvymZo\nKBiXwBoypXpUzcUaoWPmwhMfWH+0Ov4IMj6Suy808QAaESPPwJORFmd7zTl7ZE3i\nzUibhRVpU3qlgcV0ZcpJAkx4KJFHc0ADv9GTAmWTeBHGMsqWk4xZaFCwLB8bv+IB\n1l1X+7DjY9GzqupPzrfTZxeFZsrG/DVQAtKUutcbvZJPM8XWD9sHtb4oM9BEbQr8\nShaZ3CbtXBGo5MCzQCw/Sb9DGCYm66apPE3NWbcEFKPqLG4slF7PdQ8o1DyyDbjK\nv8icj6elb23wmQGRd47aIVTcsFUeis+nJHAMnlQSMfVgDNB+trggaEHrzhcgP4Ff\nIhouTrsvdLsqzz01Oa+XQfR4GkjBxL6nWZLMbbOlXmHin4iSKqLKiCWrc6lkPJ7I\nd2F1JJoEH4XpbfdTV4YtsU+D3gpjywC7uGWSweHGTs8DihnQ/x5bwBUX3Bo98+pK\nT59NTfnjD02v+802qjCKvOoM90j5dX1FUCqhekc8Nm+TUlC5UHDjtts8SAmf1x9u\nOatEZU2f5zGPJBL91kVMQS7/psD1ZkDNucVtKBKX9gCveWFvVnQ=\n=7eoQ\n-----END PGP SIGNATURE-----\n\n--0BVVorEFNEq+bZUt--\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176730117431469.mbox",
          "message_id": "<20260101-futuristic-petrel-of-ecstasy-23db5f () lindesnes>",
          "author_name": "Nicolas Schier",
          "author_email": "nicolas () fjasle ! eu",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-01 19:39:46+00:00",
          "date_str": "Thu, 01 Jan 2026 19:39:46 +0000",
          "body": "\n--0BVVorEFNEq+bZUt\nContent-Type: text/plain; charset=iso-8859-1\nContent-Disposition: inline\nContent-Transfer-Encoding: quoted-printable\n\nOn Thu, Jan 01, 2026 at 04:10:36PM +0100, Vincent Mailhol wrote:\n> On 20/12/2025 at 12:02, Vincent Mailhol wrote:\n> > The is_non_negative() and is_negative() function-like macros just\n> > exist as a workaround to silence the -Wtype-limits warning. Now that\n> > this warning is disabled, those two macros have lost their raison\n> > d'=EAtre. Remove them.\n> >=20\n> > This reverts commit dc7fe518b049 (\"overflow: Fix -Wtype-limits\n> > compilation warnings\").\n> >=20\n> > Suggested-by: Nicolas Schier <nsc@kernel.org>\n> > Link: https://lore.kernel.org/all/aUT_yWin_xslnOFh@derry.ads.avm.de\n> > Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n>=20\n> So at the end, this patch got five kernel test robot reports:\n>=20\n>   https://lore.kernel.org/all/202512221735.mRV4BZqB-lkp@intel.com/\n>   https://lore.kernel.org/all/202512230342.Lgha2HGH-lkp@intel.com/\n>   https://lore.kernel.org/all/202512251340.UApIFw9R-lkp@intel.com/\n>   https://lore.kernel.org/all/202512271618.33YepxDC-lkp@intel.com/\n>   https://lore.kernel.org/all/202512280906.wt7UNpya-lkp@intel.com/\n>=20\n> All these are the same smatch warning just triggered from a different\n> place. I think it is still too early to undo that workaround in\n> include/linux/overflow.h, otherwise developers would be getting that\n> smatch report too often.\n>=20\n> I will send a v4 in which I will drop this patch. This basically means\n> that the v4 is a revert to v1...\n\nthanks!  I think it's a bit sad to keep code only to make some checker=20\ntooling happy, but for now it seems to be the right thing to do.\n\nKind Regards,\nNicolas\n\n--0BVVorEFNEq+bZUt\nContent-Type: application/pgp-signature; name=\"signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0E3p4c3JKeBvsLGB1IKcBYmEmkFAmlWzYIACgkQB1IKcBYm\nEmkv5A/+JGh8gXsgclOmUAW84XlSnEuwIhRXs3PO+BaFvveNaRIkkKUPw6dsHWDR\nVlbsSCp/6fyRrH5A2UQ8i7mAgkaFPrmi76d50HrYsMDFDPcCmmFkQP+6UTSvymZo\nKBiXwBoypXpUzcUaoWPmwhMfWH+0Ov4IMj6Suy808QAaESPPwJORFmd7zTl7ZE3i\nzUibhRVpU3qlgcV0ZcpJAkx4KJFHc0ADv9GTAmWTeBHGMsqWk4xZaFCwLB8bv+IB\n1l1X+7DjY9GzqupPzrfTZxeFZsrG/DVQAtKUutcbvZJPM8XWD9sHtb4oM9BEbQr8\nShaZ3CbtXBGo5MCzQCw/Sb9DGCYm66apPE3NWbcEFKPqLG4slF7PdQ8o1DyyDbjK\nv8icj6elb23wmQGRd47aIVTcsFUeis+nJHAMnlQSMfVgDNB+trggaEHrzhcgP4Ff\nIhouTrsvdLsqzz01Oa+XQfR4GkjBxL6nWZLMbbOlXmHin4iSKqLKiCWrc6lkPJ7I\nd2F1JJoEH4XpbfdTV4YtsU+D3gpjywC7uGWSweHGTs8DihnQ/x5bwBUX3Bo98+pK\nT59NTfnjD02v+802qjCKvOoM90j5dX1FUCqhekc8Nm+TUlC5UHDjtts8SAmf1x9u\nOatEZU2f5zGPJBL91kVMQS7/psD1ZkDNucVtKBKX9gCveWFvVnQ=\n=7eoQ\n-----END PGP SIGNATURE-----\n\n--0BVVorEFNEq+bZUt--\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176735467625263.mbox",
          "message_id": "<CANiq72=jRT+6+2PBgshsK-TpxPiRK70H-+3D6sYaN-fdfC83qw () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 11:04:28+00:00",
          "date_str": "Fri, 02 Jan 2026 11:04:28 +0000",
          "body": "On Thu, Jan 1, 2026 at 9:13=E2=80=AFPM Nicolas Schier <nicolas@fjasle.eu> w=\nrote:\n>\n> thanks!  I think it's a bit sad to keep code only to make some checker\n> tooling happy, but for now it seems to be the right thing to do.\n\nPerhaps a patch to add a comment explaining Vincent's findings would\nbe a good outcome, i.e. explaining the reason it needs to remain in\nplace for the moment (even a link to lore.kernel.org to this thread\nwould help).\n\nCheers,\nMiguel\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176735468025268.mbox",
          "message_id": "<CANiq72=jRT+6+2PBgshsK-TpxPiRK70H-+3D6sYaN-fdfC83qw () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 11:04:28+00:00",
          "date_str": "Fri, 02 Jan 2026 11:04:28 +0000",
          "body": "On Thu, Jan 1, 2026 at 9:13=E2=80=AFPM Nicolas Schier <nicolas@fjasle.eu> w=\nrote:\n>\n> thanks!  I think it's a bit sad to keep code only to make some checker\n> tooling happy, but for now it seems to be the right thing to do.\n\nPerhaps a patch to add a comment explaining Vincent's findings would\nbe a good outcome, i.e. explaining the reason it needs to remain in\nplace for the moment (even a link to lore.kernel.org to this thread\nwould help).\n\nCheers,\nMiguel\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176735469025282.mbox",
          "message_id": "<CANiq72=jRT+6+2PBgshsK-TpxPiRK70H-+3D6sYaN-fdfC83qw () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 11:04:28+00:00",
          "date_str": "Fri, 02 Jan 2026 11:04:28 +0000",
          "body": "On Thu, Jan 1, 2026 at 9:13=E2=80=AFPM Nicolas Schier <nicolas@fjasle.eu> w=\nrote:\n>\n> thanks!  I think it's a bit sad to keep code only to make some checker\n> tooling happy, but for now it seems to be the right thing to do.\n\nPerhaps a patch to add a comment explaining Vincent's findings would\nbe a good outcome, i.e. explaining the reason it needs to remain in\nplace for the moment (even a link to lore.kernel.org to this thread\nwould help).\n\nCheers,\nMiguel\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176735468425275.mbox",
          "message_id": "<CANiq72=jRT+6+2PBgshsK-TpxPiRK70H-+3D6sYaN-fdfC83qw () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 11:04:28+00:00",
          "date_str": "Fri, 02 Jan 2026 11:04:28 +0000",
          "body": "On Thu, Jan 1, 2026 at 9:13=E2=80=AFPM Nicolas Schier <nicolas@fjasle.eu> w=\nrote:\n>\n> thanks!  I think it's a bit sad to keep code only to make some checker\n> tooling happy, but for now it seems to be the right thing to do.\n\nPerhaps a patch to add a comment explaining Vincent's findings would\nbe a good outcome, i.e. explaining the reason it needs to remain in\nplace for the moment (even a link to lore.kernel.org to this thread\nwould help).\n\nCheers,\nMiguel\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176735466725258.mbox",
          "message_id": "<CANiq72=jRT+6+2PBgshsK-TpxPiRK70H-+3D6sYaN-fdfC83qw () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 11:04:28+00:00",
          "date_str": "Fri, 02 Jan 2026 11:04:28 +0000",
          "body": "On Thu, Jan 1, 2026 at 9:13=E2=80=AFPM Nicolas Schier <nicolas@fjasle.eu> w=\nrote:\n>\n> thanks!  I think it's a bit sad to keep code only to make some checker\n> tooling happy, but for now it seems to be the right thing to do.\n\nPerhaps a patch to add a comment explaining Vincent's findings would\nbe a good outcome, i.e. explaining the reason it needs to remain in\nplace for the moment (even a link to lore.kernel.org to this thread\nwould help).\n\nCheers,\nMiguel\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176735466725259.mbox",
          "message_id": "<CANiq72=jRT+6+2PBgshsK-TpxPiRK70H-+3D6sYaN-fdfC83qw () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 11:04:28+00:00",
          "date_str": "Fri, 02 Jan 2026 11:04:28 +0000",
          "body": "On Thu, Jan 1, 2026 at 9:13=E2=80=AFPM Nicolas Schier <nicolas@fjasle.eu> w=\nrote:\n>\n> thanks!  I think it's a bit sad to keep code only to make some checker\n> tooling happy, but for now it seems to be the right thing to do.\n\nPerhaps a patch to add a comment explaining Vincent's findings would\nbe a good outcome, i.e. explaining the reason it needs to remain in\nplace for the moment (even a link to lore.kernel.org to this thread\nwould help).\n\nCheers,\nMiguel",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176739561019033.mbox",
          "message_id": "<b549e430-5623-4c60-acb1-4b5e095ae870 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 22:26:35+00:00",
          "date_str": "Fri, 02 Jan 2026 22:26:35 +0000",
          "body": "On 02/01/2026 at 12:04, Miguel Ojeda wrote:\n> On Thu, Jan 1, 2026 at 9:13\u202fPM Nicolas Schier <nicolas@fjasle.eu> wrote:\n>>\n>> thanks!  I think it's a bit sad to keep code only to make some checker\n>> tooling happy, but for now it seems to be the right thing to do.\n> \n> Perhaps a patch to add a comment explaining Vincent's findings would\n> be a good outcome, i.e. explaining the reason it needs to remain in\n> place for the moment \n\nOK. But I will send this as a separate patch as a reply to this thread\nso that this can be discussed separately without having to respin the\nmain series again and again. I will add it back to the main series only\nif it get a decent level of Acked-by tags.\n\n> (even a link to lore.kernel.org to this thread would help).\n\nIt is rather uncommon to add lore.kernel.org links in the code comment.\nBut I am not against. I will do as you suggested so and see what people\nthink of it.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176739558919016.mbox",
          "message_id": "<b549e430-5623-4c60-acb1-4b5e095ae870 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 22:26:35+00:00",
          "date_str": "Fri, 02 Jan 2026 22:26:35 +0000",
          "body": "On 02/01/2026 at 12:04, Miguel Ojeda wrote:\n> On Thu, Jan 1, 2026 at 9:13\u202fPM Nicolas Schier <nicolas@fjasle.eu> wrote:\n>>\n>> thanks!  I think it's a bit sad to keep code only to make some checker\n>> tooling happy, but for now it seems to be the right thing to do.\n> \n> Perhaps a patch to add a comment explaining Vincent's findings would\n> be a good outcome, i.e. explaining the reason it needs to remain in\n> place for the moment \n\nOK. But I will send this as a separate patch as a reply to this thread\nso that this can be discussed separately without having to respin the\nmain series again and again. I will add it back to the main series only\nif it get a decent level of Acked-by tags.\n\n> (even a link to lore.kernel.org to this thread would help).\n\nIt is rather uncommon to add lore.kernel.org links in the code comment.\nBut I am not against. I will do as you suggested so and see what people\nthink of it.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176739559919025.mbox",
          "message_id": "<b549e430-5623-4c60-acb1-4b5e095ae870 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 22:26:35+00:00",
          "date_str": "Fri, 02 Jan 2026 22:26:35 +0000",
          "body": "On 02/01/2026 at 12:04, Miguel Ojeda wrote:\n> On Thu, Jan 1, 2026 at 9:13\u202fPM Nicolas Schier <nicolas@fjasle.eu> wrote:\n>>\n>> thanks!  I think it's a bit sad to keep code only to make some checker\n>> tooling happy, but for now it seems to be the right thing to do.\n> \n> Perhaps a patch to add a comment explaining Vincent's findings would\n> be a good outcome, i.e. explaining the reason it needs to remain in\n> place for the moment \n\nOK. But I will send this as a separate patch as a reply to this thread\nso that this can be discussed separately without having to respin the\nmain series again and again. I will add it back to the main series only\nif it get a decent level of Acked-by tags.\n\n> (even a link to lore.kernel.org to this thread would help).\n\nIt is rather uncommon to add lore.kernel.org links in the code comment.\nBut I am not against. I will do as you suggested so and see what people\nthink of it.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176739559319019.mbox",
          "message_id": "<b549e430-5623-4c60-acb1-4b5e095ae870 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 22:26:35+00:00",
          "date_str": "Fri, 02 Jan 2026 22:26:35 +0000",
          "body": "On 02/01/2026 at 12:04, Miguel Ojeda wrote:\n> On Thu, Jan 1, 2026 at 9:13\u202fPM Nicolas Schier <nicolas@fjasle.eu> wrote:\n>>\n>> thanks!  I think it's a bit sad to keep code only to make some checker\n>> tooling happy, but for now it seems to be the right thing to do.\n> \n> Perhaps a patch to add a comment explaining Vincent's findings would\n> be a good outcome, i.e. explaining the reason it needs to remain in\n> place for the moment \n\nOK. But I will send this as a separate patch as a reply to this thread\nso that this can be discussed separately without having to respin the\nmain series again and again. I will add it back to the main series only\nif it get a decent level of Acked-by tags.\n\n> (even a link to lore.kernel.org to this thread would help).\n\nIt is rather uncommon to add lore.kernel.org links in the code comment.\nBut I am not against. I will do as you suggested so and see what people\nthink of it.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176739560519030.mbox",
          "message_id": "<b549e430-5623-4c60-acb1-4b5e095ae870 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 22:26:35+00:00",
          "date_str": "Fri, 02 Jan 2026 22:26:35 +0000",
          "body": "On 02/01/2026 at 12:04, Miguel Ojeda wrote:\n> On Thu, Jan 1, 2026 at 9:13\u202fPM Nicolas Schier <nicolas@fjasle.eu> wrote:\n>>\n>> thanks!  I think it's a bit sad to keep code only to make some checker\n>> tooling happy, but for now it seems to be the right thing to do.\n> \n> Perhaps a patch to add a comment explaining Vincent's findings would\n> be a good outcome, i.e. explaining the reason it needs to remain in\n> place for the moment \n\nOK. But I will send this as a separate patch as a reply to this thread\nso that this can be discussed separately without having to respin the\nmain series again and again. I will add it back to the main series only\nif it get a decent level of Acked-by tags.\n\n> (even a link to lore.kernel.org to this thread would help).\n\nIt is rather uncommon to add lore.kernel.org links in the code comment.\nBut I am not against. I will do as you suggested so and see what people\nthink of it.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176739559419022.mbox",
          "message_id": "<b549e430-5623-4c60-acb1-4b5e095ae870 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH v3 3/3] overflow: Remove is_non_negative() and is_negative()",
          "date": "2026-01-02 22:26:35+00:00",
          "date_str": "Fri, 02 Jan 2026 22:26:35 +0000",
          "body": "On 02/01/2026 at 12:04, Miguel Ojeda wrote:\n> On Thu, Jan 1, 2026 at 9:13\u202fPM Nicolas Schier <nicolas@fjasle.eu> wrote:\n>>\n>> thanks!  I think it's a bit sad to keep code only to make some checker\n>> tooling happy, but for now it seems to be the right thing to do.\n> \n> Perhaps a patch to add a comment explaining Vincent's findings would\n> be a good outcome, i.e. explaining the reason it needs to remain in\n> place for the moment \n\nOK. But I will send this as a separate patch as a reply to this thread\nso that this can be discussed separately without having to respin the\nmain series again and again. I will add it back to the main series only\nif it get a decent level of Acked-by tags.\n\n> (even a link to lore.kernel.org to this thread would help).\n\nIt is rather uncommon to add lore.kernel.org links in the code comment.\nBut I am not against. I will do as you suggested so and see what people\nthink of it.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
      "normalized_subject": "kbuild: cleanup local -Wno-type-limits exceptions",
      "message_count": 13,
      "participants": [
        "Nicolas Schier",
        "Vincent Mailhol"
      ],
      "categories": [
        "kernel_integration"
      ],
      "first_date": "2025-12-19T22:39:46+00:00",
      "last_date": "2025-12-20T12:53:23+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176618691529128.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-2-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 2/4] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-19 22:39:46+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:46 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623153521573.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-2-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 11:02:20+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:20 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623139721460.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-2-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 11:02:20+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:20 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623142221506.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-2-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 11:02:20+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:20 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623154121581.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-2-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 11:02:20+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:20 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623152421564.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-2-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 11:02:20+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:20 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623142121502.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-2-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 11:02:20+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:20 +0000",
          "body": "Now that -Wtype-limits is globally deactivated, there is no need for\nlocal exceptions anymore.\n\nAcked-by: David Sterba <dsterba@suse.com>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChangelog:\n\n  v1 -> v2: small change in patch description\n---\n drivers/gpu/drm/Makefile | 1 -\n fs/btrfs/Makefile        | 1 -\n 2 files changed, 2 deletions(-)\n\ndiff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile\nindex 0e1c668b46d2..b879a60ca79a 100644\n--- a/drivers/gpu/drm/Makefile\n+++ b/drivers/gpu/drm/Makefile\n@@ -22,7 +22,6 @@ subdir-ccflags-y += $(call cc-option, -Wstringop-truncation)\n # The following turn off the warnings enabled by -Wextra\n ifeq ($(findstring 2, $(KBUILD_EXTRA_WARN)),)\n subdir-ccflags-y += -Wno-missing-field-initializers\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n endif\n ifeq ($(findstring 3, $(KBUILD_EXTRA_WARN)),)\ndiff --git a/fs/btrfs/Makefile b/fs/btrfs/Makefile\nindex 743d7677b175..40bc2f7e6f6b 100644\n--- a/fs/btrfs/Makefile\n+++ b/fs/btrfs/Makefile\n@@ -17,7 +17,6 @@ subdir-ccflags-y += $(condflags)\n # The following turn off the warnings enabled by -Wextra\n subdir-ccflags-y += -Wno-missing-field-initializers\n subdir-ccflags-y += -Wno-sign-compare\n-subdir-ccflags-y += -Wno-type-limits\n subdir-ccflags-y += -Wno-shift-negative-value\n \n obj-$(CONFIG_BTRFS_FS) := btrfs.o\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623812225227.mbox",
          "message_id": "<aUacQyHLoRKXXbrb () levanger>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 12:53:23+00:00",
          "date_str": "Sat, 20 Dec 2025 12:53:23 +0000",
          "body": "On Sat, Dec 20, 2025 at 12:02:20PM +0100, Vincent Mailhol wrote:\n> Now that -Wtype-limits is globally deactivated, there is no need for\n> local exceptions anymore.\n> \n> Acked-by: David Sterba <dsterba@suse.com>\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: small change in patch description\n> ---\n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  2 files changed, 2 deletions(-)\n> \n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623812125225.mbox",
          "message_id": "<aUacQyHLoRKXXbrb () levanger>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 12:53:23+00:00",
          "date_str": "Sat, 20 Dec 2025 12:53:23 +0000",
          "body": "On Sat, Dec 20, 2025 at 12:02:20PM +0100, Vincent Mailhol wrote:\n> Now that -Wtype-limits is globally deactivated, there is no need for\n> local exceptions anymore.\n> \n> Acked-by: David Sterba <dsterba@suse.com>\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: small change in patch description\n> ---\n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  2 files changed, 2 deletions(-)\n> \n\nReviewed-by: Nicolas Schier <nsc@kernel.org>",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623812925242.mbox",
          "message_id": "<aUacQyHLoRKXXbrb () levanger>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 12:53:23+00:00",
          "date_str": "Sat, 20 Dec 2025 12:53:23 +0000",
          "body": "On Sat, Dec 20, 2025 at 12:02:20PM +0100, Vincent Mailhol wrote:\n> Now that -Wtype-limits is globally deactivated, there is no need for\n> local exceptions anymore.\n> \n> Acked-by: David Sterba <dsterba@suse.com>\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: small change in patch description\n> ---\n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  2 files changed, 2 deletions(-)\n> \n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623817725308.mbox",
          "message_id": "<aUacQyHLoRKXXbrb () levanger>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 12:53:23+00:00",
          "date_str": "Sat, 20 Dec 2025 12:53:23 +0000",
          "body": "On Sat, Dec 20, 2025 at 12:02:20PM +0100, Vincent Mailhol wrote:\n> Now that -Wtype-limits is globally deactivated, there is no need for\n> local exceptions anymore.\n> \n> Acked-by: David Sterba <dsterba@suse.com>\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: small change in patch description\n> ---\n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  2 files changed, 2 deletions(-)\n> \n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623816925304.mbox",
          "message_id": "<aUacQyHLoRKXXbrb () levanger>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 12:53:23+00:00",
          "date_str": "Sat, 20 Dec 2025 12:53:23 +0000",
          "body": "On Sat, Dec 20, 2025 at 12:02:20PM +0100, Vincent Mailhol wrote:\n> Now that -Wtype-limits is globally deactivated, there is no need for\n> local exceptions anymore.\n> \n> Acked-by: David Sterba <dsterba@suse.com>\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: small change in patch description\n> ---\n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  2 files changed, 2 deletions(-)\n> \n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623814825283.mbox",
          "message_id": "<aUacQyHLoRKXXbrb () levanger>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH v3 2/3] kbuild: cleanup local -Wno-type-limits exceptions",
          "date": "2025-12-20 12:53:23+00:00",
          "date_str": "Sat, 20 Dec 2025 12:53:23 +0000",
          "body": "On Sat, Dec 20, 2025 at 12:02:20PM +0100, Vincent Mailhol wrote:\n> Now that -Wtype-limits is globally deactivated, there is no need for\n> local exceptions anymore.\n> \n> Acked-by: David Sterba <dsterba@suse.com>\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Changelog:\n> \n>   v1 -> v2: small change in patch description\n> ---\n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  2 files changed, 2 deletions(-)\n> \n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "kernel_integration"
    },
    {
      "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
      "normalized_subject": "locking/rwlock, spinlock: Support Clang's context analysis",
      "message_count": 30,
      "participants": [
        "Marco Elver",
        "Bart Van Assche"
      ],
      "categories": [
        "context_analysis",
        "rfc_proposals",
        "compiler_compat"
      ],
      "first_date": "2025-12-19T20:26:16+00:00",
      "last_date": "2025-12-19T21:48:35+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176617884723321.mbox",
          "message_id": "<17723ae6-9611-4731-905c-60dab9fb7102 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:26:16+00:00",
          "date_str": "Fri, 19 Dec 2025 20:26:16 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n\nGiven the \"one change per patch\" rule, shouldn't the annotation fixes\nfor rwlock operations be moved into a separate patch?\n\n> -typedef struct {\n> +context_lock_struct(rwlock) {\n>   \tarch_rwlock_t raw_lock;\n>   #ifdef CONFIG_DEBUG_SPINLOCK\n>   \tunsigned int magic, owner_cpu;\n> @@ -31,7 +31,8 @@ typedef struct {\n>   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>   \tstruct lockdep_map dep_map;\n>   #endif\n> -} rwlock_t;\n> +};\n> +typedef struct rwlock rwlock_t;\n\nThis change introduces a new globally visible \"struct rwlock\". Although\nI haven't found any existing \"struct rwlock\" definitions, maybe it's a\ngood idea to use a more unique name instead.\n\n> diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> index 819aeba1c87e..018f5aabc1be 100644\n> --- a/include/linux/spinlock_api_up.h\n> +++ b/include/linux/spinlock_api_up.h\n> @@ -24,68 +24,77 @@\n>    * flags straight, to suppress compiler warnings of unused lock\n>    * variables, and to add the proper checker annotations:\n>    */\n> -#define ___LOCK(lock) \\\n> -  do { __acquire(lock); (void)(lock); } while (0)\n> +#define ___LOCK_void(lock) \\\n> +  do { (void)(lock); } while (0)\n\nInstead of introducing a new macro ___LOCK_void(), please expand this\nmacro where it is used ((void)(lock)). I think this will make the code\nin this header file easier to read.\n    > -#define __LOCK(lock) \\\n> -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> +#define ___LOCK_(lock) \\\n> +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n\nIs the macro ___LOCK_() used anywhere? If not, can it be left out?\n\n> -#define __LOCK_BH(lock) \\\n> -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> +#define ___LOCK_shared(lock) \\\n> +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n\nThe introduction of the new macros in this header file make the changes\nhard to follow. Please consider splitting the changes for this header\nfile as follows:\n* A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n   ___LOCK_shared().\n* A second patch with the thread-safety annotation changes\n   (__acquire() -> __acquire_shared()).\n\n>   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> -typedef struct spinlock {\n> +context_lock_struct(spinlock) {\n>   \tunion {\n>   \t\tstruct raw_spinlock rlock;\n>   \n> @@ -26,7 +26,8 @@ typedef struct spinlock {\n>   \t\t};\n>   #endif\n>   \t};\n> -} spinlock_t;\n> +};\n> +typedef struct spinlock spinlock_t;\n\nAlso here, a new global struct name is introduced (spinlock). Maybe the\nname of this new struct should be made more unique?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617885123324.mbox",
          "message_id": "<17723ae6-9611-4731-905c-60dab9fb7102 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:26:16+00:00",
          "date_str": "Fri, 19 Dec 2025 20:26:16 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n\nGiven the \"one change per patch\" rule, shouldn't the annotation fixes\nfor rwlock operations be moved into a separate patch?\n\n> -typedef struct {\n> +context_lock_struct(rwlock) {\n>   \tarch_rwlock_t raw_lock;\n>   #ifdef CONFIG_DEBUG_SPINLOCK\n>   \tunsigned int magic, owner_cpu;\n> @@ -31,7 +31,8 @@ typedef struct {\n>   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>   \tstruct lockdep_map dep_map;\n>   #endif\n> -} rwlock_t;\n> +};\n> +typedef struct rwlock rwlock_t;\n\nThis change introduces a new globally visible \"struct rwlock\". Although\nI haven't found any existing \"struct rwlock\" definitions, maybe it's a\ngood idea to use a more unique name instead.\n\n> diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> index 819aeba1c87e..018f5aabc1be 100644\n> --- a/include/linux/spinlock_api_up.h\n> +++ b/include/linux/spinlock_api_up.h\n> @@ -24,68 +24,77 @@\n>    * flags straight, to suppress compiler warnings of unused lock\n>    * variables, and to add the proper checker annotations:\n>    */\n> -#define ___LOCK(lock) \\\n> -  do { __acquire(lock); (void)(lock); } while (0)\n> +#define ___LOCK_void(lock) \\\n> +  do { (void)(lock); } while (0)\n\nInstead of introducing a new macro ___LOCK_void(), please expand this\nmacro where it is used ((void)(lock)). I think this will make the code\nin this header file easier to read.\n    > -#define __LOCK(lock) \\\n> -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> +#define ___LOCK_(lock) \\\n> +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n\nIs the macro ___LOCK_() used anywhere? If not, can it be left out?\n\n> -#define __LOCK_BH(lock) \\\n> -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> +#define ___LOCK_shared(lock) \\\n> +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n\nThe introduction of the new macros in this header file make the changes\nhard to follow. Please consider splitting the changes for this header\nfile as follows:\n* A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n   ___LOCK_shared().\n* A second patch with the thread-safety annotation changes\n   (__acquire() -> __acquire_shared()).\n\n>   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> -typedef struct spinlock {\n> +context_lock_struct(spinlock) {\n>   \tunion {\n>   \t\tstruct raw_spinlock rlock;\n>   \n> @@ -26,7 +26,8 @@ typedef struct spinlock {\n>   \t\t};\n>   #endif\n>   \t};\n> -} spinlock_t;\n> +};\n> +typedef struct spinlock spinlock_t;\n\nAlso here, a new global struct name is introduced (spinlock). Maybe the\nname of this new struct should be made more unique?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617886723342.mbox",
          "message_id": "<17723ae6-9611-4731-905c-60dab9fb7102 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:26:16+00:00",
          "date_str": "Fri, 19 Dec 2025 20:26:16 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n\nGiven the \"one change per patch\" rule, shouldn't the annotation fixes\nfor rwlock operations be moved into a separate patch?\n\n> -typedef struct {\n> +context_lock_struct(rwlock) {\n>   \tarch_rwlock_t raw_lock;\n>   #ifdef CONFIG_DEBUG_SPINLOCK\n>   \tunsigned int magic, owner_cpu;\n> @@ -31,7 +31,8 @@ typedef struct {\n>   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>   \tstruct lockdep_map dep_map;\n>   #endif\n> -} rwlock_t;\n> +};\n> +typedef struct rwlock rwlock_t;\n\nThis change introduces a new globally visible \"struct rwlock\". Although\nI haven't found any existing \"struct rwlock\" definitions, maybe it's a\ngood idea to use a more unique name instead.\n\n> diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> index 819aeba1c87e..018f5aabc1be 100644\n> --- a/include/linux/spinlock_api_up.h\n> +++ b/include/linux/spinlock_api_up.h\n> @@ -24,68 +24,77 @@\n>    * flags straight, to suppress compiler warnings of unused lock\n>    * variables, and to add the proper checker annotations:\n>    */\n> -#define ___LOCK(lock) \\\n> -  do { __acquire(lock); (void)(lock); } while (0)\n> +#define ___LOCK_void(lock) \\\n> +  do { (void)(lock); } while (0)\n\nInstead of introducing a new macro ___LOCK_void(), please expand this\nmacro where it is used ((void)(lock)). I think this will make the code\nin this header file easier to read.\n    > -#define __LOCK(lock) \\\n> -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> +#define ___LOCK_(lock) \\\n> +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n\nIs the macro ___LOCK_() used anywhere? If not, can it be left out?\n\n> -#define __LOCK_BH(lock) \\\n> -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> +#define ___LOCK_shared(lock) \\\n> +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n\nThe introduction of the new macros in this header file make the changes\nhard to follow. Please consider splitting the changes for this header\nfile as follows:\n* A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n   ___LOCK_shared().\n* A second patch with the thread-safety annotation changes\n   (__acquire() -> __acquire_shared()).\n\n>   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> -typedef struct spinlock {\n> +context_lock_struct(spinlock) {\n>   \tunion {\n>   \t\tstruct raw_spinlock rlock;\n>   \n> @@ -26,7 +26,8 @@ typedef struct spinlock {\n>   \t\t};\n>   #endif\n>   \t};\n> -} spinlock_t;\n> +};\n> +typedef struct spinlock spinlock_t;\n\nAlso here, a new global struct name is introduced (spinlock). Maybe the\nname of this new struct should be made more unique?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617884523316.mbox",
          "message_id": "<17723ae6-9611-4731-905c-60dab9fb7102 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:26:16+00:00",
          "date_str": "Fri, 19 Dec 2025 20:26:16 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n\nGiven the \"one change per patch\" rule, shouldn't the annotation fixes\nfor rwlock operations be moved into a separate patch?\n\n> -typedef struct {\n> +context_lock_struct(rwlock) {\n>   \tarch_rwlock_t raw_lock;\n>   #ifdef CONFIG_DEBUG_SPINLOCK\n>   \tunsigned int magic, owner_cpu;\n> @@ -31,7 +31,8 @@ typedef struct {\n>   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>   \tstruct lockdep_map dep_map;\n>   #endif\n> -} rwlock_t;\n> +};\n> +typedef struct rwlock rwlock_t;\n\nThis change introduces a new globally visible \"struct rwlock\". Although\nI haven't found any existing \"struct rwlock\" definitions, maybe it's a\ngood idea to use a more unique name instead.\n\n> diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> index 819aeba1c87e..018f5aabc1be 100644\n> --- a/include/linux/spinlock_api_up.h\n> +++ b/include/linux/spinlock_api_up.h\n> @@ -24,68 +24,77 @@\n>    * flags straight, to suppress compiler warnings of unused lock\n>    * variables, and to add the proper checker annotations:\n>    */\n> -#define ___LOCK(lock) \\\n> -  do { __acquire(lock); (void)(lock); } while (0)\n> +#define ___LOCK_void(lock) \\\n> +  do { (void)(lock); } while (0)\n\nInstead of introducing a new macro ___LOCK_void(), please expand this\nmacro where it is used ((void)(lock)). I think this will make the code\nin this header file easier to read.\n    > -#define __LOCK(lock) \\\n> -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> +#define ___LOCK_(lock) \\\n> +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n\nIs the macro ___LOCK_() used anywhere? If not, can it be left out?\n\n> -#define __LOCK_BH(lock) \\\n> -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> +#define ___LOCK_shared(lock) \\\n> +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n\nThe introduction of the new macros in this header file make the changes\nhard to follow. Please consider splitting the changes for this header\nfile as follows:\n* A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n   ___LOCK_shared().\n* A second patch with the thread-safety annotation changes\n   (__acquire() -> __acquire_shared()).\n\n>   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> -typedef struct spinlock {\n> +context_lock_struct(spinlock) {\n>   \tunion {\n>   \t\tstruct raw_spinlock rlock;\n>   \n> @@ -26,7 +26,8 @@ typedef struct spinlock {\n>   \t\t};\n>   #endif\n>   \t};\n> -} spinlock_t;\n> +};\n> +typedef struct spinlock spinlock_t;\n\nAlso here, a new global struct name is introduced (spinlock). Maybe the\nname of this new struct should be made more unique?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618102225107.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618103325111.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618101525086.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618101825096.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618101825097.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618101325080.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618101925101.mbox",
          "message_id": "<CANpmjNO0B_BBse12kAobCRBK0D2pKkSu7pKa5LQAbdzBZa2xcw () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:02:57+00:00",
          "date_str": "Fri, 19 Dec 2025 21:02:57 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> > + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>\n> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> for rwlock operations be moved into a separate patch?\n>\n> > -typedef struct {\n> > +context_lock_struct(rwlock) {\n> >       arch_rwlock_t raw_lock;\n> >   #ifdef CONFIG_DEBUG_SPINLOCK\n> >       unsigned int magic, owner_cpu;\n> > @@ -31,7 +31,8 @@ typedef struct {\n> >   #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >       struct lockdep_map dep_map;\n> >   #endif\n> > -} rwlock_t;\n> > +};\n> > +typedef struct rwlock rwlock_t;\n>\n> This change introduces a new globally visible \"struct rwlock\". Although\n> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> good idea to use a more unique name instead.\n\nThis doesn't actually introduce a new globally visible \"struct\nrwlock\", it's already the case before.\nAn inlined struct definition in a typedef is available by its struct\nname, so this is not introducing a new name\n(https://godbolt.org/z/Y1jf66e1M).\n\n> > diff --git a/include/linux/spinlock_api_up.h b/include/linux/spinlock_api_up.h\n> > index 819aeba1c87e..018f5aabc1be 100644\n> > --- a/include/linux/spinlock_api_up.h\n> > +++ b/include/linux/spinlock_api_up.h\n> > @@ -24,68 +24,77 @@\n> >    * flags straight, to suppress compiler warnings of unused lock\n> >    * variables, and to add the proper checker annotations:\n> >    */\n> > -#define ___LOCK(lock) \\\n> > -  do { __acquire(lock); (void)(lock); } while (0)\n> > +#define ___LOCK_void(lock) \\\n> > +  do { (void)(lock); } while (0)\n>\n> Instead of introducing a new macro ___LOCK_void(), please expand this\n> macro where it is used ((void)(lock)). I think this will make the code\n> in this header file easier to read.\n\nIf I recall right, we needed this to generalize __LOCK(),\n__LOCK_IRQ(), etc. which do preempt_disable(), local_irq_disable() in\nthe right way, but then need to make sure we call the right\nacquire/release helper, which require different cases depending on the\nlock kind. Obviously we could just expand all the macros below, but\nthe current pattern tried to not rewrite this altogether.\n\nThere's probably a way this can all be simplified for UP, but maybe a\nseparate patch. I'd leave it to the locking maintainers which way they\nprefer to go.\n\n>     > -#define __LOCK(lock) \\\n> > -  do { preempt_disable(); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_(lock) \\\n> > +  do { __acquire(lock); ___LOCK_void(lock); } while (0)\n>\n> Is the macro ___LOCK_() used anywhere? If not, can it be left out?\n\nYes, it's the default case if __VA_ARGS__ is empty.\n\n> > -#define __LOCK_BH(lock) \\\n> > -  do { __local_bh_disable_ip(_THIS_IP_, SOFTIRQ_LOCK_OFFSET); ___LOCK(lock); } while (0)\n> > +#define ___LOCK_shared(lock) \\\n> > +  do { __acquire_shared(lock); ___LOCK_void(lock); } while (0)\n>\n> The introduction of the new macros in this header file make the changes\n> hard to follow. Please consider splitting the changes for this header\n> file as follows:\n> * A first patch that splits ___LOCK() into ___LOCK_exclusive() and\n>    ___LOCK_shared().\n> * A second patch with the thread-safety annotation changes\n>    (__acquire() -> __acquire_shared()).\n\nI've wrangled with this maze of interdependent macros and definitions\nfor days (though that was earlier in the year), believe me when I say\nI tried to split it up. I think the commit message hints at this:\n\n> Add support for Clang's context analysis for raw_spinlock_t,\n> spinlock_t, and rwlock. This wholesale conversion is required because\n> all three of them are interdependent.\n\nIt's like a carefully crafted house of cards: you take one away, the\nwhole thing breaks apart. If I recall correctly, the main problem was\nthat as soon as you make one of these a context lock type, and because\nthey are all interdependent, the compiler will just complain endlessly\nabout either wrong attributes or incorrectly acquired/released locks\nuntil they are all precisely in the way you see them here.\n\n> >   /* Non PREEMPT_RT kernels map spinlock to raw_spinlock */\n> > -typedef struct spinlock {\n> > +context_lock_struct(spinlock) {\n> >       union {\n> >               struct raw_spinlock rlock;\n> >\n> > @@ -26,7 +26,8 @@ typedef struct spinlock {\n> >               };\n> >   #endif\n> >       };\n> > -} spinlock_t;\n> > +};\n> > +typedef struct spinlock spinlock_t;\n>\n> Also here, a new global struct name is introduced (spinlock). Maybe the\n> name of this new struct should be made more unique?\n\nAs above.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618286526355.mbox",
          "message_id": "<0088cc8c-b395-4659-854f-a6cc5df626ed () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:34:19+00:00",
          "date_str": "Fri, 19 Dec 2025 21:34:19 +0000",
          "body": "On 12/19/25 2:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618302226482.mbox",
          "message_id": "<0088cc8c-b395-4659-854f-a6cc5df626ed () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:34:19+00:00",
          "date_str": "Fri, 19 Dec 2025 21:34:19 +0000",
          "body": "On 12/19/25 2:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618302826488.mbox",
          "message_id": "<0088cc8c-b395-4659-854f-a6cc5df626ed () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:34:19+00:00",
          "date_str": "Fri, 19 Dec 2025 21:34:19 +0000",
          "body": "On 12/19/25 2:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618296026443.mbox",
          "message_id": "<0088cc8c-b395-4659-854f-a6cc5df626ed () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:34:19+00:00",
          "date_str": "Fri, 19 Dec 2025 21:34:19 +0000",
          "body": "On 12/19/25 2:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618302726485.mbox",
          "message_id": "<0088cc8c-b395-4659-854f-a6cc5df626ed () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:34:19+00:00",
          "date_str": "Fri, 19 Dec 2025 21:34:19 +0000",
          "body": "On 12/19/25 2:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618303726496.mbox",
          "message_id": "<0088cc8c-b395-4659-854f-a6cc5df626ed () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:34:19+00:00",
          "date_str": "Fri, 19 Dec 2025 21:34:19 +0000",
          "body": "On 12/19/25 2:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176619041931340.mbox",
          "message_id": "<ae957ee5-cb47-433f-b0b3-f4ac8ec7116b () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:45:45+00:00",
          "date_str": "Fri, 19 Dec 2025 21:45:45 +0000",
          "body": "On 12/19/25 1:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176619018831208.mbox",
          "message_id": "<ae957ee5-cb47-433f-b0b3-f4ac8ec7116b () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:45:45+00:00",
          "date_str": "Fri, 19 Dec 2025 21:45:45 +0000",
          "body": "On 12/19/25 1:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176619004031122.mbox",
          "message_id": "<ae957ee5-cb47-433f-b0b3-f4ac8ec7116b () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:45:45+00:00",
          "date_str": "Fri, 19 Dec 2025 21:45:45 +0000",
          "body": "On 12/19/25 1:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618991231045.mbox",
          "message_id": "<ae957ee5-cb47-433f-b0b3-f4ac8ec7116b () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:45:45+00:00",
          "date_str": "Fri, 19 Dec 2025 21:45:45 +0000",
          "body": "On 12/19/25 1:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618976430948.mbox",
          "message_id": "<ae957ee5-cb47-433f-b0b3-f4ac8ec7116b () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:45:45+00:00",
          "date_str": "Fri, 19 Dec 2025 21:45:45 +0000",
          "body": "On 12/19/25 1:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618951230782.mbox",
          "message_id": "<ae957ee5-cb47-433f-b0b3-f4ac8ec7116b () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:45:45+00:00",
          "date_str": "Fri, 19 Dec 2025 21:45:45 +0000",
          "body": "On 12/19/25 1:02 PM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n>> On 12/19/25 7:39 AM, Marco Elver wrote:\n>>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n>>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n>>\n>> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n>> for rwlock operations be moved into a separate patch?\n>>\n>>> -typedef struct {\n>>> +context_lock_struct(rwlock) {\n>>>        arch_rwlock_t raw_lock;\n>>>    #ifdef CONFIG_DEBUG_SPINLOCK\n>>>        unsigned int magic, owner_cpu;\n>>> @@ -31,7 +31,8 @@ typedef struct {\n>>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n>>>        struct lockdep_map dep_map;\n>>>    #endif\n>>> -} rwlock_t;\n>>> +};\n>>> +typedef struct rwlock rwlock_t;\n>>\n>> This change introduces a new globally visible \"struct rwlock\". Although\n>> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n>> good idea to use a more unique name instead.\n> \n> This doesn't actually introduce a new globally visible \"struct\n> rwlock\", it's already the case before.\n> An inlined struct definition in a typedef is available by its struct\n> name, so this is not introducing a new name\n> (https://godbolt.org/z/Y1jf66e1M).\n\nPlease take another look. The godbolt example follows the pattern\n\"typedef struct name { ... } name_t;\". The \"name\" part is missing from\nthe rwlock_t definition. This is why I wrote that the above code\nintroduces a new global struct name.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618375427052.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618378727067.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618379527076.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618380727091.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618375427050.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618380127081.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618375127044.mbox",
          "message_id": "<CANpmjNN4JNG1OSWfGd2fAqTyYQ+Re7Czn796WD-47TwmuECxaQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 08/36] locking/rwlock, spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:48:35+00:00",
          "date_str": "Fri, 19 Dec 2025 21:48:35 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:34, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:02 PM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 21:26, Bart Van Assche <bvanassche@acm.org> wrote:\n> >> On 12/19/25 7:39 AM, Marco Elver wrote:\n> >>> - extern void do_raw_read_lock(rwlock_t *lock) __acquires(lock);\n> >>> + extern void do_raw_read_lock(rwlock_t *lock) __acquires_shared(lock);\n> >>\n> >> Given the \"one change per patch\" rule, shouldn't the annotation fixes\n> >> for rwlock operations be moved into a separate patch?\n> >>\n> >>> -typedef struct {\n> >>> +context_lock_struct(rwlock) {\n> >>>        arch_rwlock_t raw_lock;\n> >>>    #ifdef CONFIG_DEBUG_SPINLOCK\n> >>>        unsigned int magic, owner_cpu;\n> >>> @@ -31,7 +31,8 @@ typedef struct {\n> >>>    #ifdef CONFIG_DEBUG_LOCK_ALLOC\n> >>>        struct lockdep_map dep_map;\n> >>>    #endif\n> >>> -} rwlock_t;\n> >>> +};\n> >>> +typedef struct rwlock rwlock_t;\n> >>\n> >> This change introduces a new globally visible \"struct rwlock\". Although\n> >> I haven't found any existing \"struct rwlock\" definitions, maybe it's a\n> >> good idea to use a more unique name instead.\n> >\n> > This doesn't actually introduce a new globally visible \"struct\n> > rwlock\", it's already the case before.\n> > An inlined struct definition in a typedef is available by its struct\n> > name, so this is not introducing a new name\n> > (https://godbolt.org/z/Y1jf66e1M).\n>\n> Please take another look. The godbolt example follows the pattern\n> \"typedef struct name { ... } name_t;\". The \"name\" part is missing from\n> the rwlock_t definition. This is why I wrote that the above code\n> introduces a new global struct name.\n\nYou're right. My point only applies to \"typedef struct spinlock ...\"\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
      "normalized_subject": "compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
      "message_count": 30,
      "participants": [
        "Marco Elver",
        "Bart Van Assche",
        "Peter Zijlstra"
      ],
      "categories": [
        "context_analysis",
        "compiler_compat",
        "sparse_internals"
      ],
      "first_date": "2025-12-19T18:38:53+00:00",
      "last_date": "2025-12-20T13:33:07+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176617251518160.mbox",
          "message_id": "<97e832b7-04a9-49cb-973a-bf9870c21c2f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:38:53+00:00",
          "date_str": "Fri, 19 Dec 2025 18:38:53 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> +#if defined(WARN_CONTEXT_ANALYSIS)\n> +\n> +/*\n> + * These attributes define new context lock (Clang: capability) types.\n> + * Internal only.\n> + */\n\nHow can macros be \"internal only\" that are defined in a header file that\nwill be included by almost all kernel code? Please consider changing\n\"internal only\" into something that is more clear, e.g. \"should only be\nused in the macro definitions in this header file\".\n\n> +/*\n> + * The below are used to annotate code being checked. Internal only.\n> + */\n\nSame comment here about \"internal only\".\n\n> +/**\n> + * context_lock_struct() - declare or define a context lock struct\n> + * @name: struct name\n> + *\n> + * Helper to declare or define a struct type that is also a context lock.\n> + *\n> + * .. code-block:: c\n> + *\n> + *\tcontext_lock_struct(my_handle) {\n> + *\t\tint foo;\n> + *\t\tlong bar;\n> + *\t};\n> + *\n> + *\tstruct some_state {\n> + *\t\t...\n> + *\t};\n> + *\t// ... declared elsewhere ...\n> + *\tcontext_lock_struct(some_state);\n> + *\n> + * Note: The implementation defines several helper functions that can acquire\n> + * and release the context lock.\n> + */\n> +# define context_lock_struct(name, ...)\t\t\t\t\t\t\t\t\t\\\n> +\tstruct __ctx_lock_type(name) __VA_ARGS__ name;\t\t\t\t\t\t\t\\\n> +\tstatic __always_inline void __acquire_ctx_lock(const struct name *var)\t\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }\t\\\n> +\tstatic __always_inline void __acquire_shared_ctx_lock(const struct name *var)\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> +\tstatic __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)\t\\\n> +\t{ return ret; }\t\t\t\t\t\t\t\t\t\t\t\\\n> +\tstatic __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> +\t{ return ret; }\t\t\t\t\t\t\t\t\t\t\t\\\n> +\tstatic __always_inline void __release_ctx_lock(const struct name *var)\t\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }\t\\\n> +\tstatic __always_inline void __release_shared_ctx_lock(const struct name *var)\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> +\tstatic __always_inline void __assume_ctx_lock(const struct name *var)\t\t\t\t\\\n> +\t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n> +\tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n> +\t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n> +\tstruct name\n\nI'm concerned that the context_lock_struct() macro will make code harder\nto read. Anyone who encounters the context_lock_struct() macro will have\nto look up its definition to learn what it does. I propose to split this\nmacro into two macros:\n* One macro that expands into \"__ctx_lock_type(name)\".\n* A second macro that expands into the rest of the above macro.\n\nIn other words, instead of having to write \ncontext_lock_struct(struct_name, { ... }); developers will have to write\n\nstruct context_lock_type struct_name {\n     ...;\n};\ncontext_struct_helper_functions(struct_name);\n\nMy opinion is that the alternative that I'm proposing is easier to read.\nAdditionally, it doesn't break existing tools that support jumping from\nthe name of a struct to its definition, e.g. ctags and etags.\n\n> +config WARN_CONTEXT_ANALYSIS_ALL\n> +\tbool \"Enable context analysis for all source files\"\n> +\tdepends on WARN_CONTEXT_ANALYSIS\n> +\tdepends on EXPERT && !COMPILE_TEST\n> +\thelp\n> +\t  Enable tree-wide context analysis. This is likely to produce a\n> +\t  large number of false positives - enable at your own risk.\n> +\n> +\t  If unsure, say N.\n\nWhy !COMPILE_TEST?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617252318164.mbox",
          "message_id": "<97e832b7-04a9-49cb-973a-bf9870c21c2f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:38:53+00:00",
          "date_str": "Fri, 19 Dec 2025 18:38:53 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> +#if defined(WARN_CONTEXT_ANALYSIS)\n> +\n> +/*\n> + * These attributes define new context lock (Clang: capability) types.\n> + * Internal only.\n> + */\n\nHow can macros be \"internal only\" that are defined in a header file that\nwill be included by almost all kernel code? Please consider changing\n\"internal only\" into something that is more clear, e.g. \"should only be\nused in the macro definitions in this header file\".\n\n> +/*\n> + * The below are used to annotate code being checked. Internal only.\n> + */\n\nSame comment here about \"internal only\".\n\n> +/**\n> + * context_lock_struct() - declare or define a context lock struct\n> + * @name: struct name\n> + *\n> + * Helper to declare or define a struct type that is also a context lock.\n> + *\n> + * .. code-block:: c\n> + *\n> + *\tcontext_lock_struct(my_handle) {\n> + *\t\tint foo;\n> + *\t\tlong bar;\n> + *\t};\n> + *\n> + *\tstruct some_state {\n> + *\t\t...\n> + *\t};\n> + *\t// ... declared elsewhere ...\n> + *\tcontext_lock_struct(some_state);\n> + *\n> + * Note: The implementation defines several helper functions that can acquire\n> + * and release the context lock.\n> + */\n> +# define context_lock_struct(name, ...)\t\t\t\t\t\t\t\t\t\\\n> +\tstruct __ctx_lock_type(name) __VA_ARGS__ name;\t\t\t\t\t\t\t\\\n> +\tstatic __always_inline void __acquire_ctx_lock(const struct name *var)\t\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }\t\\\n> +\tstatic __always_inline void __acquire_shared_ctx_lock(const struct name *var)\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> +\tstatic __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)\t\\\n> +\t{ return ret; }\t\t\t\t\t\t\t\t\t\t\t\\\n> +\tstatic __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> +\t{ return ret; }\t\t\t\t\t\t\t\t\t\t\t\\\n> +\tstatic __always_inline void __release_ctx_lock(const struct name *var)\t\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }\t\\\n> +\tstatic __always_inline void __release_shared_ctx_lock(const struct name *var)\t\t\t\\\n> +\t\t__attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> +\tstatic __always_inline void __assume_ctx_lock(const struct name *var)\t\t\t\t\\\n> +\t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n> +\tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n> +\t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n> +\tstruct name\n\nI'm concerned that the context_lock_struct() macro will make code harder\nto read. Anyone who encounters the context_lock_struct() macro will have\nto look up its definition to learn what it does. I propose to split this\nmacro into two macros:\n* One macro that expands into \"__ctx_lock_type(name)\".\n* A second macro that expands into the rest of the above macro.\n\nIn other words, instead of having to write \ncontext_lock_struct(struct_name, { ... }); developers will have to write\n\nstruct context_lock_type struct_name {\n     ...;\n};\ncontext_struct_helper_functions(struct_name);\n\nMy opinion is that the alternative that I'm proposing is easier to read.\nAdditionally, it doesn't break existing tools that support jumping from\nthe name of a struct to its definition, e.g. ctags and etags.\n\n> +config WARN_CONTEXT_ANALYSIS_ALL\n> +\tbool \"Enable context analysis for all source files\"\n> +\tdepends on WARN_CONTEXT_ANALYSIS\n> +\tdepends on EXPERT && !COMPILE_TEST\n> +\thelp\n> +\t  Enable tree-wide context analysis. This is likely to produce a\n> +\t  large number of false positives - enable at your own risk.\n> +\n> +\t  If unsure, say N.\n\nWhy !COMPILE_TEST?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617364219488.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617365219491.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617360919453.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617361319467.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617366319496.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617360619448.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617361219464.mbox",
          "message_id": "<CANpmjNM=4baTiSWGOiSWLfQV2YqMt6qkdV__uj+QtD4zAY8Weg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 18:59:29+00:00",
          "date_str": "Fri, 19 Dec 2025 18:59:29 +0000",
          "body": "On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > +#if defined(WARN_CONTEXT_ANALYSIS)\n> > +\n> > +/*\n> > + * These attributes define new context lock (Clang: capability) types.\n> > + * Internal only.\n> > + */\n>\n> How can macros be \"internal only\" that are defined in a header file that\n> will be included by almost all kernel code? Please consider changing\n> \"internal only\" into something that is more clear, e.g. \"should only be\n> used in the macro definitions in this header file\".\n\nSure, comment could be improved.\n\nLet's say they aren't for general use by normal code that just enables\nthe analysis for checking; for that we define the shorter (retaining\nprevious names already in use) ones below. But some of these\nattributes can and are used by implementing support for some of the\nsynchronization primitives.\n\n> > +/*\n> > + * The below are used to annotate code being checked. Internal only.\n> > + */\n>\n> Same comment here about \"internal only\".\n\nSure, can be clarified.\n\n> > +/**\n> > + * context_lock_struct() - declare or define a context lock struct\n> > + * @name: struct name\n> > + *\n> > + * Helper to declare or define a struct type that is also a context lock.\n> > + *\n> > + * .. code-block:: c\n> > + *\n> > + *   context_lock_struct(my_handle) {\n> > + *           int foo;\n> > + *           long bar;\n> > + *   };\n> > + *\n> > + *   struct some_state {\n> > + *           ...\n> > + *   };\n> > + *   // ... declared elsewhere ...\n> > + *   context_lock_struct(some_state);\n> > + *\n> > + * Note: The implementation defines several helper functions that can acquire\n> > + * and release the context lock.\n> > + */\n> > +# define context_lock_struct(name, ...)                                                                      \\\n> > +     struct __ctx_lock_type(name) __VA_ARGS__ name;                                                  \\\n> > +     static __always_inline void __acquire_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_ctx_lock(var) { }        \\\n> > +     static __always_inline void __acquire_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __acquires_shared_ctx_lock(var) { } \\\n> > +     static __always_inline bool __try_acquire_ctx_lock(const struct name *var, bool ret)            \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_ctx_lock(1, var)     \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline bool __try_acquire_shared_ctx_lock(const struct name *var, bool ret)     \\\n> > +             __attribute__((overloadable)) __no_context_analysis __try_acquires_shared_ctx_lock(1, var) \\\n> > +     { return ret; }                                                                                 \\\n> > +     static __always_inline void __release_ctx_lock(const struct name *var)                          \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_ctx_lock(var) { }        \\\n> > +     static __always_inline void __release_shared_ctx_lock(const struct name *var)                   \\\n> > +             __attribute__((overloadable)) __no_context_analysis __releases_shared_ctx_lock(var) { } \\\n> > +     static __always_inline void __assume_ctx_lock(const struct name *var)                           \\\n> > +             __attribute__((overloadable)) __assumes_ctx_lock(var) { }                               \\\n> > +     static __always_inline void __assume_shared_ctx_lock(const struct name *var)                    \\\n> > +             __attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }                        \\\n> > +     struct name\n>\n> I'm concerned that the context_lock_struct() macro will make code harder\n> to read. Anyone who encounters the context_lock_struct() macro will have\n> to look up its definition to learn what it does. I propose to split this\n> macro into two macros:\n> * One macro that expands into \"__ctx_lock_type(name)\".\n> * A second macro that expands into the rest of the above macro.\n>\n> In other words, instead of having to write\n> context_lock_struct(struct_name, { ... }); developers will have to write\n>\n> struct context_lock_type struct_name {\n>      ...;\n> };\n> context_struct_helper_functions(struct_name);\n\nThis doesn't necessarily help with not having to look up its\ndefinition to learn what it does.\n\nIf this is the common pattern, it will blindly be repeated, and this\nadds 1 more line and makes this a bit more verbose. Maybe the helper\nfunctions aren't always needed, but I also think that context lock\ntypes should remain relatively few.  For all synchronization\nprimitives that were enabled in this series, the helpers are required.\n\nThe current usage is simply:\n\ncontext_lock_struct(na",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617392019763.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617401719823.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617391319754.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617401219820.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617391419757.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617400519817.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617391219750.mbox",
          "message_id": "<2f0c27eb-eca5-4a7f-8035-71c6b0c84e30 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:04:49+00:00",
          "date_str": "Fri, 19 Dec 2025 19:04:49 +0000",
          "body": "On 12/19/25 10:59 AM, Marco Elver wrote:\n> On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> <kasan-dev@googlegroups.com> wrote:\n>> I'm concerned that the context_lock_struct() macro will make code harder\n>> to read. Anyone who encounters the context_lock_struct() macro will have\n>> to look up its definition to learn what it does. I propose to split this\n>> macro into two macros:\n>> * One macro that expands into \"__ctx_lock_type(name)\".\n>> * A second macro that expands into the rest of the above macro.\n>>\n>> In other words, instead of having to write\n>> context_lock_struct(struct_name, { ... }); developers will have to write\n>>\n>> struct context_lock_type struct_name {\n>>       ...;\n>> };\n>> context_struct_helper_functions(struct_name);\n> \n> This doesn't necessarily help with not having to look up its\n> definition to learn what it does.\n> \n> If this is the common pattern, it will blindly be repeated, and this\n> adds 1 more line and makes this a bit more verbose. Maybe the helper\n> functions aren't always needed, but I also think that context lock\n> types should remain relatively few.  For all synchronization\n> primitives that were enabled in this series, the helpers are required.\n> \n> The current usage is simply:\n> \n> context_lock_struct(name) {\n>     ... struct goes here ...\n> };  // note no awkward ) brace\n> \n> I don't know which way the current kernel style is leaning towards,\n> but if we take <linux/cleanup.h> as an example, a simple programming\n> model / API is actually preferred.\nMany kernel developers are used to look up the definition of a data\nstructure either by using ctags, etags or a similar tool or by using\ngrep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\ndeveloper use today to look up data structure definitions might cause\nconsiderable frustration and hence shouldn't be done lightly.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617433420127.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617433320126.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617434420131.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617434520134.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617434920138.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617432720118.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617433020121.mbox",
          "message_id": "<aUWjfxQ1fIZdxd-C () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-19 19:11:59+00:00",
          "date_str": "Fri, 19 Dec 2025 19:11:59 +0000",
          "body": "On Fri, Dec 19, 2025 at 11:04AM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 10:59 AM, Marco Elver wrote:\n> > On Fri, 19 Dec 2025 at 19:39, 'Bart Van Assche' via kasan-dev\n> > <kasan-dev@googlegroups.com> wrote:\n> > > I'm concerned that the context_lock_struct() macro will make code harder\n> > > to read. Anyone who encounters the context_lock_struct() macro will have\n> > > to look up its definition to learn what it does. I propose to split this\n> > > macro into two macros:\n> > > * One macro that expands into \"__ctx_lock_type(name)\".\n> > > * A second macro that expands into the rest of the above macro.\n> > > \n> > > In other words, instead of having to write\n> > > context_lock_struct(struct_name, { ... }); developers will have to write\n> > > \n> > > struct context_lock_type struct_name {\n> > >       ...;\n> > > };\n> > > context_struct_helper_functions(struct_name);\n> > \n> > This doesn't necessarily help with not having to look up its\n> > definition to learn what it does.\n> > \n> > If this is the common pattern, it will blindly be repeated, and this\n> > adds 1 more line and makes this a bit more verbose. Maybe the helper\n> > functions aren't always needed, but I also think that context lock\n> > types should remain relatively few.  For all synchronization\n> > primitives that were enabled in this series, the helpers are required.\n> > \n> > The current usage is simply:\n> > \n> > context_lock_struct(name) {\n> >     ... struct goes here ...\n> > };  // note no awkward ) brace\n> > \n> > I don't know which way the current kernel style is leaning towards,\n> > but if we take <linux/cleanup.h> as an example, a simple programming\n> > model / API is actually preferred.\n> Many kernel developers are used to look up the definition of a data\n> structure either by using ctags, etags or a similar tool or by using\n> grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> developer use today to look up data structure definitions might cause\n> considerable frustration and hence shouldn't be done lightly.\n\nFair point. In fact, it's as simple as e.g. (just tested with mutex) as\nthis:\n\ndiff --git a/include/linux/mutex_types.h b/include/linux/mutex_types.h\nindex 80975935ec48..63ab9e65bb48 100644\n--- a/include/linux/mutex_types.h\n+++ b/include/linux/mutex_types.h\n@@ -38,7 +38,8 @@\n  * - detects multi-task circular deadlocks and prints out all affected\n  *   locks and tasks (and only those tasks)\n  */\n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tatomic_long_t\t\towner;\n \traw_spinlock_t\t\twait_lock;\n #ifdef CONFIG_MUTEX_SPIN_ON_OWNER\n@@ -59,7 +60,8 @@ context_lock_struct(mutex) {\n  */\n #include <linux/rtmutex.h>\n \n-context_lock_struct(mutex) {\n+context_lock_struct(mutex);\n+struct mutex {\n \tstruct rt_mutex_base\trtmutex;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n\nSo the existing macro does support both use-cases as-is. I suppose we\ncould force the above use pattern.\n\nThe reason it works, is because it forward-declares the struct anyway to\ndefine the helper functions.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624041126789.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624041626805.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624041626803.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624042126813.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624041626807.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624042626824.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176624041626806.mbox",
          "message_id": "<20251220133307.GR3707891 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 02/36] compiler-context-analysis: Add infrastructure for Context Analysis with Clang",
          "date": "2025-12-20 13:33:07+00:00",
          "date_str": "Sat, 20 Dec 2025 13:33:07 +0000",
          "body": "On Fri, Dec 19, 2025 at 08:11:59PM +0100, Marco Elver wrote:\n\n> > Many kernel developers are used to look up the definition of a data\n> > structure either by using ctags, etags or a similar tool or by using\n> > grep and a pattern like \"${struct_name} {\\$\". Breaking the tools kernel\n> > developer use today to look up data structure definitions might cause\n> > considerable frustration and hence shouldn't be done lightly.\n\nIts a simple matter of adding a regex to scripts/tags.sh :-) Also clangd\nlanguage server sees right through it as is. So all 'modern' stuff using\nthat will have no problems.\n\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
      "normalized_subject": "compiler-context-analysis: Remove __cond_lock() function-like helper",
      "message_count": 19,
      "participants": [
        "Marco Elver",
        "Bart Van Assche"
      ],
      "categories": [
        "general",
        "compiler_compat"
      ],
      "first_date": "2025-12-19T15:40:13+00:00",
      "last_date": "2025-12-20T12:51:30+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176616355609479.mbox",
          "message_id": "<20251219154418.3592607-25-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 15:40:13+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:13 +0000",
          "body": "As discussed in [1], removing __cond_lock() will improve the readability\nof trylock code. Now that Sparse context tracking support has been\nremoved, we can also remove __cond_lock().\n\nChange existing APIs to either drop __cond_lock() completely, or make\nuse of the __cond_acquires() function attribute instead.\n\nIn particular, spinlock and rwlock implementations required switching\nover to inline helpers rather than statement-expressions for their\ntrylock_* variants.\n\nLink: https://lore.kernel.org/all/20250207082832.GU7145@noisy.programming.kicks-ass.net/ [1]\nSuggested-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Fix up include/linux/lockref.h, too.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst  |  2 -\n Documentation/mm/process_addrs.rst            |  6 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n include/linux/compiler-context-analysis.h     | 31 ----------\n include/linux/lockref.h                       |  4 +-\n include/linux/mm.h                            | 33 ++--------\n include/linux/rwlock.h                        | 11 +---\n include/linux/rwlock_api_smp.h                | 14 ++++-\n include/linux/rwlock_rt.h                     | 21 ++++---\n include/linux/sched/signal.h                  | 14 +----\n include/linux/spinlock.h                      | 45 +++++---------\n include/linux/spinlock_api_smp.h              | 20 ++++++\n include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n include/linux/spinlock_rt.h                   | 26 ++++----\n kernel/signal.c                               |  4 +-\n kernel/time/posix-timers.c                    | 13 +---\n lib/dec_and_lock.c                            |  8 +--\n lib/lockref.c                                 |  1 -\n mm/memory.c                                   |  4 +-\n mm/pgtable-generic.c                          | 19 +++---\n tools/include/linux/compiler_types.h          |  2 -\n 24 files changed, 163 insertions(+), 195 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 8dd6c0d695aa..e69896e597b6 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -112,10 +112,8 @@ Keywords\n                  __releases_shared\n                  __acquire\n                  __release\n-                 __cond_lock\n                  __acquire_shared\n                  __release_shared\n-                 __cond_lock_shared\n                  __acquire_ret\n                  __acquire_shared_ret\n                  context_unsafe\ndiff --git a/Documentation/mm/process_addrs.rst b/Documentation/mm/process_addrs.rst\nindex 7f2f3e87071d..851680ead45f 100644\n--- a/Documentation/mm/process_addrs.rst\n+++ b/Documentation/mm/process_addrs.rst\n@@ -583,7 +583,7 @@ To access PTE-level page tables, a helper like :c:func:`!pte_offset_map_lock` or\n :c:func:`!pte_offset_map` can be used depending on stability requirements.\n These map the page table into kernel memory if required, take the RCU lock, and\n depending on variant, may also look up or acquire the PTE lock.\n-See the comment on :c:func:`!__pte_offset_map_lock`.\n+See the comment on :c:func:`!pte_offset_map_lock`.\n \n Atomicity\n ^^^^^^^^^\n@@ -667,7 +667,7 @@ must be released via :c:func:`!pte_unmap_unlock`.\n .. note:: There are some variants on this, such as\n    :c:func:`!pte_offset_map_rw_nolock` when we know we hold the PTE stable but\n    for brevity we do not explore this.  See the comment for\n-   :c:func:`!__pte_offset_map_lock` for more details.\n+   :c:func:`!pte_offset_map_lock` for more details.\n \n When modifying data in ranges we typically only wish to allocate higher page\n tables as necessary, using these locks to avoid races or overwriting anything,\n@@ -686,7 +686,7 @@ At the leaf page table, that is the PTE, we can't entirely rely on this pattern\n as we have separate PMD and PTE locks and a THP collapse for instance might have\n eliminated the PMD entry as well as the PTE from under us.\n \n-This is why :c:func:`!__pte_offset_map_lock` locklessly retrieves the PMD entry\n+This is why :c:func:`!pte_offset_map_lock` locklessly retrieves the PMD entry\n for the PTE, carefully checking it is as expected, before acquiring the\n PTE-specific lock, and then *again* checking that the PMD entry is as expected.\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\nindex cc8a84018f70..fa1442246662 100644\n--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n@@ -548,11 +548,11 @@ int iwl_trans_read_config32(struct iwl_trans *trans, u32 ofs,\n \treturn iwl_trans_pcie_read_config32(trans, ofs, val);\n }\n \n-bool _iwl_trans_grab_nic_access(struct iwl_trans *trans)\n+bo",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616984315815.mbox",
          "message_id": "<20251219154418.3592607-25-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 15:40:13+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:13 +0000",
          "body": "As discussed in [1], removing __cond_lock() will improve the readability\nof trylock code. Now that Sparse context tracking support has been\nremoved, we can also remove __cond_lock().\n\nChange existing APIs to either drop __cond_lock() completely, or make\nuse of the __cond_acquires() function attribute instead.\n\nIn particular, spinlock and rwlock implementations required switching\nover to inline helpers rather than statement-expressions for their\ntrylock_* variants.\n\nLink: https://lore.kernel.org/all/20250207082832.GU7145@noisy.programming.kicks-ass.net/ [1]\nSuggested-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Fix up include/linux/lockref.h, too.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst  |  2 -\n Documentation/mm/process_addrs.rst            |  6 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n include/linux/compiler-context-analysis.h     | 31 ----------\n include/linux/lockref.h                       |  4 +-\n include/linux/mm.h                            | 33 ++--------\n include/linux/rwlock.h                        | 11 +---\n include/linux/rwlock_api_smp.h                | 14 ++++-\n include/linux/rwlock_rt.h                     | 21 ++++---\n include/linux/sched/signal.h                  | 14 +----\n include/linux/spinlock.h                      | 45 +++++---------\n include/linux/spinlock_api_smp.h              | 20 ++++++\n include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n include/linux/spinlock_rt.h                   | 26 ++++----\n kernel/signal.c                               |  4 +-\n kernel/time/posix-timers.c                    | 13 +---\n lib/dec_and_lock.c                            |  8 +--\n lib/lockref.c                                 |  1 -\n mm/memory.c                                   |  4 +-\n mm/pgtable-generic.c                          | 19 +++---\n tools/include/linux/compiler_types.h          |  2 -\n 24 files changed, 163 insertions(+), 195 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 8dd6c0d695aa..e69896e597b6 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -112,10 +112,8 @@ Keywords\n                  __releases_shared\n                  __acquire\n                  __release\n-                 __cond_lock\n                  __acquire_shared\n                  __release_shared\n-                 __cond_lock_shared\n                  __acquire_ret\n                  __acquire_shared_ret\n                  context_unsafe\ndiff --git a/Documentation/mm/process_addrs.rst b/Documentation/mm/process_addrs.rst\nindex 7f2f3e87071d..851680ead45f 100644\n--- a/Documentation/mm/process_addrs.rst\n+++ b/Documentation/mm/process_addrs.rst\n@@ -583,7 +583,7 @@ To access PTE-level page tables, a helper like :c:func:`!pte_offset_map_lock` or\n :c:func:`!pte_offset_map` can be used depending on stability requirements.\n These map the page table into kernel memory if required, take the RCU lock, and\n depending on variant, may also look up or acquire the PTE lock.\n-See the comment on :c:func:`!__pte_offset_map_lock`.\n+See the comment on :c:func:`!pte_offset_map_lock`.\n \n Atomicity\n ^^^^^^^^^\n@@ -667,7 +667,7 @@ must be released via :c:func:`!pte_unmap_unlock`.\n .. note:: There are some variants on this, such as\n    :c:func:`!pte_offset_map_rw_nolock` when we know we hold the PTE stable but\n    for brevity we do not explore this.  See the comment for\n-   :c:func:`!__pte_offset_map_lock` for more details.\n+   :c:func:`!pte_offset_map_lock` for more details.\n \n When modifying data in ranges we typically only wish to allocate higher page\n tables as necessary, using these locks to avoid races or overwriting anything,\n@@ -686,7 +686,7 @@ At the leaf page table, that is the PTE, we can't entirely rely on this pattern\n as we have separate PMD and PTE locks and a THP collapse for instance might have\n eliminated the PMD entry as well as the PTE from under us.\n \n-This is why :c:func:`!__pte_offset_map_lock` locklessly retrieves the PMD entry\n+This is why :c:func:`!pte_offset_map_lock` locklessly retrieves the PMD entry\n for the PTE, carefully checking it is as expected, before acquiring the\n PTE-specific lock, and then *again* checking that the PMD entry is as expected.\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\nindex cc8a84018f70..fa1442246662 100644\n--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n@@ -548,11 +548,11 @@ int iwl_trans_read_config32(struct iwl_trans *trans, u32 ofs,\n \treturn iwl_trans_pcie_read_config32(trans, ofs, val);\n }\n \n-bool _iwl_trans_grab_nic_access(struct iwl_trans *trans)\n+bo",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616291808821.mbox",
          "message_id": "<20251219154418.3592607-25-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 15:40:13+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:13 +0000",
          "body": "As discussed in [1], removing __cond_lock() will improve the readability\nof trylock code. Now that Sparse context tracking support has been\nremoved, we can also remove __cond_lock().\n\nChange existing APIs to either drop __cond_lock() completely, or make\nuse of the __cond_acquires() function attribute instead.\n\nIn particular, spinlock and rwlock implementations required switching\nover to inline helpers rather than statement-expressions for their\ntrylock_* variants.\n\nLink: https://lore.kernel.org/all/20250207082832.GU7145@noisy.programming.kicks-ass.net/ [1]\nSuggested-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Fix up include/linux/lockref.h, too.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst  |  2 -\n Documentation/mm/process_addrs.rst            |  6 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n include/linux/compiler-context-analysis.h     | 31 ----------\n include/linux/lockref.h                       |  4 +-\n include/linux/mm.h                            | 33 ++--------\n include/linux/rwlock.h                        | 11 +---\n include/linux/rwlock_api_smp.h                | 14 ++++-\n include/linux/rwlock_rt.h                     | 21 ++++---\n include/linux/sched/signal.h                  | 14 +----\n include/linux/spinlock.h                      | 45 +++++---------\n include/linux/spinlock_api_smp.h              | 20 ++++++\n include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n include/linux/spinlock_rt.h                   | 26 ++++----\n kernel/signal.c                               |  4 +-\n kernel/time/posix-timers.c                    | 13 +---\n lib/dec_and_lock.c                            |  8 +--\n lib/lockref.c                                 |  1 -\n mm/memory.c                                   |  4 +-\n mm/pgtable-generic.c                          | 19 +++---\n tools/include/linux/compiler_types.h          |  2 -\n 24 files changed, 163 insertions(+), 195 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 8dd6c0d695aa..e69896e597b6 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -112,10 +112,8 @@ Keywords\n                  __releases_shared\n                  __acquire\n                  __release\n-                 __cond_lock\n                  __acquire_shared\n                  __release_shared\n-                 __cond_lock_shared\n                  __acquire_ret\n                  __acquire_shared_ret\n                  context_unsafe\ndiff --git a/Documentation/mm/process_addrs.rst b/Documentation/mm/process_addrs.rst\nindex 7f2f3e87071d..851680ead45f 100644\n--- a/Documentation/mm/process_addrs.rst\n+++ b/Documentation/mm/process_addrs.rst\n@@ -583,7 +583,7 @@ To access PTE-level page tables, a helper like :c:func:`!pte_offset_map_lock` or\n :c:func:`!pte_offset_map` can be used depending on stability requirements.\n These map the page table into kernel memory if required, take the RCU lock, and\n depending on variant, may also look up or acquire the PTE lock.\n-See the comment on :c:func:`!__pte_offset_map_lock`.\n+See the comment on :c:func:`!pte_offset_map_lock`.\n \n Atomicity\n ^^^^^^^^^\n@@ -667,7 +667,7 @@ must be released via :c:func:`!pte_unmap_unlock`.\n .. note:: There are some variants on this, such as\n    :c:func:`!pte_offset_map_rw_nolock` when we know we hold the PTE stable but\n    for brevity we do not explore this.  See the comment for\n-   :c:func:`!__pte_offset_map_lock` for more details.\n+   :c:func:`!pte_offset_map_lock` for more details.\n \n When modifying data in ranges we typically only wish to allocate higher page\n tables as necessary, using these locks to avoid races or overwriting anything,\n@@ -686,7 +686,7 @@ At the leaf page table, that is the PTE, we can't entirely rely on this pattern\n as we have separate PMD and PTE locks and a THP collapse for instance might have\n eliminated the PMD entry as well as the PTE from under us.\n \n-This is why :c:func:`!__pte_offset_map_lock` locklessly retrieves the PMD entry\n+This is why :c:func:`!pte_offset_map_lock` locklessly retrieves the PMD entry\n for the PTE, carefully checking it is as expected, before acquiring the\n PTE-specific lock, and then *again* checking that the PMD entry is as expected.\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\nindex cc8a84018f70..fa1442246662 100644\n--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n@@ -548,11 +548,11 @@ int iwl_trans_read_config32(struct iwl_trans *trans, u32 ofs,\n \treturn iwl_trans_pcie_read_config32(trans, ofs, val);\n }\n \n-bool _iwl_trans_grab_nic_access(struct iwl_trans *trans)\n+bo",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616287408748.mbox",
          "message_id": "<20251219154418.3592607-25-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 15:40:13+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:13 +0000",
          "body": "As discussed in [1], removing __cond_lock() will improve the readability\nof trylock code. Now that Sparse context tracking support has been\nremoved, we can also remove __cond_lock().\n\nChange existing APIs to either drop __cond_lock() completely, or make\nuse of the __cond_acquires() function attribute instead.\n\nIn particular, spinlock and rwlock implementations required switching\nover to inline helpers rather than statement-expressions for their\ntrylock_* variants.\n\nLink: https://lore.kernel.org/all/20250207082832.GU7145@noisy.programming.kicks-ass.net/ [1]\nSuggested-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Fix up include/linux/lockref.h, too.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst  |  2 -\n Documentation/mm/process_addrs.rst            |  6 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n include/linux/compiler-context-analysis.h     | 31 ----------\n include/linux/lockref.h                       |  4 +-\n include/linux/mm.h                            | 33 ++--------\n include/linux/rwlock.h                        | 11 +---\n include/linux/rwlock_api_smp.h                | 14 ++++-\n include/linux/rwlock_rt.h                     | 21 ++++---\n include/linux/sched/signal.h                  | 14 +----\n include/linux/spinlock.h                      | 45 +++++---------\n include/linux/spinlock_api_smp.h              | 20 ++++++\n include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n include/linux/spinlock_rt.h                   | 26 ++++----\n kernel/signal.c                               |  4 +-\n kernel/time/posix-timers.c                    | 13 +---\n lib/dec_and_lock.c                            |  8 +--\n lib/lockref.c                                 |  1 -\n mm/memory.c                                   |  4 +-\n mm/pgtable-generic.c                          | 19 +++---\n tools/include/linux/compiler_types.h          |  2 -\n 24 files changed, 163 insertions(+), 195 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 8dd6c0d695aa..e69896e597b6 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -112,10 +112,8 @@ Keywords\n                  __releases_shared\n                  __acquire\n                  __release\n-                 __cond_lock\n                  __acquire_shared\n                  __release_shared\n-                 __cond_lock_shared\n                  __acquire_ret\n                  __acquire_shared_ret\n                  context_unsafe\ndiff --git a/Documentation/mm/process_addrs.rst b/Documentation/mm/process_addrs.rst\nindex 7f2f3e87071d..851680ead45f 100644\n--- a/Documentation/mm/process_addrs.rst\n+++ b/Documentation/mm/process_addrs.rst\n@@ -583,7 +583,7 @@ To access PTE-level page tables, a helper like :c:func:`!pte_offset_map_lock` or\n :c:func:`!pte_offset_map` can be used depending on stability requirements.\n These map the page table into kernel memory if required, take the RCU lock, and\n depending on variant, may also look up or acquire the PTE lock.\n-See the comment on :c:func:`!__pte_offset_map_lock`.\n+See the comment on :c:func:`!pte_offset_map_lock`.\n \n Atomicity\n ^^^^^^^^^\n@@ -667,7 +667,7 @@ must be released via :c:func:`!pte_unmap_unlock`.\n .. note:: There are some variants on this, such as\n    :c:func:`!pte_offset_map_rw_nolock` when we know we hold the PTE stable but\n    for brevity we do not explore this.  See the comment for\n-   :c:func:`!__pte_offset_map_lock` for more details.\n+   :c:func:`!pte_offset_map_lock` for more details.\n \n When modifying data in ranges we typically only wish to allocate higher page\n tables as necessary, using these locks to avoid races or overwriting anything,\n@@ -686,7 +686,7 @@ At the leaf page table, that is the PTE, we can't entirely rely on this pattern\n as we have separate PMD and PTE locks and a THP collapse for instance might have\n eliminated the PMD entry as well as the PTE from under us.\n \n-This is why :c:func:`!__pte_offset_map_lock` locklessly retrieves the PMD entry\n+This is why :c:func:`!pte_offset_map_lock` locklessly retrieves the PMD entry\n for the PTE, carefully checking it is as expected, before acquiring the\n PTE-specific lock, and then *again* checking that the PMD entry is as expected.\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\nindex cc8a84018f70..fa1442246662 100644\n--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n@@ -548,11 +548,11 @@ int iwl_trans_read_config32(struct iwl_trans *trans, u32 ofs,\n \treturn iwl_trans_pcie_read_config32(trans, ofs, val);\n }\n \n-bool _iwl_trans_grab_nic_access(struct iwl_trans *trans)\n+bo",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616290908815.mbox",
          "message_id": "<20251219154418.3592607-25-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 15:40:13+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:13 +0000",
          "body": "As discussed in [1], removing __cond_lock() will improve the readability\nof trylock code. Now that Sparse context tracking support has been\nremoved, we can also remove __cond_lock().\n\nChange existing APIs to either drop __cond_lock() completely, or make\nuse of the __cond_acquires() function attribute instead.\n\nIn particular, spinlock and rwlock implementations required switching\nover to inline helpers rather than statement-expressions for their\ntrylock_* variants.\n\nLink: https://lore.kernel.org/all/20250207082832.GU7145@noisy.programming.kicks-ass.net/ [1]\nSuggested-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Fix up include/linux/lockref.h, too.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst  |  2 -\n Documentation/mm/process_addrs.rst            |  6 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n include/linux/compiler-context-analysis.h     | 31 ----------\n include/linux/lockref.h                       |  4 +-\n include/linux/mm.h                            | 33 ++--------\n include/linux/rwlock.h                        | 11 +---\n include/linux/rwlock_api_smp.h                | 14 ++++-\n include/linux/rwlock_rt.h                     | 21 ++++---\n include/linux/sched/signal.h                  | 14 +----\n include/linux/spinlock.h                      | 45 +++++---------\n include/linux/spinlock_api_smp.h              | 20 ++++++\n include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n include/linux/spinlock_rt.h                   | 26 ++++----\n kernel/signal.c                               |  4 +-\n kernel/time/posix-timers.c                    | 13 +---\n lib/dec_and_lock.c                            |  8 +--\n lib/lockref.c                                 |  1 -\n mm/memory.c                                   |  4 +-\n mm/pgtable-generic.c                          | 19 +++---\n tools/include/linux/compiler_types.h          |  2 -\n 24 files changed, 163 insertions(+), 195 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 8dd6c0d695aa..e69896e597b6 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -112,10 +112,8 @@ Keywords\n                  __releases_shared\n                  __acquire\n                  __release\n-                 __cond_lock\n                  __acquire_shared\n                  __release_shared\n-                 __cond_lock_shared\n                  __acquire_ret\n                  __acquire_shared_ret\n                  context_unsafe\ndiff --git a/Documentation/mm/process_addrs.rst b/Documentation/mm/process_addrs.rst\nindex 7f2f3e87071d..851680ead45f 100644\n--- a/Documentation/mm/process_addrs.rst\n+++ b/Documentation/mm/process_addrs.rst\n@@ -583,7 +583,7 @@ To access PTE-level page tables, a helper like :c:func:`!pte_offset_map_lock` or\n :c:func:`!pte_offset_map` can be used depending on stability requirements.\n These map the page table into kernel memory if required, take the RCU lock, and\n depending on variant, may also look up or acquire the PTE lock.\n-See the comment on :c:func:`!__pte_offset_map_lock`.\n+See the comment on :c:func:`!pte_offset_map_lock`.\n \n Atomicity\n ^^^^^^^^^\n@@ -667,7 +667,7 @@ must be released via :c:func:`!pte_unmap_unlock`.\n .. note:: There are some variants on this, such as\n    :c:func:`!pte_offset_map_rw_nolock` when we know we hold the PTE stable but\n    for brevity we do not explore this.  See the comment for\n-   :c:func:`!__pte_offset_map_lock` for more details.\n+   :c:func:`!pte_offset_map_lock` for more details.\n \n When modifying data in ranges we typically only wish to allocate higher page\n tables as necessary, using these locks to avoid races or overwriting anything,\n@@ -686,7 +686,7 @@ At the leaf page table, that is the PTE, we can't entirely rely on this pattern\n as we have separate PMD and PTE locks and a THP collapse for instance might have\n eliminated the PMD entry as well as the PTE from under us.\n \n-This is why :c:func:`!__pte_offset_map_lock` locklessly retrieves the PMD entry\n+This is why :c:func:`!pte_offset_map_lock` locklessly retrieves the PMD entry\n for the PTE, carefully checking it is as expected, before acquiring the\n PTE-specific lock, and then *again* checking that the PMD entry is as expected.\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\nindex cc8a84018f70..fa1442246662 100644\n--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n@@ -548,11 +548,11 @@ int iwl_trans_read_config32(struct iwl_trans *trans, u32 ofs,\n \treturn iwl_trans_pcie_read_config32(trans, ofs, val);\n }\n \n-bool _iwl_trans_grab_nic_access(struct iwl_trans *trans)\n+bo",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176617370719539.mbox",
          "message_id": "<20251219154418.3592607-25-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 15:40:13+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:13 +0000",
          "body": "As discussed in [1], removing __cond_lock() will improve the readability\nof trylock code. Now that Sparse context tracking support has been\nremoved, we can also remove __cond_lock().\n\nChange existing APIs to either drop __cond_lock() completely, or make\nuse of the __cond_acquires() function attribute instead.\n\nIn particular, spinlock and rwlock implementations required switching\nover to inline helpers rather than statement-expressions for their\ntrylock_* variants.\n\nLink: https://lore.kernel.org/all/20250207082832.GU7145@noisy.programming.kicks-ass.net/ [1]\nSuggested-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Fix up include/linux/lockref.h, too.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst  |  2 -\n Documentation/mm/process_addrs.rst            |  6 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n include/linux/compiler-context-analysis.h     | 31 ----------\n include/linux/lockref.h                       |  4 +-\n include/linux/mm.h                            | 33 ++--------\n include/linux/rwlock.h                        | 11 +---\n include/linux/rwlock_api_smp.h                | 14 ++++-\n include/linux/rwlock_rt.h                     | 21 ++++---\n include/linux/sched/signal.h                  | 14 +----\n include/linux/spinlock.h                      | 45 +++++---------\n include/linux/spinlock_api_smp.h              | 20 ++++++\n include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n include/linux/spinlock_rt.h                   | 26 ++++----\n kernel/signal.c                               |  4 +-\n kernel/time/posix-timers.c                    | 13 +---\n lib/dec_and_lock.c                            |  8 +--\n lib/lockref.c                                 |  1 -\n mm/memory.c                                   |  4 +-\n mm/pgtable-generic.c                          | 19 +++---\n tools/include/linux/compiler_types.h          |  2 -\n 24 files changed, 163 insertions(+), 195 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 8dd6c0d695aa..e69896e597b6 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -112,10 +112,8 @@ Keywords\n                  __releases_shared\n                  __acquire\n                  __release\n-                 __cond_lock\n                  __acquire_shared\n                  __release_shared\n-                 __cond_lock_shared\n                  __acquire_ret\n                  __acquire_shared_ret\n                  context_unsafe\ndiff --git a/Documentation/mm/process_addrs.rst b/Documentation/mm/process_addrs.rst\nindex 7f2f3e87071d..851680ead45f 100644\n--- a/Documentation/mm/process_addrs.rst\n+++ b/Documentation/mm/process_addrs.rst\n@@ -583,7 +583,7 @@ To access PTE-level page tables, a helper like :c:func:`!pte_offset_map_lock` or\n :c:func:`!pte_offset_map` can be used depending on stability requirements.\n These map the page table into kernel memory if required, take the RCU lock, and\n depending on variant, may also look up or acquire the PTE lock.\n-See the comment on :c:func:`!__pte_offset_map_lock`.\n+See the comment on :c:func:`!pte_offset_map_lock`.\n \n Atomicity\n ^^^^^^^^^\n@@ -667,7 +667,7 @@ must be released via :c:func:`!pte_unmap_unlock`.\n .. note:: There are some variants on this, such as\n    :c:func:`!pte_offset_map_rw_nolock` when we know we hold the PTE stable but\n    for brevity we do not explore this.  See the comment for\n-   :c:func:`!__pte_offset_map_lock` for more details.\n+   :c:func:`!pte_offset_map_lock` for more details.\n \n When modifying data in ranges we typically only wish to allocate higher page\n tables as necessary, using these locks to avoid races or overwriting anything,\n@@ -686,7 +686,7 @@ At the leaf page table, that is the PTE, we can't entirely rely on this pattern\n as we have separate PMD and PTE locks and a THP collapse for instance might have\n eliminated the PMD entry as well as the PTE from under us.\n \n-This is why :c:func:`!__pte_offset_map_lock` locklessly retrieves the PMD entry\n+This is why :c:func:`!pte_offset_map_lock` locklessly retrieves the PMD entry\n for the PTE, carefully checking it is as expected, before acquiring the\n PTE-specific lock, and then *again* checking that the PMD entry is as expected.\n \ndiff --git a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\nindex cc8a84018f70..fa1442246662 100644\n--- a/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n+++ b/drivers/net/wireless/intel/iwlwifi/iwl-trans.c\n@@ -548,11 +548,11 @@ int iwl_trans_read_config32(struct iwl_trans *trans, u32 ofs,\n \treturn iwl_trans_pcie_read_config32(trans, ofs, val);\n }\n \n-bool _iwl_trans_grab_nic_access(struct iwl_trans *trans)\n+bo",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618336626729.mbox",
          "message_id": "<9af0d949-45f5-45cd-b49d-d45d53f5d8f6 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 21:42:38+00:00",
          "date_str": "Fri, 19 Dec 2025 21:42:38 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n>   Documentation/dev-tools/context-analysis.rst  |  2 -\n>   Documentation/mm/process_addrs.rst            |  6 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n>   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n>   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n>   include/linux/compiler-context-analysis.h     | 31 ----------\n>   include/linux/lockref.h                       |  4 +-\n>   include/linux/mm.h                            | 33 ++--------\n>   include/linux/rwlock.h                        | 11 +---\n>   include/linux/rwlock_api_smp.h                | 14 ++++-\n>   include/linux/rwlock_rt.h                     | 21 ++++---\n>   include/linux/sched/signal.h                  | 14 +----\n>   include/linux/spinlock.h                      | 45 +++++---------\n>   include/linux/spinlock_api_smp.h              | 20 ++++++\n>   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n>   include/linux/spinlock_rt.h                   | 26 ++++----\n>   kernel/signal.c                               |  4 +-\n>   kernel/time/posix-timers.c                    | 13 +---\n>   lib/dec_and_lock.c                            |  8 +--\n>   lib/lockref.c                                 |  1 -\n>   mm/memory.c                                   |  4 +-\n>   mm/pgtable-generic.c                          | 19 +++---\n>   tools/include/linux/compiler_types.h          |  2 -\n\nThis patch should be split into one patch per subsystem or driver.\nE.g. one patch for the iwlwifi driver, another patch for the mm\nsubsystem, one patch for the rwlock primitive, one patch for the\nspinlock primitive, etc.\n\nThe tools/include/linux/compiler_types.h change probably should be\nleft out because it is user space code instead of kernel code and\nthe rest of the series applies to kernel code only.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618336826731.mbox",
          "message_id": "<9af0d949-45f5-45cd-b49d-d45d53f5d8f6 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 21:42:38+00:00",
          "date_str": "Fri, 19 Dec 2025 21:42:38 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n>   Documentation/dev-tools/context-analysis.rst  |  2 -\n>   Documentation/mm/process_addrs.rst            |  6 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n>   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n>   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n>   include/linux/compiler-context-analysis.h     | 31 ----------\n>   include/linux/lockref.h                       |  4 +-\n>   include/linux/mm.h                            | 33 ++--------\n>   include/linux/rwlock.h                        | 11 +---\n>   include/linux/rwlock_api_smp.h                | 14 ++++-\n>   include/linux/rwlock_rt.h                     | 21 ++++---\n>   include/linux/sched/signal.h                  | 14 +----\n>   include/linux/spinlock.h                      | 45 +++++---------\n>   include/linux/spinlock_api_smp.h              | 20 ++++++\n>   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n>   include/linux/spinlock_rt.h                   | 26 ++++----\n>   kernel/signal.c                               |  4 +-\n>   kernel/time/posix-timers.c                    | 13 +---\n>   lib/dec_and_lock.c                            |  8 +--\n>   lib/lockref.c                                 |  1 -\n>   mm/memory.c                                   |  4 +-\n>   mm/pgtable-generic.c                          | 19 +++---\n>   tools/include/linux/compiler_types.h          |  2 -\n\nThis patch should be split into one patch per subsystem or driver.\nE.g. one patch for the iwlwifi driver, another patch for the mm\nsubsystem, one patch for the rwlock primitive, one patch for the\nspinlock primitive, etc.\n\nThe tools/include/linux/compiler_types.h change probably should be\nleft out because it is user space code instead of kernel code and\nthe rest of the series applies to kernel code only.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618337226740.mbox",
          "message_id": "<9af0d949-45f5-45cd-b49d-d45d53f5d8f6 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 21:42:38+00:00",
          "date_str": "Fri, 19 Dec 2025 21:42:38 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n>   Documentation/dev-tools/context-analysis.rst  |  2 -\n>   Documentation/mm/process_addrs.rst            |  6 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n>   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n>   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n>   include/linux/compiler-context-analysis.h     | 31 ----------\n>   include/linux/lockref.h                       |  4 +-\n>   include/linux/mm.h                            | 33 ++--------\n>   include/linux/rwlock.h                        | 11 +---\n>   include/linux/rwlock_api_smp.h                | 14 ++++-\n>   include/linux/rwlock_rt.h                     | 21 ++++---\n>   include/linux/sched/signal.h                  | 14 +----\n>   include/linux/spinlock.h                      | 45 +++++---------\n>   include/linux/spinlock_api_smp.h              | 20 ++++++\n>   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n>   include/linux/spinlock_rt.h                   | 26 ++++----\n>   kernel/signal.c                               |  4 +-\n>   kernel/time/posix-timers.c                    | 13 +---\n>   lib/dec_and_lock.c                            |  8 +--\n>   lib/lockref.c                                 |  1 -\n>   mm/memory.c                                   |  4 +-\n>   mm/pgtable-generic.c                          | 19 +++---\n>   tools/include/linux/compiler_types.h          |  2 -\n\nThis patch should be split into one patch per subsystem or driver.\nE.g. one patch for the iwlwifi driver, another patch for the mm\nsubsystem, one patch for the rwlock primitive, one patch for the\nspinlock primitive, etc.\n\nThe tools/include/linux/compiler_types.h change probably should be\nleft out because it is user space code instead of kernel code and\nthe rest of the series applies to kernel code only.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618337126735.mbox",
          "message_id": "<9af0d949-45f5-45cd-b49d-d45d53f5d8f6 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 21:42:38+00:00",
          "date_str": "Fri, 19 Dec 2025 21:42:38 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n>   Documentation/dev-tools/context-analysis.rst  |  2 -\n>   Documentation/mm/process_addrs.rst            |  6 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n>   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n>   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n>   include/linux/compiler-context-analysis.h     | 31 ----------\n>   include/linux/lockref.h                       |  4 +-\n>   include/linux/mm.h                            | 33 ++--------\n>   include/linux/rwlock.h                        | 11 +---\n>   include/linux/rwlock_api_smp.h                | 14 ++++-\n>   include/linux/rwlock_rt.h                     | 21 ++++---\n>   include/linux/sched/signal.h                  | 14 +----\n>   include/linux/spinlock.h                      | 45 +++++---------\n>   include/linux/spinlock_api_smp.h              | 20 ++++++\n>   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n>   include/linux/spinlock_rt.h                   | 26 ++++----\n>   kernel/signal.c                               |  4 +-\n>   kernel/time/posix-timers.c                    | 13 +---\n>   lib/dec_and_lock.c                            |  8 +--\n>   lib/lockref.c                                 |  1 -\n>   mm/memory.c                                   |  4 +-\n>   mm/pgtable-generic.c                          | 19 +++---\n>   tools/include/linux/compiler_types.h          |  2 -\n\nThis patch should be split into one patch per subsystem or driver.\nE.g. one patch for the iwlwifi driver, another patch for the mm\nsubsystem, one patch for the rwlock primitive, one patch for the\nspinlock primitive, etc.\n\nThe tools/include/linux/compiler_types.h change probably should be\nleft out because it is user space code instead of kernel code and\nthe rest of the series applies to kernel code only.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618337626748.mbox",
          "message_id": "<9af0d949-45f5-45cd-b49d-d45d53f5d8f6 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 21:42:38+00:00",
          "date_str": "Fri, 19 Dec 2025 21:42:38 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n>   Documentation/dev-tools/context-analysis.rst  |  2 -\n>   Documentation/mm/process_addrs.rst            |  6 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n>   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n>   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n>   include/linux/compiler-context-analysis.h     | 31 ----------\n>   include/linux/lockref.h                       |  4 +-\n>   include/linux/mm.h                            | 33 ++--------\n>   include/linux/rwlock.h                        | 11 +---\n>   include/linux/rwlock_api_smp.h                | 14 ++++-\n>   include/linux/rwlock_rt.h                     | 21 ++++---\n>   include/linux/sched/signal.h                  | 14 +----\n>   include/linux/spinlock.h                      | 45 +++++---------\n>   include/linux/spinlock_api_smp.h              | 20 ++++++\n>   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n>   include/linux/spinlock_rt.h                   | 26 ++++----\n>   kernel/signal.c                               |  4 +-\n>   kernel/time/posix-timers.c                    | 13 +---\n>   lib/dec_and_lock.c                            |  8 +--\n>   lib/lockref.c                                 |  1 -\n>   mm/memory.c                                   |  4 +-\n>   mm/pgtable-generic.c                          | 19 +++---\n>   tools/include/linux/compiler_types.h          |  2 -\n\nThis patch should be split into one patch per subsystem or driver.\nE.g. one patch for the iwlwifi driver, another patch for the mm\nsubsystem, one patch for the rwlock primitive, one patch for the\nspinlock primitive, etc.\n\nThe tools/include/linux/compiler_types.h change probably should be\nleft out because it is user space code instead of kernel code and\nthe rest of the series applies to kernel code only.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618336826732.mbox",
          "message_id": "<9af0d949-45f5-45cd-b49d-d45d53f5d8f6 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-19 21:42:38+00:00",
          "date_str": "Fri, 19 Dec 2025 21:42:38 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n>   Documentation/dev-tools/context-analysis.rst  |  2 -\n>   Documentation/mm/process_addrs.rst            |  6 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n>   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n>   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n>   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n>   include/linux/compiler-context-analysis.h     | 31 ----------\n>   include/linux/lockref.h                       |  4 +-\n>   include/linux/mm.h                            | 33 ++--------\n>   include/linux/rwlock.h                        | 11 +---\n>   include/linux/rwlock_api_smp.h                | 14 ++++-\n>   include/linux/rwlock_rt.h                     | 21 ++++---\n>   include/linux/sched/signal.h                  | 14 +----\n>   include/linux/spinlock.h                      | 45 +++++---------\n>   include/linux/spinlock_api_smp.h              | 20 ++++++\n>   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n>   include/linux/spinlock_rt.h                   | 26 ++++----\n>   kernel/signal.c                               |  4 +-\n>   kernel/time/posix-timers.c                    | 13 +---\n>   lib/dec_and_lock.c                            |  8 +--\n>   lib/lockref.c                                 |  1 -\n>   mm/memory.c                                   |  4 +-\n>   mm/pgtable-generic.c                          | 19 +++---\n>   tools/include/linux/compiler_types.h          |  2 -\n\nThis patch should be split into one patch per subsystem or driver.\nE.g. one patch for the iwlwifi driver, another patch for the mm\nsubsystem, one patch for the rwlock primitive, one patch for the\nspinlock primitive, etc.\n\nThe tools/include/linux/compiler_types.h change probably should be\nleft out because it is user space code instead of kernel code and\nthe rest of the series applies to kernel code only.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623792725075.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623795925102.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623792725076.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623792525068.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623793525085.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623792825079.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623793525084.mbox",
          "message_id": "<CANpmjNOUr8rHmui_nPpGBzmXe4VRn=70dT7n6sWpJc6FD2qLbA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 24/36] compiler-context-analysis: Remove __cond_lock() function-like helper",
          "date": "2025-12-20 12:51:30+00:00",
          "date_str": "Sat, 20 Dec 2025 12:51:30 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:42, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> >   Documentation/dev-tools/context-analysis.rst  |  2 -\n> >   Documentation/mm/process_addrs.rst            |  6 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.c    |  4 +-\n> >   .../net/wireless/intel/iwlwifi/iwl-trans.h    |  6 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/internal.h      |  5 +-\n> >   .../intel/iwlwifi/pcie/gen1_2/trans.c         |  4 +-\n> >   include/linux/compiler-context-analysis.h     | 31 ----------\n> >   include/linux/lockref.h                       |  4 +-\n> >   include/linux/mm.h                            | 33 ++--------\n> >   include/linux/rwlock.h                        | 11 +---\n> >   include/linux/rwlock_api_smp.h                | 14 ++++-\n> >   include/linux/rwlock_rt.h                     | 21 ++++---\n> >   include/linux/sched/signal.h                  | 14 +----\n> >   include/linux/spinlock.h                      | 45 +++++---------\n> >   include/linux/spinlock_api_smp.h              | 20 ++++++\n> >   include/linux/spinlock_api_up.h               | 61 ++++++++++++++++---\n> >   include/linux/spinlock_rt.h                   | 26 ++++----\n> >   kernel/signal.c                               |  4 +-\n> >   kernel/time/posix-timers.c                    | 13 +---\n> >   lib/dec_and_lock.c                            |  8 +--\n> >   lib/lockref.c                                 |  1 -\n> >   mm/memory.c                                   |  4 +-\n> >   mm/pgtable-generic.c                          | 19 +++---\n> >   tools/include/linux/compiler_types.h          |  2 -\n>\n> This patch should be split into one patch per subsystem or driver.\n> E.g. one patch for the iwlwifi driver, another patch for the mm\n> subsystem, one patch for the rwlock primitive, one patch for the\n> spinlock primitive, etc.\n>\n> The tools/include/linux/compiler_types.h change probably should be\n> left out because it is user space code instead of kernel code and\n> the rest of the series applies to kernel code only.\n\nAFAIK, the user space version is just a copy of the kernel version to\nsupport headers that are used by both. See\n4bba4c4bb09ad4a2b70836725e08439c86d8f9e4. The sparse annotations were\ncopied in ab3c0ddb0d71dc214b61d11deb8770196ef46c05.\n\nAnd there's no point in keeping it around given it's all gone:\n\n% git grep __cond_lock\n<nothing>\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
      "normalized_subject": "compiler-context-analysis: Remove Sparse support",
      "message_count": 13,
      "participants": [
        "Marco Elver",
        "Bart Van Assche"
      ],
      "categories": [
        "context_analysis",
        "general",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-12-19T15:40:12+00:00",
      "last_date": "2025-12-19T21:38:12+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176616963215627.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616201707828.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616993015891.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616372409717.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616985315825.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616372209714.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616355509475.mbox",
          "message_id": "<20251219154418.3592607-24-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 15:40:12+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:12 +0000",
          "body": "Remove Sparse support as discussed at [1].\n\nThe kernel codebase is still scattered with numerous places that try to\nappease Sparse's context tracking (\"annotation for sparse\", \"fake out\nsparse\", \"work around sparse\", etc.). Eventually, as more subsystems\nenable Clang's context analysis, these places will show up and need\nadjustment or removal of the workarounds altogether.\n\nLink: https://lore.kernel.org/all/20250207083335.GW7145@noisy.programming.kicks-ass.net/ [1]\nLink: https://lore.kernel.org/all/Z6XTKTo_LMj9KmbY@elver.google.com/ [2]\nCc: Chris Li <sparse@chrisli.org>\nCc: \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/sparse.rst        | 19 -----\n include/linux/compiler-context-analysis.h | 85 +++++++----------------\n include/linux/rcupdate.h                  | 15 +---\n 3 files changed, 28 insertions(+), 91 deletions(-)\n\ndiff --git a/Documentation/dev-tools/sparse.rst b/Documentation/dev-tools/sparse.rst\nindex dc791c8d84d1..37b20170835d 100644\n--- a/Documentation/dev-tools/sparse.rst\n+++ b/Documentation/dev-tools/sparse.rst\n@@ -53,25 +53,6 @@ sure that bitwise types don't get mixed up (little-endian vs big-endian\n vs cpu-endian vs whatever), and there the constant \"0\" really _is_\n special.\n \n-Using sparse for lock checking\n-------------------------------\n-\n-The following macros are undefined for gcc and defined during a sparse\n-run to use the \"context\" tracking feature of sparse, applied to\n-locking.  These annotations tell sparse when a lock is held, with\n-regard to the annotated function's entry and exit.\n-\n-__must_hold - The specified lock is held on function entry and exit.\n-\n-__acquires - The specified lock is held on function exit, but not entry.\n-\n-__releases - The specified lock is held on function entry, but not exit.\n-\n-If the function enters and exits without the lock held, acquiring and\n-releasing the lock inside the function in a balanced way, no\n-annotation is needed.  The three annotations above are for cases where\n-sparse would otherwise report a context imbalance.\n-\n Getting sparse\n --------------\n \ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex 9ad800e27692..fccd6d68158e 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -262,57 +262,32 @@ static inline void _context_unsafe_alias(void **p) { }\n \textern const struct __ctx_lock_##ctx *name\n \n /*\n- * Common keywords for static context analysis. Both Clang's \"capability\n- * analysis\" and Sparse's \"context tracking\" are currently supported.\n- */\n-#ifdef __CHECKER__\n-\n-/* Sparse context/lock checking support. */\n-# define __must_hold(x)\t\t__attribute__((context(x,1,1)))\n-# define __must_not_hold(x)\n-# define __acquires(x)\t\t__attribute__((context(x,0,1)))\n-# define __cond_acquires(ret, x) __attribute__((context(x,0,-1)))\n-# define __releases(x)\t\t__attribute__((context(x,1,0)))\n-# define __acquire(x)\t\t__context__(x,1)\n-# define __release(x)\t\t__context__(x,-1)\n-# define __cond_lock(x, c)\t((c) ? ({ __acquire(x); 1; }) : 0)\n-/* For Sparse, there's no distinction between exclusive and shared locks. */\n-# define __must_hold_shared\t__must_hold\n-# define __acquires_shared\t__acquires\n-# define __cond_acquires_shared __cond_acquires\n-# define __releases_shared\t__releases\n-# define __acquire_shared\t__acquire\n-# define __release_shared\t__release\n-# define __cond_lock_shared\t__cond_acquire\n-\n-#else /* !__CHECKER__ */\n+ * Common keywords for static context analysis.\n+ */\n \n /**\n  * __must_hold() - function attribute, caller must hold exclusive context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must hold the given context\n- * lock instance @x exclusively.\n+ * lock instance(s) exclusively.\n  */\n-# define __must_hold(x)\t\t__requires_ctx_lock(x)\n+#define __must_hold(...)\t__requires_ctx_lock(__VA_ARGS__)\n \n /**\n  * __must_not_hold() - function attribute, caller must not hold context lock\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the caller must not hold the given context\n- * lock instance @x.\n+ * lock instance(s).\n  */\n-# define __must_not_hold(x)\t__excludes_ctx_lock(x)\n+#define __must_not_hold(...)\t__excludes_ctx_lock(__VA_ARGS__)\n \n /**\n  * __acquires() - function attribute, function acquires context lock exclusively\n- * @x: context lock instance pointer\n  *\n  * Function attribute declaring that the function acquires the given context\n- * lock instance @x exclusively, but does not release it.\n+ * lock instance(s) exclusively, but does not release them.\n  */\n-# define __acquires(x)\t\t__acquires_ctx_lock(x)\n+#define __acquires(...)\t\t__acquires_ctx_lock(__VA_ARGS__)\n \n /*\n  * Clang's analysis does not care precisely about the value, o",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618310026545.mbox",
          "message_id": "<34cda24f-acdc-4049-9869-b666b08897d9 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 21:38:12+00:00",
          "date_str": "Fri, 19 Dec 2025 21:38:12 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Remove Sparse support as discussed at [1].\n\nKernel patch descriptions should be self-contained. In other words, the\nconclusion from [1] should be summarized in the patch description\ninstead of only referring to that discussion with a hyperlink.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618312226557.mbox",
          "message_id": "<34cda24f-acdc-4049-9869-b666b08897d9 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 21:38:12+00:00",
          "date_str": "Fri, 19 Dec 2025 21:38:12 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Remove Sparse support as discussed at [1].\n\nKernel patch descriptions should be self-contained. In other words, the\nconclusion from [1] should be summarized in the patch description\ninstead of only referring to that discussion with a hyperlink.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618313926570.mbox",
          "message_id": "<34cda24f-acdc-4049-9869-b666b08897d9 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 21:38:12+00:00",
          "date_str": "Fri, 19 Dec 2025 21:38:12 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Remove Sparse support as discussed at [1].\n\nKernel patch descriptions should be self-contained. In other words, the\nconclusion from [1] should be summarized in the patch description\ninstead of only referring to that discussion with a hyperlink.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618313426567.mbox",
          "message_id": "<34cda24f-acdc-4049-9869-b666b08897d9 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 21:38:12+00:00",
          "date_str": "Fri, 19 Dec 2025 21:38:12 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Remove Sparse support as discussed at [1].\n\nKernel patch descriptions should be self-contained. In other words, the\nconclusion from [1] should be summarized in the patch description\ninstead of only referring to that discussion with a hyperlink.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618311826551.mbox",
          "message_id": "<34cda24f-acdc-4049-9869-b666b08897d9 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 21:38:12+00:00",
          "date_str": "Fri, 19 Dec 2025 21:38:12 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Remove Sparse support as discussed at [1].\n\nKernel patch descriptions should be self-contained. In other words, the\nconclusion from [1] should be summarized in the patch description\ninstead of only referring to that discussion with a hyperlink.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618312426562.mbox",
          "message_id": "<34cda24f-acdc-4049-9869-b666b08897d9 () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 23/36] compiler-context-analysis: Remove Sparse support",
          "date": "2025-12-19 21:38:12+00:00",
          "date_str": "Fri, 19 Dec 2025 21:38:12 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Remove Sparse support as discussed at [1].\n\nKernel patch descriptions should be self-contained. In other words, the\nconclusion from [1] should be summarized in the patch description\ninstead of only referring to that discussion with a hyperlink.\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
      "normalized_subject": "locking/ww_mutex: Support Clang's context analysis",
      "message_count": 30,
      "participants": [
        "Marco Elver",
        "Bart Van Assche",
        "Maarten Lankhorst"
      ],
      "categories": [
        "context_analysis",
        "rfc_proposals",
        "compiler_compat"
      ],
      "first_date": "2025-12-19T15:40:09+00:00",
      "last_date": "2026-01-12T10:32:25+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2026/01/176616985615828.mbox",
          "message_id": "<20251219154418.3592607-21-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2025-12-19 15:40:09+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:09 +0000",
          "body": "Add support for Clang's context analysis for ww_mutex.\n\nThe programming model for ww_mutex is subtly more complex than other\nlocking primitives when using ww_acquire_ctx. Encoding the respective\npre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\nusing Clang's context analysis makes incorrect use of the API harder.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* __assert -> __assume rename\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst |  3 +-\n include/linux/ww_mutex.h                     | 22 +++++--\n lib/test_context-analysis.c                  | 69 ++++++++++++++++++++\n 3 files changed, 87 insertions(+), 7 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex a48b75f45e79..8dd6c0d695aa 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,8 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`, `local_lock_t`.\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`, `local_lock_t`,\n+`ww_mutex`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/ww_mutex.h b/include/linux/ww_mutex.h\nindex 45ff6f7a872b..58e959ee10e9 100644\n--- a/include/linux/ww_mutex.h\n+++ b/include/linux/ww_mutex.h\n@@ -44,7 +44,7 @@ struct ww_class {\n \tunsigned int is_wait_die;\n };\n \n-struct ww_mutex {\n+context_lock_struct(ww_mutex) {\n \tstruct WW_MUTEX_BASE base;\n \tstruct ww_acquire_ctx *ctx;\n #ifdef DEBUG_WW_MUTEXES\n@@ -52,7 +52,7 @@ struct ww_mutex {\n #endif\n };\n \n-struct ww_acquire_ctx {\n+context_lock_struct(ww_acquire_ctx) {\n \tstruct task_struct *task;\n \tunsigned long stamp;\n \tunsigned int acquired;\n@@ -107,6 +107,7 @@ struct ww_acquire_ctx {\n  */\n static inline void ww_mutex_init(struct ww_mutex *lock,\n \t\t\t\t struct ww_class *ww_class)\n+\t__assumes_ctx_lock(lock)\n {\n \tww_mutex_base_init(&lock->base, ww_class->mutex_name, &ww_class->mutex_key);\n \tlock->ctx = NULL;\n@@ -141,6 +142,7 @@ static inline void ww_mutex_init(struct ww_mutex *lock,\n  */\n static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n \t\t\t\t   struct ww_class *ww_class)\n+\t__acquires(ctx) __no_context_analysis\n {\n \tctx->task = current;\n \tctx->stamp = atomic_long_inc_return_relaxed(&ww_class->stamp);\n@@ -179,6 +181,7 @@ static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n  * data structures.\n  */\n static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n+\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n {\n #ifdef DEBUG_WW_MUTEXES\n \tlockdep_assert_held(ctx);\n@@ -196,6 +199,7 @@ static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n  * mutexes have been released with ww_mutex_unlock.\n  */\n static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n+\t__releases_shared(ctx) __no_context_analysis\n {\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tmutex_release(&ctx->first_lock_dep_map, _THIS_IP_);\n@@ -245,7 +249,8 @@ static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n  *\n  * A mutex acquired with this function must be released with ww_mutex_unlock.\n  */\n-extern int /* __must_check */ ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx);\n+extern int /* __must_check */ ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n+\t__cond_acquires(0, lock) __must_hold(ctx);\n \n /**\n  * ww_mutex_lock_interruptible - acquire the w/w mutex, interruptible\n@@ -278,7 +283,8 @@ extern int /* __must_check */ ww_mutex_lock(struct ww_mutex *lock, struct ww_acq\n  * A mutex acquired with this function must be released with ww_mutex_unlock.\n  */\n extern int __must_check ww_mutex_lock_interruptible(struct ww_mutex *lock,\n-\t\t\t\t\t\t    struct ww_acquire_ctx *ctx);\n+\t\t\t\t\t\t    struct ww_acquire_ctx *ctx)\n+\t__cond_acquires(0, lock) __must_hold(ctx);\n \n /**\n  * ww_mutex_lock_slow - slowpath acquiring of the w/w mutex\n@@ -305,6 +311,7 @@ extern int __must_check ww_mutex_lock_interruptible(struct ww_mutex *lock,\n  */\n static inline void\n ww_mutex_lock_slow(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n+\t__acquires(lock) __must_hold(ctx) __no_context_analysis\n {\n \tint ret;\n #ifdef DEBUG_WW_MUTEXES\n@@ -342,6 +349,7 @@ ww_mutex_lock_slow(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n static inline int __must_check\n ww_mutex_lock_slow_interruptible(struct ww_mutex *lock,\n \t\t\t\t struct ww_acquire_ctx *ctx)\n+\t__cond_acquires(0, lock) __must_hold(ctx)\n {\n #ifdef DEBUG_WW_MUTEXES\n \tDEBUG_LOCKS_WARN_ON(!ctx->contending_lock);\n@@ -349,10 +357,11 @@ ww_mutex_lock_slow_interruptible(struct ww_mutex *lock,\n \treturn ww_mutex_lock_interruptible(lock, ctx);\n }\n \n-extern voi",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176617385419678.mbox",
          "message_id": "<20251219154418.3592607-21-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2025-12-19 15:40:09+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:09 +0000",
          "body": "Add support for Clang's context analysis for ww_mutex.\n\nThe programming model for ww_mutex is subtly more complex than other\nlocking primitives when using ww_acquire_ctx. Encoding the respective\npre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\nusing Clang's context analysis makes incorrect use of the API harder.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* __assert -> __assume rename\n\nv2:\n* New patch.\n---\n Documentation/dev-tools/context-analysis.rst |  3 +-\n include/linux/ww_mutex.h                     | 22 +++++--\n lib/test_context-analysis.c                  | 69 ++++++++++++++++++++\n 3 files changed, 87 insertions(+), 7 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex a48b75f45e79..8dd6c0d695aa 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,8 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`, `local_lock_t`.\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`, `local_lock_t`,\n+`ww_mutex`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/ww_mutex.h b/include/linux/ww_mutex.h\nindex 45ff6f7a872b..58e959ee10e9 100644\n--- a/include/linux/ww_mutex.h\n+++ b/include/linux/ww_mutex.h\n@@ -44,7 +44,7 @@ struct ww_class {\n \tunsigned int is_wait_die;\n };\n \n-struct ww_mutex {\n+context_lock_struct(ww_mutex) {\n \tstruct WW_MUTEX_BASE base;\n \tstruct ww_acquire_ctx *ctx;\n #ifdef DEBUG_WW_MUTEXES\n@@ -52,7 +52,7 @@ struct ww_mutex {\n #endif\n };\n \n-struct ww_acquire_ctx {\n+context_lock_struct(ww_acquire_ctx) {\n \tstruct task_struct *task;\n \tunsigned long stamp;\n \tunsigned int acquired;\n@@ -107,6 +107,7 @@ struct ww_acquire_ctx {\n  */\n static inline void ww_mutex_init(struct ww_mutex *lock,\n \t\t\t\t struct ww_class *ww_class)\n+\t__assumes_ctx_lock(lock)\n {\n \tww_mutex_base_init(&lock->base, ww_class->mutex_name, &ww_class->mutex_key);\n \tlock->ctx = NULL;\n@@ -141,6 +142,7 @@ static inline void ww_mutex_init(struct ww_mutex *lock,\n  */\n static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n \t\t\t\t   struct ww_class *ww_class)\n+\t__acquires(ctx) __no_context_analysis\n {\n \tctx->task = current;\n \tctx->stamp = atomic_long_inc_return_relaxed(&ww_class->stamp);\n@@ -179,6 +181,7 @@ static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n  * data structures.\n  */\n static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n+\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n {\n #ifdef DEBUG_WW_MUTEXES\n \tlockdep_assert_held(ctx);\n@@ -196,6 +199,7 @@ static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n  * mutexes have been released with ww_mutex_unlock.\n  */\n static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n+\t__releases_shared(ctx) __no_context_analysis\n {\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tmutex_release(&ctx->first_lock_dep_map, _THIS_IP_);\n@@ -245,7 +249,8 @@ static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n  *\n  * A mutex acquired with this function must be released with ww_mutex_unlock.\n  */\n-extern int /* __must_check */ ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx);\n+extern int /* __must_check */ ww_mutex_lock(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n+\t__cond_acquires(0, lock) __must_hold(ctx);\n \n /**\n  * ww_mutex_lock_interruptible - acquire the w/w mutex, interruptible\n@@ -278,7 +283,8 @@ extern int /* __must_check */ ww_mutex_lock(struct ww_mutex *lock, struct ww_acq\n  * A mutex acquired with this function must be released with ww_mutex_unlock.\n  */\n extern int __must_check ww_mutex_lock_interruptible(struct ww_mutex *lock,\n-\t\t\t\t\t\t    struct ww_acquire_ctx *ctx);\n+\t\t\t\t\t\t    struct ww_acquire_ctx *ctx)\n+\t__cond_acquires(0, lock) __must_hold(ctx);\n \n /**\n  * ww_mutex_lock_slow - slowpath acquiring of the w/w mutex\n@@ -305,6 +311,7 @@ extern int __must_check ww_mutex_lock_interruptible(struct ww_mutex *lock,\n  */\n static inline void\n ww_mutex_lock_slow(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n+\t__acquires(lock) __must_hold(ctx) __no_context_analysis\n {\n \tint ret;\n #ifdef DEBUG_WW_MUTEXES\n@@ -342,6 +349,7 @@ ww_mutex_lock_slow(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n static inline int __must_check\n ww_mutex_lock_slow_interruptible(struct ww_mutex *lock,\n \t\t\t\t struct ww_acquire_ctx *ctx)\n+\t__cond_acquires(0, lock) __must_hold(ctx)\n {\n #ifdef DEBUG_WW_MUTEXES\n \tDEBUG_LOCKS_WARN_ON(!ctx->contending_lock);\n@@ -349,10 +357,11 @@ ww_mutex_lock_slow_interruptible(struct ww_mutex *lock,\n \treturn ww_mutex_lock_interruptible(lock, ctx);\n }\n \n-extern voi",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799259217995.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799259618002.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799270318112.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799272318175.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799270418117.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799271118137.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799271518153.mbox",
          "message_id": "<05c77ca1-7618-43c5-b259-d89741808479 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 20:16:33+00:00",
          "date_str": "Fri, 09 Jan 2026 20:16:33 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> Add support for Clang's context analysis for ww_mutex.\n> \n> The programming model for ww_mutex is subtly more complex than other\n> locking primitives when using ww_acquire_ctx. Encoding the respective\n> pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> using Clang's context analysis makes incorrect use of the API harder.\n\nThat's a very short description. It should have been explained in the\npatch description how the ww_acquire_ctx changes affect callers of the\nww_acquire_{init,done,fini}() functions.\n\n>   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n>   \t\t\t\t   struct ww_class *ww_class)\n> +\t__acquires(ctx) __no_context_analysis\n> [ ... ]\n>   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n>   {\n> [ ... ]\n>   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> +\t__releases_shared(ctx) __no_context_analysis\n\nThe above changes make it mandatory to call ww_acquire_done() before\ncalling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\nthere is an example where there is no ww_acquire_done() call between\nww_acquire_init() and ww_acquire_fini() (see also line 202). The\nfunction dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\nww_acquire_done() at all. Does this mean that the above annotations are\nwrong? Is there a better solution than removing the __acquire() and\n__release() annotations from the above three functions?\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799564620493.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799564620492.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799565420504.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799565420505.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799565320501.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799559620459.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799569920532.mbox",
          "message_id": "<aWFt6hcLaCjQQu2c () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:06:50+00:00",
          "date_str": "Fri, 09 Jan 2026 21:06:50 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:16PM -0800, Bart Van Assche wrote:\n> On 12/19/25 8:40 AM, Marco Elver wrote:\n> > Add support for Clang's context analysis for ww_mutex.\n> > \n> > The programming model for ww_mutex is subtly more complex than other\n> > locking primitives when using ww_acquire_ctx. Encoding the respective\n> > pre-conditions for ww_mutex lock/unlock based on ww_acquire_ctx state\n> > using Clang's context analysis makes incorrect use of the API harder.\n> \n> That's a very short description. It should have been explained in the\n> patch description how the ww_acquire_ctx changes affect callers of the\n> ww_acquire_{init,done,fini}() functions.\n\nHow so? The API is the same (now statically enforced), and there's no\nfunctional change at runtime. Or did I miss something?\n\n> >   static inline void ww_acquire_init(struct ww_acquire_ctx *ctx,\n> >   \t\t\t\t   struct ww_class *ww_class)\n> > +\t__acquires(ctx) __no_context_analysis\n> > [ ... ]\n> >   static inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n> > +\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n> >   {\n> > [ ... ]\n> >   static inline void ww_acquire_fini(struct ww_acquire_ctx *ctx)\n> > +\t__releases_shared(ctx) __no_context_analysis\n> \n> The above changes make it mandatory to call ww_acquire_done() before\n> calling ww_acquire_fini(). In Documentation/locking/ww-mutex-design.rst\n> there is an example where there is no ww_acquire_done() call between\n> ww_acquire_init() and ww_acquire_fini() (see also line 202).\n\nIt might be worth updating the example with what the kernel-doc\ndocumentation recommends (below).\n\n> The\n> function dma_resv_lockdep() in drivers/dma-buf/dma-resv.c doesn't call\n> ww_acquire_done() at all. Does this mean that the above annotations are\n> wrong?\n\nIf there's 1 out of N ww_mutex users that missed ww_acquire_done()\nthere's a good chance that 1 case is wrong.\n\nBut generally, depends if we want to enforce ww_acquire_done() or not\nwhich itself is no-op in non-lockdep builds, however, with\nDEBUG_WW_MUTEXES it's no longer no-op so it might be a good idea to\nenforce it to get proper lockdep checking.\n\n> Is there a better solution than removing the __acquire() and\n> __release() annotations from the above three functions?\n\nThe kernel-doc comment for ww_acquire_done() says:\n\n\t/**\n\t * ww_acquire_done - marks the end of the acquire phase\n\t * @ctx: the acquire context\n\t *\n>>\t * Marks the end of the acquire phase, any further w/w mutex lock calls using\n>>\t * this context are forbidden.\n>>\t *\n>>\t * Calling this function is optional, it is just useful to document w/w mutex\n>>\t * code and clearly designated the acquire phase from actually using the locked\n>>\t * data structures.\n\t */\n\tstatic inline void ww_acquire_done(struct ww_acquire_ctx *ctx)\n\t\t__releases(ctx) __acquires_shared(ctx) __no_context_analysis\n\t{\n\t#ifdef DEBUG_WW_MUTEXES\n\t\tlockdep_assert_held(ctx);\n\n\t\tDEBUG_LOCKS_WARN_ON(ctx->done_acquire);\n\t\tctx->done_acquire = 1;\n\t#endif\n\t}\n\nIt states it's optional, but it's unclear if that's true with\nDEBUG_WW_MUTEXES builds. I'd vote for enforcing use of\nww_acquire_done(). If there's old code that's not using it, it should be\nadded there to get proper lockdep checking.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799678321294.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799678721306.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799678421299.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799678921310.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799678421300.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799678821307.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176799680021319.mbox",
          "message_id": "<8143ab09-fd9b-4615-8afb-7ee10e073c51 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-09 21:26:23+00:00",
          "date_str": "Fri, 09 Jan 2026 21:26:23 +0000",
          "body": "(+Maarten)\n\nOn 1/9/26 2:06 PM, Marco Elver wrote:\n> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n> there's a good chance that 1 case is wrong.\n\n$ git grep -w ww_acquire_done '**c'|wc -l\n11\n$ git grep -w ww_acquire_fini '**c'|wc -l\n33\n\nThe above statistics show that there are more cases where\nww_acquire_done() is not called rather than cases where\nww_acquire_done() is called.\n\nMaarten, since you introduced the ww_mutex code, do you perhaps prefer\nthat calling ww_acquire_done() is optional or rather that all users that\ndo not call ww_acquire_done() are modified such that they call\nww_acquire_done()? The full email conversation is available here:\nhttps://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821682514697.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821684014717.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821682014691.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821677414596.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821681614682.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821683114705.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176821681714685.mbox",
          "message_id": "<1502e5eb-0ac7-4581-85ce-2f0c390bd7db () linux ! intel ! com>",
          "author_name": "Maarten Lankhorst",
          "author_email": "maarten.lankhorst () linux ! intel ! com",
          "subject": "Re: [PATCH v5 20/36] locking/ww_mutex: Support Clang's context analysis",
          "date": "2026-01-12 10:32:25+00:00",
          "date_str": "Mon, 12 Jan 2026 10:32:25 +0000",
          "body": "Hey,\n\nThe acquire_done() call was always optional. It's meant to indicate that after this point,\nww_acquire_lock may no longer be called and backoff can no longer occur.\n\nIt's allowed to call ww_acquire_fini() without ww_acquire_done()\n\nThink of this case:\nww_acquire_init()\n\nww_acquire_lock_interruptible() -> -ERESTARTSYS\n\nww_acquire_fini()\n\nHere it wouldn't make sense to call ww_acquire_done().\n\nIt's mostly to facilitate this case:\n\nww_acquire_init()\n\nww_acquire_lock() a bunch.\n\n/* Got all locks, do the work as no more backoff occurs */\nww_acquire_done()\n\n...\n\nunlock_all()\nww_acquire_fini()\n\nIf you call ww_acquire_lock after done, a warning should occur as this should no longer happen.\n\nKind regards,\n~Maarten Lankhorst\n\nDen 2026-01-09 kl. 22:26, skrev Bart Van Assche:\n> (+Maarten)\n> \n> On 1/9/26 2:06 PM, Marco Elver wrote:\n>> If there's 1 out of N ww_mutex users that missed ww_acquire_done()\n>> there's a good chance that 1 case is wrong.\n> \n> $ git grep -w ww_acquire_done '**c'|wc -l\n> 11\n> $ git grep -w ww_acquire_fini '**c'|wc -l\n> 33\n> \n> The above statistics show that there are more cases where\n> ww_acquire_done() is not called rather than cases where\n> ww_acquire_done() is called.\n> \n> Maarten, since you introduced the ww_mutex code, do you perhaps prefer\n> that calling ww_acquire_done() is optional or rather that all users that\n> do not call ww_acquire_done() are modified such that they call\n> ww_acquire_done()? The full email conversation is available here:\n> https://lore.kernel.org/all/20251219154418.3592607-1-elver@google.com/\n> \n> Thanks,\n> \n> Bart.\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
      "normalized_subject": "locking/rwsem: Support Clang's context analysis",
      "message_count": 20,
      "participants": [
        "Marco Elver",
        "Bart Van Assche"
      ],
      "categories": [
        "context_analysis",
        "rfc_proposals",
        "compiler_compat"
      ],
      "first_date": "2025-12-19T15:40:06+00:00",
      "last_date": "2025-12-20T12:52:13+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176616313109090.mbox",
          "message_id": "<20251219154418.3592607-18-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 15:40:06+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:06 +0000",
          "body": "Add support for Clang's context analysis for rw_semaphore.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* __assert -> __assume rename\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/rwsem.h                        | 76 +++++++++++++-------\n lib/test_context-analysis.c                  | 64 +++++++++++++++++\n 3 files changed, 114 insertions(+), 28 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex f7736f1c0767..7b660c3003a0 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/rwsem.h b/include/linux/rwsem.h\nindex f1aaf676a874..8da14a08a4e1 100644\n--- a/include/linux/rwsem.h\n+++ b/include/linux/rwsem.h\n@@ -45,7 +45,7 @@\n  * reduce the chance that they will share the same cacheline causing\n  * cacheline bouncing problem.\n  */\n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tatomic_long_t count;\n \t/*\n \t * Write owner or one of the read owners as well flags regarding\n@@ -76,11 +76,13 @@ static inline int rwsem_is_locked(struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n }\n \n static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n }\n@@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n /*\n@@ -148,7 +151,7 @@ extern bool is_rwsem_reader_owned(struct rw_semaphore *sem);\n \n #include <linux/rwbase_rt.h>\n \n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tstruct rwbase_rt\trwbase;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n@@ -172,6 +175,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n@@ -180,11 +184,13 @@ static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n }\n \n static __always_inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rwsem_is_locked(sem));\n }\n \n static __always_inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rw_base_is_write_locked(&sem->rwbase));\n }\n@@ -202,6 +208,7 @@ static __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n  */\n \n static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held(sem);\n@@ -210,6 +217,7 @@ static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held_write(sem);\n@@ -220,48 +228,62 @@ static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n /*\n  * lock for reading\n  */\n-extern void down_read(struct rw_semaphore *sem);\n-extern int __must_check down_read_interruptible(struct rw_semaphore *sem);\n-extern int __must_check down_read_killable(struct rw_semaphore *sem);\n+extern void down_read(struct rw_semaphore *sem) __acquires_shared(sem);\n+extern int __must_check down_read_interruptible(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n+extern int __must_check down_read_killable(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n \n /*\n  * trylock for reading -- returns 1 if successful, 0 if contention\n  */\n-extern int down_read_trylock(struct rw_semaphore *sem);\n+extern int down_read_trylock(struct rw_semaphore *sem) __cond_acquires_shared(true, sem);\n \n /*\n  * lock for writing\n  */\n-extern void down_write(struct rw_semaphore *sem);\n-extern int __must_check down_write_killable(struct rw_semaphore *sem);\n+extern void down_write(struct rw_semaphore *sem) __acquires(sem);\n+extern int __must_check down_write_killable(struct rw_semaphore *sem) __cond_acquires(0, ",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616295808850.mbox",
          "message_id": "<20251219154418.3592607-18-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 15:40:06+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:06 +0000",
          "body": "Add support for Clang's context analysis for rw_semaphore.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* __assert -> __assume rename\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/rwsem.h                        | 76 +++++++++++++-------\n lib/test_context-analysis.c                  | 64 +++++++++++++++++\n 3 files changed, 114 insertions(+), 28 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex f7736f1c0767..7b660c3003a0 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/rwsem.h b/include/linux/rwsem.h\nindex f1aaf676a874..8da14a08a4e1 100644\n--- a/include/linux/rwsem.h\n+++ b/include/linux/rwsem.h\n@@ -45,7 +45,7 @@\n  * reduce the chance that they will share the same cacheline causing\n  * cacheline bouncing problem.\n  */\n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tatomic_long_t count;\n \t/*\n \t * Write owner or one of the read owners as well flags regarding\n@@ -76,11 +76,13 @@ static inline int rwsem_is_locked(struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n }\n \n static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n }\n@@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n /*\n@@ -148,7 +151,7 @@ extern bool is_rwsem_reader_owned(struct rw_semaphore *sem);\n \n #include <linux/rwbase_rt.h>\n \n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tstruct rwbase_rt\trwbase;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n@@ -172,6 +175,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n@@ -180,11 +184,13 @@ static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n }\n \n static __always_inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rwsem_is_locked(sem));\n }\n \n static __always_inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rw_base_is_write_locked(&sem->rwbase));\n }\n@@ -202,6 +208,7 @@ static __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n  */\n \n static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held(sem);\n@@ -210,6 +217,7 @@ static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held_write(sem);\n@@ -220,48 +228,62 @@ static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n /*\n  * lock for reading\n  */\n-extern void down_read(struct rw_semaphore *sem);\n-extern int __must_check down_read_interruptible(struct rw_semaphore *sem);\n-extern int __must_check down_read_killable(struct rw_semaphore *sem);\n+extern void down_read(struct rw_semaphore *sem) __acquires_shared(sem);\n+extern int __must_check down_read_interruptible(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n+extern int __must_check down_read_killable(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n \n /*\n  * trylock for reading -- returns 1 if successful, 0 if contention\n  */\n-extern int down_read_trylock(struct rw_semaphore *sem);\n+extern int down_read_trylock(struct rw_semaphore *sem) __cond_acquires_shared(true, sem);\n \n /*\n  * lock for writing\n  */\n-extern void down_write(struct rw_semaphore *sem);\n-extern int __must_check down_write_killable(struct rw_semaphore *sem);\n+extern void down_write(struct rw_semaphore *sem) __acquires(sem);\n+extern int __must_check down_write_killable(struct rw_semaphore *sem) __cond_acquires(0, ",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616609312168.mbox",
          "message_id": "<20251219154418.3592607-18-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 15:40:06+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:06 +0000",
          "body": "Add support for Clang's context analysis for rw_semaphore.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* __assert -> __assume rename\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/rwsem.h                        | 76 +++++++++++++-------\n lib/test_context-analysis.c                  | 64 +++++++++++++++++\n 3 files changed, 114 insertions(+), 28 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex f7736f1c0767..7b660c3003a0 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/rwsem.h b/include/linux/rwsem.h\nindex f1aaf676a874..8da14a08a4e1 100644\n--- a/include/linux/rwsem.h\n+++ b/include/linux/rwsem.h\n@@ -45,7 +45,7 @@\n  * reduce the chance that they will share the same cacheline causing\n  * cacheline bouncing problem.\n  */\n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tatomic_long_t count;\n \t/*\n \t * Write owner or one of the read owners as well flags regarding\n@@ -76,11 +76,13 @@ static inline int rwsem_is_locked(struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n }\n \n static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n }\n@@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n /*\n@@ -148,7 +151,7 @@ extern bool is_rwsem_reader_owned(struct rw_semaphore *sem);\n \n #include <linux/rwbase_rt.h>\n \n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tstruct rwbase_rt\trwbase;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n@@ -172,6 +175,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n@@ -180,11 +184,13 @@ static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n }\n \n static __always_inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rwsem_is_locked(sem));\n }\n \n static __always_inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rw_base_is_write_locked(&sem->rwbase));\n }\n@@ -202,6 +208,7 @@ static __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n  */\n \n static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held(sem);\n@@ -210,6 +217,7 @@ static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held_write(sem);\n@@ -220,48 +228,62 @@ static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n /*\n  * lock for reading\n  */\n-extern void down_read(struct rw_semaphore *sem);\n-extern int __must_check down_read_interruptible(struct rw_semaphore *sem);\n-extern int __must_check down_read_killable(struct rw_semaphore *sem);\n+extern void down_read(struct rw_semaphore *sem) __acquires_shared(sem);\n+extern int __must_check down_read_interruptible(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n+extern int __must_check down_read_killable(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n \n /*\n  * trylock for reading -- returns 1 if successful, 0 if contention\n  */\n-extern int down_read_trylock(struct rw_semaphore *sem);\n+extern int down_read_trylock(struct rw_semaphore *sem) __cond_acquires_shared(true, sem);\n \n /*\n  * lock for writing\n  */\n-extern void down_write(struct rw_semaphore *sem);\n-extern int __must_check down_write_killable(struct rw_semaphore *sem);\n+extern void down_write(struct rw_semaphore *sem) __acquires(sem);\n+extern int __must_check down_write_killable(struct rw_semaphore *sem) __cond_acquires(0, ",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616362209618.mbox",
          "message_id": "<20251219154418.3592607-18-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 15:40:06+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:06 +0000",
          "body": "Add support for Clang's context analysis for rw_semaphore.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* __assert -> __assume rename\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/rwsem.h                        | 76 +++++++++++++-------\n lib/test_context-analysis.c                  | 64 +++++++++++++++++\n 3 files changed, 114 insertions(+), 28 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex f7736f1c0767..7b660c3003a0 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/rwsem.h b/include/linux/rwsem.h\nindex f1aaf676a874..8da14a08a4e1 100644\n--- a/include/linux/rwsem.h\n+++ b/include/linux/rwsem.h\n@@ -45,7 +45,7 @@\n  * reduce the chance that they will share the same cacheline causing\n  * cacheline bouncing problem.\n  */\n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tatomic_long_t count;\n \t/*\n \t * Write owner or one of the read owners as well flags regarding\n@@ -76,11 +76,13 @@ static inline int rwsem_is_locked(struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n }\n \n static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n }\n@@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n /*\n@@ -148,7 +151,7 @@ extern bool is_rwsem_reader_owned(struct rw_semaphore *sem);\n \n #include <linux/rwbase_rt.h>\n \n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tstruct rwbase_rt\trwbase;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n@@ -172,6 +175,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n@@ -180,11 +184,13 @@ static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n }\n \n static __always_inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rwsem_is_locked(sem));\n }\n \n static __always_inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rw_base_is_write_locked(&sem->rwbase));\n }\n@@ -202,6 +208,7 @@ static __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n  */\n \n static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held(sem);\n@@ -210,6 +217,7 @@ static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held_write(sem);\n@@ -220,48 +228,62 @@ static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n /*\n  * lock for reading\n  */\n-extern void down_read(struct rw_semaphore *sem);\n-extern int __must_check down_read_interruptible(struct rw_semaphore *sem);\n-extern int __must_check down_read_killable(struct rw_semaphore *sem);\n+extern void down_read(struct rw_semaphore *sem) __acquires_shared(sem);\n+extern int __must_check down_read_interruptible(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n+extern int __must_check down_read_killable(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n \n /*\n  * trylock for reading -- returns 1 if successful, 0 if contention\n  */\n-extern int down_read_trylock(struct rw_semaphore *sem);\n+extern int down_read_trylock(struct rw_semaphore *sem) __cond_acquires_shared(true, sem);\n \n /*\n  * lock for writing\n  */\n-extern void down_write(struct rw_semaphore *sem);\n-extern int __must_check down_write_killable(struct rw_semaphore *sem);\n+extern void down_write(struct rw_semaphore *sem) __acquires(sem);\n+extern int __must_check down_write_killable(struct rw_semaphore *sem) __cond_acquires(0, ",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616355009467.mbox",
          "message_id": "<20251219154418.3592607-18-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 15:40:06+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:06 +0000",
          "body": "Add support for Clang's context analysis for rw_semaphore.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* __assert -> __assume rename\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/rwsem.h                        | 76 +++++++++++++-------\n lib/test_context-analysis.c                  | 64 +++++++++++++++++\n 3 files changed, 114 insertions(+), 28 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex f7736f1c0767..7b660c3003a0 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/rwsem.h b/include/linux/rwsem.h\nindex f1aaf676a874..8da14a08a4e1 100644\n--- a/include/linux/rwsem.h\n+++ b/include/linux/rwsem.h\n@@ -45,7 +45,7 @@\n  * reduce the chance that they will share the same cacheline causing\n  * cacheline bouncing problem.\n  */\n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tatomic_long_t count;\n \t/*\n \t * Write owner or one of the read owners as well flags regarding\n@@ -76,11 +76,13 @@ static inline int rwsem_is_locked(struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n }\n \n static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n }\n@@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n /*\n@@ -148,7 +151,7 @@ extern bool is_rwsem_reader_owned(struct rw_semaphore *sem);\n \n #include <linux/rwbase_rt.h>\n \n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tstruct rwbase_rt\trwbase;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n@@ -172,6 +175,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n@@ -180,11 +184,13 @@ static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n }\n \n static __always_inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rwsem_is_locked(sem));\n }\n \n static __always_inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rw_base_is_write_locked(&sem->rwbase));\n }\n@@ -202,6 +208,7 @@ static __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n  */\n \n static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held(sem);\n@@ -210,6 +217,7 @@ static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held_write(sem);\n@@ -220,48 +228,62 @@ static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n /*\n  * lock for reading\n  */\n-extern void down_read(struct rw_semaphore *sem);\n-extern int __must_check down_read_interruptible(struct rw_semaphore *sem);\n-extern int __must_check down_read_killable(struct rw_semaphore *sem);\n+extern void down_read(struct rw_semaphore *sem) __acquires_shared(sem);\n+extern int __must_check down_read_interruptible(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n+extern int __must_check down_read_killable(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n \n /*\n  * trylock for reading -- returns 1 if successful, 0 if contention\n  */\n-extern int down_read_trylock(struct rw_semaphore *sem);\n+extern int down_read_trylock(struct rw_semaphore *sem) __cond_acquires_shared(true, sem);\n \n /*\n  * lock for writing\n  */\n-extern void down_write(struct rw_semaphore *sem);\n-extern int __must_check down_write_killable(struct rw_semaphore *sem);\n+extern void down_write(struct rw_semaphore *sem) __acquires(sem);\n+extern int __must_check down_write_killable(struct rw_semaphore *sem) __cond_acquires(0, ",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616295908853.mbox",
          "message_id": "<20251219154418.3592607-18-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 15:40:06+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:06 +0000",
          "body": "Add support for Clang's context analysis for rw_semaphore.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* __assert -> __assume rename\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/rwsem.h                        | 76 +++++++++++++-------\n lib/test_context-analysis.c                  | 64 +++++++++++++++++\n 3 files changed, 114 insertions(+), 28 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex f7736f1c0767..7b660c3003a0 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`), `rw_semaphore`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/rwsem.h b/include/linux/rwsem.h\nindex f1aaf676a874..8da14a08a4e1 100644\n--- a/include/linux/rwsem.h\n+++ b/include/linux/rwsem.h\n@@ -45,7 +45,7 @@\n  * reduce the chance that they will share the same cacheline causing\n  * cacheline bouncing problem.\n  */\n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tatomic_long_t count;\n \t/*\n \t * Write owner or one of the read owners as well flags regarding\n@@ -76,11 +76,13 @@ static inline int rwsem_is_locked(struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n }\n \n static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n }\n@@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n /*\n@@ -148,7 +151,7 @@ extern bool is_rwsem_reader_owned(struct rw_semaphore *sem);\n \n #include <linux/rwbase_rt.h>\n \n-struct rw_semaphore {\n+context_lock_struct(rw_semaphore) {\n \tstruct rwbase_rt\trwbase;\n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \tstruct lockdep_map\tdep_map;\n@@ -172,6 +175,7 @@ do {\t\t\t\t\t\t\t\t\\\n \tstatic struct lock_class_key __key;\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n+\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n } while (0)\n \n static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n@@ -180,11 +184,13 @@ static __always_inline int rwsem_is_locked(const struct rw_semaphore *sem)\n }\n \n static __always_inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rwsem_is_locked(sem));\n }\n \n static __always_inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tWARN_ON(!rw_base_is_write_locked(&sem->rwbase));\n }\n@@ -202,6 +208,7 @@ static __always_inline int rwsem_is_contended(struct rw_semaphore *sem)\n  */\n \n static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held(sem);\n@@ -210,6 +217,7 @@ static inline void rwsem_assert_held(const struct rw_semaphore *sem)\n }\n \n static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n+\t__assumes_ctx_lock(sem)\n {\n \tif (IS_ENABLED(CONFIG_LOCKDEP))\n \t\tlockdep_assert_held_write(sem);\n@@ -220,48 +228,62 @@ static inline void rwsem_assert_held_write(const struct rw_semaphore *sem)\n /*\n  * lock for reading\n  */\n-extern void down_read(struct rw_semaphore *sem);\n-extern int __must_check down_read_interruptible(struct rw_semaphore *sem);\n-extern int __must_check down_read_killable(struct rw_semaphore *sem);\n+extern void down_read(struct rw_semaphore *sem) __acquires_shared(sem);\n+extern int __must_check down_read_interruptible(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n+extern int __must_check down_read_killable(struct rw_semaphore *sem) __cond_acquires_shared(0, sem);\n \n /*\n  * trylock for reading -- returns 1 if successful, 0 if contention\n  */\n-extern int down_read_trylock(struct rw_semaphore *sem);\n+extern int down_read_trylock(struct rw_semaphore *sem) __cond_acquires_shared(true, sem);\n \n /*\n  * lock for writing\n  */\n-extern void down_write(struct rw_semaphore *sem);\n-extern int __must_check down_write_killable(struct rw_semaphore *sem);\n+extern void down_write(struct rw_semaphore *sem) __acquires(sem);\n+extern int __must_check down_write_killable(struct rw_semaphore *sem) __cond_acquires(0, ",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618053124665.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618052224653.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618053524671.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618052524662.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618052324656.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618052524661.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618070824843.mbox",
          "message_id": "<81d2defc-8980-4022-a464-3d285aff199c () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-19 20:55:01+00:00",
          "date_str": "Fri, 19 Dec 2025 20:55:01 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n>   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n>   }\n>   \n>   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> +\t__assumes_ctx_lock(sem)\n>   {\n>   \tWARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n>   }\n> @@ -119,6 +121,7 @@ do {\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\\\n>   \t\t\t\t\t\t\t\t\\\n>   \t__init_rwsem((sem), #sem, &__key);\t\t\t\\\n> +\t__assume_ctx_lock(sem);\t\t\t\t\t\\\n>   } while (0)\n\nJust like as for lockdep.h, I think that the above annotations should be \nchanged into __must_hold().\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623801625156.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623801825159.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623797225115.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623797525118.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623796825108.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623797125112.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623801225147.mbox",
          "message_id": "<CANpmjNMAGYeFK-jYafSihmA+T7wi3zC8Sb4fJ+ZjzDK5jGuMvQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 17/36] locking/rwsem: Support Clang's context analysis",
          "date": "2025-12-20 12:52:13+00:00",
          "date_str": "Sat, 20 Dec 2025 12:52:13 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:55, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> >   static inline void rwsem_assert_held_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(atomic_long_read(&sem->count) == RWSEM_UNLOCKED_VALUE);\n> >   }\n> >\n> >   static inline void rwsem_assert_held_write_nolockdep(const struct rw_semaphore *sem)\n> > +     __assumes_ctx_lock(sem)\n> >   {\n> >       WARN_ON(!(atomic_long_read(&sem->count) & RWSEM_WRITER_LOCKED));\n> >   }\n> > @@ -119,6 +121,7 @@ do {                                                              \\\n> >       static struct lock_class_key __key;                     \\\n> >                                                               \\\n> >       __init_rwsem((sem), #sem, &__key);                      \\\n> > +     __assume_ctx_lock(sem);                                 \\\n> >   } while (0)\n>\n> Just like as for lockdep.h, I think that the above annotations should be\n> changed into __must_hold().\n\nMy point is the same: we use it to delegate to dynamic analysis where\nwe reach the limits of static analysis, to avoid false positives [1].\nCode should apply __must_hold() or __guarded_by() to called or\nprotected variables respectively, which is both cleaner and the\nidiomatic way to use all this.\n\n[1] https://lore.kernel.org/all/CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg@mail.gmail.com/\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
      "normalized_subject": "srcu: Support Clang's context analysis",
      "message_count": 31,
      "participants": [
        "Marco Elver",
        "Bart Van Assche",
        "Peter Zijlstra"
      ],
      "categories": [
        "context_analysis",
        "rfc_proposals",
        "compiler_compat"
      ],
      "first_date": "2025-12-19T15:40:04+00:00",
      "last_date": "2026-01-26T23:46:49+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2026/01/176617388819697.mbox",
          "message_id": "<20251219154418.3592607-16-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2025-12-19 15:40:04+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:04 +0000",
          "body": "Add support for Clang's context analysis for SRCU.\n\nSigned-off-by: Marco Elver <elver@google.com>\nAcked-by: Paul E. McKenney <paulmck@kernel.org>\n---\nv5:\n* Fix up annotation for recently added SRCU interfaces.\n* Rename \"context guard\" -> \"context lock\".\n* Use new cleanup.h helpers to properly support scoped lock guards.\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* Switch to DECLARE_LOCK_GUARD_1_ATTRS() (suggested by Peter)\n* Support SRCU being reentrant.\n---\n Documentation/dev-tools/context-analysis.rst |  2 +-\n include/linux/srcu.h                         | 73 ++++++++++++++------\n include/linux/srcutiny.h                     |  6 ++\n include/linux/srcutree.h                     | 10 ++-\n lib/test_context-analysis.c                  | 25 +++++++\n 5 files changed, 91 insertions(+), 25 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 3bc72f71fe25..f7736f1c0767 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -80,7 +80,7 @@ Supported Kernel Primitives\n \n Currently the following synchronization primitives are supported:\n `raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n-`bit_spinlock`, RCU.\n+`bit_spinlock`, RCU, SRCU (`srcu_struct`).\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/srcu.h b/include/linux/srcu.h\nindex 344ad51c8f6c..bb44a0bd7696 100644\n--- a/include/linux/srcu.h\n+++ b/include/linux/srcu.h\n@@ -21,7 +21,7 @@\n #include <linux/workqueue.h>\n #include <linux/rcu_segcblist.h>\n \n-struct srcu_struct;\n+context_lock_struct(srcu_struct, __reentrant_ctx_lock);\n \n #ifdef CONFIG_DEBUG_LOCK_ALLOC\n \n@@ -77,7 +77,7 @@ int init_srcu_struct_fast_updown(struct srcu_struct *ssp);\n #define SRCU_READ_FLAVOR_SLOWGP\t\t(SRCU_READ_FLAVOR_FAST | SRCU_READ_FLAVOR_FAST_UPDOWN)\n \t\t\t\t\t\t// Flavors requiring synchronize_rcu()\n \t\t\t\t\t\t// instead of smp_mb().\n-void __srcu_read_unlock(struct srcu_struct *ssp, int idx) __releases(ssp);\n+void __srcu_read_unlock(struct srcu_struct *ssp, int idx) __releases_shared(ssp);\n \n #ifdef CONFIG_TINY_SRCU\n #include <linux/srcutiny.h>\n@@ -131,14 +131,16 @@ static inline bool same_state_synchronize_srcu(unsigned long oldstate1, unsigned\n }\n \n #ifdef CONFIG_NEED_SRCU_NMI_SAFE\n-int __srcu_read_lock_nmisafe(struct srcu_struct *ssp) __acquires(ssp);\n-void __srcu_read_unlock_nmisafe(struct srcu_struct *ssp, int idx) __releases(ssp);\n+int __srcu_read_lock_nmisafe(struct srcu_struct *ssp) __acquires_shared(ssp);\n+void __srcu_read_unlock_nmisafe(struct srcu_struct *ssp, int idx) __releases_shared(ssp);\n #else\n static inline int __srcu_read_lock_nmisafe(struct srcu_struct *ssp)\n+\t__acquires_shared(ssp)\n {\n \treturn __srcu_read_lock(ssp);\n }\n static inline void __srcu_read_unlock_nmisafe(struct srcu_struct *ssp, int idx)\n+\t__releases_shared(ssp)\n {\n \t__srcu_read_unlock(ssp, idx);\n }\n@@ -210,6 +212,14 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n \n #endif /* #else #ifdef CONFIG_DEBUG_LOCK_ALLOC */\n \n+/*\n+ * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n+ * should still be marked with __rcu_guarded, and we do not want to mark them\n+ * with __guarded_by(ssp) as it would complicate annotations for writers, we\n+ * choose the following strategy: srcu_dereference_check() calls this helper\n+ * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n+ */\n+static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n \n /**\n  * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n@@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n  * to 1.  The @c argument will normally be a logical expression containing\n  * lockdep_is_held() calls.\n  */\n-#define srcu_dereference_check(p, ssp, c) \\\n-\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n-\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n+#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\t\t\\\n+\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n+\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n+\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n+\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n+\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n+\t__v;\t\t\t\t\t\t\t\t\t\\\n+})\n \n /**\n  * srcu_dereference - fetch SRCU-protected pointer for later dereferencing\n@@ -268,7 +284,8 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n  * invoke srcu_read_unlock() from one task and the matching srcu_read_lock()\n  * from another.\n  */\n-static inline int srcu_read_lock(struct srcu_struct *ssp) __acquires(ssp)\n+static inline int srcu_read_lock(struct srcu_struct *ssp)\n+\t__acquires_shared(ssp)\n {\n \tint retval;\n \n@@ -304,7 +321,8 @@ static inline int srcu_read_lock(struct srcu_struct *ssp) __acquires(ssp)\n  * contexts where RCU i",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945145304962.mbox",
          "message_id": "<dd65bb7b-0dac-437a-a370-38efeb4737ba () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 17:31:09+00:00",
          "date_str": "Mon, 26 Jan 2026 17:31:09 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> + * should still be marked with __rcu_guarded, and we do not want to mark them\n> + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> + * choose the following strategy: srcu_dereference_check() calls this helper\n> + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> + */\n> +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n>   \n>   /**\n>    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n>    * to 1.  The @c argument will normally be a logical expression containing\n>    * lockdep_is_held() calls.\n>    */\n> -#define srcu_dereference_check(p, ssp, c) \\\n> -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> +({\t\t\t\t\t\t\t\t\t\t\\\n> +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> +\t__v;\t\t\t\t\t\t\t\t\t\\\n> +})\n\nHi Marco,\n\nThe above change is something I'm not happy about. The original\nimplementation of the srcu_dereference_check() macro shows that it is\nsufficient to either hold an SRCU reader lock or the updater lock ('c').\nThe addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\nfail if the caller doesn't hold an SRCU reader lock. I'm concerned that\nthis will either lead to adding __no_context_analysis to SRCU updater\ncode that uses srcu_dereference_check() or to adding misleading\n__assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945146804985.mbox",
          "message_id": "<dd65bb7b-0dac-437a-a370-38efeb4737ba () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 17:31:09+00:00",
          "date_str": "Mon, 26 Jan 2026 17:31:09 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> + * should still be marked with __rcu_guarded, and we do not want to mark them\n> + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> + * choose the following strategy: srcu_dereference_check() calls this helper\n> + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> + */\n> +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n>   \n>   /**\n>    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n>    * to 1.  The @c argument will normally be a logical expression containing\n>    * lockdep_is_held() calls.\n>    */\n> -#define srcu_dereference_check(p, ssp, c) \\\n> -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> +({\t\t\t\t\t\t\t\t\t\t\\\n> +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> +\t__v;\t\t\t\t\t\t\t\t\t\\\n> +})\n\nHi Marco,\n\nThe above change is something I'm not happy about. The original\nimplementation of the srcu_dereference_check() macro shows that it is\nsufficient to either hold an SRCU reader lock or the updater lock ('c').\nThe addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\nfail if the caller doesn't hold an SRCU reader lock. I'm concerned that\nthis will either lead to adding __no_context_analysis to SRCU updater\ncode that uses srcu_dereference_check() or to adding misleading\n__assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945531708877.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945531208859.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945531308862.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945530808850.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945530208837.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945530508842.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945530508843.mbox",
          "message_id": "<aXez9fSxdfu5-Boo () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:35:33+00:00",
          "date_str": "Mon, 26 Jan 2026 18:35:33 +0000",
          "body": "On Mon, Jan 26, 2026 at 09:31AM -0800, Bart Van Assche wrote:\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * No-op helper to denote that ssp must be held. Because SRCU-protected pointers\n> > + * should still be marked with __rcu_guarded, and we do not want to mark them\n> > + * with __guarded_by(ssp) as it would complicate annotations for writers, we\n> > + * choose the following strategy: srcu_dereference_check() calls this helper\n> > + * that checks that the passed ssp is held, and then fake-acquires 'RCU'.\n> > + */\n> > +static inline void __srcu_read_lock_must_hold(const struct srcu_struct *ssp) __must_hold_shared(ssp) { }\n> >   /**\n> >    * srcu_dereference_check - fetch SRCU-protected pointer for later dereferencing\n> > @@ -223,9 +233,15 @@ static inline int srcu_read_lock_held(const struct srcu_struct *ssp)\n> >    * to 1.  The @c argument will normally be a logical expression containing\n> >    * lockdep_is_held() calls.\n> >    */\n> > -#define srcu_dereference_check(p, ssp, c) \\\n> > -\t__rcu_dereference_check((p), __UNIQUE_ID(rcu), \\\n> > -\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu)\n> > +#define srcu_dereference_check(p, ssp, c)\t\t\t\t\t\\\n> > +({\t\t\t\t\t\t\t\t\t\t\\\n> > +\t__srcu_read_lock_must_hold(ssp);\t\t\t\t\t\\\n> > +\t__acquire_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__auto_type __v = __rcu_dereference_check((p), __UNIQUE_ID(rcu),\t\\\n> > +\t\t\t\t(c) || srcu_read_lock_held(ssp), __rcu);\t\\\n> > +\t__release_shared_ctx_lock(RCU);\t\t\t\t\t\\\n> > +\t__v;\t\t\t\t\t\t\t\t\t\\\n> > +})\n> \n> Hi Marco,\n> \n> The above change is something I'm not happy about. The original\n> implementation of the srcu_dereference_check() macro shows that it is\n> sufficient to either hold an SRCU reader lock or the updater lock ('c').\n> The addition of \"__srcu_read_lock_must_hold()\" will cause compilation to\n> fail if the caller doesn't hold an SRCU reader lock. I'm concerned that\n> this will either lead to adding __no_context_analysis to SRCU updater\n> code that uses srcu_dereference_check() or to adding misleading\n> __assume_ctx_lock(ssp) annotations in SRCU updater code.\n\nRight, and it doesn't help 'c' is an arbitrary condition. But it's\nfundamentally difficult to say \"hold either this or that lock\".\n\nThat being said, I don't think it's wrong to write e.g.:\n\n\tspin_lock(&updater_lock);\n\t__acquire_shared(ssp);\n\t...\n\t// writes happen through rcu_assign_pointer()\n\t// reads can happen through srcu_dereference_check()\n\t...\n\t__release_shared(ssp);\n\tspin_unlock(&updater_lock);\n\n, given holding the updater lock implies reader access.\n\nAnd given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\nit's a manageable problem.\n\nIf you have a different idea how we can solve this, please let us know.\n\nOne final note, usage of srcu_dereference_check() is rare enough:\n\n\tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n\tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n\tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n\tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n\tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n\tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n\tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n\tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n\tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n\tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n\tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\n, that I think it's easy enough to annotate these places with the above\nsuggestions in case you're trying out global enablement.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945647709855.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945648109878.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945647609854.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945648009873.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945648809886.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945648209881.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176945649609896.mbox",
          "message_id": "<8c1bbab4-4615-4518-b773-a006d1402b8b () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 18:54:56+00:00",
          "date_str": "Mon, 26 Jan 2026 18:54:56 +0000",
          "body": "On 1/26/26 10:35 AM, Marco Elver wrote:\n> That being said, I don't think it's wrong to write e.g.:\n> \n> \tspin_lock(&updater_lock);\n> \t__acquire_shared(ssp);\n> \t...\n> \t// writes happen through rcu_assign_pointer()\n> \t// reads can happen through srcu_dereference_check()\n> \t...\n> \t__release_shared(ssp);\n> \tspin_unlock(&updater_lock);\n> \n> , given holding the updater lock implies reader access.\n> \n> And given the analysis is opt-in (CONTEXT_ANALYSIS := y), I think\n> it's a manageable problem.\n\nI'd like to make context-analysis mandatory for the entire kernel tree.\n\n> If you have a different idea how we can solve this, please let us know.\n> \n> One final note, usage of srcu_dereference_check() is rare enough:\n> \n> \tarch/x86/kvm/hyperv.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \tarch/x86/kvm/x86.c:\tkvm_free_msr_filter(srcu_dereference_check(kvm->arch.msr_filter, &kvm->srcu, 1));\n> \tarch/x86/kvm/x86.c:\tkfree(srcu_dereference_check(kvm->arch.pmu_event_filter, &kvm->srcu, 1));\n> \tdrivers/gpio/gpiolib.c:\tlabel = srcu_dereference_check(desc->label, &desc->gdev->desc_srcu,\n> \tdrivers/hv/mshv_irq.c:\tgirq_tbl = srcu_dereference_check(partition->pt_girq_tbl,\n> \tdrivers/hwtracing/stm/core.c:\tlink = srcu_dereference_check(src->link, &stm_source_srcu, 1);\n> \tdrivers/infiniband/hw/hfi1/user_sdma.c:\tpq = srcu_dereference_check(fd->pq, &fd->pq_srcu,\n> \tfs/quota/dquot.c:\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\t\t\tstruct dquot *dquot = srcu_dereference_check(\n> \tfs/quota/dquot.c:\t\tput[cnt] = srcu_dereference_check(dquots[cnt], &dquot_srcu,\n> \tfs/quota/dquot.c:\t\ttransfer_from[cnt] = srcu_dereference_check(dquots[cnt],\n> \tinclude/linux/kvm_host.h:\treturn srcu_dereference_check(kvm->memslots[as_id], &kvm->srcu,\n> \tvirt/kvm/irqchip.c:\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n> \n> , that I think it's easy enough to annotate these places with the above\n> suggestions in case you're trying out global enablement.\n\nHas it ever been considered to add support in the clang compiler for a\nvariant of __must_hold() that expresses that one of two capabilities\nmust be held by the caller? I think that would remove the need to\nannotate SRCU update-side code with __acquire_shared(ssp) and\n__release_shared(ssp).\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946615618199.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946614918188.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946614918187.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946613618171.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946614318179.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946616618208.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176946614418180.mbox",
          "message_id": "<20260126213556.GQ171111 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 21:35:56+00:00",
          "date_str": "Mon, 26 Jan 2026 21:35:56 +0000",
          "body": "On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n\n> Has it ever been considered to add support in the clang compiler for a\n> variant of __must_hold() that expresses that one of two capabilities\n> must be held by the caller? I think that would remove the need to\n> annotate SRCU update-side code with __acquire_shared(ssp) and\n> __release_shared(ssp).\n\nRight, I think I've asked for logical operators like that. Although I\nthink it was in the __guarded_by() clause rather than the __must_hold().\nBoth || and && would be nice to have ;-)\n\nSpecifically, I think I asked for something like:\n\n        cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n                                     __guarded_shared_by(pi_lock || rq->__lock);\n\n\nI think Marco's suggestion was to use 'fake' locks to mimic those\nsemantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947400423948.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947401623968.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947400423954.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947400423955.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947400723962.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947400723959.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176947400523956.mbox",
          "message_id": "<CANpmjNPs9CtY1w1-MqL1-CnHVFLxXoA2rbd6d2w4wfxT8AP0ew () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 15/36] srcu: Support Clang's context analysis",
          "date": "2026-01-26 23:46:49+00:00",
          "date_str": "Mon, 26 Jan 2026 23:46:49 +0000",
          "body": "On Mon, 26 Jan 2026 at 22:36, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> On Mon, Jan 26, 2026 at 10:54:56AM -0800, Bart Van Assche wrote:\n>\n> > Has it ever been considered to add support in the clang compiler for a\n> > variant of __must_hold() that expresses that one of two capabilities\n> > must be held by the caller? I think that would remove the need to\n> > annotate SRCU update-side code with __acquire_shared(ssp) and\n> > __release_shared(ssp).\n>\n> Right, I think I've asked for logical operators like that. Although I\n> think it was in the __guarded_by() clause rather than the __must_hold().\n> Both || and && would be nice to have ;-)\n\nSome attributes take multiple arguments (__must_hold does), though\n__guarded_by doesn't. Yet, && can still be had with adding it multiple\ntimes e.g. '__guarded_by(pi_lock) __guarded_by(rq->__lock)'.\n\nOnly thing that doesn't exist is ||. I think the syntax you ask for\nwon't fly, but I can add it to the backlog to investigate an _any\nvariant of these attributes. Don't hold your breath though, given the\ntime it takes to land all that in a released Clang version.\n\n> Specifically, I think I asked for something like:\n>\n>         cpumask_t       cpus_allowed __guarded_by(pi_lock && rq->__lock)\n>                                      __guarded_shared_by(pi_lock || rq->__lock);\n>\n>\n> I think Marco's suggestion was to use 'fake' locks to mimic those\n> semantics.\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
      "normalized_subject": "bit_spinlock: Support Clang's context analysis",
      "message_count": 20,
      "participants": [
        "Marco Elver",
        "Bart Van Assche"
      ],
      "categories": [
        "context_analysis",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-12-19T15:40:02+00:00",
      "last_date": "2025-12-19T21:09:23+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176616602512126.mbox",
          "message_id": "<20251219154418.3592607-14-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 15:40:02+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:02 +0000",
          "body": "The annotations for bit_spinlock.h have simply been using \"bitlock\" as\nthe token. For Sparse, that was likely sufficient in most cases. But\nClang's context analysis is more precise, and we need to ensure we\ncan distinguish different bitlocks.\n\nTo do so, add a token context, and a macro __bitlock(bitnum, addr)\nthat is used to construct unique per-bitlock tokens.\n\nAdd the appropriate test.\n\n<linux/list_bl.h> is implicitly included through other includes, and\nrequires 2 annotations to indicate that acquisition (without release)\nand release (without prior acquisition) of its bitlock is intended.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n---\n Documentation/dev-tools/context-analysis.rst |  3 ++-\n include/linux/bit_spinlock.h                 | 22 ++++++++++++++---\n include/linux/list_bl.h                      |  2 ++\n lib/test_context-analysis.c                  | 26 ++++++++++++++++++++\n 4 files changed, 48 insertions(+), 5 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 690565910084..b2d69fb4a884 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -79,7 +79,8 @@ Supported Kernel Primitives\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Currently the following synchronization primitives are supported:\n-`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`.\n+`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n+`bit_spinlock`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/bit_spinlock.h b/include/linux/bit_spinlock.h\nindex 59e345f74b0e..7869a6e59b6a 100644\n--- a/include/linux/bit_spinlock.h\n+++ b/include/linux/bit_spinlock.h\n@@ -9,6 +9,16 @@\n \n #include <asm/processor.h>  /* for cpu_relax() */\n \n+/*\n+ * For static context analysis, we need a unique token for each possible bit\n+ * that can be used as a bit_spinlock. The easiest way to do that is to create a\n+ * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n+ * below, which will give us unique instances for each (bit, addr) pair that the\n+ * static analysis can use.\n+ */\n+context_lock_struct(__context_bitlock) { };\n+#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n+\n /*\n  *  bit-based spin_lock()\n  *\n@@ -16,6 +26,7 @@\n  * are significantly faster.\n  */\n static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n+\t__acquires(__bitlock(bitnum, addr))\n {\n \t/*\n \t * Assuming the lock is uncontended, this never enters\n@@ -34,13 +45,14 @@ static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n \t\tpreempt_disable();\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n }\n \n /*\n  * Return true if it was acquired\n  */\n static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n+\t__cond_acquires(true, __bitlock(bitnum, addr))\n {\n \tpreempt_disable();\n #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n@@ -49,7 +61,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n \t\treturn 0;\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n \treturn 1;\n }\n \n@@ -57,6 +69,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n  *  bit-based spin_unlock()\n  */\n static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -65,7 +78,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n \tclear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\n@@ -74,6 +87,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n  *  protecting the rest of the flags in the word.\n  */\n static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -82,7 +96,7 @@ static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n \t__clear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\ndiff --git a/include/linux/list_bl.h b/include/linux/list_bl.h\nindex ae1b541446c9..df9eebe6afca 100644\n--- a/include/linux/list_bl.h\n+++ b/include/linux/list_bl.h\n@@ -144,11 +144,13 @@ static inline void hlist_bl_del_init(struct hlist_bl_node *n)\n }\n \n static inline void hlist_bl_lock(struct hlist_bl_head *b)\n+\t__acquires(__bitlock(0, b))\n {\n \tbit_spin_lock(0, (unsigned long *)b);\n }\n \n static inline void hlist_bl_unlock(struct hlist_bl_head *b)\n+\t__releases(__bitlock(0, b))\n {\n \t__bit_spin_un",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616289608799.mbox",
          "message_id": "<20251219154418.3592607-14-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 15:40:02+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:02 +0000",
          "body": "The annotations for bit_spinlock.h have simply been using \"bitlock\" as\nthe token. For Sparse, that was likely sufficient in most cases. But\nClang's context analysis is more precise, and we need to ensure we\ncan distinguish different bitlocks.\n\nTo do so, add a token context, and a macro __bitlock(bitnum, addr)\nthat is used to construct unique per-bitlock tokens.\n\nAdd the appropriate test.\n\n<linux/list_bl.h> is implicitly included through other includes, and\nrequires 2 annotations to indicate that acquisition (without release)\nand release (without prior acquisition) of its bitlock is intended.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n---\n Documentation/dev-tools/context-analysis.rst |  3 ++-\n include/linux/bit_spinlock.h                 | 22 ++++++++++++++---\n include/linux/list_bl.h                      |  2 ++\n lib/test_context-analysis.c                  | 26 ++++++++++++++++++++\n 4 files changed, 48 insertions(+), 5 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 690565910084..b2d69fb4a884 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -79,7 +79,8 @@ Supported Kernel Primitives\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Currently the following synchronization primitives are supported:\n-`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`.\n+`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n+`bit_spinlock`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/bit_spinlock.h b/include/linux/bit_spinlock.h\nindex 59e345f74b0e..7869a6e59b6a 100644\n--- a/include/linux/bit_spinlock.h\n+++ b/include/linux/bit_spinlock.h\n@@ -9,6 +9,16 @@\n \n #include <asm/processor.h>  /* for cpu_relax() */\n \n+/*\n+ * For static context analysis, we need a unique token for each possible bit\n+ * that can be used as a bit_spinlock. The easiest way to do that is to create a\n+ * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n+ * below, which will give us unique instances for each (bit, addr) pair that the\n+ * static analysis can use.\n+ */\n+context_lock_struct(__context_bitlock) { };\n+#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n+\n /*\n  *  bit-based spin_lock()\n  *\n@@ -16,6 +26,7 @@\n  * are significantly faster.\n  */\n static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n+\t__acquires(__bitlock(bitnum, addr))\n {\n \t/*\n \t * Assuming the lock is uncontended, this never enters\n@@ -34,13 +45,14 @@ static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n \t\tpreempt_disable();\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n }\n \n /*\n  * Return true if it was acquired\n  */\n static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n+\t__cond_acquires(true, __bitlock(bitnum, addr))\n {\n \tpreempt_disable();\n #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n@@ -49,7 +61,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n \t\treturn 0;\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n \treturn 1;\n }\n \n@@ -57,6 +69,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n  *  bit-based spin_unlock()\n  */\n static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -65,7 +78,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n \tclear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\n@@ -74,6 +87,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n  *  protecting the rest of the flags in the word.\n  */\n static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -82,7 +96,7 @@ static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n \t__clear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\ndiff --git a/include/linux/list_bl.h b/include/linux/list_bl.h\nindex ae1b541446c9..df9eebe6afca 100644\n--- a/include/linux/list_bl.h\n+++ b/include/linux/list_bl.h\n@@ -144,11 +144,13 @@ static inline void hlist_bl_del_init(struct hlist_bl_node *n)\n }\n \n static inline void hlist_bl_lock(struct hlist_bl_head *b)\n+\t__acquires(__bitlock(0, b))\n {\n \tbit_spin_lock(0, (unsigned long *)b);\n }\n \n static inline void hlist_bl_unlock(struct hlist_bl_head *b)\n+\t__releases(__bitlock(0, b))\n {\n \t__bit_spin_un",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616303408952.mbox",
          "message_id": "<20251219154418.3592607-14-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 15:40:02+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:02 +0000",
          "body": "The annotations for bit_spinlock.h have simply been using \"bitlock\" as\nthe token. For Sparse, that was likely sufficient in most cases. But\nClang's context analysis is more precise, and we need to ensure we\ncan distinguish different bitlocks.\n\nTo do so, add a token context, and a macro __bitlock(bitnum, addr)\nthat is used to construct unique per-bitlock tokens.\n\nAdd the appropriate test.\n\n<linux/list_bl.h> is implicitly included through other includes, and\nrequires 2 annotations to indicate that acquisition (without release)\nand release (without prior acquisition) of its bitlock is intended.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n---\n Documentation/dev-tools/context-analysis.rst |  3 ++-\n include/linux/bit_spinlock.h                 | 22 ++++++++++++++---\n include/linux/list_bl.h                      |  2 ++\n lib/test_context-analysis.c                  | 26 ++++++++++++++++++++\n 4 files changed, 48 insertions(+), 5 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 690565910084..b2d69fb4a884 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -79,7 +79,8 @@ Supported Kernel Primitives\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Currently the following synchronization primitives are supported:\n-`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`.\n+`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n+`bit_spinlock`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/bit_spinlock.h b/include/linux/bit_spinlock.h\nindex 59e345f74b0e..7869a6e59b6a 100644\n--- a/include/linux/bit_spinlock.h\n+++ b/include/linux/bit_spinlock.h\n@@ -9,6 +9,16 @@\n \n #include <asm/processor.h>  /* for cpu_relax() */\n \n+/*\n+ * For static context analysis, we need a unique token for each possible bit\n+ * that can be used as a bit_spinlock. The easiest way to do that is to create a\n+ * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n+ * below, which will give us unique instances for each (bit, addr) pair that the\n+ * static analysis can use.\n+ */\n+context_lock_struct(__context_bitlock) { };\n+#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n+\n /*\n  *  bit-based spin_lock()\n  *\n@@ -16,6 +26,7 @@\n  * are significantly faster.\n  */\n static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n+\t__acquires(__bitlock(bitnum, addr))\n {\n \t/*\n \t * Assuming the lock is uncontended, this never enters\n@@ -34,13 +45,14 @@ static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n \t\tpreempt_disable();\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n }\n \n /*\n  * Return true if it was acquired\n  */\n static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n+\t__cond_acquires(true, __bitlock(bitnum, addr))\n {\n \tpreempt_disable();\n #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n@@ -49,7 +61,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n \t\treturn 0;\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n \treturn 1;\n }\n \n@@ -57,6 +69,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n  *  bit-based spin_unlock()\n  */\n static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -65,7 +78,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n \tclear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\n@@ -74,6 +87,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n  *  protecting the rest of the flags in the word.\n  */\n static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -82,7 +96,7 @@ static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n \t__clear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\ndiff --git a/include/linux/list_bl.h b/include/linux/list_bl.h\nindex ae1b541446c9..df9eebe6afca 100644\n--- a/include/linux/list_bl.h\n+++ b/include/linux/list_bl.h\n@@ -144,11 +144,13 @@ static inline void hlist_bl_del_init(struct hlist_bl_node *n)\n }\n \n static inline void hlist_bl_lock(struct hlist_bl_head *b)\n+\t__acquires(__bitlock(0, b))\n {\n \tbit_spin_lock(0, (unsigned long *)b);\n }\n \n static inline void hlist_bl_unlock(struct hlist_bl_head *b)\n+\t__releases(__bitlock(0, b))\n {\n \t__bit_spin_un",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616278508630.mbox",
          "message_id": "<20251219154418.3592607-14-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 15:40:02+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:02 +0000",
          "body": "The annotations for bit_spinlock.h have simply been using \"bitlock\" as\nthe token. For Sparse, that was likely sufficient in most cases. But\nClang's context analysis is more precise, and we need to ensure we\ncan distinguish different bitlocks.\n\nTo do so, add a token context, and a macro __bitlock(bitnum, addr)\nthat is used to construct unique per-bitlock tokens.\n\nAdd the appropriate test.\n\n<linux/list_bl.h> is implicitly included through other includes, and\nrequires 2 annotations to indicate that acquisition (without release)\nand release (without prior acquisition) of its bitlock is intended.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n---\n Documentation/dev-tools/context-analysis.rst |  3 ++-\n include/linux/bit_spinlock.h                 | 22 ++++++++++++++---\n include/linux/list_bl.h                      |  2 ++\n lib/test_context-analysis.c                  | 26 ++++++++++++++++++++\n 4 files changed, 48 insertions(+), 5 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 690565910084..b2d69fb4a884 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -79,7 +79,8 @@ Supported Kernel Primitives\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Currently the following synchronization primitives are supported:\n-`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`.\n+`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n+`bit_spinlock`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/bit_spinlock.h b/include/linux/bit_spinlock.h\nindex 59e345f74b0e..7869a6e59b6a 100644\n--- a/include/linux/bit_spinlock.h\n+++ b/include/linux/bit_spinlock.h\n@@ -9,6 +9,16 @@\n \n #include <asm/processor.h>  /* for cpu_relax() */\n \n+/*\n+ * For static context analysis, we need a unique token for each possible bit\n+ * that can be used as a bit_spinlock. The easiest way to do that is to create a\n+ * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n+ * below, which will give us unique instances for each (bit, addr) pair that the\n+ * static analysis can use.\n+ */\n+context_lock_struct(__context_bitlock) { };\n+#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n+\n /*\n  *  bit-based spin_lock()\n  *\n@@ -16,6 +26,7 @@\n  * are significantly faster.\n  */\n static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n+\t__acquires(__bitlock(bitnum, addr))\n {\n \t/*\n \t * Assuming the lock is uncontended, this never enters\n@@ -34,13 +45,14 @@ static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n \t\tpreempt_disable();\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n }\n \n /*\n  * Return true if it was acquired\n  */\n static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n+\t__cond_acquires(true, __bitlock(bitnum, addr))\n {\n \tpreempt_disable();\n #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n@@ -49,7 +61,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n \t\treturn 0;\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n \treturn 1;\n }\n \n@@ -57,6 +69,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n  *  bit-based spin_unlock()\n  */\n static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -65,7 +78,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n \tclear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\n@@ -74,6 +87,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n  *  protecting the rest of the flags in the word.\n  */\n static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -82,7 +96,7 @@ static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n \t__clear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\ndiff --git a/include/linux/list_bl.h b/include/linux/list_bl.h\nindex ae1b541446c9..df9eebe6afca 100644\n--- a/include/linux/list_bl.h\n+++ b/include/linux/list_bl.h\n@@ -144,11 +144,13 @@ static inline void hlist_bl_del_init(struct hlist_bl_node *n)\n }\n \n static inline void hlist_bl_lock(struct hlist_bl_head *b)\n+\t__acquires(__bitlock(0, b))\n {\n \tbit_spin_lock(0, (unsigned long *)b);\n }\n \n static inline void hlist_bl_unlock(struct hlist_bl_head *b)\n+\t__releases(__bitlock(0, b))\n {\n \t__bit_spin_un",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616427110382.mbox",
          "message_id": "<20251219154418.3592607-14-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 15:40:02+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:02 +0000",
          "body": "The annotations for bit_spinlock.h have simply been using \"bitlock\" as\nthe token. For Sparse, that was likely sufficient in most cases. But\nClang's context analysis is more precise, and we need to ensure we\ncan distinguish different bitlocks.\n\nTo do so, add a token context, and a macro __bitlock(bitnum, addr)\nthat is used to construct unique per-bitlock tokens.\n\nAdd the appropriate test.\n\n<linux/list_bl.h> is implicitly included through other includes, and\nrequires 2 annotations to indicate that acquisition (without release)\nand release (without prior acquisition) of its bitlock is intended.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n---\n Documentation/dev-tools/context-analysis.rst |  3 ++-\n include/linux/bit_spinlock.h                 | 22 ++++++++++++++---\n include/linux/list_bl.h                      |  2 ++\n lib/test_context-analysis.c                  | 26 ++++++++++++++++++++\n 4 files changed, 48 insertions(+), 5 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 690565910084..b2d69fb4a884 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -79,7 +79,8 @@ Supported Kernel Primitives\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Currently the following synchronization primitives are supported:\n-`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`.\n+`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n+`bit_spinlock`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/bit_spinlock.h b/include/linux/bit_spinlock.h\nindex 59e345f74b0e..7869a6e59b6a 100644\n--- a/include/linux/bit_spinlock.h\n+++ b/include/linux/bit_spinlock.h\n@@ -9,6 +9,16 @@\n \n #include <asm/processor.h>  /* for cpu_relax() */\n \n+/*\n+ * For static context analysis, we need a unique token for each possible bit\n+ * that can be used as a bit_spinlock. The easiest way to do that is to create a\n+ * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n+ * below, which will give us unique instances for each (bit, addr) pair that the\n+ * static analysis can use.\n+ */\n+context_lock_struct(__context_bitlock) { };\n+#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n+\n /*\n  *  bit-based spin_lock()\n  *\n@@ -16,6 +26,7 @@\n  * are significantly faster.\n  */\n static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n+\t__acquires(__bitlock(bitnum, addr))\n {\n \t/*\n \t * Assuming the lock is uncontended, this never enters\n@@ -34,13 +45,14 @@ static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n \t\tpreempt_disable();\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n }\n \n /*\n  * Return true if it was acquired\n  */\n static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n+\t__cond_acquires(true, __bitlock(bitnum, addr))\n {\n \tpreempt_disable();\n #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n@@ -49,7 +61,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n \t\treturn 0;\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n \treturn 1;\n }\n \n@@ -57,6 +69,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n  *  bit-based spin_unlock()\n  */\n static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -65,7 +78,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n \tclear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\n@@ -74,6 +87,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n  *  protecting the rest of the flags in the word.\n  */\n static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -82,7 +96,7 @@ static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n \t__clear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\ndiff --git a/include/linux/list_bl.h b/include/linux/list_bl.h\nindex ae1b541446c9..df9eebe6afca 100644\n--- a/include/linux/list_bl.h\n+++ b/include/linux/list_bl.h\n@@ -144,11 +144,13 @@ static inline void hlist_bl_del_init(struct hlist_bl_node *n)\n }\n \n static inline void hlist_bl_lock(struct hlist_bl_head *b)\n+\t__acquires(__bitlock(0, b))\n {\n \tbit_spin_lock(0, (unsigned long *)b);\n }\n \n static inline void hlist_bl_unlock(struct hlist_bl_head *b)\n+\t__releases(__bitlock(0, b))\n {\n \t__bit_spin_un",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616300108918.mbox",
          "message_id": "<20251219154418.3592607-14-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 15:40:02+00:00",
          "date_str": "Fri, 19 Dec 2025 15:40:02 +0000",
          "body": "The annotations for bit_spinlock.h have simply been using \"bitlock\" as\nthe token. For Sparse, that was likely sufficient in most cases. But\nClang's context analysis is more precise, and we need to ensure we\ncan distinguish different bitlocks.\n\nTo do so, add a token context, and a macro __bitlock(bitnum, addr)\nthat is used to construct unique per-bitlock tokens.\n\nAdd the appropriate test.\n\n<linux/list_bl.h> is implicitly included through other includes, and\nrequires 2 annotations to indicate that acquisition (without release)\nand release (without prior acquisition) of its bitlock is intended.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n---\n Documentation/dev-tools/context-analysis.rst |  3 ++-\n include/linux/bit_spinlock.h                 | 22 ++++++++++++++---\n include/linux/list_bl.h                      |  2 ++\n lib/test_context-analysis.c                  | 26 ++++++++++++++++++++\n 4 files changed, 48 insertions(+), 5 deletions(-)\n\ndiff --git a/Documentation/dev-tools/context-analysis.rst b/Documentation/dev-tools/context-analysis.rst\nindex 690565910084..b2d69fb4a884 100644\n--- a/Documentation/dev-tools/context-analysis.rst\n+++ b/Documentation/dev-tools/context-analysis.rst\n@@ -79,7 +79,8 @@ Supported Kernel Primitives\n ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n Currently the following synchronization primitives are supported:\n-`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`.\n+`raw_spinlock_t`, `spinlock_t`, `rwlock_t`, `mutex`, `seqlock_t`,\n+`bit_spinlock`.\n \n For context locks with an initialization function (e.g., `spin_lock_init()`),\n calling this function before initializing any guarded members or globals\ndiff --git a/include/linux/bit_spinlock.h b/include/linux/bit_spinlock.h\nindex 59e345f74b0e..7869a6e59b6a 100644\n--- a/include/linux/bit_spinlock.h\n+++ b/include/linux/bit_spinlock.h\n@@ -9,6 +9,16 @@\n \n #include <asm/processor.h>  /* for cpu_relax() */\n \n+/*\n+ * For static context analysis, we need a unique token for each possible bit\n+ * that can be used as a bit_spinlock. The easiest way to do that is to create a\n+ * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n+ * below, which will give us unique instances for each (bit, addr) pair that the\n+ * static analysis can use.\n+ */\n+context_lock_struct(__context_bitlock) { };\n+#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n+\n /*\n  *  bit-based spin_lock()\n  *\n@@ -16,6 +26,7 @@\n  * are significantly faster.\n  */\n static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n+\t__acquires(__bitlock(bitnum, addr))\n {\n \t/*\n \t * Assuming the lock is uncontended, this never enters\n@@ -34,13 +45,14 @@ static __always_inline void bit_spin_lock(int bitnum, unsigned long *addr)\n \t\tpreempt_disable();\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n }\n \n /*\n  * Return true if it was acquired\n  */\n static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n+\t__cond_acquires(true, __bitlock(bitnum, addr))\n {\n \tpreempt_disable();\n #if defined(CONFIG_SMP) || defined(CONFIG_DEBUG_SPINLOCK)\n@@ -49,7 +61,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n \t\treturn 0;\n \t}\n #endif\n-\t__acquire(bitlock);\n+\t__acquire(__bitlock(bitnum, addr));\n \treturn 1;\n }\n \n@@ -57,6 +69,7 @@ static __always_inline int bit_spin_trylock(int bitnum, unsigned long *addr)\n  *  bit-based spin_unlock()\n  */\n static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -65,7 +78,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n \tclear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\n@@ -74,6 +87,7 @@ static __always_inline void bit_spin_unlock(int bitnum, unsigned long *addr)\n  *  protecting the rest of the flags in the word.\n  */\n static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n+\t__releases(__bitlock(bitnum, addr))\n {\n #ifdef CONFIG_DEBUG_SPINLOCK\n \tBUG_ON(!test_bit(bitnum, addr));\n@@ -82,7 +96,7 @@ static __always_inline void __bit_spin_unlock(int bitnum, unsigned long *addr)\n \t__clear_bit_unlock(bitnum, addr);\n #endif\n \tpreempt_enable();\n-\t__release(bitlock);\n+\t__release(__bitlock(bitnum, addr));\n }\n \n /*\ndiff --git a/include/linux/list_bl.h b/include/linux/list_bl.h\nindex ae1b541446c9..df9eebe6afca 100644\n--- a/include/linux/list_bl.h\n+++ b/include/linux/list_bl.h\n@@ -144,11 +144,13 @@ static inline void hlist_bl_del_init(struct hlist_bl_node *n)\n }\n \n static inline void hlist_bl_lock(struct hlist_bl_head *b)\n+\t__acquires(__bitlock(0, b))\n {\n \tbit_spin_lock(0, (unsigned long *)b);\n }\n \n static inline void hlist_bl_unlock(struct hlist_bl_head *b)\n+\t__releases(__bitlock(0, b))\n {\n \t__bit_spin_un",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618008124304.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618038924546.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618037224530.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618008824313.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618037424533.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618037724536.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618008724310.mbox",
          "message_id": "<3b070057-5fda-410e-a047-d9061d56a82f () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 20:47:43+00:00",
          "date_str": "Fri, 19 Dec 2025 20:47:43 +0000",
          "body": "On 12/19/25 7:40 AM, Marco Elver wrote:\n> +/*\n> + * For static context analysis, we need a unique token for each possible bit\n> + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> + * below, which will give us unique instances for each (bit, addr) pair that the\n> + * static analysis can use.\n> + */\n> +context_lock_struct(__context_bitlock) { };\n> +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n\nWill this cause static analyzers to complain about out-of-bounds\naccesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618139925387.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618140625404.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618140625405.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618139925386.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618140625403.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618140125391.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618140225394.mbox",
          "message_id": "<CANpmjNN6QrxwUUkpAopTfxLwUqGfB53J96dwOWHNcoYrOrEocQ () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 13/36] bit_spinlock: Support Clang's context analysis",
          "date": "2025-12-19 21:09:23+00:00",
          "date_str": "Fri, 19 Dec 2025 21:09:23 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:48, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:40 AM, Marco Elver wrote:\n> > +/*\n> > + * For static context analysis, we need a unique token for each possible bit\n> > + * that can be used as a bit_spinlock. The easiest way to do that is to create a\n> > + * fake context that we can cast to with the __bitlock(bitnum, addr) macro\n> > + * below, which will give us unique instances for each (bit, addr) pair that the\n> > + * static analysis can use.\n> > + */\n> > +context_lock_struct(__context_bitlock) { };\n> > +#define __bitlock(bitnum, addr) (struct __context_bitlock *)(bitnum + (addr))\n>\n> Will this cause static analyzers to complain about out-of-bounds\n> accesses for (bitnum + (addr)), which is equivalent to &(addr)[bitnum]?\n\nOnly if they decide to interpret never-executed code (i think the\nkernel has various dead code that's optimized out that might trigger\nstatic analyzers if they analyzed it).\nBut this could probably be improved by using a different idiom, and\nusing an empty inline function that takes bitnum, addr as args, and\nClang simply takes the call to that function as the context lock\nidentity.\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
      "normalized_subject": "lockdep: Annotate lockdep assertions for context analysis",
      "message_count": 30,
      "participants": [
        "Marco Elver",
        "Bart Van Assche"
      ],
      "categories": [
        "context_analysis",
        "compiler_compat"
      ],
      "first_date": "2025-12-19T15:39:56+00:00",
      "last_date": "2025-12-19T21:47:06+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176616969415704.mbox",
          "message_id": "<20251219154418.3592607-8-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 15:39:56+00:00",
          "date_str": "Fri, 19 Dec 2025 15:39:56 +0000",
          "body": "Clang's context analysis can be made aware of functions that assert that\nlocks are held.\n\nPresence of these annotations causes the analysis to assume the context\nlock is held after calls to the annotated function, and avoid false\npositives with complex control-flow; for example, where not all\ncontrol-flow paths in a function require a held lock, and therefore\nmarking the function with __must_hold(..) is inappropriate.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* __assert -> __assume rename\n---\n include/linux/lockdep.h | 12 ++++++------\n 1 file changed, 6 insertions(+), 6 deletions(-)\n\ndiff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\nindex dd634103b014..621566345406 100644\n--- a/include/linux/lockdep.h\n+++ b/include/linux/lockdep.h\n@@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n \n #define lockdep_assert_held(l)\t\t\\\n-\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n+\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n \n #define lockdep_assert_not_held(l)\t\\\n \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n \n #define lockdep_assert_held_write(l)\t\\\n-\tlockdep_assert(lockdep_is_held_type(l, 0))\n+\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n \n #define lockdep_assert_held_read(l)\t\\\n-\tlockdep_assert(lockdep_is_held_type(l, 1))\n+\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n \n #define lockdep_assert_held_once(l)\t\t\\\n \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n@@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n #define lockdep_assert(c)\t\t\tdo { } while (0)\n #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n \n-#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n+#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n-#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n-#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n+#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n+#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n #define lockdep_assert_none_held_once()\tdo { } while (0)\n \n-- \n2.52.0.322.g1dd061c0dc-goog\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616921215233.mbox",
          "message_id": "<20251219154418.3592607-8-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 15:39:56+00:00",
          "date_str": "Fri, 19 Dec 2025 15:39:56 +0000",
          "body": "Clang's context analysis can be made aware of functions that assert that\nlocks are held.\n\nPresence of these annotations causes the analysis to assume the context\nlock is held after calls to the annotated function, and avoid false\npositives with complex control-flow; for example, where not all\ncontrol-flow paths in a function require a held lock, and therefore\nmarking the function with __must_hold(..) is inappropriate.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* __assert -> __assume rename\n---\n include/linux/lockdep.h | 12 ++++++------\n 1 file changed, 6 insertions(+), 6 deletions(-)\n\ndiff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\nindex dd634103b014..621566345406 100644\n--- a/include/linux/lockdep.h\n+++ b/include/linux/lockdep.h\n@@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n \n #define lockdep_assert_held(l)\t\t\\\n-\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n+\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n \n #define lockdep_assert_not_held(l)\t\\\n \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n \n #define lockdep_assert_held_write(l)\t\\\n-\tlockdep_assert(lockdep_is_held_type(l, 0))\n+\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n \n #define lockdep_assert_held_read(l)\t\\\n-\tlockdep_assert(lockdep_is_held_type(l, 1))\n+\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n \n #define lockdep_assert_held_once(l)\t\t\\\n \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n@@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n #define lockdep_assert(c)\t\t\tdo { } while (0)\n #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n \n-#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n+#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n-#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n-#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n+#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n+#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n #define lockdep_assert_none_held_once()\tdo { } while (0)\n \n-- \n2.52.0.322.g1dd061c0dc-goog\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176616999915960.mbox",
          "message_id": "<20251219154418.3592607-8-elver () google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "[PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 15:39:56+00:00",
          "date_str": "Fri, 19 Dec 2025 15:39:56 +0000",
          "body": "Clang's context analysis can be made aware of functions that assert that\nlocks are held.\n\nPresence of these annotations causes the analysis to assume the context\nlock is held after calls to the annotated function, and avoid false\npositives with complex control-flow; for example, where not all\ncontrol-flow paths in a function require a held lock, and therefore\nmarking the function with __must_hold(..) is inappropriate.\n\nSigned-off-by: Marco Elver <elver@google.com>\n---\nv5:\n* Rename \"context guard\" -> \"context lock\".\n\nv4:\n* Rename capability -> context analysis.\n\nv3:\n* __assert -> __assume rename\n---\n include/linux/lockdep.h | 12 ++++++------\n 1 file changed, 6 insertions(+), 6 deletions(-)\n\ndiff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\nindex dd634103b014..621566345406 100644\n--- a/include/linux/lockdep.h\n+++ b/include/linux/lockdep.h\n@@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n \n #define lockdep_assert_held(l)\t\t\\\n-\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n+\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n \n #define lockdep_assert_not_held(l)\t\\\n \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n \n #define lockdep_assert_held_write(l)\t\\\n-\tlockdep_assert(lockdep_is_held_type(l, 0))\n+\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n \n #define lockdep_assert_held_read(l)\t\\\n-\tlockdep_assert(lockdep_is_held_type(l, 1))\n+\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n \n #define lockdep_assert_held_once(l)\t\t\\\n \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n@@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n #define lockdep_assert(c)\t\t\tdo { } while (0)\n #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n \n-#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n+#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n-#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n-#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n+#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n+#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n #define lockdep_assert_none_held_once()\tdo { } while (0)\n \n-- \n2.52.0.322.g1dd061c0dc-goog\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618063124770.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618043824594.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618062424766.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618043924600.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618063924792.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618043924601.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618062224758.mbox",
          "message_id": "<cdde6c60-7f6f-4715-a249-5aab39438b57 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 20:53:38+00:00",
          "date_str": "Fri, 19 Dec 2025 20:53:38 +0000",
          "body": "On 12/19/25 7:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> index dd634103b014..621566345406 100644\n> --- a/include/linux/lockdep.h\n> +++ b/include/linux/lockdep.h\n> @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n>   \tdo { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n>   \n>   #define lockdep_assert_held(l)\t\t\\\n> -\tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> +\tdo { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_not_held(l)\t\\\n>   \tlockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n>   \n>   #define lockdep_assert_held_write(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 0))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_read(l)\t\\\n> -\tlockdep_assert(lockdep_is_held_type(l, 1))\n> +\tdo { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n>   \n>   #define lockdep_assert_held_once(l)\t\t\\\n>   \tlockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n>   #define lockdep_assert(c)\t\t\tdo { } while (0)\n>   #define lockdep_assert_once(c)\t\t\tdo { } while (0)\n>   \n> -#define lockdep_assert_held(l)\t\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held(l)\t\t\t__assume_ctx_lock(l)\n>   #define lockdep_assert_not_held(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_write(l)\t\tdo { (void)(l); } while (0)\n> -#define lockdep_assert_held_read(l)\t\tdo { (void)(l); } while (0)\n> +#define lockdep_assert_held_write(l)\t\t__assume_ctx_lock(l)\n> +#define lockdep_assert_held_read(l)\t\t__assume_shared_ctx_lock(l)\n>   #define lockdep_assert_held_once(l)\t\tdo { (void)(l); } while (0)\n>   #define lockdep_assert_none_held_once()\tdo { } while (0)\n\nI think these macros should use __must_hold() instead of __assume...().\nlockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\nI think that code where lockdep_assert_held() is used should not compile\nif it cannot be verified at compile time that 'l' is held.\n\nThanks,\n\nBart.\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618183425663.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618183925669.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618188225720.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618185025683.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618183325660.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618183525666.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618183225657.mbox",
          "message_id": "<CANpmjNPJXVtZgT96PP--eNAkHNOvw1MrYzWt5f2aA0LUeK8iGA () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:16:36+00:00",
          "date_str": "Fri, 19 Dec 2025 21:16:36 +0000",
          "body": "On Fri, 19 Dec 2025 at 21:54, 'Bart Van Assche' via kasan-dev\n<kasan-dev@googlegroups.com> wrote:\n>\n> On 12/19/25 7:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h\n> > index dd634103b014..621566345406 100644\n> > --- a/include/linux/lockdep.h\n> > +++ b/include/linux/lockdep.h\n> > @@ -282,16 +282,16 @@ extern void lock_unpin_lock(struct lockdep_map *lock, struct pin_cookie);\n> >       do { WARN_ON_ONCE(debug_locks && !(cond)); } while (0)\n> >\n> >   #define lockdep_assert_held(l)              \\\n> > -     lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > +     do { lockdep_assert(lockdep_is_held(l) != LOCK_STATE_NOT_HELD); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_not_held(l)  \\\n> >       lockdep_assert(lockdep_is_held(l) != LOCK_STATE_HELD)\n> >\n> >   #define lockdep_assert_held_write(l)        \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 0))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 0)); __assume_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_read(l) \\\n> > -     lockdep_assert(lockdep_is_held_type(l, 1))\n> > +     do { lockdep_assert(lockdep_is_held_type(l, 1)); __assume_shared_ctx_lock(l); } while (0)\n> >\n> >   #define lockdep_assert_held_once(l)         \\\n> >       lockdep_assert_once(lockdep_is_held(l) != LOCK_STATE_NOT_HELD)\n> > @@ -389,10 +389,10 @@ extern int lockdep_is_held(const void *);\n> >   #define lockdep_assert(c)                   do { } while (0)\n> >   #define lockdep_assert_once(c)                      do { } while (0)\n> >\n> > -#define lockdep_assert_held(l)                       do { (void)(l); } while (0)\n> > +#define lockdep_assert_held(l)                       __assume_ctx_lock(l)\n> >   #define lockdep_assert_not_held(l)          do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_write(l)         do { (void)(l); } while (0)\n> > -#define lockdep_assert_held_read(l)          do { (void)(l); } while (0)\n> > +#define lockdep_assert_held_write(l)         __assume_ctx_lock(l)\n> > +#define lockdep_assert_held_read(l)          __assume_shared_ctx_lock(l)\n> >   #define lockdep_assert_held_once(l)         do { (void)(l); } while (0)\n> >   #define lockdep_assert_none_held_once()     do { } while (0)\n>\n> I think these macros should use __must_hold() instead of __assume...().\n> lockdep_assert_held() emits a runtime warning if 'l' is not held. Hence,\n> I think that code where lockdep_assert_held() is used should not compile\n> if it cannot be verified at compile time that 'l' is held.\n\nThat's not the purpose of this - if a function or variable should have\na lock held, we mark them explicitly with __must_hold() or\n__guarded_by(), and we don't really need to use lockdep_assert,\nbecause the compiler helped us out. In an ideal world, every function\nor variable that requires a lock held is annotated, and we don't need\nto ever worry about explicitly checking if a lock is held (but we'll\nbe far from that for a while).\n\nThe purpose is described in the commit message:\n\n> Presence of these annotations causes the analysis to assume the context\n> lock is held after calls to the annotated function, and avoid false\n> positives with complex control-flow; [...]\n\nIt's basically an escape hatch to defer to dynamic analysis where the\nlimits of the static analysis are reached. This is also the original\npurpose of the \"assert\"/\"assume\" attributes:\nhttps://clang.llvm.org/docs/ThreadSafetyAnalysis.html#assert-capability-and-assert-shared-capability\n\nWithout this escape hatch, and deferral to dynamic analysis, we'd be\nstuck in some cases.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618255826056.mbox",
          "message_id": "<ecb35204-ea13-488b-8d60-e21d4812902a () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:28:48+00:00",
          "date_str": "Fri, 19 Dec 2025 21:28:48 +0000",
          "body": "On 12/19/25 2:16 PM, Marco Elver wrote:\n> It's basically an escape hatch to defer to dynamic analysis where the\n> limits of the static analysis are reached.\n\nThat's not how lockdep_assert_held() is used in the kernel. This macro\nis more often than not used to document assumptions that can be verified\nat compile time.\n\nThis patch seems like a step in the wrong direction to me because it\n*suppresses* compile time analysis compile-time analysis is useful. I\nthink that this patch either should be dropped or that the __assume()\nannotations should be changed into __must_hold() annotations.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618256426063.mbox",
          "message_id": "<ecb35204-ea13-488b-8d60-e21d4812902a () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:28:48+00:00",
          "date_str": "Fri, 19 Dec 2025 21:28:48 +0000",
          "body": "On 12/19/25 2:16 PM, Marco Elver wrote:\n> It's basically an escape hatch to defer to dynamic analysis where the\n> limits of the static analysis are reached.\n\nThat's not how lockdep_assert_held() is used in the kernel. This macro\nis more often than not used to document assumptions that can be verified\nat compile time.\n\nThis patch seems like a step in the wrong direction to me because it\n*suppresses* compile time analysis compile-time analysis is useful. I\nthink that this patch either should be dropped or that the __assume()\nannotations should be changed into __must_hold() annotations.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618256626066.mbox",
          "message_id": "<ecb35204-ea13-488b-8d60-e21d4812902a () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:28:48+00:00",
          "date_str": "Fri, 19 Dec 2025 21:28:48 +0000",
          "body": "On 12/19/25 2:16 PM, Marco Elver wrote:\n> It's basically an escape hatch to defer to dynamic analysis where the\n> limits of the static analysis are reached.\n\nThat's not how lockdep_assert_held() is used in the kernel. This macro\nis more often than not used to document assumptions that can be verified\nat compile time.\n\nThis patch seems like a step in the wrong direction to me because it\n*suppresses* compile time analysis compile-time analysis is useful. I\nthink that this patch either should be dropped or that the __assume()\nannotations should be changed into __must_hold() annotations.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618256226059.mbox",
          "message_id": "<ecb35204-ea13-488b-8d60-e21d4812902a () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:28:48+00:00",
          "date_str": "Fri, 19 Dec 2025 21:28:48 +0000",
          "body": "On 12/19/25 2:16 PM, Marco Elver wrote:\n> It's basically an escape hatch to defer to dynamic analysis where the\n> limits of the static analysis are reached.\n\nThat's not how lockdep_assert_held() is used in the kernel. This macro\nis more often than not used to document assumptions that can be verified\nat compile time.\n\nThis patch seems like a step in the wrong direction to me because it\n*suppresses* compile time analysis compile-time analysis is useful. I\nthink that this patch either should be dropped or that the __assume()\nannotations should be changed into __must_hold() annotations.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618253126043.mbox",
          "message_id": "<ecb35204-ea13-488b-8d60-e21d4812902a () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:28:48+00:00",
          "date_str": "Fri, 19 Dec 2025 21:28:48 +0000",
          "body": "On 12/19/25 2:16 PM, Marco Elver wrote:\n> It's basically an escape hatch to defer to dynamic analysis where the\n> limits of the static analysis are reached.\n\nThat's not how lockdep_assert_held() is used in the kernel. This macro\nis more often than not used to document assumptions that can be verified\nat compile time.\n\nThis patch seems like a step in the wrong direction to me because it\n*suppresses* compile time analysis compile-time analysis is useful. I\nthink that this patch either should be dropped or that the __assume()\nannotations should be changed into __must_hold() annotations.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618255026050.mbox",
          "message_id": "<ecb35204-ea13-488b-8d60-e21d4812902a () gmail ! com>",
          "author_name": "Bart Van Assche",
          "author_email": "bart.vanassche () gmail ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:28:48+00:00",
          "date_str": "Fri, 19 Dec 2025 21:28:48 +0000",
          "body": "On 12/19/25 2:16 PM, Marco Elver wrote:\n> It's basically an escape hatch to defer to dynamic analysis where the\n> limits of the static analysis are reached.\n\nThat's not how lockdep_assert_held() is used in the kernel. This macro\nis more often than not used to document assumptions that can be verified\nat compile time.\n\nThis patch seems like a step in the wrong direction to me because it\n*suppresses* compile time analysis compile-time analysis is useful. I\nthink that this patch either should be dropped or that the __assume()\nannotations should be changed into __must_hold() annotations.\n\nBart.\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618370127007.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618375527055.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618366326977.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618370727018.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618375727059.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618375627058.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618370627014.mbox",
          "message_id": "<CANpmjNPp6Gkz3rdaD0V7EkPrm60sA5tPpw+m8Xg3u8MTXuc2mg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 07/36] lockdep: Annotate lockdep assertions for context analysis",
          "date": "2025-12-19 21:47:06+00:00",
          "date_str": "Fri, 19 Dec 2025 21:47:06 +0000",
          "body": "On Fri, 19 Dec 2025 at 22:28, Bart Van Assche <bart.vanassche@gmail.com> wrote:\n>\n> On 12/19/25 2:16 PM, Marco Elver wrote:\n> > It's basically an escape hatch to defer to dynamic analysis where the\n> > limits of the static analysis are reached.\n>\n> That's not how lockdep_assert_held() is used in the kernel.\n\nBecause there had not been any static analysis like this, and dynamic\nanalysis is the only reasonable option.\n\n> This macro\n> is more often than not used to document assumptions that can be verified\n> at compile time.\n\nIn that case the lockdep_assert can be dropped.\n\n> This patch seems like a step in the wrong direction to me because it\n> *suppresses* compile time analysis compile-time analysis is useful. I\n> think that this patch either should be dropped or that the __assume()\n> annotations should be changed into __must_hold() annotations.\n\nIf we drop this patch, e.g. the \"sched: Enable context analysis for\ncore.c and fair.c\" will no longer compile.\n\nIt's a trade-off: more false positives vs. more complete analysis. For\nan analysis to be useful, these trade-offs make or break the analysis\ndepending on the system they are applied to.\n\nIn the kernel, our experience with developer tooling has been that any\nefforts to reduce false positives will help a tool succeed at scale.\nLater you can claw back some completeness, but focusing on\ncompleteness first will kill the tool if false positives cannot\nreasonably be dealt with.\n\nFrom the user space world we know that \"assert lock held\" [1] as this\nkind of escape hatch is valuable to deal with cases the static\nanalysis just can't deal with. Sure, here we can make our own rules,\nbut I'd argue we're in a worse position than most user space code, in\nthat kernel code is significantly more complex (which is the reason I\nspent over half a year banging my head to make Clang's analysis\nsignificantly more capable).\n\n[1] https://github.com/abseil/abseil-cpp/blob/a8960c053bf4adadac097c1101d0028742d8042f/absl/synchronization/mutex.h#L210\n(ASSERT_EXCLUSIVE_LOCK() == __assume_ctx_lock())\n",
          "year": "2025",
          "month": "12"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
      "normalized_subject": "kbuild: remove gcc's -Wtype-limits",
      "message_count": 60,
      "participants": [
        "Vincent Mailhol",
        "David Laight",
        "Nicolas Schier",
        "Dan Carpenter",
        "Nathan Chancellor",
        "Linus Torvalds"
      ],
      "categories": [
        "kernel_integration",
        "sparse_internals",
        "type_system",
        "compiler_compat",
        "rfc_proposals"
      ],
      "first_date": "2025-12-18T18:50:01+00:00",
      "last_date": "2026-01-05T23:56:46+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/12/176608681618779.mbox",
          "message_id": "<20251218-remove_wtype-limits-v1-1-735417536787 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 18:50:01+00:00",
          "date_str": "Thu, 18 Dec 2025 18:50:01 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608667818672.mbox",
          "message_id": "<20251218-remove_wtype-limits-v1-1-735417536787 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 18:50:01+00:00",
          "date_str": "Thu, 18 Dec 2025 18:50:01 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608682818787.mbox",
          "message_id": "<20251218-remove_wtype-limits-v1-1-735417536787 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 18:50:01+00:00",
          "date_str": "Thu, 18 Dec 2025 18:50:01 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608667718670.mbox",
          "message_id": "<20251218-remove_wtype-limits-v1-1-735417536787 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 18:50:01+00:00",
          "date_str": "Thu, 18 Dec 2025 18:50:01 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608668118677.mbox",
          "message_id": "<20251218-remove_wtype-limits-v1-1-735417536787 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 18:50:01+00:00",
          "date_str": "Thu, 18 Dec 2025 18:50:01 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608937320812.mbox",
          "message_id": "<aURXpAwm-ITVlHMl () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 19:36:04+00:00",
          "date_str": "Thu, 18 Dec 2025 19:36:04 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> W=2 builds are heavily polluted by the -Wtype-limits warning.\n> \n> Here are some W=12 statistics on Linux v6.19-rc1 for an x86_64\n> defconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n> \n> \t Warning name\t\t\tcount\tpercent\n> \t-------------------------------------------------\n> \t -Wlogical-op\t\t\t    2\t  0.00 %\n> \t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n> \t -Wunused-macros\t\t  869\t  1.24 %\n> \t -Wmissing-field-initializers\t 1418\t  2.02 %\n> \t -Wshadow\t\t\t 2234\t  3.19 %\n> \t -Wtype-limits\t\t\t65378\t 93.35 %\n> \t-------------------------------------------------\n> \t Total\t\t\t\t70039\t100.00 %\n> \n> As we can see, -Wtype-limits represents the vast majority of all\n> warnings. The reason behind this is that these warnings appear in\n> some common header files, meaning that some unique warnings are\n> repeated tens of thousands of times (once per header inclusion).\n> \n> Add to this the fact that each warning is coupled with a dozen lines\n> detailing some macro expansion. The end result is that the W=2 output\n> is just too bloated and painful to use.\n> \n> Three years ago, I proposed in [1] modifying one such header to\n> silence that noise. Because the code was not faulty, Linus rejected\n> the idea and instead suggested simply removing that warning.\n> \n> At that time, I could not bring myself to send such a patch because,\n> despite its problems, -Wtype-limits would still catch the below bug:\n> \n> \tunsigned int ret;\n> \n> \tret = check();\n> \tif (ret < 0)\n> \t\terror();\n> \n> Meanwhile, based on another suggestion from Linus, I added a new check\n> to sparse [2] that would catch the above bug without the useless spam.\n> \n> With this, remove gcc's -Wtype-limits. People who still want to catch\n> incorrect comparisons between unsigned integers and zero can now use\n> sparse instead.\n> \n> On a side note, clang also has a -Wtype-limits warning but:\n> \n>   * it is not enabled in the kernel at the moment because, contrary to\n>     gcc, clang did not include it under -Wextra.\n> \n>   * it does not warn if the code results from a macro expansion. So,\n>     if activated, it would not cause as much spam as gcc does.\n> \n>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>     it were to be activated, we could select which one to keep.\n> \n\nSounds good.  I like your Sparse check.\n\nMaybe we should enable the Sparse checking as well because it sounds\nlike they are doing a lot of things right.  I think Smatch catches the\nsame bugs that Clang would but it would be good to have multiple\nimplementations.  The -Wtautological-unsigned-enum-zero-compare trips\npeople up because they aren't necessarily expecting enums to be\nunsigned.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608937220808.mbox",
          "message_id": "<aURXpAwm-ITVlHMl () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 19:36:04+00:00",
          "date_str": "Thu, 18 Dec 2025 19:36:04 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> W=2 builds are heavily polluted by the -Wtype-limits warning.\n> \n> Here are some W=12 statistics on Linux v6.19-rc1 for an x86_64\n> defconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n> \n> \t Warning name\t\t\tcount\tpercent\n> \t-------------------------------------------------\n> \t -Wlogical-op\t\t\t    2\t  0.00 %\n> \t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n> \t -Wunused-macros\t\t  869\t  1.24 %\n> \t -Wmissing-field-initializers\t 1418\t  2.02 %\n> \t -Wshadow\t\t\t 2234\t  3.19 %\n> \t -Wtype-limits\t\t\t65378\t 93.35 %\n> \t-------------------------------------------------\n> \t Total\t\t\t\t70039\t100.00 %\n> \n> As we can see, -Wtype-limits represents the vast majority of all\n> warnings. The reason behind this is that these warnings appear in\n> some common header files, meaning that some unique warnings are\n> repeated tens of thousands of times (once per header inclusion).\n> \n> Add to this the fact that each warning is coupled with a dozen lines\n> detailing some macro expansion. The end result is that the W=2 output\n> is just too bloated and painful to use.\n> \n> Three years ago, I proposed in [1] modifying one such header to\n> silence that noise. Because the code was not faulty, Linus rejected\n> the idea and instead suggested simply removing that warning.\n> \n> At that time, I could not bring myself to send such a patch because,\n> despite its problems, -Wtype-limits would still catch the below bug:\n> \n> \tunsigned int ret;\n> \n> \tret = check();\n> \tif (ret < 0)\n> \t\terror();\n> \n> Meanwhile, based on another suggestion from Linus, I added a new check\n> to sparse [2] that would catch the above bug without the useless spam.\n> \n> With this, remove gcc's -Wtype-limits. People who still want to catch\n> incorrect comparisons between unsigned integers and zero can now use\n> sparse instead.\n> \n> On a side note, clang also has a -Wtype-limits warning but:\n> \n>   * it is not enabled in the kernel at the moment because, contrary to\n>     gcc, clang did not include it under -Wextra.\n> \n>   * it does not warn if the code results from a macro expansion. So,\n>     if activated, it would not cause as much spam as gcc does.\n> \n>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>     it were to be activated, we could select which one to keep.\n> \n\nSounds good.  I like your Sparse check.\n\nMaybe we should enable the Sparse checking as well because it sounds\nlike they are doing a lot of things right.  I think Smatch catches the\nsame bugs that Clang would but it would be good to have multiple\nimplementations.  The -Wtautological-unsigned-enum-zero-compare trips\npeople up because they aren't necessarily expecting enums to be\nunsigned.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608937220810.mbox",
          "message_id": "<aURXpAwm-ITVlHMl () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 19:36:04+00:00",
          "date_str": "Thu, 18 Dec 2025 19:36:04 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> W=2 builds are heavily polluted by the -Wtype-limits warning.\n> \n> Here are some W=12 statistics on Linux v6.19-rc1 for an x86_64\n> defconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n> \n> \t Warning name\t\t\tcount\tpercent\n> \t-------------------------------------------------\n> \t -Wlogical-op\t\t\t    2\t  0.00 %\n> \t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n> \t -Wunused-macros\t\t  869\t  1.24 %\n> \t -Wmissing-field-initializers\t 1418\t  2.02 %\n> \t -Wshadow\t\t\t 2234\t  3.19 %\n> \t -Wtype-limits\t\t\t65378\t 93.35 %\n> \t-------------------------------------------------\n> \t Total\t\t\t\t70039\t100.00 %\n> \n> As we can see, -Wtype-limits represents the vast majority of all\n> warnings. The reason behind this is that these warnings appear in\n> some common header files, meaning that some unique warnings are\n> repeated tens of thousands of times (once per header inclusion).\n> \n> Add to this the fact that each warning is coupled with a dozen lines\n> detailing some macro expansion. The end result is that the W=2 output\n> is just too bloated and painful to use.\n> \n> Three years ago, I proposed in [1] modifying one such header to\n> silence that noise. Because the code was not faulty, Linus rejected\n> the idea and instead suggested simply removing that warning.\n> \n> At that time, I could not bring myself to send such a patch because,\n> despite its problems, -Wtype-limits would still catch the below bug:\n> \n> \tunsigned int ret;\n> \n> \tret = check();\n> \tif (ret < 0)\n> \t\terror();\n> \n> Meanwhile, based on another suggestion from Linus, I added a new check\n> to sparse [2] that would catch the above bug without the useless spam.\n> \n> With this, remove gcc's -Wtype-limits. People who still want to catch\n> incorrect comparisons between unsigned integers and zero can now use\n> sparse instead.\n> \n> On a side note, clang also has a -Wtype-limits warning but:\n> \n>   * it is not enabled in the kernel at the moment because, contrary to\n>     gcc, clang did not include it under -Wextra.\n> \n>   * it does not warn if the code results from a macro expansion. So,\n>     if activated, it would not cause as much spam as gcc does.\n> \n>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>     it were to be activated, we could select which one to keep.\n> \n\nSounds good.  I like your Sparse check.\n\nMaybe we should enable the Sparse checking as well because it sounds\nlike they are doing a lot of things right.  I think Smatch catches the\nsame bugs that Clang would but it would be good to have multiple\nimplementations.  The -Wtautological-unsigned-enum-zero-compare trips\npeople up because they aren't necessarily expecting enums to be\nunsigned.\n\nregards,\ndan carpenter\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608939720830.mbox",
          "message_id": "<aURXpAwm-ITVlHMl () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 19:36:04+00:00",
          "date_str": "Thu, 18 Dec 2025 19:36:04 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> W=2 builds are heavily polluted by the -Wtype-limits warning.\n> \n> Here are some W=12 statistics on Linux v6.19-rc1 for an x86_64\n> defconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n> \n> \t Warning name\t\t\tcount\tpercent\n> \t-------------------------------------------------\n> \t -Wlogical-op\t\t\t    2\t  0.00 %\n> \t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n> \t -Wunused-macros\t\t  869\t  1.24 %\n> \t -Wmissing-field-initializers\t 1418\t  2.02 %\n> \t -Wshadow\t\t\t 2234\t  3.19 %\n> \t -Wtype-limits\t\t\t65378\t 93.35 %\n> \t-------------------------------------------------\n> \t Total\t\t\t\t70039\t100.00 %\n> \n> As we can see, -Wtype-limits represents the vast majority of all\n> warnings. The reason behind this is that these warnings appear in\n> some common header files, meaning that some unique warnings are\n> repeated tens of thousands of times (once per header inclusion).\n> \n> Add to this the fact that each warning is coupled with a dozen lines\n> detailing some macro expansion. The end result is that the W=2 output\n> is just too bloated and painful to use.\n> \n> Three years ago, I proposed in [1] modifying one such header to\n> silence that noise. Because the code was not faulty, Linus rejected\n> the idea and instead suggested simply removing that warning.\n> \n> At that time, I could not bring myself to send such a patch because,\n> despite its problems, -Wtype-limits would still catch the below bug:\n> \n> \tunsigned int ret;\n> \n> \tret = check();\n> \tif (ret < 0)\n> \t\terror();\n> \n> Meanwhile, based on another suggestion from Linus, I added a new check\n> to sparse [2] that would catch the above bug without the useless spam.\n> \n> With this, remove gcc's -Wtype-limits. People who still want to catch\n> incorrect comparisons between unsigned integers and zero can now use\n> sparse instead.\n> \n> On a side note, clang also has a -Wtype-limits warning but:\n> \n>   * it is not enabled in the kernel at the moment because, contrary to\n>     gcc, clang did not include it under -Wextra.\n> \n>   * it does not warn if the code results from a macro expansion. So,\n>     if activated, it would not cause as much spam as gcc does.\n> \n>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>     it were to be activated, we could select which one to keep.\n> \n\nSounds good.  I like your Sparse check.\n\nMaybe we should enable the Sparse checking as well because it sounds\nlike they are doing a lot of things right.  I think Smatch catches the\nsame bugs that Clang would but it would be good to have multiple\nimplementations.  The -Wtautological-unsigned-enum-zero-compare trips\npeople up because they aren't necessarily expecting enums to be\nunsigned.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176608937920817.mbox",
          "message_id": "<aURXpAwm-ITVlHMl () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 19:36:04+00:00",
          "date_str": "Thu, 18 Dec 2025 19:36:04 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> W=2 builds are heavily polluted by the -Wtype-limits warning.\n> \n> Here are some W=12 statistics on Linux v6.19-rc1 for an x86_64\n> defconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n> \n> \t Warning name\t\t\tcount\tpercent\n> \t-------------------------------------------------\n> \t -Wlogical-op\t\t\t    2\t  0.00 %\n> \t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n> \t -Wunused-macros\t\t  869\t  1.24 %\n> \t -Wmissing-field-initializers\t 1418\t  2.02 %\n> \t -Wshadow\t\t\t 2234\t  3.19 %\n> \t -Wtype-limits\t\t\t65378\t 93.35 %\n> \t-------------------------------------------------\n> \t Total\t\t\t\t70039\t100.00 %\n> \n> As we can see, -Wtype-limits represents the vast majority of all\n> warnings. The reason behind this is that these warnings appear in\n> some common header files, meaning that some unique warnings are\n> repeated tens of thousands of times (once per header inclusion).\n> \n> Add to this the fact that each warning is coupled with a dozen lines\n> detailing some macro expansion. The end result is that the W=2 output\n> is just too bloated and painful to use.\n> \n> Three years ago, I proposed in [1] modifying one such header to\n> silence that noise. Because the code was not faulty, Linus rejected\n> the idea and instead suggested simply removing that warning.\n> \n> At that time, I could not bring myself to send such a patch because,\n> despite its problems, -Wtype-limits would still catch the below bug:\n> \n> \tunsigned int ret;\n> \n> \tret = check();\n> \tif (ret < 0)\n> \t\terror();\n> \n> Meanwhile, based on another suggestion from Linus, I added a new check\n> to sparse [2] that would catch the above bug without the useless spam.\n> \n> With this, remove gcc's -Wtype-limits. People who still want to catch\n> incorrect comparisons between unsigned integers and zero can now use\n> sparse instead.\n> \n> On a side note, clang also has a -Wtype-limits warning but:\n> \n>   * it is not enabled in the kernel at the moment because, contrary to\n>     gcc, clang did not include it under -Wextra.\n> \n>   * it does not warn if the code results from a macro expansion. So,\n>     if activated, it would not cause as much spam as gcc does.\n> \n>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>     it were to be activated, we could select which one to keep.\n> \n\nSounds good.  I like your Sparse check.\n\nMaybe we should enable the Sparse checking as well because it sounds\nlike they are doing a lot of things right.  I think Smatch catches the\nsame bugs that Clang would but it would be good to have multiple\nimplementations.  The -Wtautological-unsigned-enum-zero-compare trips\npeople up because they aren't necessarily expecting enums to be\nunsigned.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609327024033.mbox",
          "message_id": "<CAHk-=wjrNyuMfkU2RHs28TbFGSORk45mkjtzqeB7uhYJx33Vuw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 20:34:05+00:00",
          "date_str": "Thu, 18 Dec 2025 20:34:05 +0000",
          "body": "On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> One possibility is to conditionally add _Pragma()\n\nNo. That compiler warning is pure and utter garbage. I have pointed it\nout fopr *years*, and compiler people don't get it.\n\nSo that warning just needs to die. It's shit. It's wrong.\n\nThe sparse patch points out that this *can* be done correctly if you a\ncompiler person doesn't have their head up their arse.\n\n(And no, I'm not claiming the sparse patch is perfect. I'm only\nclaiming the sparse patch is _much_ better. Bit tt could be better\nstill, and there could be other valid cases that could be warned for).\n\nThe \"warn on type limits\" is idiotic. It expects programmers to have\nto always track what the exact type limits are, instead of just\nwriting safe and obvious code, and it warns about *good* code and.\n\nIt's exactly the *wrong* kind of thing to warn about.\n\n               Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609286723731.mbox",
          "message_id": "<CAHk-=wjrNyuMfkU2RHs28TbFGSORk45mkjtzqeB7uhYJx33Vuw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 20:34:05+00:00",
          "date_str": "Thu, 18 Dec 2025 20:34:05 +0000",
          "body": "On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> One possibility is to conditionally add _Pragma()\n\nNo. That compiler warning is pure and utter garbage. I have pointed it\nout fopr *years*, and compiler people don't get it.\n\nSo that warning just needs to die. It's shit. It's wrong.\n\nThe sparse patch points out that this *can* be done correctly if you a\ncompiler person doesn't have their head up their arse.\n\n(And no, I'm not claiming the sparse patch is perfect. I'm only\nclaiming the sparse patch is _much_ better. Bit tt could be better\nstill, and there could be other valid cases that could be warned for).\n\nThe \"warn on type limits\" is idiotic. It expects programmers to have\nto always track what the exact type limits are, instead of just\nwriting safe and obvious code, and it warns about *good* code and.\n\nIt's exactly the *wrong* kind of thing to warn about.\n\n               Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609286723730.mbox",
          "message_id": "<CAHk-=wjrNyuMfkU2RHs28TbFGSORk45mkjtzqeB7uhYJx33Vuw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 20:34:05+00:00",
          "date_str": "Thu, 18 Dec 2025 20:34:05 +0000",
          "body": "On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> One possibility is to conditionally add _Pragma()\n\nNo. That compiler warning is pure and utter garbage. I have pointed it\nout fopr *years*, and compiler people don't get it.\n\nSo that warning just needs to die. It's shit. It's wrong.\n\nThe sparse patch points out that this *can* be done correctly if you a\ncompiler person doesn't have their head up their arse.\n\n(And no, I'm not claiming the sparse patch is perfect. I'm only\nclaiming the sparse patch is _much_ better. Bit tt could be better\nstill, and there could be other valid cases that could be warned for).\n\nThe \"warn on type limits\" is idiotic. It expects programmers to have\nto always track what the exact type limits are, instead of just\nwriting safe and obvious code, and it warns about *good* code and.\n\nIt's exactly the *wrong* kind of thing to warn about.\n\n               Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609287723739.mbox",
          "message_id": "<CAHk-=wjrNyuMfkU2RHs28TbFGSORk45mkjtzqeB7uhYJx33Vuw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 20:34:05+00:00",
          "date_str": "Thu, 18 Dec 2025 20:34:05 +0000",
          "body": "On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> One possibility is to conditionally add _Pragma()\n\nNo. That compiler warning is pure and utter garbage. I have pointed it\nout fopr *years*, and compiler people don't get it.\n\nSo that warning just needs to die. It's shit. It's wrong.\n\nThe sparse patch points out that this *can* be done correctly if you a\ncompiler person doesn't have their head up their arse.\n\n(And no, I'm not claiming the sparse patch is perfect. I'm only\nclaiming the sparse patch is _much_ better. Bit tt could be better\nstill, and there could be other valid cases that could be warned for).\n\nThe \"warn on type limits\" is idiotic. It expects programmers to have\nto always track what the exact type limits are, instead of just\nwriting safe and obvious code, and it warns about *good* code and.\n\nIt's exactly the *wrong* kind of thing to warn about.\n\n               Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609286723729.mbox",
          "message_id": "<CAHk-=wjrNyuMfkU2RHs28TbFGSORk45mkjtzqeB7uhYJx33Vuw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 20:34:05+00:00",
          "date_str": "Thu, 18 Dec 2025 20:34:05 +0000",
          "body": "On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> One possibility is to conditionally add _Pragma()\n\nNo. That compiler warning is pure and utter garbage. I have pointed it\nout fopr *years*, and compiler people don't get it.\n\nSo that warning just needs to die. It's shit. It's wrong.\n\nThe sparse patch points out that this *can* be done correctly if you a\ncompiler person doesn't have their head up their arse.\n\n(And no, I'm not claiming the sparse patch is perfect. I'm only\nclaiming the sparse patch is _much_ better. Bit tt could be better\nstill, and there could be other valid cases that could be warned for).\n\nThe \"warn on type limits\" is idiotic. It expects programmers to have\nto always track what the exact type limits are, instead of just\nwriting safe and obvious code, and it warns about *good* code and.\n\nIt's exactly the *wrong* kind of thing to warn about.\n\n               Linus",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609841928365.mbox",
          "message_id": "<20251218220651.5cdde06f () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:06:51+00:00",
          "date_str": "Thu, 18 Dec 2025 22:06:51 +0000",
          "body": "On Fri, 19 Dec 2025 08:34:05 +1200\nLinus Torvalds <torvalds@linux-foundation.org> wrote:\n\n> On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> >\n> > One possibility is to conditionally add _Pragma()  \n> \n> No. That compiler warning is pure and utter garbage. I have pointed it\n> out fopr *years*, and compiler people don't get it.\n> \n> So that warning just needs to die. It's shit. It's wrong.\n\nTrue - especially for code like:\n\tif (x < 0 || x > limit)\n\t\treturn ...\nwhere the code is correct even with 'accidental' conversion of a\nnegative signed value to a large unsigned one.\n\nclang seems to have a dozen similar warnings, all of which are a PITA\nfor kernel code - like rejecting !(4 << 16).\n\n_Pragma() might be usable for -Wshadow, which is generally useful for\nlocal variables (but not global functions like log() and j0()).\n(I usually enable it and fix up the consequences.)\nThings like the masked userspace access define which carefully\ncreates a readonly variable that shadows a user local would need\nto disable that one.\n\n\tDavid\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609842828377.mbox",
          "message_id": "<20251218220651.5cdde06f () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:06:51+00:00",
          "date_str": "Thu, 18 Dec 2025 22:06:51 +0000",
          "body": "On Fri, 19 Dec 2025 08:34:05 +1200\nLinus Torvalds <torvalds@linux-foundation.org> wrote:\n\n> On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> >\n> > One possibility is to conditionally add _Pragma()  \n> \n> No. That compiler warning is pure and utter garbage. I have pointed it\n> out fopr *years*, and compiler people don't get it.\n> \n> So that warning just needs to die. It's shit. It's wrong.\n\nTrue - especially for code like:\n\tif (x < 0 || x > limit)\n\t\treturn ...\nwhere the code is correct even with 'accidental' conversion of a\nnegative signed value to a large unsigned one.\n\nclang seems to have a dozen similar warnings, all of which are a PITA\nfor kernel code - like rejecting !(4 << 16).\n\n_Pragma() might be usable for -Wshadow, which is generally useful for\nlocal variables (but not global functions like log() and j0()).\n(I usually enable it and fix up the consequences.)\nThings like the masked userspace access define which carefully\ncreates a readonly variable that shadows a user local would need\nto disable that one.\n\n\tDavid\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609841928367.mbox",
          "message_id": "<20251218220651.5cdde06f () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:06:51+00:00",
          "date_str": "Thu, 18 Dec 2025 22:06:51 +0000",
          "body": "On Fri, 19 Dec 2025 08:34:05 +1200\nLinus Torvalds <torvalds@linux-foundation.org> wrote:\n\n> On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> >\n> > One possibility is to conditionally add _Pragma()  \n> \n> No. That compiler warning is pure and utter garbage. I have pointed it\n> out fopr *years*, and compiler people don't get it.\n> \n> So that warning just needs to die. It's shit. It's wrong.\n\nTrue - especially for code like:\n\tif (x < 0 || x > limit)\n\t\treturn ...\nwhere the code is correct even with 'accidental' conversion of a\nnegative signed value to a large unsigned one.\n\nclang seems to have a dozen similar warnings, all of which are a PITA\nfor kernel code - like rejecting !(4 << 16).\n\n_Pragma() might be usable for -Wshadow, which is generally useful for\nlocal variables (but not global functions like log() and j0()).\n(I usually enable it and fix up the consequences.)\nThings like the masked userspace access define which carefully\ncreates a readonly variable that shadows a user local would need\nto disable that one.\n\n\tDavid\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609842128371.mbox",
          "message_id": "<20251218220651.5cdde06f () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:06:51+00:00",
          "date_str": "Thu, 18 Dec 2025 22:06:51 +0000",
          "body": "On Fri, 19 Dec 2025 08:34:05 +1200\nLinus Torvalds <torvalds@linux-foundation.org> wrote:\n\n> On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> >\n> > One possibility is to conditionally add _Pragma()  \n> \n> No. That compiler warning is pure and utter garbage. I have pointed it\n> out fopr *years*, and compiler people don't get it.\n> \n> So that warning just needs to die. It's shit. It's wrong.\n\nTrue - especially for code like:\n\tif (x < 0 || x > limit)\n\t\treturn ...\nwhere the code is correct even with 'accidental' conversion of a\nnegative signed value to a large unsigned one.\n\nclang seems to have a dozen similar warnings, all of which are a PITA\nfor kernel code - like rejecting !(4 << 16).\n\n_Pragma() might be usable for -Wshadow, which is generally useful for\nlocal variables (but not global functions like log() and j0()).\n(I usually enable it and fix up the consequences.)\nThings like the masked userspace access define which carefully\ncreates a readonly variable that shadows a user local would need\nto disable that one.\n\n\tDavid\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609843528383.mbox",
          "message_id": "<20251218220651.5cdde06f () pumpkin>",
          "author_name": "David Laight",
          "author_email": "david.laight.linux () gmail ! com",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:06:51+00:00",
          "date_str": "Thu, 18 Dec 2025 22:06:51 +0000",
          "body": "On Fri, 19 Dec 2025 08:34:05 +1200\nLinus Torvalds <torvalds@linux-foundation.org> wrote:\n\n> On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> >\n> > One possibility is to conditionally add _Pragma()  \n> \n> No. That compiler warning is pure and utter garbage. I have pointed it\n> out fopr *years*, and compiler people don't get it.\n> \n> So that warning just needs to die. It's shit. It's wrong.\n\nTrue - especially for code like:\n\tif (x < 0 || x > limit)\n\t\treturn ...\nwhere the code is correct even with 'accidental' conversion of a\nnegative signed value to a large unsigned one.\n\nclang seems to have a dozen similar warnings, all of which are a PITA\nfor kernel code - like rejecting !(4 << 16).\n\n_Pragma() might be usable for -Wshadow, which is generally useful for\nlocal variables (but not global functions like log() and j0()).\n(I usually enable it and fix up the consequences.)\nThings like the masked userspace access define which carefully\ncreates a readonly variable that shadows a user local would need\nto disable that one.\n\n\tDavid\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609917628882.mbox",
          "message_id": "<CAHk-=wjMVfu-aiQ8aNHcgsh6hYwbZCoX1B4ps2scibokO8EZ+A () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:19:15+00:00",
          "date_str": "Thu, 18 Dec 2025 22:19:15 +0000",
          "body": "On Fri, 19 Dec 2025 at 10:06, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> True - especially for code like:\n>         if (x < 0 || x > limit)\n>                 return ...\n\nExactly.\n\nAnd yes, sometimes the type of 'x' is obvious, and having the range\ncheck for zero can be seen as redundant for unsigned types, but even\nin that \"obviously redundant\" case the code is *clearer* with both the\nlower and upper range checked.\n\nAnd apart from being clearer, it's also then safe when somebody does\nchange the type for whatever reason.\n\nAnd lots of types do *not* have obvious signedness. They might be\ntypedefs, or have other much subtler issues. Something as simple as\n\"char\" has subtle sign behavior, and when it comes to things like\nenums the signedness can also be very non-obvious.\n\nSo having both sides of a range check is *always* a good idea, even if\none side _may_ be redundant for some type-range reasons.\n\nAnd there really is absolutely _no_ sane way to get rid of that broken\nwarning except to just disable the warning itself. All other\nalternatives are actively broken - adding a Pragma only makes the code\nworse and illegible, and removing the lower bounds check again only\nmakes the code worse.\n\nSo this is a compiler warning that actively encourages worse code. It\nneeds to *die*. It doesn't fix anything.\n\nAnd the people who point out that it can show bugs - absolutely *ANY*\nwarning can do that. That doesn't make a warning good. Any code can\nhave bugs in it.\n\nThe sparse warning I outlined (and that Vincent wrote up and tested\nand made into a proper patch) was actually showing interesting issues\nin a much better way.\n\nAnd that sparse warning could certainly be improved on too - I think\nthat one too would be better if it noticed \"oh, it's a pure range\ncheck, so let's not warn even when the code otherwise looks dodgy\".\n\nBut at least it didn't warn for obviously good code like the horrid\nbroken type-range warning does.\n\n                  Linus",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609917528881.mbox",
          "message_id": "<CAHk-=wjMVfu-aiQ8aNHcgsh6hYwbZCoX1B4ps2scibokO8EZ+A () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:19:15+00:00",
          "date_str": "Thu, 18 Dec 2025 22:19:15 +0000",
          "body": "On Fri, 19 Dec 2025 at 10:06, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> True - especially for code like:\n>         if (x < 0 || x > limit)\n>                 return ...\n\nExactly.\n\nAnd yes, sometimes the type of 'x' is obvious, and having the range\ncheck for zero can be seen as redundant for unsigned types, but even\nin that \"obviously redundant\" case the code is *clearer* with both the\nlower and upper range checked.\n\nAnd apart from being clearer, it's also then safe when somebody does\nchange the type for whatever reason.\n\nAnd lots of types do *not* have obvious signedness. They might be\ntypedefs, or have other much subtler issues. Something as simple as\n\"char\" has subtle sign behavior, and when it comes to things like\nenums the signedness can also be very non-obvious.\n\nSo having both sides of a range check is *always* a good idea, even if\none side _may_ be redundant for some type-range reasons.\n\nAnd there really is absolutely _no_ sane way to get rid of that broken\nwarning except to just disable the warning itself. All other\nalternatives are actively broken - adding a Pragma only makes the code\nworse and illegible, and removing the lower bounds check again only\nmakes the code worse.\n\nSo this is a compiler warning that actively encourages worse code. It\nneeds to *die*. It doesn't fix anything.\n\nAnd the people who point out that it can show bugs - absolutely *ANY*\nwarning can do that. That doesn't make a warning good. Any code can\nhave bugs in it.\n\nThe sparse warning I outlined (and that Vincent wrote up and tested\nand made into a proper patch) was actually showing interesting issues\nin a much better way.\n\nAnd that sparse warning could certainly be improved on too - I think\nthat one too would be better if it noticed \"oh, it's a pure range\ncheck, so let's not warn even when the code otherwise looks dodgy\".\n\nBut at least it didn't warn for obviously good code like the horrid\nbroken type-range warning does.\n\n                  Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609919528912.mbox",
          "message_id": "<CAHk-=wjMVfu-aiQ8aNHcgsh6hYwbZCoX1B4ps2scibokO8EZ+A () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:19:15+00:00",
          "date_str": "Thu, 18 Dec 2025 22:19:15 +0000",
          "body": "On Fri, 19 Dec 2025 at 10:06, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> True - especially for code like:\n>         if (x < 0 || x > limit)\n>                 return ...\n\nExactly.\n\nAnd yes, sometimes the type of 'x' is obvious, and having the range\ncheck for zero can be seen as redundant for unsigned types, but even\nin that \"obviously redundant\" case the code is *clearer* with both the\nlower and upper range checked.\n\nAnd apart from being clearer, it's also then safe when somebody does\nchange the type for whatever reason.\n\nAnd lots of types do *not* have obvious signedness. They might be\ntypedefs, or have other much subtler issues. Something as simple as\n\"char\" has subtle sign behavior, and when it comes to things like\nenums the signedness can also be very non-obvious.\n\nSo having both sides of a range check is *always* a good idea, even if\none side _may_ be redundant for some type-range reasons.\n\nAnd there really is absolutely _no_ sane way to get rid of that broken\nwarning except to just disable the warning itself. All other\nalternatives are actively broken - adding a Pragma only makes the code\nworse and illegible, and removing the lower bounds check again only\nmakes the code worse.\n\nSo this is a compiler warning that actively encourages worse code. It\nneeds to *die*. It doesn't fix anything.\n\nAnd the people who point out that it can show bugs - absolutely *ANY*\nwarning can do that. That doesn't make a warning good. Any code can\nhave bugs in it.\n\nThe sparse warning I outlined (and that Vincent wrote up and tested\nand made into a proper patch) was actually showing interesting issues\nin a much better way.\n\nAnd that sparse warning could certainly be improved on too - I think\nthat one too would be better if it noticed \"oh, it's a pure range\ncheck, so let's not warn even when the code otherwise looks dodgy\".\n\nBut at least it didn't warn for obviously good code like the horrid\nbroken type-range warning does.\n\n                  Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609918828901.mbox",
          "message_id": "<CAHk-=wjMVfu-aiQ8aNHcgsh6hYwbZCoX1B4ps2scibokO8EZ+A () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:19:15+00:00",
          "date_str": "Thu, 18 Dec 2025 22:19:15 +0000",
          "body": "On Fri, 19 Dec 2025 at 10:06, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> True - especially for code like:\n>         if (x < 0 || x > limit)\n>                 return ...\n\nExactly.\n\nAnd yes, sometimes the type of 'x' is obvious, and having the range\ncheck for zero can be seen as redundant for unsigned types, but even\nin that \"obviously redundant\" case the code is *clearer* with both the\nlower and upper range checked.\n\nAnd apart from being clearer, it's also then safe when somebody does\nchange the type for whatever reason.\n\nAnd lots of types do *not* have obvious signedness. They might be\ntypedefs, or have other much subtler issues. Something as simple as\n\"char\" has subtle sign behavior, and when it comes to things like\nenums the signedness can also be very non-obvious.\n\nSo having both sides of a range check is *always* a good idea, even if\none side _may_ be redundant for some type-range reasons.\n\nAnd there really is absolutely _no_ sane way to get rid of that broken\nwarning except to just disable the warning itself. All other\nalternatives are actively broken - adding a Pragma only makes the code\nworse and illegible, and removing the lower bounds check again only\nmakes the code worse.\n\nSo this is a compiler warning that actively encourages worse code. It\nneeds to *die*. It doesn't fix anything.\n\nAnd the people who point out that it can show bugs - absolutely *ANY*\nwarning can do that. That doesn't make a warning good. Any code can\nhave bugs in it.\n\nThe sparse warning I outlined (and that Vincent wrote up and tested\nand made into a proper patch) was actually showing interesting issues\nin a much better way.\n\nAnd that sparse warning could certainly be improved on too - I think\nthat one too would be better if it noticed \"oh, it's a pure range\ncheck, so let's not warn even when the code otherwise looks dodgy\".\n\nBut at least it didn't warn for obviously good code like the horrid\nbroken type-range warning does.\n\n                  Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609918428894.mbox",
          "message_id": "<CAHk-=wjMVfu-aiQ8aNHcgsh6hYwbZCoX1B4ps2scibokO8EZ+A () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:19:15+00:00",
          "date_str": "Thu, 18 Dec 2025 22:19:15 +0000",
          "body": "On Fri, 19 Dec 2025 at 10:06, David Laight <david.laight.linux@gmail.com> wrote:\n>\n> True - especially for code like:\n>         if (x < 0 || x > limit)\n>                 return ...\n\nExactly.\n\nAnd yes, sometimes the type of 'x' is obvious, and having the range\ncheck for zero can be seen as redundant for unsigned types, but even\nin that \"obviously redundant\" case the code is *clearer* with both the\nlower and upper range checked.\n\nAnd apart from being clearer, it's also then safe when somebody does\nchange the type for whatever reason.\n\nAnd lots of types do *not* have obvious signedness. They might be\ntypedefs, or have other much subtler issues. Something as simple as\n\"char\" has subtle sign behavior, and when it comes to things like\nenums the signedness can also be very non-obvious.\n\nSo having both sides of a range check is *always* a good idea, even if\none side _may_ be redundant for some type-range reasons.\n\nAnd there really is absolutely _no_ sane way to get rid of that broken\nwarning except to just disable the warning itself. All other\nalternatives are actively broken - adding a Pragma only makes the code\nworse and illegible, and removing the lower bounds check again only\nmakes the code worse.\n\nSo this is a compiler warning that actively encourages worse code. It\nneeds to *die*. It doesn't fix anything.\n\nAnd the people who point out that it can show bugs - absolutely *ANY*\nwarning can do that. That doesn't make a warning good. Any code can\nhave bugs in it.\n\nThe sparse warning I outlined (and that Vincent wrote up and tested\nand made into a proper patch) was actually showing interesting issues\nin a much better way.\n\nAnd that sparse warning could certainly be improved on too - I think\nthat one too would be better if it noticed \"oh, it's a pure range\ncheck, so let's not warn even when the code otherwise looks dodgy\".\n\nBut at least it didn't warn for obviously good code like the horrid\nbroken type-range warning does.\n\n                  Linus\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176610013929644.mbox",
          "message_id": "<480c3c06-7b3c-4150-b347-21057678f619 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:31:40+00:00",
          "date_str": "Thu, 18 Dec 2025 22:31:40 +0000",
          "body": "Hi Dan,\n\nOn 18/12/2025 at 20:36, Dan Carpenter wrote:\n> On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n>> With this, remove gcc's -Wtype-limits. People who still want to catch\n>> incorrect comparisons between unsigned integers and zero can now use\n>> sparse instead.\n>>\n>> On a side note, clang also has a -Wtype-limits warning but:\n>>\n>>   * it is not enabled in the kernel at the moment because, contrary to\n>>     gcc, clang did not include it under -Wextra.\n>>\n>>   * it does not warn if the code results from a macro expansion. So,\n>>     if activated, it would not cause as much spam as gcc does.\n>>\n>>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>>     it were to be activated, we could select which one to keep.\n>>\n> \n> Sounds good.  I like your Sparse check.\n\nDoes it mean I have your Reviewed-by?\n\n> Maybe we should enable the Sparse checking as well because it sounds\n> like they are doing a lot of things right.\n\nI am not sure to understand what do you mean by \"enable the Sparse checking\"?\nThe new sparse check I introduced is on by default.\n\n> I think Smatch catches the\n> same bugs that Clang would but it would be good to have multiple\n> implementations.  The -Wtautological-unsigned-enum-zero-compare trips\n> people up because they aren't necessarily expecting enums to be\n> unsigned.\n\nI do not know enough about Smatch, I will let you judge on that one.\n\n\nConcerning clang, here are the statistics:\n\n\t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t      2 [-Wtautological-type-limit-compare]\n\t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n\n(done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n\nNot so many warnings, at least, less than what I would have thought!\n\n-Wtautological-unsigned-char-zero-compare and\n-Wtautological-unsigned-zero-compare gave zero findings. So those two\ncan be enabled, I guess? I am still surprised that\n-Wtautological-unsigned-zero-compare gives nothing. I would have\nexpected some kind of false positives on that one. No sure if I missed\nsomething here.\n\n\nThe two -Wtautological-type-limit-compare are:\n\n\tfs/libfs.c:1640:20: warning: result of comparison 'u64' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t 1640 |             (last_fs_page > (pgoff_t)(~0ULL))) {\n\t      |              ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n\t1 warning generated.\n\tblock/ioctl.c:765:29: warning: result of comparison 'sector_t' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t  765 |                 if (bdev_nr_sectors(bdev) > ~0UL)\n\t      |                     ~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~\n\t1 warning generated.\n\nIf I got it correctly, those checks are just meant for the case where\nunsigned long are 32 bits.\n\nBecause clang does not warn when the code comes from a macro\nexpansion, a way to silent these would be to use:\n\n\t(last_fs_page > type_max(pgoff_t))\n\nin fs/libfs.c and:\n\n\tif (bdev_nr_sectors(bdev) > ULONG_MAX)\n\nin block/ioctl.c.\n\nWell, none of those findings were incorrect to begin with, but\narguably, the code readability can be improved.\n\nSo, I would say why not for -Wtautological-type-limit-compare.\n\n\nConcerning the -Wtautological-unsigned-enum-zero-compare, here is a\nrepresentative finding:\n\n\tdrivers/video/hdmi.c:1099:20: warning: result of comparison of unsigned enum expression < 0 is always false [-Wtautological-unsigned-enum-zero-compare]\n\t 1099 |         if (active_aspect < 0 || active_aspect > 0xf)\n\t      |             ~~~~~~~~~~~~~ ^ ~\n\n(all the other 14 findings follow the same pattern).\n\nHere, the code just want to check that a value is in range. This is\nthe same logic as gcc's -Wtype-limits: something we do *not* want.\n\nSo -Wtautological-unsigned-enum-zero-compare will stay disabled.\n\nIn conclusion, I agree that we could enable three of clang's\n-Wtype-limits sub-warning. But this is not the scope of that series. I\nwould rather prefer to have this as a separate series.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609994329481.mbox",
          "message_id": "<480c3c06-7b3c-4150-b347-21057678f619 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:31:40+00:00",
          "date_str": "Thu, 18 Dec 2025 22:31:40 +0000",
          "body": "Hi Dan,\n\nOn 18/12/2025 at 20:36, Dan Carpenter wrote:\n> On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n>> With this, remove gcc's -Wtype-limits. People who still want to catch\n>> incorrect comparisons between unsigned integers and zero can now use\n>> sparse instead.\n>>\n>> On a side note, clang also has a -Wtype-limits warning but:\n>>\n>>   * it is not enabled in the kernel at the moment because, contrary to\n>>     gcc, clang did not include it under -Wextra.\n>>\n>>   * it does not warn if the code results from a macro expansion. So,\n>>     if activated, it would not cause as much spam as gcc does.\n>>\n>>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>>     it were to be activated, we could select which one to keep.\n>>\n> \n> Sounds good.  I like your Sparse check.\n\nDoes it mean I have your Reviewed-by?\n\n> Maybe we should enable the Sparse checking as well because it sounds\n> like they are doing a lot of things right.\n\nI am not sure to understand what do you mean by \"enable the Sparse checking\"?\nThe new sparse check I introduced is on by default.\n\n> I think Smatch catches the\n> same bugs that Clang would but it would be good to have multiple\n> implementations.  The -Wtautological-unsigned-enum-zero-compare trips\n> people up because they aren't necessarily expecting enums to be\n> unsigned.\n\nI do not know enough about Smatch, I will let you judge on that one.\n\n\nConcerning clang, here are the statistics:\n\n\t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t      2 [-Wtautological-type-limit-compare]\n\t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n\n(done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n\nNot so many warnings, at least, less than what I would have thought!\n\n-Wtautological-unsigned-char-zero-compare and\n-Wtautological-unsigned-zero-compare gave zero findings. So those two\ncan be enabled, I guess? I am still surprised that\n-Wtautological-unsigned-zero-compare gives nothing. I would have\nexpected some kind of false positives on that one. No sure if I missed\nsomething here.\n\n\nThe two -Wtautological-type-limit-compare are:\n\n\tfs/libfs.c:1640:20: warning: result of comparison 'u64' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t 1640 |             (last_fs_page > (pgoff_t)(~0ULL))) {\n\t      |              ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n\t1 warning generated.\n\tblock/ioctl.c:765:29: warning: result of comparison 'sector_t' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t  765 |                 if (bdev_nr_sectors(bdev) > ~0UL)\n\t      |                     ~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~\n\t1 warning generated.\n\nIf I got it correctly, those checks are just meant for the case where\nunsigned long are 32 bits.\n\nBecause clang does not warn when the code comes from a macro\nexpansion, a way to silent these would be to use:\n\n\t(last_fs_page > type_max(pgoff_t))\n\nin fs/libfs.c and:\n\n\tif (bdev_nr_sectors(bdev) > ULONG_MAX)\n\nin block/ioctl.c.\n\nWell, none of those findings were incorrect to begin with, but\narguably, the code readability can be improved.\n\nSo, I would say why not for -Wtautological-type-limit-compare.\n\n\nConcerning the -Wtautological-unsigned-enum-zero-compare, here is a\nrepresentative finding:\n\n\tdrivers/video/hdmi.c:1099:20: warning: result of comparison of unsigned enum expression < 0 is always false [-Wtautological-unsigned-enum-zero-compare]\n\t 1099 |         if (active_aspect < 0 || active_aspect > 0xf)\n\t      |             ~~~~~~~~~~~~~ ^ ~\n\n(all the other 14 findings follow the same pattern).\n\nHere, the code just want to check that a value is in range. This is\nthe same logic as gcc's -Wtype-limits: something we do *not* want.\n\nSo -Wtautological-unsigned-enum-zero-compare will stay disabled.\n\nIn conclusion, I agree that we could enable three of clang's\n-Wtype-limits sub-warning. But this is not the scope of that series. I\nwould rather prefer to have this as a separate series.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176610013929643.mbox",
          "message_id": "<480c3c06-7b3c-4150-b347-21057678f619 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:31:40+00:00",
          "date_str": "Thu, 18 Dec 2025 22:31:40 +0000",
          "body": "Hi Dan,\n\nOn 18/12/2025 at 20:36, Dan Carpenter wrote:\n> On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n>> With this, remove gcc's -Wtype-limits. People who still want to catch\n>> incorrect comparisons between unsigned integers and zero can now use\n>> sparse instead.\n>>\n>> On a side note, clang also has a -Wtype-limits warning but:\n>>\n>>   * it is not enabled in the kernel at the moment because, contrary to\n>>     gcc, clang did not include it under -Wextra.\n>>\n>>   * it does not warn if the code results from a macro expansion. So,\n>>     if activated, it would not cause as much spam as gcc does.\n>>\n>>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>>     it were to be activated, we could select which one to keep.\n>>\n> \n> Sounds good.  I like your Sparse check.\n\nDoes it mean I have your Reviewed-by?\n\n> Maybe we should enable the Sparse checking as well because it sounds\n> like they are doing a lot of things right.\n\nI am not sure to understand what do you mean by \"enable the Sparse checking\"?\nThe new sparse check I introduced is on by default.\n\n> I think Smatch catches the\n> same bugs that Clang would but it would be good to have multiple\n> implementations.  The -Wtautological-unsigned-enum-zero-compare trips\n> people up because they aren't necessarily expecting enums to be\n> unsigned.\n\nI do not know enough about Smatch, I will let you judge on that one.\n\n\nConcerning clang, here are the statistics:\n\n\t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t      2 [-Wtautological-type-limit-compare]\n\t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n\n(done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n\nNot so many warnings, at least, less than what I would have thought!\n\n-Wtautological-unsigned-char-zero-compare and\n-Wtautological-unsigned-zero-compare gave zero findings. So those two\ncan be enabled, I guess? I am still surprised that\n-Wtautological-unsigned-zero-compare gives nothing. I would have\nexpected some kind of false positives on that one. No sure if I missed\nsomething here.\n\n\nThe two -Wtautological-type-limit-compare are:\n\n\tfs/libfs.c:1640:20: warning: result of comparison 'u64' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t 1640 |             (last_fs_page > (pgoff_t)(~0ULL))) {\n\t      |              ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n\t1 warning generated.\n\tblock/ioctl.c:765:29: warning: result of comparison 'sector_t' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t  765 |                 if (bdev_nr_sectors(bdev) > ~0UL)\n\t      |                     ~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~\n\t1 warning generated.\n\nIf I got it correctly, those checks are just meant for the case where\nunsigned long are 32 bits.\n\nBecause clang does not warn when the code comes from a macro\nexpansion, a way to silent these would be to use:\n\n\t(last_fs_page > type_max(pgoff_t))\n\nin fs/libfs.c and:\n\n\tif (bdev_nr_sectors(bdev) > ULONG_MAX)\n\nin block/ioctl.c.\n\nWell, none of those findings were incorrect to begin with, but\narguably, the code readability can be improved.\n\nSo, I would say why not for -Wtautological-type-limit-compare.\n\n\nConcerning the -Wtautological-unsigned-enum-zero-compare, here is a\nrepresentative finding:\n\n\tdrivers/video/hdmi.c:1099:20: warning: result of comparison of unsigned enum expression < 0 is always false [-Wtautological-unsigned-enum-zero-compare]\n\t 1099 |         if (active_aspect < 0 || active_aspect > 0xf)\n\t      |             ~~~~~~~~~~~~~ ^ ~\n\n(all the other 14 findings follow the same pattern).\n\nHere, the code just want to check that a value is in range. This is\nthe same logic as gcc's -Wtype-limits: something we do *not* want.\n\nSo -Wtautological-unsigned-enum-zero-compare will stay disabled.\n\nIn conclusion, I agree that we could enable three of clang's\n-Wtype-limits sub-warning. But this is not the scope of that series. I\nwould rather prefer to have this as a separate series.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176609990829461.mbox",
          "message_id": "<480c3c06-7b3c-4150-b347-21057678f619 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:31:40+00:00",
          "date_str": "Thu, 18 Dec 2025 22:31:40 +0000",
          "body": "Hi Dan,\n\nOn 18/12/2025 at 20:36, Dan Carpenter wrote:\n> On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n>> With this, remove gcc's -Wtype-limits. People who still want to catch\n>> incorrect comparisons between unsigned integers and zero can now use\n>> sparse instead.\n>>\n>> On a side note, clang also has a -Wtype-limits warning but:\n>>\n>>   * it is not enabled in the kernel at the moment because, contrary to\n>>     gcc, clang did not include it under -Wextra.\n>>\n>>   * it does not warn if the code results from a macro expansion. So,\n>>     if activated, it would not cause as much spam as gcc does.\n>>\n>>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>>     it were to be activated, we could select which one to keep.\n>>\n> \n> Sounds good.  I like your Sparse check.\n\nDoes it mean I have your Reviewed-by?\n\n> Maybe we should enable the Sparse checking as well because it sounds\n> like they are doing a lot of things right.\n\nI am not sure to understand what do you mean by \"enable the Sparse checking\"?\nThe new sparse check I introduced is on by default.\n\n> I think Smatch catches the\n> same bugs that Clang would but it would be good to have multiple\n> implementations.  The -Wtautological-unsigned-enum-zero-compare trips\n> people up because they aren't necessarily expecting enums to be\n> unsigned.\n\nI do not know enough about Smatch, I will let you judge on that one.\n\n\nConcerning clang, here are the statistics:\n\n\t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t      2 [-Wtautological-type-limit-compare]\n\t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n\n(done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n\nNot so many warnings, at least, less than what I would have thought!\n\n-Wtautological-unsigned-char-zero-compare and\n-Wtautological-unsigned-zero-compare gave zero findings. So those two\ncan be enabled, I guess? I am still surprised that\n-Wtautological-unsigned-zero-compare gives nothing. I would have\nexpected some kind of false positives on that one. No sure if I missed\nsomething here.\n\n\nThe two -Wtautological-type-limit-compare are:\n\n\tfs/libfs.c:1640:20: warning: result of comparison 'u64' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t 1640 |             (last_fs_page > (pgoff_t)(~0ULL))) {\n\t      |              ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n\t1 warning generated.\n\tblock/ioctl.c:765:29: warning: result of comparison 'sector_t' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t  765 |                 if (bdev_nr_sectors(bdev) > ~0UL)\n\t      |                     ~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~\n\t1 warning generated.\n\nIf I got it correctly, those checks are just meant for the case where\nunsigned long are 32 bits.\n\nBecause clang does not warn when the code comes from a macro\nexpansion, a way to silent these would be to use:\n\n\t(last_fs_page > type_max(pgoff_t))\n\nin fs/libfs.c and:\n\n\tif (bdev_nr_sectors(bdev) > ULONG_MAX)\n\nin block/ioctl.c.\n\nWell, none of those findings were incorrect to begin with, but\narguably, the code readability can be improved.\n\nSo, I would say why not for -Wtautological-type-limit-compare.\n\n\nConcerning the -Wtautological-unsigned-enum-zero-compare, here is a\nrepresentative finding:\n\n\tdrivers/video/hdmi.c:1099:20: warning: result of comparison of unsigned enum expression < 0 is always false [-Wtautological-unsigned-enum-zero-compare]\n\t 1099 |         if (active_aspect < 0 || active_aspect > 0xf)\n\t      |             ~~~~~~~~~~~~~ ^ ~\n\n(all the other 14 findings follow the same pattern).\n\nHere, the code just want to check that a value is in range. This is\nthe same logic as gcc's -Wtype-limits: something we do *not* want.\n\nSo -Wtautological-unsigned-enum-zero-compare will stay disabled.\n\nIn conclusion, I agree that we could enable three of clang's\n-Wtype-limits sub-warning. But this is not the scope of that series. I\nwould rather prefer to have this as a separate series.\n\n\nYours sincerely,\nVincent Mailhol",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176610015329659.mbox",
          "message_id": "<480c3c06-7b3c-4150-b347-21057678f619 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-18 22:31:40+00:00",
          "date_str": "Thu, 18 Dec 2025 22:31:40 +0000",
          "body": "Hi Dan,\n\nOn 18/12/2025 at 20:36, Dan Carpenter wrote:\n> On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n>> With this, remove gcc's -Wtype-limits. People who still want to catch\n>> incorrect comparisons between unsigned integers and zero can now use\n>> sparse instead.\n>>\n>> On a side note, clang also has a -Wtype-limits warning but:\n>>\n>>   * it is not enabled in the kernel at the moment because, contrary to\n>>     gcc, clang did not include it under -Wextra.\n>>\n>>   * it does not warn if the code results from a macro expansion. So,\n>>     if activated, it would not cause as much spam as gcc does.\n>>\n>>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n>>     it were to be activated, we could select which one to keep.\n>>\n> \n> Sounds good.  I like your Sparse check.\n\nDoes it mean I have your Reviewed-by?\n\n> Maybe we should enable the Sparse checking as well because it sounds\n> like they are doing a lot of things right.\n\nI am not sure to understand what do you mean by \"enable the Sparse checking\"?\nThe new sparse check I introduced is on by default.\n\n> I think Smatch catches the\n> same bugs that Clang would but it would be good to have multiple\n> implementations.  The -Wtautological-unsigned-enum-zero-compare trips\n> people up because they aren't necessarily expecting enums to be\n> unsigned.\n\nI do not know enough about Smatch, I will let you judge on that one.\n\n\nConcerning clang, here are the statistics:\n\n\t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t      2 [-Wtautological-type-limit-compare]\n\t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n\n(done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n\nNot so many warnings, at least, less than what I would have thought!\n\n-Wtautological-unsigned-char-zero-compare and\n-Wtautological-unsigned-zero-compare gave zero findings. So those two\ncan be enabled, I guess? I am still surprised that\n-Wtautological-unsigned-zero-compare gives nothing. I would have\nexpected some kind of false positives on that one. No sure if I missed\nsomething here.\n\n\nThe two -Wtautological-type-limit-compare are:\n\n\tfs/libfs.c:1640:20: warning: result of comparison 'u64' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t 1640 |             (last_fs_page > (pgoff_t)(~0ULL))) {\n\t      |              ~~~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~\n\t1 warning generated.\n\tblock/ioctl.c:765:29: warning: result of comparison 'sector_t' (aka 'unsigned long long') > 18446744073709551615 is always false [-Wtautological-type-limit-compare]\n\t  765 |                 if (bdev_nr_sectors(bdev) > ~0UL)\n\t      |                     ~~~~~~~~~~~~~~~~~~~~~ ^ ~~~~\n\t1 warning generated.\n\nIf I got it correctly, those checks are just meant for the case where\nunsigned long are 32 bits.\n\nBecause clang does not warn when the code comes from a macro\nexpansion, a way to silent these would be to use:\n\n\t(last_fs_page > type_max(pgoff_t))\n\nin fs/libfs.c and:\n\n\tif (bdev_nr_sectors(bdev) > ULONG_MAX)\n\nin block/ioctl.c.\n\nWell, none of those findings were incorrect to begin with, but\narguably, the code readability can be improved.\n\nSo, I would say why not for -Wtautological-type-limit-compare.\n\n\nConcerning the -Wtautological-unsigned-enum-zero-compare, here is a\nrepresentative finding:\n\n\tdrivers/video/hdmi.c:1099:20: warning: result of comparison of unsigned enum expression < 0 is always false [-Wtautological-unsigned-enum-zero-compare]\n\t 1099 |         if (active_aspect < 0 || active_aspect > 0xf)\n\t      |             ~~~~~~~~~~~~~ ^ ~\n\n(all the other 14 findings follow the same pattern).\n\nHere, the code just want to check that a value is in range. This is\nthe same logic as gcc's -Wtype-limits: something we do *not* want.\n\nSo -Wtautological-unsigned-enum-zero-compare will stay disabled.\n\nIn conclusion, I agree that we could enable three of clang's\n-Wtype-limits sub-warning. But this is not the scope of that series. I\nwould rather prefer to have this as a separate series.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613017115635.mbox",
          "message_id": "<aUT3BYAT1bLCk1w9 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 06:56:05+00:00",
          "date_str": "Fri, 19 Dec 2025 06:56:05 +0000",
          "body": "On Thu, Dec 18, 2025 at 11:31:40PM +0100, Vincent Mailhol wrote:\n> Hi Dan,\n> \n> On 18/12/2025 at 20:36, Dan Carpenter wrote:\n> > On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> \n> (...)\n> \n> >> With this, remove gcc's -Wtype-limits. People who still want to catch\n> >> incorrect comparisons between unsigned integers and zero can now use\n> >> sparse instead.\n> >>\n> >> On a side note, clang also has a -Wtype-limits warning but:\n> >>\n> >>   * it is not enabled in the kernel at the moment because, contrary to\n> >>     gcc, clang did not include it under -Wextra.\n> >>\n> >>   * it does not warn if the code results from a macro expansion. So,\n> >>     if activated, it would not cause as much spam as gcc does.\n> >>\n> >>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n> >>     it were to be activated, we could select which one to keep.\n> >>\n> > \n> > Sounds good.  I like your Sparse check.\n> \n> Does it mean I have your Reviewed-by?\n> \n> > Maybe we should enable the Sparse checking as well because it sounds\n> > like they are doing a lot of things right.\n> \n> I am not sure to understand what do you mean by \"enable the Sparse checking\"?\n\nI meant Clang...  Sorry.  Doh.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613017215639.mbox",
          "message_id": "<aUT3BYAT1bLCk1w9 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 06:56:05+00:00",
          "date_str": "Fri, 19 Dec 2025 06:56:05 +0000",
          "body": "On Thu, Dec 18, 2025 at 11:31:40PM +0100, Vincent Mailhol wrote:\n> Hi Dan,\n> \n> On 18/12/2025 at 20:36, Dan Carpenter wrote:\n> > On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> \n> (...)\n> \n> >> With this, remove gcc's -Wtype-limits. People who still want to catch\n> >> incorrect comparisons between unsigned integers and zero can now use\n> >> sparse instead.\n> >>\n> >> On a side note, clang also has a -Wtype-limits warning but:\n> >>\n> >>   * it is not enabled in the kernel at the moment because, contrary to\n> >>     gcc, clang did not include it under -Wextra.\n> >>\n> >>   * it does not warn if the code results from a macro expansion. So,\n> >>     if activated, it would not cause as much spam as gcc does.\n> >>\n> >>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n> >>     it were to be activated, we could select which one to keep.\n> >>\n> > \n> > Sounds good.  I like your Sparse check.\n> \n> Does it mean I have your Reviewed-by?\n> \n> > Maybe we should enable the Sparse checking as well because it sounds\n> > like they are doing a lot of things right.\n> \n> I am not sure to understand what do you mean by \"enable the Sparse checking\"?\n\nI meant Clang...  Sorry.  Doh.\n\nregards,\ndan carpenter\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613017315642.mbox",
          "message_id": "<aUT3BYAT1bLCk1w9 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 06:56:05+00:00",
          "date_str": "Fri, 19 Dec 2025 06:56:05 +0000",
          "body": "On Thu, Dec 18, 2025 at 11:31:40PM +0100, Vincent Mailhol wrote:\n> Hi Dan,\n> \n> On 18/12/2025 at 20:36, Dan Carpenter wrote:\n> > On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> \n> (...)\n> \n> >> With this, remove gcc's -Wtype-limits. People who still want to catch\n> >> incorrect comparisons between unsigned integers and zero can now use\n> >> sparse instead.\n> >>\n> >> On a side note, clang also has a -Wtype-limits warning but:\n> >>\n> >>   * it is not enabled in the kernel at the moment because, contrary to\n> >>     gcc, clang did not include it under -Wextra.\n> >>\n> >>   * it does not warn if the code results from a macro expansion. So,\n> >>     if activated, it would not cause as much spam as gcc does.\n> >>\n> >>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n> >>     it were to be activated, we could select which one to keep.\n> >>\n> > \n> > Sounds good.  I like your Sparse check.\n> \n> Does it mean I have your Reviewed-by?\n> \n> > Maybe we should enable the Sparse checking as well because it sounds\n> > like they are doing a lot of things right.\n> \n> I am not sure to understand what do you mean by \"enable the Sparse checking\"?\n\nI meant Clang...  Sorry.  Doh.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613017415645.mbox",
          "message_id": "<aUT3BYAT1bLCk1w9 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 06:56:05+00:00",
          "date_str": "Fri, 19 Dec 2025 06:56:05 +0000",
          "body": "On Thu, Dec 18, 2025 at 11:31:40PM +0100, Vincent Mailhol wrote:\n> Hi Dan,\n> \n> On 18/12/2025 at 20:36, Dan Carpenter wrote:\n> > On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> \n> (...)\n> \n> >> With this, remove gcc's -Wtype-limits. People who still want to catch\n> >> incorrect comparisons between unsigned integers and zero can now use\n> >> sparse instead.\n> >>\n> >> On a side note, clang also has a -Wtype-limits warning but:\n> >>\n> >>   * it is not enabled in the kernel at the moment because, contrary to\n> >>     gcc, clang did not include it under -Wextra.\n> >>\n> >>   * it does not warn if the code results from a macro expansion. So,\n> >>     if activated, it would not cause as much spam as gcc does.\n> >>\n> >>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n> >>     it were to be activated, we could select which one to keep.\n> >>\n> > \n> > Sounds good.  I like your Sparse check.\n> \n> Does it mean I have your Reviewed-by?\n> \n> > Maybe we should enable the Sparse checking as well because it sounds\n> > like they are doing a lot of things right.\n> \n> I am not sure to understand what do you mean by \"enable the Sparse checking\"?\n\nI meant Clang...  Sorry.  Doh.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613017915653.mbox",
          "message_id": "<aUT3BYAT1bLCk1w9 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 06:56:05+00:00",
          "date_str": "Fri, 19 Dec 2025 06:56:05 +0000",
          "body": "On Thu, Dec 18, 2025 at 11:31:40PM +0100, Vincent Mailhol wrote:\n> Hi Dan,\n> \n> On 18/12/2025 at 20:36, Dan Carpenter wrote:\n> > On Thu, Dec 18, 2025 at 07:50:01PM +0100, Vincent Mailhol wrote:\n> \n> (...)\n> \n> >> With this, remove gcc's -Wtype-limits. People who still want to catch\n> >> incorrect comparisons between unsigned integers and zero can now use\n> >> sparse instead.\n> >>\n> >> On a side note, clang also has a -Wtype-limits warning but:\n> >>\n> >>   * it is not enabled in the kernel at the moment because, contrary to\n> >>     gcc, clang did not include it under -Wextra.\n> >>\n> >>   * it does not warn if the code results from a macro expansion. So,\n> >>     if activated, it would not cause as much spam as gcc does.\n> >>\n> >>   * -Wtype-limits is split into four sub-warnings [3] meaning that if\n> >>     it were to be activated, we could select which one to keep.\n> >>\n> > \n> > Sounds good.  I like your Sparse check.\n> \n> Does it mean I have your Reviewed-by?\n> \n> > Maybe we should enable the Sparse checking as well because it sounds\n> > like they are doing a lot of things right.\n> \n> I am not sure to understand what do you mean by \"enable the Sparse checking\"?\n\nI meant Clang...  Sorry.  Doh.\n\nregards,\ndan carpenter\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613097116220.mbox",
          "message_id": "<aUT54I0fD0aqBVyw () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:08:16+00:00",
          "date_str": "Fri, 19 Dec 2025 07:08:16 +0000",
          "body": "On Thu, Dec 18, 2025 at 10:06:51PM +0000, David Laight wrote:\n> On Fri, 19 Dec 2025 08:34:05 +1200\n> Linus Torvalds <torvalds@linux-foundation.org> wrote:\n> \n> > On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> > >\n> > > One possibility is to conditionally add _Pragma()  \n> > \n> > No. That compiler warning is pure and utter garbage. I have pointed it\n> > out fopr *years*, and compiler people don't get it.\n> > \n> > So that warning just needs to die. It's shit. It's wrong.\n> \n> True - especially for code like:\n> \tif (x < 0 || x > limit)\n> \t\treturn ...\n> where the code is correct even with 'accidental' conversion of a\n> negative signed value to a large unsigned one.\n> \n> clang seems to have a dozen similar warnings, all of which are a PITA\n> for kernel code - like rejecting !(4 << 16).\n\nIn this example is 4 a literal or do we at least know that 4 is\nnon-zero?\n\nI really thought I had a check for that in Smatch but I guess I\ndon't...\n\nregards,\ndan carpenter\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613098416224.mbox",
          "message_id": "<aUT54I0fD0aqBVyw () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:08:16+00:00",
          "date_str": "Fri, 19 Dec 2025 07:08:16 +0000",
          "body": "On Thu, Dec 18, 2025 at 10:06:51PM +0000, David Laight wrote:\n> On Fri, 19 Dec 2025 08:34:05 +1200\n> Linus Torvalds <torvalds@linux-foundation.org> wrote:\n> \n> > On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> > >\n> > > One possibility is to conditionally add _Pragma()  \n> > \n> > No. That compiler warning is pure and utter garbage. I have pointed it\n> > out fopr *years*, and compiler people don't get it.\n> > \n> > So that warning just needs to die. It's shit. It's wrong.\n> \n> True - especially for code like:\n> \tif (x < 0 || x > limit)\n> \t\treturn ...\n> where the code is correct even with 'accidental' conversion of a\n> negative signed value to a large unsigned one.\n> \n> clang seems to have a dozen similar warnings, all of which are a PITA\n> for kernel code - like rejecting !(4 << 16).\n\nIn this example is 4 a literal or do we at least know that 4 is\nnon-zero?\n\nI really thought I had a check for that in Smatch but I guess I\ndon't...\n\nregards,\ndan carpenter\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613090116168.mbox",
          "message_id": "<aUT54I0fD0aqBVyw () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:08:16+00:00",
          "date_str": "Fri, 19 Dec 2025 07:08:16 +0000",
          "body": "On Thu, Dec 18, 2025 at 10:06:51PM +0000, David Laight wrote:\n> On Fri, 19 Dec 2025 08:34:05 +1200\n> Linus Torvalds <torvalds@linux-foundation.org> wrote:\n> \n> > On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> > >\n> > > One possibility is to conditionally add _Pragma()  \n> > \n> > No. That compiler warning is pure and utter garbage. I have pointed it\n> > out fopr *years*, and compiler people don't get it.\n> > \n> > So that warning just needs to die. It's shit. It's wrong.\n> \n> True - especially for code like:\n> \tif (x < 0 || x > limit)\n> \t\treturn ...\n> where the code is correct even with 'accidental' conversion of a\n> negative signed value to a large unsigned one.\n> \n> clang seems to have a dozen similar warnings, all of which are a PITA\n> for kernel code - like rejecting !(4 << 16).\n\nIn this example is 4 a literal or do we at least know that 4 is\nnon-zero?\n\nI really thought I had a check for that in Smatch but I guess I\ndon't...\n\nregards,\ndan carpenter\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613098816227.mbox",
          "message_id": "<aUT54I0fD0aqBVyw () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:08:16+00:00",
          "date_str": "Fri, 19 Dec 2025 07:08:16 +0000",
          "body": "On Thu, Dec 18, 2025 at 10:06:51PM +0000, David Laight wrote:\n> On Fri, 19 Dec 2025 08:34:05 +1200\n> Linus Torvalds <torvalds@linux-foundation.org> wrote:\n> \n> > On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> > >\n> > > One possibility is to conditionally add _Pragma()  \n> > \n> > No. That compiler warning is pure and utter garbage. I have pointed it\n> > out fopr *years*, and compiler people don't get it.\n> > \n> > So that warning just needs to die. It's shit. It's wrong.\n> \n> True - especially for code like:\n> \tif (x < 0 || x > limit)\n> \t\treturn ...\n> where the code is correct even with 'accidental' conversion of a\n> negative signed value to a large unsigned one.\n> \n> clang seems to have a dozen similar warnings, all of which are a PITA\n> for kernel code - like rejecting !(4 << 16).\n\nIn this example is 4 a literal or do we at least know that 4 is\nnon-zero?\n\nI really thought I had a check for that in Smatch but I guess I\ndon't...\n\nregards,\ndan carpenter\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613096716217.mbox",
          "message_id": "<aUT54I0fD0aqBVyw () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:08:16+00:00",
          "date_str": "Fri, 19 Dec 2025 07:08:16 +0000",
          "body": "On Thu, Dec 18, 2025 at 10:06:51PM +0000, David Laight wrote:\n> On Fri, 19 Dec 2025 08:34:05 +1200\n> Linus Torvalds <torvalds@linux-foundation.org> wrote:\n> \n> > On Fri, 19 Dec 2025 at 08:26, David Laight <david.laight.linux@gmail.com> wrote:\n> > >\n> > > One possibility is to conditionally add _Pragma()  \n> > \n> > No. That compiler warning is pure and utter garbage. I have pointed it\n> > out fopr *years*, and compiler people don't get it.\n> > \n> > So that warning just needs to die. It's shit. It's wrong.\n> \n> True - especially for code like:\n> \tif (x < 0 || x > limit)\n> \t\treturn ...\n> where the code is correct even with 'accidental' conversion of a\n> negative signed value to a large unsigned one.\n> \n> clang seems to have a dozen similar warnings, all of which are a PITA\n> for kernel code - like rejecting !(4 << 16).\n\nIn this example is 4 a literal or do we at least know that 4 is\nnon-zero?\n\nI really thought I had a check for that in Smatch but I guess I\ndon't...\n\nregards,\ndan carpenter\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613244217123.mbox",
          "message_id": "<aUT_yWin_xslnOFh () derry ! ads ! avm ! de>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:33:29+00:00",
          "date_str": "Fri, 19 Dec 2025 07:33:29 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n> I often read on the mailing list people saying \"who cares about W=2\n> builds anyway?\". At least I do. Not that I want to fix all of them,\n> but on some occasions, such as new driver submissions, I have often\n> found a couple valid diagnostics in the W=2 output.\n> \n> That said, the annoying thing is that W=2 is heavily polluted by one\n> warning: -Wtype-limits. Try a gcc W=2 build on any file and see the\n> results for yourself. I suspect this to be the reason why so few\n> people are using W=2.\n> \n> This series removes gcc's -Wtype-limits in an attempt to make W=2 more\n> useful. Those who do not use W=2 can continue to not use it if they\n> want. Those who, like me, use it form time to time will get an\n> improved experience from the reduced spam.\n> \n> Extra details on statistics, past attempts and -Wtype-limits\n> alternatives are given in the first patch description.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Vincent Mailhol (2):\n>       kbuild: remove gcc's -Wtype-limits\n>       kbuild: cleanup local -Wno-type-limits exceptions\n> \n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  scripts/Makefile.warn    | 4 +++-\n>  3 files changed, 3 insertions(+), 3 deletions(-)\n> ---\n> base-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\n> change-id: 20251205-remove_wtype-limits-c77eb46d09c2\n> \n> Best regards,\n> -- \n> Vincent Mailhol <mailhol@kernel.org>\n> \n\nThanks for the effort!  (This allows to revert commit dc7fe518b049\n(\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613241417093.mbox",
          "message_id": "<aUT_yWin_xslnOFh () derry ! ads ! avm ! de>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:33:29+00:00",
          "date_str": "Fri, 19 Dec 2025 07:33:29 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n> I often read on the mailing list people saying \"who cares about W=2\n> builds anyway?\". At least I do. Not that I want to fix all of them,\n> but on some occasions, such as new driver submissions, I have often\n> found a couple valid diagnostics in the W=2 output.\n> \n> That said, the annoying thing is that W=2 is heavily polluted by one\n> warning: -Wtype-limits. Try a gcc W=2 build on any file and see the\n> results for yourself. I suspect this to be the reason why so few\n> people are using W=2.\n> \n> This series removes gcc's -Wtype-limits in an attempt to make W=2 more\n> useful. Those who do not use W=2 can continue to not use it if they\n> want. Those who, like me, use it form time to time will get an\n> improved experience from the reduced spam.\n> \n> Extra details on statistics, past attempts and -Wtype-limits\n> alternatives are given in the first patch description.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Vincent Mailhol (2):\n>       kbuild: remove gcc's -Wtype-limits\n>       kbuild: cleanup local -Wno-type-limits exceptions\n> \n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  scripts/Makefile.warn    | 4 +++-\n>  3 files changed, 3 insertions(+), 3 deletions(-)\n> ---\n> base-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\n> change-id: 20251205-remove_wtype-limits-c77eb46d09c2\n> \n> Best regards,\n> -- \n> Vincent Mailhol <mailhol@kernel.org>\n> \n\nThanks for the effort!  (This allows to revert commit dc7fe518b049\n(\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613241717097.mbox",
          "message_id": "<aUT_yWin_xslnOFh () derry ! ads ! avm ! de>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:33:29+00:00",
          "date_str": "Fri, 19 Dec 2025 07:33:29 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n> I often read on the mailing list people saying \"who cares about W=2\n> builds anyway?\". At least I do. Not that I want to fix all of them,\n> but on some occasions, such as new driver submissions, I have often\n> found a couple valid diagnostics in the W=2 output.\n> \n> That said, the annoying thing is that W=2 is heavily polluted by one\n> warning: -Wtype-limits. Try a gcc W=2 build on any file and see the\n> results for yourself. I suspect this to be the reason why so few\n> people are using W=2.\n> \n> This series removes gcc's -Wtype-limits in an attempt to make W=2 more\n> useful. Those who do not use W=2 can continue to not use it if they\n> want. Those who, like me, use it form time to time will get an\n> improved experience from the reduced spam.\n> \n> Extra details on statistics, past attempts and -Wtype-limits\n> alternatives are given in the first patch description.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Vincent Mailhol (2):\n>       kbuild: remove gcc's -Wtype-limits\n>       kbuild: cleanup local -Wno-type-limits exceptions\n> \n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  scripts/Makefile.warn    | 4 +++-\n>  3 files changed, 3 insertions(+), 3 deletions(-)\n> ---\n> base-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\n> change-id: 20251205-remove_wtype-limits-c77eb46d09c2\n> \n> Best regards,\n> -- \n> Vincent Mailhol <mailhol@kernel.org>\n> \n\nThanks for the effort!  (This allows to revert commit dc7fe518b049\n(\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613241817101.mbox",
          "message_id": "<aUT_yWin_xslnOFh () derry ! ads ! avm ! de>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:33:29+00:00",
          "date_str": "Fri, 19 Dec 2025 07:33:29 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n> I often read on the mailing list people saying \"who cares about W=2\n> builds anyway?\". At least I do. Not that I want to fix all of them,\n> but on some occasions, such as new driver submissions, I have often\n> found a couple valid diagnostics in the W=2 output.\n> \n> That said, the annoying thing is that W=2 is heavily polluted by one\n> warning: -Wtype-limits. Try a gcc W=2 build on any file and see the\n> results for yourself. I suspect this to be the reason why so few\n> people are using W=2.\n> \n> This series removes gcc's -Wtype-limits in an attempt to make W=2 more\n> useful. Those who do not use W=2 can continue to not use it if they\n> want. Those who, like me, use it form time to time will get an\n> improved experience from the reduced spam.\n> \n> Extra details on statistics, past attempts and -Wtype-limits\n> alternatives are given in the first patch description.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Vincent Mailhol (2):\n>       kbuild: remove gcc's -Wtype-limits\n>       kbuild: cleanup local -Wno-type-limits exceptions\n> \n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  scripts/Makefile.warn    | 4 +++-\n>  3 files changed, 3 insertions(+), 3 deletions(-)\n> ---\n> base-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\n> change-id: 20251205-remove_wtype-limits-c77eb46d09c2\n> \n> Best regards,\n> -- \n> Vincent Mailhol <mailhol@kernel.org>\n> \n\nThanks for the effort!  (This allows to revert commit dc7fe518b049\n(\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176613243517116.mbox",
          "message_id": "<aUT_yWin_xslnOFh () derry ! ads ! avm ! de>",
          "author_name": "Nicolas Schier",
          "author_email": "nsc () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 07:33:29+00:00",
          "date_str": "Fri, 19 Dec 2025 07:33:29 +0000",
          "body": "On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n> I often read on the mailing list people saying \"who cares about W=2\n> builds anyway?\". At least I do. Not that I want to fix all of them,\n> but on some occasions, such as new driver submissions, I have often\n> found a couple valid diagnostics in the W=2 output.\n> \n> That said, the annoying thing is that W=2 is heavily polluted by one\n> warning: -Wtype-limits. Try a gcc W=2 build on any file and see the\n> results for yourself. I suspect this to be the reason why so few\n> people are using W=2.\n> \n> This series removes gcc's -Wtype-limits in an attempt to make W=2 more\n> useful. Those who do not use W=2 can continue to not use it if they\n> want. Those who, like me, use it form time to time will get an\n> improved experience from the reduced spam.\n> \n> Extra details on statistics, past attempts and -Wtype-limits\n> alternatives are given in the first patch description.\n> \n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Vincent Mailhol (2):\n>       kbuild: remove gcc's -Wtype-limits\n>       kbuild: cleanup local -Wno-type-limits exceptions\n> \n>  drivers/gpu/drm/Makefile | 1 -\n>  fs/btrfs/Makefile        | 1 -\n>  scripts/Makefile.warn    | 4 +++-\n>  3 files changed, 3 insertions(+), 3 deletions(-)\n> ---\n> base-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\n> change-id: 20251205-remove_wtype-limits-c77eb46d09c2\n> \n> Best regards,\n> -- \n> Vincent Mailhol <mailhol@kernel.org>\n> \n\nThanks for the effort!  (This allows to revert commit dc7fe518b049\n(\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\n\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618477327658.mbox",
          "message_id": "<8c9f2a57-9541-427e-b5ac-aade03f85f65 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:06:05+00:00",
          "date_str": "Fri, 19 Dec 2025 22:06:05 +0000",
          "body": "On 19/12/2025 at 08:33, Nicolas Schier wrote:\n> On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n> Thanks for the effort!  (This allows to revert commit dc7fe518b049\n> (\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nAck. I will send a v2 with more patches to cleanup some -Wtype-limits workarounds.\n\n> Reviewed-by: Nicolas Schier <nsc@kernel.org>\n\nThanks!\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618477527668.mbox",
          "message_id": "<8c9f2a57-9541-427e-b5ac-aade03f85f65 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:06:05+00:00",
          "date_str": "Fri, 19 Dec 2025 22:06:05 +0000",
          "body": "On 19/12/2025 at 08:33, Nicolas Schier wrote:\n> On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n> Thanks for the effort!  (This allows to revert commit dc7fe518b049\n> (\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nAck. I will send a v2 with more patches to cleanup some -Wtype-limits workarounds.\n\n> Reviewed-by: Nicolas Schier <nsc@kernel.org>\n\nThanks!\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618477327664.mbox",
          "message_id": "<8c9f2a57-9541-427e-b5ac-aade03f85f65 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:06:05+00:00",
          "date_str": "Fri, 19 Dec 2025 22:06:05 +0000",
          "body": "On 19/12/2025 at 08:33, Nicolas Schier wrote:\n> On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n> Thanks for the effort!  (This allows to revert commit dc7fe518b049\n> (\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nAck. I will send a v2 with more patches to cleanup some -Wtype-limits workarounds.\n\n> Reviewed-by: Nicolas Schier <nsc@kernel.org>\n\nThanks!\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618477327661.mbox",
          "message_id": "<8c9f2a57-9541-427e-b5ac-aade03f85f65 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:06:05+00:00",
          "date_str": "Fri, 19 Dec 2025 22:06:05 +0000",
          "body": "On 19/12/2025 at 08:33, Nicolas Schier wrote:\n> On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n> Thanks for the effort!  (This allows to revert commit dc7fe518b049\n> (\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nAck. I will send a v2 with more patches to cleanup some -Wtype-limits workarounds.\n\n> Reviewed-by: Nicolas Schier <nsc@kernel.org>\n\nThanks!\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618477427667.mbox",
          "message_id": "<8c9f2a57-9541-427e-b5ac-aade03f85f65 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 0/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:06:05+00:00",
          "date_str": "Fri, 19 Dec 2025 22:06:05 +0000",
          "body": "On 19/12/2025 at 08:33, Nicolas Schier wrote:\n> On Thu, Dec 18, 2025 at 07:50:00PM +0100, Vincent Mailhol wrote:\n\n(...)\n\n> Thanks for the effort!  (This allows to revert commit dc7fe518b049\n> (\"overflow: Fix -Wtype-limits compilation warnings\").)\n\nAck. I will send a v2 with more patches to cleanup some -Wtype-limits workarounds.\n\n> Reviewed-by: Nicolas Schier <nsc@kernel.org>\n\nThanks!\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618572028239.mbox",
          "message_id": "<3ead6685-a5d4-4113-923d-84bf8aee49b3 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:21:51+00:00",
          "date_str": "Fri, 19 Dec 2025 22:21:51 +0000",
          "body": "On 18/12/2025 at 23:31, Vincent Mailhol wrote:\n\n(...)\n\n> Concerning clang, here are the statistics:\n> \n> \t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n> \t      2 [-Wtautological-type-limit-compare]\n> \t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n> \n> (done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n> \n> Not so many warnings, at least, less than what I would have thought!\n> \n> -Wtautological-unsigned-char-zero-compare and\n> -Wtautological-unsigned-zero-compare gave zero findings. So those two\n> can be enabled, I guess? I am still surprised that\n> -Wtautological-unsigned-zero-compare gives nothing. I would have\n> expected some kind of false positives on that one. No sure if I missed\n> something here.\n\nI was a bit worried of that -Wtautological-unsigned-zero-compare got\nzero findings so I reran a build but this time on an allyesconfig\n(minus CONFIG_WERROR):\n\n\t$ make -j8 -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t     29 [-Wtautological-type-limit-compare]\n\t     55 [-Wtautological-unsigned-enum-zero-compare]\n\t     76 [-Wtautological-unsigned-zero-compare]\n\nThis is closer than expected. And looking at the findings,\n-Wtautological-unsigned-zero-compare also warns on some sane code\nwhich is just doing some range checks.\n\n(...)\n\n> In conclusion, I agree that we could enable three of clang's\n> -Wtype-limits sub-warning. But this is not the scope of that series. I\n> would rather prefer to have this as a separate series.\n\nWith this, I want to amend my conclusion. both\n-Wtautological-unsigned-enum-zero-compare and\n-Wtautological-unsigned-zero-compare should be kept disabled. The only\ncandidates are -Wtautological-type-limit-compare and\n-Wtautological-unsigned-char-zero-compare.\n\n-Wtautological-unsigned-char-zero-compare would need another study. It\nseems that this warning is only triggered on platforms where char is\nunsigned which explains why I did not see it when building on x86_64.\n\nWell, I think I will stop this clang's -Wtype-limits study for the\nmoment. If anyone wants to continue the work please go ahead.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618571828233.mbox",
          "message_id": "<3ead6685-a5d4-4113-923d-84bf8aee49b3 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:21:51+00:00",
          "date_str": "Fri, 19 Dec 2025 22:21:51 +0000",
          "body": "On 18/12/2025 at 23:31, Vincent Mailhol wrote:\n\n(...)\n\n> Concerning clang, here are the statistics:\n> \n> \t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n> \t      2 [-Wtautological-type-limit-compare]\n> \t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n> \n> (done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n> \n> Not so many warnings, at least, less than what I would have thought!\n> \n> -Wtautological-unsigned-char-zero-compare and\n> -Wtautological-unsigned-zero-compare gave zero findings. So those two\n> can be enabled, I guess? I am still surprised that\n> -Wtautological-unsigned-zero-compare gives nothing. I would have\n> expected some kind of false positives on that one. No sure if I missed\n> something here.\n\nI was a bit worried of that -Wtautological-unsigned-zero-compare got\nzero findings so I reran a build but this time on an allyesconfig\n(minus CONFIG_WERROR):\n\n\t$ make -j8 -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t     29 [-Wtautological-type-limit-compare]\n\t     55 [-Wtautological-unsigned-enum-zero-compare]\n\t     76 [-Wtautological-unsigned-zero-compare]\n\nThis is closer than expected. And looking at the findings,\n-Wtautological-unsigned-zero-compare also warns on some sane code\nwhich is just doing some range checks.\n\n(...)\n\n> In conclusion, I agree that we could enable three of clang's\n> -Wtype-limits sub-warning. But this is not the scope of that series. I\n> would rather prefer to have this as a separate series.\n\nWith this, I want to amend my conclusion. both\n-Wtautological-unsigned-enum-zero-compare and\n-Wtautological-unsigned-zero-compare should be kept disabled. The only\ncandidates are -Wtautological-type-limit-compare and\n-Wtautological-unsigned-char-zero-compare.\n\n-Wtautological-unsigned-char-zero-compare would need another study. It\nseems that this warning is only triggered on platforms where char is\nunsigned which explains why I did not see it when building on x86_64.\n\nWell, I think I will stop this clang's -Wtype-limits study for the\nmoment. If anyone wants to continue the work please go ahead.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618573428267.mbox",
          "message_id": "<3ead6685-a5d4-4113-923d-84bf8aee49b3 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:21:51+00:00",
          "date_str": "Fri, 19 Dec 2025 22:21:51 +0000",
          "body": "On 18/12/2025 at 23:31, Vincent Mailhol wrote:\n\n(...)\n\n> Concerning clang, here are the statistics:\n> \n> \t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n> \t      2 [-Wtautological-type-limit-compare]\n> \t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n> \n> (done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n> \n> Not so many warnings, at least, less than what I would have thought!\n> \n> -Wtautological-unsigned-char-zero-compare and\n> -Wtautological-unsigned-zero-compare gave zero findings. So those two\n> can be enabled, I guess? I am still surprised that\n> -Wtautological-unsigned-zero-compare gives nothing. I would have\n> expected some kind of false positives on that one. No sure if I missed\n> something here.\n\nI was a bit worried of that -Wtautological-unsigned-zero-compare got\nzero findings so I reran a build but this time on an allyesconfig\n(minus CONFIG_WERROR):\n\n\t$ make -j8 -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t     29 [-Wtautological-type-limit-compare]\n\t     55 [-Wtautological-unsigned-enum-zero-compare]\n\t     76 [-Wtautological-unsigned-zero-compare]\n\nThis is closer than expected. And looking at the findings,\n-Wtautological-unsigned-zero-compare also warns on some sane code\nwhich is just doing some range checks.\n\n(...)\n\n> In conclusion, I agree that we could enable three of clang's\n> -Wtype-limits sub-warning. But this is not the scope of that series. I\n> would rather prefer to have this as a separate series.\n\nWith this, I want to amend my conclusion. both\n-Wtautological-unsigned-enum-zero-compare and\n-Wtautological-unsigned-zero-compare should be kept disabled. The only\ncandidates are -Wtautological-type-limit-compare and\n-Wtautological-unsigned-char-zero-compare.\n\n-Wtautological-unsigned-char-zero-compare would need another study. It\nseems that this warning is only triggered on platforms where char is\nunsigned which explains why I did not see it when building on x86_64.\n\nWell, I think I will stop this clang's -Wtype-limits study for the\nmoment. If anyone wants to continue the work please go ahead.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618572028240.mbox",
          "message_id": "<3ead6685-a5d4-4113-923d-84bf8aee49b3 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:21:51+00:00",
          "date_str": "Fri, 19 Dec 2025 22:21:51 +0000",
          "body": "On 18/12/2025 at 23:31, Vincent Mailhol wrote:\n\n(...)\n\n> Concerning clang, here are the statistics:\n> \n> \t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n> \t      2 [-Wtautological-type-limit-compare]\n> \t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n> \n> (done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n> \n> Not so many warnings, at least, less than what I would have thought!\n> \n> -Wtautological-unsigned-char-zero-compare and\n> -Wtautological-unsigned-zero-compare gave zero findings. So those two\n> can be enabled, I guess? I am still surprised that\n> -Wtautological-unsigned-zero-compare gives nothing. I would have\n> expected some kind of false positives on that one. No sure if I missed\n> something here.\n\nI was a bit worried of that -Wtautological-unsigned-zero-compare got\nzero findings so I reran a build but this time on an allyesconfig\n(minus CONFIG_WERROR):\n\n\t$ make -j8 -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t     29 [-Wtautological-type-limit-compare]\n\t     55 [-Wtautological-unsigned-enum-zero-compare]\n\t     76 [-Wtautological-unsigned-zero-compare]\n\nThis is closer than expected. And looking at the findings,\n-Wtautological-unsigned-zero-compare also warns on some sane code\nwhich is just doing some range checks.\n\n(...)\n\n> In conclusion, I agree that we could enable three of clang's\n> -Wtype-limits sub-warning. But this is not the scope of that series. I\n> would rather prefer to have this as a separate series.\n\nWith this, I want to amend my conclusion. both\n-Wtautological-unsigned-enum-zero-compare and\n-Wtautological-unsigned-zero-compare should be kept disabled. The only\ncandidates are -Wtautological-type-limit-compare and\n-Wtautological-unsigned-char-zero-compare.\n\n-Wtautological-unsigned-char-zero-compare would need another study. It\nseems that this warning is only triggered on platforms where char is\nunsigned which explains why I did not see it when building on x86_64.\n\nWell, I think I will stop this clang's -Wtype-limits study for the\nmoment. If anyone wants to continue the work please go ahead.\n\n\nYours sincerely,\nVincent Mailhol",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618571728229.mbox",
          "message_id": "<3ead6685-a5d4-4113-923d-84bf8aee49b3 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH 1/2] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:21:51+00:00",
          "date_str": "Fri, 19 Dec 2025 22:21:51 +0000",
          "body": "On 18/12/2025 at 23:31, Vincent Mailhol wrote:\n\n(...)\n\n> Concerning clang, here are the statistics:\n> \n> \t$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n> \t      2 [-Wtautological-type-limit-compare]\n> \t     15 [-Wtautological-unsigned-enum-zero-compare]$ make -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\"\n> \n> (done on a linux v6.19-rc1 defconfig with clang v20.1.8)\n> \n> Not so many warnings, at least, less than what I would have thought!\n> \n> -Wtautological-unsigned-char-zero-compare and\n> -Wtautological-unsigned-zero-compare gave zero findings. So those two\n> can be enabled, I guess? I am still surprised that\n> -Wtautological-unsigned-zero-compare gives nothing. I would have\n> expected some kind of false positives on that one. No sure if I missed\n> something here.\n\nI was a bit worried of that -Wtautological-unsigned-zero-compare got\nzero findings so I reran a build but this time on an allyesconfig\n(minus CONFIG_WERROR):\n\n\t$ make -j8 -s LLVM=1 CFLAGS_KERNEL=\"-Wtype-limits\" 2>&1 | grep -o '\\[-W\\S*\\]' | sort | uniq -c\n\t     29 [-Wtautological-type-limit-compare]\n\t     55 [-Wtautological-unsigned-enum-zero-compare]\n\t     76 [-Wtautological-unsigned-zero-compare]\n\nThis is closer than expected. And looking at the findings,\n-Wtautological-unsigned-zero-compare also warns on some sane code\nwhich is just doing some range checks.\n\n(...)\n\n> In conclusion, I agree that we could enable three of clang's\n> -Wtype-limits sub-warning. But this is not the scope of that series. I\n> would rather prefer to have this as a separate series.\n\nWith this, I want to amend my conclusion. both\n-Wtautological-unsigned-enum-zero-compare and\n-Wtautological-unsigned-zero-compare should be kept disabled. The only\ncandidates are -Wtautological-type-limit-compare and\n-Wtautological-unsigned-char-zero-compare.\n\n-Wtautological-unsigned-char-zero-compare would need another study. It\nseems that this warning is only triggered on platforms where char is\nunsigned which explains why I did not see it when building on x86_64.\n\nWell, I think I will stop this clang's -Wtype-limits study for the\nmoment. If anyone wants to continue the work please go ahead.\n\n\nYours sincerely,\nVincent Mailhol\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618681928986.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-0-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 0/4] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:39:44+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:44 +0000",
          "body": "I often read on the mailing list people saying \"who cares about W=2\nbuilds anyway?\". At least I do. Not that I want to fix all of them,\nbut on some occasions, such as new driver submissions, I have often\nfound a couple valid diagnostics in the W=2 output.\n\nThat said, the annoying thing is that W=2 is heavily polluted by one\nwarning: -Wtype-limits. Try a gcc W=2 build on any file and see the\nresults for yourself. I suspect this to be the reason why so few\npeople are using W=2.\n\nThis series removes gcc's -Wtype-limits in an attempt to make W=2 more\nuseful. Those who do not use W=2 can continue to not use it if they\nwant. Those who, like me, use it for time to time will get an improved\nexperience from the reduced spam.\n\nPatch #1 deactivates -Wtype-limits.  Extra details on statistics, past\nattempts and alternatives are given in the description.\n\nPatch #2 clean-ups the local kbuild -Wno-type-limits exceptions,\npatches #3 and #4 undo some of the local workarounds which silenced\nthat warning by uglifying the code.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChanges in v2:\n\n  - Add two more patches to clean up some -Wtype-limits workarounds\n  - Collect the Reviewed-by tags.\n\nLink to v1: https://lore.kernel.org/r/20251218-remove_wtype-limits-v1-0-735417536787@kernel.org\n\n---\nVincent Mailhol (4):\n      kbuild: remove gcc's -Wtype-limits\n      kbuild: cleanup local -Wno-type-limits exceptions\n      overflow: Remove is_non_negative() and is_negative()\n      minmax: remove useless cast in __is_nonneg()\n\n drivers/gpu/drm/Makefile |  1 -\n fs/btrfs/Makefile        |  1 -\n include/linux/minmax.h   |  5 +----\n include/linux/overflow.h | 10 ++--------\n scripts/Makefile.warn    |  4 +++-\n 5 files changed, 6 insertions(+), 15 deletions(-)\n---\nbase-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\nchange-id: 20251205-remove_wtype-limits-c77eb46d09c2\n\nBest regards,\n-- \nVincent Mailhol <mailhol@kernel.org>\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176618687029074.mbox",
          "message_id": "<20251219-remove_wtype-limits-v2-1-2e92b3f566c5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v2 1/4] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-19 22:39:45+00:00",
          "date_str": "Fri, 19 Dec 2025 22:39:45 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623138921441.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-0-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 0/3] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-20 11:02:18+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:18 +0000",
          "body": "I often read on the mailing list people saying \"who cares about W=2\nbuilds anyway?\". At least I do. Not that I want to fix all of them,\nbut on some occasions, such as new driver submissions, I have often\nfound a couple valid diagnostics in the W=2 output.\n\nThat said, the annoying thing is that W=2 is heavily polluted by one\nwarning: -Wtype-limits. Try a gcc W=2 build on any file and see the\nresults for yourself. I suspect this to be the reason why so few\npeople are using W=2.\n\nThis series removes gcc's -Wtype-limits in an attempt to make W=2 more\nuseful. Those who do not use W=2 can continue to not use it if they\nwant. Those who, like me, use it for time to time will get an improved\nexperience from the reduced spam.\n\nPatch #1 deactivates -Wtype-limits.  Extra details on statistics, past\nattempts and alternatives are given in the description.\n\nPatch #2 clean-ups the local kbuild -Wno-type-limits exceptions, while\npatch #3 undoes a local workaround which silenced that warning by\nuglifying the code.\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nChanges in v3:\n\n  - Remove patch #4.\n\nLink to v2: https://lore.kernel.org/r/20251219-remove_wtype-limits-v2-0-2e92b3f566c5@kernel.org\n\nChanges in v2:\n\n  - Add two more patches to clean up some -Wtype-limits workarounds\n  - Collect the Reviewed-by tags.\n\nLink to v1: https://lore.kernel.org/r/20251218-remove_wtype-limits-v1-0-735417536787@kernel.org\n\n---\nVincent Mailhol (3):\n      kbuild: remove gcc's -Wtype-limits\n      kbuild: cleanup local -Wno-type-limits exceptions\n      overflow: Remove is_non_negative() and is_negative()\n\n drivers/gpu/drm/Makefile |  1 -\n fs/btrfs/Makefile        |  1 -\n include/linux/overflow.h | 10 ++--------\n scripts/Makefile.warn    |  4 +++-\n 4 files changed, 5 insertions(+), 11 deletions(-)\n---\nbase-commit: 3e7f562e20ee87a25e104ef4fce557d39d62fa85\nchange-id: 20251205-remove_wtype-limits-c77eb46d09c2\n\nBest regards,\n-- \nVincent Mailhol <mailhol@kernel.org>\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2025/12/176623140221482.mbox",
          "message_id": "<20251220-remove_wtype-limits-v3-1-24b170af700e () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH v3 1/3] kbuild: remove gcc's -Wtype-limits",
          "date": "2025-12-20 11:02:19+00:00",
          "date_str": "Sat, 20 Dec 2025 11:02:19 +0000",
          "body": "W=2 builds are heavily polluted by the -Wtype-limits warning.\n\nHere are some W=12 statistics on Linux v6.19-rc1 for an x86_64\ndefconfig (with just CONFIG_WERROR set to \"n\") using gcc 14.3.1:\n\n\t Warning name\t\t\tcount\tpercent\n\t-------------------------------------------------\n\t -Wlogical-op\t\t\t    2\t  0.00 %\n\t -Wmaybe-uninitialized\t\t  138\t  0.20 %\n\t -Wunused-macros\t\t  869\t  1.24 %\n\t -Wmissing-field-initializers\t 1418\t  2.02 %\n\t -Wshadow\t\t\t 2234\t  3.19 %\n\t -Wtype-limits\t\t\t65378\t 93.35 %\n\t-------------------------------------------------\n\t Total\t\t\t\t70039\t100.00 %\n\nAs we can see, -Wtype-limits represents the vast majority of all\nwarnings. The reason behind this is that these warnings appear in\nsome common header files, meaning that some unique warnings are\nrepeated tens of thousands of times (once per header inclusion).\n\nAdd to this the fact that each warning is coupled with a dozen lines\ndetailing some macro expansion. The end result is that the W=2 output\nis just too bloated and painful to use.\n\nThree years ago, I proposed in [1] modifying one such header to\nsilence that noise. Because the code was not faulty, Linus rejected\nthe idea and instead suggested simply removing that warning.\n\nAt that time, I could not bring myself to send such a patch because,\ndespite its problems, -Wtype-limits would still catch the below bug:\n\n\tunsigned int ret;\n\n\tret = check();\n\tif (ret < 0)\n\t\terror();\n\nMeanwhile, based on another suggestion from Linus, I added a new check\nto sparse [2] that would catch the above bug without the useless spam.\n\nWith this, remove gcc's -Wtype-limits. People who still want to catch\nincorrect comparisons between unsigned integers and zero can now use\nsparse instead.\n\nOn a side note, clang also has a -Wtype-limits warning but:\n\n  * it is not enabled in the kernel at the moment because, contrary to\n    gcc, clang did not include it under -Wextra.\n\n  * it does not warn if the code results from a macro expansion. So,\n    if activated, it would not cause as much spam as gcc does.\n\n  * -Wtype-limits is split into four sub-warnings [3] meaning that if\n    it were to be activated, we could select which one to keep.\n\nSo there is no present need to explicitly disable -Wtype-limits in\nclang.\n\n[1] linux/bits.h: GENMASK_INPUT_CHECK: reduce W=2 noise by 31% treewide\nLink: https://lore.kernel.org/all/20220308141201.2343757-1-mailhol.vincent@wanadoo.fr/\n\n[2] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/all/20250921061337.3047616-1-mailhol@kernel.org/\n\n[3] clang's -Wtype-limits\nLink: https://clang.llvm.org/docs/DiagnosticsReference.html#wtype-limits\n\nReviewed-by: Nicolas Schier <nsc@kernel.org>\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\n scripts/Makefile.warn | 4 +++-\n 1 file changed, 3 insertions(+), 1 deletion(-)\n\ndiff --git a/scripts/Makefile.warn b/scripts/Makefile.warn\nindex 68e6fafcb80c..c593ab1257de 100644\n--- a/scripts/Makefile.warn\n+++ b/scripts/Makefile.warn\n@@ -55,6 +55,9 @@ else\n KBUILD_CFLAGS += -Wno-main\n endif\n \n+# Too noisy on range checks and in macros handling both signed and unsigned.\n+KBUILD_CFLAGS += -Wno-type-limits\n+\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-option, -Wno-dangling-pointer)\n \n@@ -174,7 +177,6 @@ else\n \n # The following turn off the warnings enabled by -Wextra\n KBUILD_CFLAGS += -Wno-missing-field-initializers\n-KBUILD_CFLAGS += -Wno-type-limits\n KBUILD_CFLAGS += -Wno-shift-negative-value\n \n ifdef CONFIG_CC_IS_CLANG\n\n-- \n2.51.2\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2026/01/176766026100607.mbox",
          "message_id": "<176765740692.3236304.10853846154010651497.b4-ty () kernel ! org>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 0/3] kbuild: remove gcc's -Wtype-limits",
          "date": "2026-01-05 23:56:46+00:00",
          "date_str": "Mon, 05 Jan 2026 23:56:46 +0000",
          "body": "On Sat, 20 Dec 2025 12:02:18 +0100, Vincent Mailhol wrote:\n> I often read on the mailing list people saying \"who cares about W=2\n> builds anyway?\". At least I do. Not that I want to fix all of them,\n> but on some occasions, such as new driver submissions, I have often\n> found a couple valid diagnostics in the W=2 output.\n> \n> That said, the annoying thing is that W=2 is heavily polluted by one\n> warning: -Wtype-limits. Try a gcc W=2 build on any file and see the\n> results for yourself. I suspect this to be the reason why so few\n> people are using W=2.\n> \n> [...]\n\nApplied to\n\n  https://git.kernel.org/pub/scm/linux/kernel/git/kbuild/linux.git kbuild-next\n\nThanks!\n\n[1/3] kbuild: remove gcc's -Wtype-limits\n      https://git.kernel.org/kbuild/c/660e899103e29\n[2/3] kbuild: cleanup local -Wno-type-limits exceptions\n      https://git.kernel.org/kbuild/c/34a1bd0b6b2c0\n[3/3] overflow: Remove is_non_negative() and is_negative()\n      https://git.kernel.org/kbuild/c/5ce3218d4f102\n\nPlease look out for regression or issue reports or other follow up\ncomments, as they may result in the patch/series getting dropped or\nreverted.\n\nBest regards,\n-- \nNathan Chancellor <nathan@kernel.org>\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
      "normalized_subject": "sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
      "message_count": 7,
      "participants": [
        "Chris Li",
        "Oleg Nesterov"
      ],
      "categories": [
        "compiler_compat",
        "rfc_proposals"
      ],
      "first_date": "2025-12-17T15:17:44+00:00",
      "last_date": "2026-01-19T12:32:56+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2026/01/176598951422945.mbox",
          "message_id": "<aULJmGi8yib_XH0P () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2025-12-17 15:17:44+00:00",
          "date_str": "Wed, 17 Dec 2025 15:17:44 +0000",
          "body": "I don't quite understand why does expand() -> collect_arg() path\nupdate ->pos for each token in the input *list, but this breaks\ndissect and thus semind.\n\nTest-case:\n\n\t$ cat -n PP_POS.c\n\t     1\t#define READ_ONCE(x) x\n\t     2\t#define WRITE_ONCE(x, y) x = y\n\t     3\n\t     4\tint R, W;\n\t     5\n\t     6\tvoid func(void)\n\t     7\t{\n\t     8\t  WRITE_ONCE(\n\t     9\t     W,\n\t    10\t     READ_ONCE(R)\n\t    11\t  );\n\t    12\t}\n\n\t$ ./test-dissect PP_POS.c\n\t   4:5                    def   v R                                int\n\t   4:8                    def   v W                                int\n\t   6:6                    def   f func                             void ( ... )\n\t   8:3   func             -w-   v W                                int\n\t   8:3   func             -r-   v R                                int\n\nThe reported positions of the usage of R and W are wrong,\nand thus ./semind doesn't work:\n\n\t$ ./semind add PP_POS.c\n\t$ ./semind search -l PP_POS.c:10:16\n\nWith this patch:\n\n\t$ ./test-dissect PP_POS.c\n\t   4:5                    def   v R                                int\n\t   4:8                    def   v W                                int\n\t   6:6                    def   f func                             void ( ... )\n\t   9:6   func             -w-   v W                                int\n\t  10:16  func             -r-   v R                                int\n\n\t$ ./semind add PP_POS.c\n\t$ ./semind search -l PP_POS.c:10:16\n\t(def) PP_POS.c\t4\t5\t\tint R, W;\n\t(-r-) PP_POS.c\t10\t16\tfunc\tREAD_ONCE(R)\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n dissect.c     | 1 +\n options.c     | 1 +\n options.h     | 1 +\n pre-process.c | 8 +++++---\n 4 files changed, 8 insertions(+), 3 deletions(-)\n\ndiff --git a/dissect.c b/dissect.c\nindex a6003afa..5fed8e22 100644\n--- a/dissect.c\n+++ b/dissect.c\n@@ -714,6 +714,7 @@ end:\n \n void dissect(struct reporter *rep, struct string_list *filelist)\n {\n+\tdissect_mode = 1;\n \treporter = rep;\n \n \tDO_LIST(filelist, file, do_file(file));\ndiff --git a/options.c b/options.c\nindex 6ee4d878..0f207e80 100644\n--- a/options.c\n+++ b/options.c\n@@ -71,6 +71,7 @@ int dump_macro_defs = 0;\n int dump_macros_only = 0;\n \n int dissect_show_all_symbols = 0;\n+int dissect_mode = 0;\n \n unsigned long fdump_ir;\n int fhosted = 1;\ndiff --git a/options.h b/options.h\nindex c2a9551a..b559254d 100644\n--- a/options.h\n+++ b/options.h\n@@ -71,6 +71,7 @@ extern int dump_macro_defs;\n extern int dump_macros_only;\n \n extern int dissect_show_all_symbols;\n+extern int dissect_mode;\n \n extern unsigned long fdump_ir;\n extern int fhosted;\ndiff --git a/pre-process.c b/pre-process.c\nindex 3fb25082..64445881 100644\n--- a/pre-process.c\n+++ b/pre-process.c\n@@ -294,9 +294,11 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position\n \t\t} else if (match_op(next, ',') && !nesting && !vararg) {\n \t\t\tbreak;\n \t\t}\n-\t\tnext->pos.stream = pos->stream;\n-\t\tnext->pos.line = pos->line;\n-\t\tnext->pos.pos = pos->pos;\n+\t\tif (!dissect_mode) {\n+\t\t\tnext->pos.stream = pos->stream;\n+\t\t\tnext->pos.line = pos->line;\n+\t\t\tnext->pos.pos = pos->pos;\n+\t\t}\n \t\tnext->pos.newline = 0;\n \t\tp = &next->next;\n \t}\n-- \n2.52.0\n\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176860896327868.mbox",
          "message_id": "<CACePvbW2OybP7P-Vk+pa23SqA0+R0i8=20TiQMq99PvNAYJ8GA () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2026-01-16 23:29:41+00:00",
          "date_str": "Fri, 16 Jan 2026 23:29:41 +0000",
          "body": "Hi Oleg,\n\nSlowly catching up my back log from the holidays.\n\nOn Wed, Dec 17, 2025 at 7:26=E2=80=AFAM Oleg Nesterov <oleg@redhat.com> wro=\nte:\n>\n> I don't quite understand why does expand() -> collect_arg() path\n> update ->pos for each token in the input *list, but this breaks\n> dissect and thus semind.\n\nThat is a good question, I don't understand why it did that either. I\ndid some digging, inside macro argument list expansion, the \"#include\n\" is not allowed. It is not possible to switch streams here. The\n\"pos.pos\" is for human consumption anyway, it has no effect on the IR\ngeneration. The only visible effect as far as I can tell is related to\nthe preprocessor \"-E\" in lib.c:\n\n        if (preprocess_only) {\n                while (!eof_token(token)) {\n                        int prec =3D 1;\n                        struct token *next =3D token->next;\n                        const char *separator =3D \"\";\n                        if (next->pos.whitespace)\n                                separator =3D \" \";\n                        if (next->pos.newline) {\n                                separator =3D \"\\n\\t\\t\\t\\t\\t\";\n                                prec =3D next->pos.pos; <--- use pos as\nindentation level.\n                                if (prec > 4)\n                                        prec =3D 4;\n                        }\n                        printf(\"%s%.*s\", show_token(token), prec, separator=\n);\n                        token =3D next;\n\nThe \"-E\" output has some indentation enhancement to turn space into\ntab level indentation. This \"pos\" assignment tries to align the\nindentation context of the input arguments to the same level of the\nexpanding macro name.\n\n> Test-case:\n>\n>         $ cat -n PP_POS.c\n>              1  #define READ_ONCE(x) x\n>              2  #define WRITE_ONCE(x, y) x =3D y\n>              3\n>              4  int R, W;\n>              5\n>              6  void func(void)\n>              7  {\n>              8    WRITE_ONCE(\n>              9       W,\n\nWith your patch, when doing \"-E\", the W will get indentation deeper\nthan WRITE_ONCE.\n\n>             10       READ_ONCE(R)\n>             11    );\n>             12  }\n>\n>         $ ./test-dissect PP_POS.c\n>            4:5                    def   v R                              =\n  int\n>            4:8                    def   v W                              =\n  int\n>            6:6                    def   f func                           =\n  void ( ... )\n>            8:3   func             -w-   v W                              =\n  int\n>            8:3   func             -r-   v R                              =\n  int\n>\n> The reported positions of the usage of R and W are wrong,\n> and thus ./semind doesn't work:\n\nIt seems to me this enhancement can be used on other macro related\nexpansions as well.\n\n>\n>         $ ./semind add PP_POS.c\n>         $ ./semind search -l PP_POS.c:10:16\n>\n> With this patch:\n>\n>         $ ./test-dissect PP_POS.c\n>            4:5                    def   v R                              =\n  int\n>            4:8                    def   v W                              =\n  int\n>            6:6                    def   f func                           =\n  void ( ... )\n>            9:6   func             -w-   v W                              =\n  int\n>           10:16  func             -r-   v R                              =\n  int\n>\n>         $ ./semind add PP_POS.c\n>         $ ./semind search -l PP_POS.c:10:16\n>         (def) PP_POS.c  4       5               int R, W;\n>         (-r-) PP_POS.c  10      16      func    READ_ONCE(R)\n>\n> Signed-off-by: Oleg Nesterov <oleg@redhat.com>\n> ---\n>  dissect.c     | 1 +\n>  options.c     | 1 +\n>  options.h     | 1 +\n>  pre-process.c | 8 +++++---\n>  4 files changed, 8 insertions(+), 3 deletions(-)\n>\n> diff --git a/dissect.c b/dissect.c\n> index a6003afa..5fed8e22 100644\n> --- a/dissect.c\n> +++ b/dissect.c\n> @@ -714,6 +714,7 @@ end:\n>\n>  void dissect(struct reporter *rep, struct string_list *filelist)\n>  {\n> +       dissect_mode =3D 1;\n\nI don't think we need dissect_mode. I am leaning towards enabling it\nall the time, maybe except for the preprocessor only mode.\n\n>         reporter =3D rep;\n>\n>         DO_LIST(filelist, file, do_file(file));\n> diff --git a/options.c b/options.c\n> index 6ee4d878..0f207e80 100644\n> --- a/options.c\n> +++ b/options.c\n> @@ -71,6 +71,7 @@ int dump_macro_defs =3D 0;\n>  int dump_macros_only =3D 0;\n>\n>  int dissect_show_all_symbols =3D 0;\n> +int dissect_mode =3D 0;\n>\n>  unsigned long fdump_ir;\n>  int fhosted =3D 1;\n> diff --git a/options.h b/options.h\n> index c2a9551a..b559254d 100644\n> --- a/options.h\n> +++ b/options.h\n> @@ -71,6 +71,7 @@ extern int dump_macro_defs;\n>  extern int dump_macros_only;\n>\n>  extern int dissect_show_all_symbols;\n> +extern int dissect_mode;\n>\n>  extern unsigned long fdump_ir;\n>  extern int fhosted;\n> diff --git a/pre-process.c b/pre-process.c\n> index 3fb25082..64445881 100644\n> --- a/pre-process.c\n> +++ b/pre-process.c\n> @@ -294,9 +294,11 @@",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176866236325852.mbox",
          "message_id": "<aWuagcDh53AQxEmw () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2026-01-17 14:19:45+00:00",
          "date_str": "Sat, 17 Jan 2026 14:19:45 +0000",
          "body": "Hi Chris,\n\nOn 01/16, Chris Li wrote:\n>\n> On Wed, Dec 17, 2025 at 7:26\u202fAM Oleg Nesterov <oleg@redhat.com> wrote:\n> >\n> > I don't quite understand why does expand() -> collect_arg() path\n> > update ->pos for each token in the input *list, but this breaks\n> > dissect and thus semind.\n>\n> That is a good question, I don't understand why it did that either. I\n> did some digging, inside macro argument list expansion, the \"#include\n> \" is not allowed. It is not possible to switch streams here. The\n> \"pos.pos\" is for human consumption anyway, it has no effect on the IR\n> generation. The only visible effect as far as I can tell is related to\n> the preprocessor \"-E\" in lib.c:\n>\n>         if (preprocess_only) {\n>                 while (!eof_token(token)) {\n>                         int prec = 1;\n>                         struct token *next = token->next;\n>                         const char *separator = \"\";\n>                         if (next->pos.whitespace)\n>                                 separator = \" \";\n>                         if (next->pos.newline) {\n>                                 separator = \"\\n\\t\\t\\t\\t\\t\";\n>                                 prec = next->pos.pos; <--- use pos as\n> indentation level.\n>                                 if (prec > 4)\n>                                         prec = 4;\n>                         }\n>                         printf(\"%s%.*s\", show_token(token), prec, separator);\n>                         token = next;\n>\n> The \"-E\" output has some indentation enhancement to turn space into\n> tab level indentation. This \"pos\" assignment tries to align the\n> indentation context of the input arguments to the same level of the\n> expanding macro name.\n\nYes, exactly! Initially I tried to simply remove these next->pos.* updates\nin collect_arg(), but this causes a lot of failures in validation/preprocessor\n(due to extra indentations) and I failed to find a simple fix for the\n\"if (preprocess_only)\" code above. Plus I wasn't comfortable because\nI don't understand the intent...\n\n> >  void dissect(struct reporter *rep, struct string_list *filelist)\n> >  {\n> > +       dissect_mode = 1;\n>\n> I don't think we need dissect_mode. I am leaning towards enabling it\n> all the time, maybe except for the preprocessor only mode.\n\n...\n\n> > +               if (!dissect_mode) {\n> > +                       next->pos.stream = pos->stream;\n> > +                       next->pos.line = pos->line;\n> > +                       next->pos.pos = pos->pos;\n> > +               }\n>\n> Maybe change it to \"if (preprocess_only)\", and fix all the validation\n> error output of the checker. What do you say?\n\nAgreed! This was my plan B ;)\n\nWith this change\n\n\t-               if (!dissect_mode) {\n\t+               if (preprocess_only) {\n\nmake check reports 2 failures\n\n\t-parsing/attr-cleanup.c:10:17: error: argument is not an identifier\n\t+parsing/attr-cleanup.c:10:27: error: argument is not an identifier\n\n\t-sizeof-void.c:20:14: warning: expression using sizeof(void)\n\t+sizeof-void.c:20:27: warning: expression using sizeof(void)\n\nbut the new positions look more correct.\n\nHowever. I didn't dare to send this patch because other warnings from\nsizeof-void.c still blame the column 14, this looks inconsistent...\nBut perhaps we don't really care?\n\nSo. I am going to update the changelog and send the trivial V2 below.\n\nWill you agree?\n\nOleg.\n---\n\ndiff --git a/pre-process.c b/pre-process.c\nindex 3fb25082..a4bb6cb6 100644\n--- a/pre-process.c\n+++ b/pre-process.c\n@@ -294,9 +294,11 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position\n \t\t} else if (match_op(next, ',') && !nesting && !vararg) {\n \t\t\tbreak;\n \t\t}\n-\t\tnext->pos.stream = pos->stream;\n-\t\tnext->pos.line = pos->line;\n-\t\tnext->pos.pos = pos->pos;\n+\t\tif (preprocess_only) {\n+\t\t\tnext->pos.stream = pos->stream;\n+\t\t\tnext->pos.line = pos->line;\n+\t\t\tnext->pos.pos = pos->pos;\n+\t\t}\n \t\tnext->pos.newline = 0;\n \t\tp = &next->next;\n \t}\ndiff --git a/validation/parsing/attr-cleanup.c b/validation/parsing/attr-cleanup.c\nindex ac64649c..fa3cb1ca 100644\n--- a/validation/parsing/attr-cleanup.c\n+++ b/validation/parsing/attr-cleanup.c\n@@ -24,7 +24,7 @@ int test(int n)\n  * check-command: sparse -Wunknown-attribute $file\n  *\n  * check-error-start\n-parsing/attr-cleanup.c:10:17: error: argument is not an identifier\n+parsing/attr-cleanup.c:10:27: error: argument is not an identifier\n parsing/attr-cleanup.c:11:39: error: an argument is expected for attribute 'cleanup'\n parsing/attr-cleanup.c:12:40: error: an argument is expected for attribute 'cleanup'\n parsing/attr-cleanup.c:13:43: error: Expected ) after attribute's argument'\ndiff --git a/validation/sizeof-void.c b/validation/sizeof-void.c\nindex 0fd917a2..6792ff02 100644\n--- a/validation/sizeof-void.c\n+++ b/validation/sizeof-void.c\n@@ -36,7 +36,7 @@ sizeof-void.c:16:14: warning: expression using sizeof(void)\n sizeof-void.c:17:14: warning: expression using sizeof(void)\n sizeof-void.c:18:14: warning: expression using sizeof(void)\n sizeof-void.c:1",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176867030930404.mbox",
          "message_id": "<aWu5g1VkGe0ktRaW () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2026-01-17 16:32:03+00:00",
          "date_str": "Sat, 17 Jan 2026 16:32:03 +0000",
          "body": "On 01/17, Oleg Nesterov wrote:\n>\n> Agreed! This was my plan B ;)\n>\n> With this change\n>\n> \t-               if (!dissect_mode) {\n> \t+               if (preprocess_only) {\n>\n> make check reports 2 failures\n>\n> \t-parsing/attr-cleanup.c:10:17: error: argument is not an identifier\n> \t+parsing/attr-cleanup.c:10:27: error: argument is not an identifier\n>\n> \t-sizeof-void.c:20:14: warning: expression using sizeof(void)\n> \t+sizeof-void.c:20:27: warning: expression using sizeof(void)\n>\n> but the new positions look more correct.\n>\n> However. I didn't dare to send this patch because other warnings from\n> sizeof-void.c still blame the column 14, this looks inconsistent...\n> But perhaps we don't really care?\n\nOn a 2nd thought...\n\nUnlike other warnings, this one (sizeof-void.c:20:27) refers to the\ninner \"sizeof *ptr\", so I think that this patch fixes the reported\nposition. So yes, I think we don't care even if the new column == 27\ndiffers from other warnings.\n\nWhat do you think?\n\nOleg.\n\n\n> So. I am going to update the changelog and send the trivial V2 below.\n>\n> Will you agree?\n>\n> Oleg.\n> ---\n>\n> diff --git a/pre-process.c b/pre-process.c\n> index 3fb25082..a4bb6cb6 100644\n> --- a/pre-process.c\n> +++ b/pre-process.c\n> @@ -294,9 +294,11 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position\n>  \t\t} else if (match_op(next, ',') && !nesting && !vararg) {\n>  \t\t\tbreak;\n>  \t\t}\n> -\t\tnext->pos.stream = pos->stream;\n> -\t\tnext->pos.line = pos->line;\n> -\t\tnext->pos.pos = pos->pos;\n> +\t\tif (preprocess_only) {\n> +\t\t\tnext->pos.stream = pos->stream;\n> +\t\t\tnext->pos.line = pos->line;\n> +\t\t\tnext->pos.pos = pos->pos;\n> +\t\t}\n>  \t\tnext->pos.newline = 0;\n>  \t\tp = &next->next;\n>  \t}\n> diff --git a/validation/parsing/attr-cleanup.c b/validation/parsing/attr-cleanup.c\n> index ac64649c..fa3cb1ca 100644\n> --- a/validation/parsing/attr-cleanup.c\n> +++ b/validation/parsing/attr-cleanup.c\n> @@ -24,7 +24,7 @@ int test(int n)\n>   * check-command: sparse -Wunknown-attribute $file\n>   *\n>   * check-error-start\n> -parsing/attr-cleanup.c:10:17: error: argument is not an identifier\n> +parsing/attr-cleanup.c:10:27: error: argument is not an identifier\n>  parsing/attr-cleanup.c:11:39: error: an argument is expected for attribute 'cleanup'\n>  parsing/attr-cleanup.c:12:40: error: an argument is expected for attribute 'cleanup'\n>  parsing/attr-cleanup.c:13:43: error: Expected ) after attribute's argument'\n> diff --git a/validation/sizeof-void.c b/validation/sizeof-void.c\n> index 0fd917a2..6792ff02 100644\n> --- a/validation/sizeof-void.c\n> +++ b/validation/sizeof-void.c\n> @@ -36,7 +36,7 @@ sizeof-void.c:16:14: warning: expression using sizeof(void)\n>  sizeof-void.c:17:14: warning: expression using sizeof(void)\n>  sizeof-void.c:18:14: warning: expression using sizeof(void)\n>  sizeof-void.c:19:14: warning: expression using sizeof(void)\n> -sizeof-void.c:20:14: warning: expression using sizeof(void)\n> +sizeof-void.c:20:27: warning: expression using sizeof(void)\n>  sizeof-void.c:21:14: warning: expression using sizeof(void)\n>  sizeof-void.c:22:14: warning: expression using sizeof(void)\n>  sizeof-void.c:23:14: warning: expression using sizeof(void)\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176878489603532.mbox",
          "message_id": "<CACePvbWe8FoUjKvtaAyBtVdurMOE=c9zDuX_eNfGqouaQ0kDFg () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2026-01-19 00:21:54+00:00",
          "date_str": "Mon, 19 Jan 2026 00:21:54 +0000",
          "body": "On Sat, Jan 17, 2026 at 6:19=E2=80=AFAM Oleg Nesterov <oleg@redhat.com> wro=\nte:\n>\n> Hi Chris,\n>\n> On 01/16, Chris Li wrote:\n> >\n> > On Wed, Dec 17, 2025 at 7:26=E2=80=AFAM Oleg Nesterov <oleg@redhat.com>=\n wrote:\n> > >\n> > > I don't quite understand why does expand() -> collect_arg() path\n> > > update ->pos for each token in the input *list, but this breaks\n> > > dissect and thus semind.\n> >\n> > That is a good question, I don't understand why it did that either. I\n> > did some digging, inside macro argument list expansion, the \"#include\n> > \" is not allowed. It is not possible to switch streams here. The\n> > \"pos.pos\" is for human consumption anyway, it has no effect on the IR\n> > generation. The only visible effect as far as I can tell is related to\n> > the preprocessor \"-E\" in lib.c:\n> >\n> >         if (preprocess_only) {\n> >                 while (!eof_token(token)) {\n> >                         int prec =3D 1;\n> >                         struct token *next =3D token->next;\n> >                         const char *separator =3D \"\";\n> >                         if (next->pos.whitespace)\n> >                                 separator =3D \" \";\n> >                         if (next->pos.newline) {\n> >                                 separator =3D \"\\n\\t\\t\\t\\t\\t\";\n> >                                 prec =3D next->pos.pos; <--- use pos as\n> > indentation level.\n> >                                 if (prec > 4)\n> >                                         prec =3D 4;\n> >                         }\n> >                         printf(\"%s%.*s\", show_token(token), prec, separ=\nator);\n> >                         token =3D next;\n> >\n> > The \"-E\" output has some indentation enhancement to turn space into\n> > tab level indentation. This \"pos\" assignment tries to align the\n> > indentation context of the input arguments to the same level of the\n> > expanding macro name.\n>\n> Yes, exactly! Initially I tried to simply remove these next->pos.* update=\ns\n> in collect_arg(), but this causes a lot of failures in validation/preproc=\nessor\n> (due to extra indentations) and I failed to find a simple fix for the\n> \"if (preprocess_only)\" code above. Plus I wasn't comfortable because\n> I don't understand the intent...\n\nAs far as I can tell, the new position report is more useful to the\nreader. I haven't heard any objections yet. Let's put it on the\nsparse-dev for a bit then merge into sparse. In the worst case there\nis some burning reason to use the old behavior, we can always change\nthe behavior back. It is only  software and it is easy to fix.\n\n>\n> > >  void dissect(struct reporter *rep, struct string_list *filelist)\n> > >  {\n> > > +       dissect_mode =3D 1;\n> >\n> > I don't think we need dissect_mode. I am leaning towards enabling it\n> > all the time, maybe except for the preprocessor only mode.\n>\n> ...\n>\n> > > +               if (!dissect_mode) {\n> > > +                       next->pos.stream =3D pos->stream;\n> > > +                       next->pos.line =3D pos->line;\n> > > +                       next->pos.pos =3D pos->pos;\n> > > +               }\n> >\n> > Maybe change it to \"if (preprocess_only)\", and fix all the validation\n> > error output of the checker. What do you say?\n>\n> Agreed! This was my plan B ;)\n>\n> With this change\n>\n>         -               if (!dissect_mode) {\n>         +               if (preprocess_only) {\n>\n> make check reports 2 failures\n>\n>         -parsing/attr-cleanup.c:10:17: error: argument is not an identifi=\ner\n>         +parsing/attr-cleanup.c:10:27: error: argument is not an identifi=\ner\n>\n>         -sizeof-void.c:20:14: warning: expression using sizeof(void)\n>         +sizeof-void.c:20:27: warning: expression using sizeof(void)\n>\n> but the new positions look more correct.\n>\n> However. I didn't dare to send this patch because other warnings from\n> sizeof-void.c still blame the column 14, this looks inconsistent...\n> But perhaps we don't really care?\n\nWell, we care in the sense that we don't want unnecessary check\nfailures. But we can update the expected output of the validation\ncheck to silence the error.\n\n>\n> So. I am going to update the changelog and send the trivial V2 below.\n>\n> Will you agree?\n\nAgree. As far as I can tell. The new position is more desirable. Let's\nswitch to the new position.\n\nChris\n\n>\n> Oleg.\n> ---\n>\n> diff --git a/pre-process.c b/pre-process.c\n> index 3fb25082..a4bb6cb6 100644\n> --- a/pre-process.c\n> +++ b/pre-process.c\n> @@ -294,9 +294,11 @@ static struct token *collect_arg(struct token *prev,=\n int vararg, struct position\n>                 } else if (match_op(next, ',') && !nesting && !vararg) {\n>                         break;\n>                 }\n> -               next->pos.stream =3D pos->stream;\n> -               next->pos.line =3D pos->line;\n> -               next->pos.pos =3D pos->pos;\n> +               if (preprocess_only) {\n> +                       next->pos.stream =3D pos->stream;\n> +                       next->pos.line =3D pos->line;\n> +                       next->pos.p",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176878499603564.mbox",
          "message_id": "<CACePvbXb+EJ9tdq=E8pw3uC-fjYp4CgQ27GqLwEgirWJiMVU6g () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2026-01-19 00:23:37+00:00",
          "date_str": "Mon, 19 Jan 2026 00:23:37 +0000",
          "body": "On Sat, Jan 17, 2026 at 8:32=E2=80=AFAM Oleg Nesterov <oleg@redhat.com> wro=\nte:\n>\n> On 01/17, Oleg Nesterov wrote:\n> >\n> > Agreed! This was my plan B ;)\n> >\n> > With this change\n> >\n> >       -               if (!dissect_mode) {\n> >       +               if (preprocess_only) {\n> >\n> > make check reports 2 failures\n> >\n> >       -parsing/attr-cleanup.c:10:17: error: argument is not an identifi=\ner\n> >       +parsing/attr-cleanup.c:10:27: error: argument is not an identifi=\ner\n> >\n> >       -sizeof-void.c:20:14: warning: expression using sizeof(void)\n> >       +sizeof-void.c:20:27: warning: expression using sizeof(void)\n> >\n> > but the new positions look more correct.\n> >\n> > However. I didn't dare to send this patch because other warnings from\n> > sizeof-void.c still blame the column 14, this looks inconsistent...\n> > But perhaps we don't really care?\n>\n> On a 2nd thought...\n>\n> Unlike other warnings, this one (sizeof-void.c:20:27) refers to the\n> inner \"sizeof *ptr\", so I think that this patch fixes the reported\n> position. So yes, I think we don't care even if the new column =3D=3D 27\n> differs from other warnings.\n>\n> What do you think?\n\nI would just update the checker to have the new expected value\nmatching what new pos so validation can pass without errors.\n\nChris\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176882875109888.mbox",
          "message_id": "<aW4keHjmqTS_S9ie () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "Re: [PATCH] sparse/pre-process: introduce \"dissect_mode\" option to fix dissect/semind",
          "date": "2026-01-19 12:32:56+00:00",
          "date_str": "Mon, 19 Jan 2026 12:32:56 +0000",
          "body": "On 01/18, Chris Li wrote:\n>\n> On Sat, Jan 17, 2026 at 8:32\u202fAM Oleg Nesterov <oleg@redhat.com> wrote:\n> >\n> > On a 2nd thought...\n> >\n> > Unlike other warnings, this one (sizeof-void.c:20:27) refers to the\n> > inner \"sizeof *ptr\", so I think that this patch fixes the reported\n> > position. So yes, I think we don't care even if the new column == 27\n> > differs from other warnings.\n> >\n> > What do you think?\n>\n> I would just update the checker to have the new expected value\n> matching what new pos so validation can pass without errors.\n\nYes, this is what I did. See\n\n\t[PATCH] sparse/pre-process: don't update next->pos in collect_arg()\n\thttps://lore.kernel.org/all/aWz0V_zQ47afKFJy@redhat.com/\n\nI was confused and tried to confuse you... let me explain. With this patch\n./sparse -Wpointer-arith validation/sizeof-void.c outputs\n\n\tvalidation/sizeof-void.c:16:14: warning: expression using sizeof(void)\n\tvalidation/sizeof-void.c:17:14: warning: expression using sizeof(void)\n\tvalidation/sizeof-void.c:18:14: warning: expression using sizeof(void)\n\tvalidation/sizeof-void.c:19:14: warning: expression using sizeof(void)\n\tvalidation/sizeof-void.c:20:27: warning: expression using sizeof(void) // changed\n\tvalidation/sizeof-void.c:21:14: warning: expression using sizeof(void)\n\tvalidation/sizeof-void.c:22:14: warning: expression using sizeof(void)\n\tvalidation/sizeof-void.c:23:14: warning: expression using sizeof(void)\n\nand somehow I wrongly came to conlusion that my patch is incomplete or\ninconsistent because it only corrects the warning's position for the\nline 20.\n\nNow that I actually looked at validation/sizeof-void.c, I see that the\ncode at line 20\n\n\ts += is_constexpr(sizeof *ptr);\n\ndiffers in that it is the inner \"sizeof *ptr\" which triggers the warning,\nso I think the patch is fine.\n\nThank you,\n\nOleg.\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[bug] false positive \"invalid initializer\"",
      "normalized_subject": "[bug] false positive \"invalid initializer\"",
      "message_count": 1,
      "participants": [
        "Guennadi Liakhovetski"
      ],
      "categories": [
        "type_system"
      ],
      "first_date": "2025-10-28T14:26:18+00:00",
      "last_date": "2025-10-28T14:26:18+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176166178421554.mbox",
          "message_id": "<6dc61f89-b00c-3013-ef1c-9566f18e1592 () linux ! intel ! com>",
          "author_name": "Guennadi Liakhovetski",
          "author_email": "guennadi.liakhovetski () linux ! intel ! com",
          "subject": "[bug] false positive \"invalid initializer\"",
          "date": "2025-10-28 14:26:18+00:00",
          "date_str": "Tue, 28 Oct 2025 14:26:18 +0000",
          "body": "Hi\n\nUsing this example\n\nvoid foo(void)\n{\n \tchar c[] = \"say\";\n \t__auto_type x = c;\n \tconst __typeof__(x) y = x;\n\n \t(void)y;\n}\n\nresults in\n\n$ sparse -v -nostdinc -o ../l.o -c ../l.c\n../l.c:4:25: error: invalid initializer\n../l.c:5:33: error: invalid initializer\n\nwhich appears to be a bug to me. Any fix suggestions would be appreciated.\n\nThanks\nGuennadi\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH] validation: add check for typeof() and address spaces",
      "normalized_subject": "validation: add check for typeof() and address spaces",
      "message_count": 1,
      "participants": [
        "Dan Carpenter"
      ],
      "categories": [
        "type_system",
        "compiler_compat",
        "address_space"
      ],
      "first_date": "2025-10-28T13:32:08+00:00",
      "last_date": "2025-10-28T13:32:08+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176165820217974.mbox",
          "message_id": "<aQDF2Ila2-LNmllC () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "[PATCH] validation: add check for typeof() and address spaces",
          "date": "2025-10-28 13:32:08+00:00",
          "date_str": "Tue, 28 Oct 2025 13:32:08 +0000",
          "body": "The typeof() key word should preserve the address space and\ntypeof_unqual() should not.  Add a check to verify this works as\nexpected.\n\nSigned-off-by: Dan Carpenter <dan.carpenter@linaro.org>\n---\n validation/typeof-as.c | 32 ++++++++++++++++++++++++++++++++\n 1 file changed, 32 insertions(+)\n create mode 100644 validation/typeof-as.c\n\ndiff --git a/validation/typeof-as.c b/validation/typeof-as.c\nnew file mode 100644\nindex 000000000000..563685281d92\n--- /dev/null\n+++ b/validation/typeof-as.c\n@@ -0,0 +1,32 @@\n+#define __seg_gs\t\t__attribute__((address_space(__seg_gs)))\n+static int __seg_gs m;\n+\n+static int __seg_gs bad_manual (void)\n+{\n+\treturn (*(int *)&m);\n+}\n+\n+static int __seg_gs good_manual (void)\n+{\n+\treturn (*(int __seg_gs *)&m);\n+}\n+\n+static int bad_typeof (void)\n+{\n+\treturn (*(typeof_unqual(m) *)&m);\n+}\n+\n+static int __seg_gs good_typeof (void)\n+{\n+\treturn (*(volatile typeof(m) *)&m);\n+}\n+\n+/*\n+ * check-name: typeof address space\n+ * check-command: ./sparse typeof-as.c\n+ *\n+ * check-error-start\n+typeof-as.c:6:19: warning: cast removes address space '__seg_gs' of expression\n+typeof-as.c:16:19: warning: cast removes address space '__seg_gs' of expression\n+ * check-error-end\n+ */\n-- \n2.51.0\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH 3/3] compiler.h: add __chkp_no_side_effects() empty hint/assertion macro",
      "normalized_subject": "compiler.h: add __chkp_no_side_effects() empty hint/assertion macro",
      "message_count": 4,
      "participants": [
        "Linus Torvalds",
        "Jim Cromie"
      ],
      "categories": [
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-10-25T21:15:18+00:00",
      "last_date": "2025-10-26T00:09:59+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176142679303487.mbox",
          "message_id": "<20251025211519.1616439-4-jim.cromie () gmail ! com>",
          "author_name": "Jim Cromie",
          "author_email": "jim.cromie () gmail ! com",
          "subject": "[PATCH 3/3] compiler.h: add __chkp_no_side_effects() empty hint/assertion macro",
          "date": "2025-10-25 21:15:18+00:00",
          "date_str": "Sat, 25 Oct 2025 21:15:18 +0000",
          "body": "cpp has no intrinsic protection against macro arg side-effects, so to\ncompensate, checkpatch is paranoid:\n\n  CHECK: Macro argument reuse '_var' - possible side-effects?\n\nAllow an author to suppress these warnings on _var by adding\n'__chkp_no_side_effects(_var)' to the body of macros which trigger\nthat warning.  This may reduce blowouts in CI pipelines.\n\nSigned-off-by: Jim Cromie <jim.cromie@gmail.com>\n---\n include/linux/compiler.h | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\ndiff --git a/include/linux/compiler.h b/include/linux/compiler.h\nindex 64ff73c533e5..96f6bfbd4088 100644\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -379,6 +379,18 @@ static inline void *offset_to_ptr(const int *off)\n  */\n #define prevent_tail_call_optimization()\tmb()\n \n+/*\n+ * tell checkpatch --strict that you know the named args (a subset of\n+ * the containing macro's args) are safe for multiple expansions.\n+ *\n+ * Prefer ({ typeof ..}) or do{}while(0) when they work.  They would\n+ * not work on module_param_named(name, value, type, perm), or on a\n+ * locally useful \"for_simplicity()\" macro.\n+ *\n+ * NB: use at top of macro body, omit trailing semicolon.\n+ */\n+#define __chkp_no_side_effects(...)  /* checkpatch \"annotation\" helper */\n+\n #include <asm/rwonce.h>\n \n #endif /* __LINUX_COMPILER_H */\n-- \n2.51.0\n\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176142678303471.mbox",
          "message_id": "<20251025211519.1616439-4-jim.cromie () gmail ! com>",
          "author_name": "Jim Cromie",
          "author_email": "jim.cromie () gmail ! com",
          "subject": "[PATCH 3/3] compiler.h: add __chkp_no_side_effects() empty hint/assertion macro",
          "date": "2025-10-25 21:15:18+00:00",
          "date_str": "Sat, 25 Oct 2025 21:15:18 +0000",
          "body": "cpp has no intrinsic protection against macro arg side-effects, so to\ncompensate, checkpatch is paranoid:\n\n  CHECK: Macro argument reuse '_var' - possible side-effects?\n\nAllow an author to suppress these warnings on _var by adding\n'__chkp_no_side_effects(_var)' to the body of macros which trigger\nthat warning.  This may reduce blowouts in CI pipelines.\n\nSigned-off-by: Jim Cromie <jim.cromie@gmail.com>\n---\n include/linux/compiler.h | 12 ++++++++++++\n 1 file changed, 12 insertions(+)\n\ndiff --git a/include/linux/compiler.h b/include/linux/compiler.h\nindex 64ff73c533e5..96f6bfbd4088 100644\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -379,6 +379,18 @@ static inline void *offset_to_ptr(const int *off)\n  */\n #define prevent_tail_call_optimization()\tmb()\n \n+/*\n+ * tell checkpatch --strict that you know the named args (a subset of\n+ * the containing macro's args) are safe for multiple expansions.\n+ *\n+ * Prefer ({ typeof ..}) or do{}while(0) when they work.  They would\n+ * not work on module_param_named(name, value, type, perm), or on a\n+ * locally useful \"for_simplicity()\" macro.\n+ *\n+ * NB: use at top of macro body, omit trailing semicolon.\n+ */\n+#define __chkp_no_side_effects(...)  /* checkpatch \"annotation\" helper */\n+\n #include <asm/rwonce.h>\n \n #endif /* __LINUX_COMPILER_H */\n-- \n2.51.0\n\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176143725809123.mbox",
          "message_id": "<CAHk-=wiwpTUr8keTinnPU8kTN9dpYgDtwM4wONRF_j=1gvo3MQ () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 3/3] compiler.h: add __chkp_no_side_effects() empty hint/assertion macro",
          "date": "2025-10-26 00:09:59+00:00",
          "date_str": "Sun, 26 Oct 2025 00:09:59 +0000",
          "body": "On Sat, 25 Oct 2025 at 14:15, Jim Cromie <jim.cromie@gmail.com> wrote:\n>\n> Allow an author to suppress these warnings on _var by adding\n> '__chkp_no_side_effects(_var)' to the body of macros which trigger\n> that warning.  This may reduce blowouts in CI pipelines.\n\nHow about just not doing that checkpatch thing at all if it causes problems?\n\nSeriously, I think checkpatch often causes more problems than it\nfixes. If it then causes us to write even uglier macros - and it's not\nlike our macros are pretty in general - it really is just causing\npain.\n\nI think we should cut down checkpatch to things that are obvious and\nreal issues. Not things that then cause people to make code worse.\n\n                 Linus\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176143725909124.mbox",
          "message_id": "<CAHk-=wiwpTUr8keTinnPU8kTN9dpYgDtwM4wONRF_j=1gvo3MQ () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH 3/3] compiler.h: add __chkp_no_side_effects() empty hint/assertion macro",
          "date": "2025-10-26 00:09:59+00:00",
          "date_str": "Sun, 26 Oct 2025 00:09:59 +0000",
          "body": "On Sat, 25 Oct 2025 at 14:15, Jim Cromie <jim.cromie@gmail.com> wrote:\n>\n> Allow an author to suppress these warnings on _var by adding\n> '__chkp_no_side_effects(_var)' to the body of macros which trigger\n> that warning.  This may reduce blowouts in CI pipelines.\n\nHow about just not doing that checkpatch thing at all if it causes problems?\n\nSeriously, I think checkpatch often causes more problems than it\nfixes. If it then causes us to write even uglier macros - and it's not\nlike our macros are pretty in general - it really is just causing\npain.\n\nI think we should cut down checkpatch to things that are obvious and\nreal issues. Not things that then cause people to make code worse.\n\n                 Linus\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH] symbol: preserve address space qualifiers with typeof()",
      "normalized_subject": "symbol: preserve address space qualifiers with typeof()",
      "message_count": 2,
      "participants": [
        "Chris Li",
        "Dan Carpenter"
      ],
      "categories": [
        "type_system",
        "sparse_internals",
        "address_space"
      ],
      "first_date": "2025-10-21T07:22:38+00:00",
      "last_date": "2025-10-28T13:05:59+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176103134827687.mbox",
          "message_id": "<CACePvbXdMNTp1cO=ORLv3C824McNP2xdOmtNXK2KkoCd=F82og () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] symbol: preserve address space qualifiers with typeof()",
          "date": "2025-10-21 07:22:38+00:00",
          "date_str": "Tue, 21 Oct 2025 07:22:38 +0000",
          "body": "On Sat, Oct 18, 2025 at 2:36=E2=80=AFAM Dan Carpenter <dan.carpenter@linaro=\n.org> wrote:\n>\n> When we're parsing typeof(var) we then preserve the address space\n> qualifiers as well.  Otherwise it leads to warnings like this:\n>\n> \"warning: cast removes address space '__seg_gs' of expression\"\n>\n> Reported-by: Uros Bizjak <ubizjak@gmail.com>\n> Signed-off-by: Dan Carpenter <dan.carpenter@linaro.org>\n\nThanks.\n\nI just apply it on sparse-dev tips, it applies without conflicts.\n\nHowever it seems \"make check\" has 67 tests failed now rather than 65\nknown failures.\nThere are two more test cases that failed with this patch:\n\nKO: out of 902 tests, 835 passed, 67 failed\n65 of them are known to fail\n2 tests were disabled\nmake: *** [Makefile:285: check] Error 1\n\nMaybe some test cases need to be updated as well? I haven't debugged\nthe details of the new failure yet.\n\nWhile we are at it, can we add Uros' reporting case as a validator\ncheck as well?\n\nAfter fixing the new test failure, I can apply this patch to\nsparse-dev. If the validation check patch shows up in the sparse\nmailing list. I will move the validation check before this patch.\n\nChris\n\n> ---\n>  symbol.c | 3 +++\n>  1 file changed, 3 insertions(+)\n>\n> diff --git a/symbol.c b/symbol.c\n> index 6a39e5487c17..301a6ed225d2 100644\n> --- a/symbol.c\n> +++ b/symbol.c\n> @@ -552,6 +552,7 @@ static struct symbol *examine_pointer_type(struct sym=\nbol *sym)\n>  static struct symbol *examine_typeof_helper(struct symbol *sym, bool qua=\nl)\n>  {\n>         struct symbol *base =3D evaluate_expression(sym->initializer);\n> +       struct ident *as =3D base->ctype.as;\n>         unsigned long mod =3D 0;\n>\n>         if (!base)\n> @@ -567,6 +568,8 @@ static struct symbol *examine_typeof_helper(struct sy=\nmbol *sym, bool qual)\n>         sym->type =3D SYM_NODE;\n>         sym->ctype.modifiers =3D mod;\n>         sym->ctype.base_type =3D base;\n> +       if (qual)\n> +               sym->ctype.as =3D as;\n>         return examine_node_type(sym);\n>  }\n>\n> --\n> 2.51.0\n>\n>\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176165660716703.mbox",
          "message_id": "<aQC_tw-8gLpf00yH () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "[PATCH v2] symbol: preserve address space qualifiers with typeof()",
          "date": "2025-10-28 13:05:59+00:00",
          "date_str": "Tue, 28 Oct 2025 13:05:59 +0000",
          "body": "When we're parsing typeof(var) we then preserve the address space\nqualifiers as well.  Otherwise it leads to warnings like this:\n\n\"warning: cast removes address space '__seg_gs' of expression\"\n\nReported-by: Uros Bizjak <ubizjak@gmail.com>\nSigned-off-by: Dan Carpenter <dan.carpenter@linaro.org>\n---\nv2: Fix a NULL dereference because \"base\" can be NULL.  Sorry for not\nrunning the validation/ tests...  :(\n\n symbol.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\ndiff --git a/symbol.c b/symbol.c\nindex 7060acb666d9..a42289226650 100644\n--- a/symbol.c\n+++ b/symbol.c\n@@ -544,9 +544,12 @@ static struct symbol *examine_pointer_type(struct symbol *sym)\n static struct symbol *examine_typeof_helper(struct symbol *sym, bool qual)\n {\n \tstruct symbol *base = evaluate_expression(sym->initializer);\n+\tstruct ident *as = NULL;\n \tunsigned long mod = 0;\n \n-\tif (!base)\n+\tif (base)\n+\t\tas = base->ctype.as;\n+\telse\n \t\tbase = &bad_ctype;\n \tif (base->type == SYM_NODE) {\n \t\tmod |= base->ctype.modifiers & MOD_TYPEOF;\n@@ -559,6 +562,8 @@ static struct symbol *examine_typeof_helper(struct symbol *sym, bool qual)\n \tsym->type = SYM_NODE;\n \tsym->ctype.modifiers = mod;\n \tsym->ctype.base_type = base;\n+\tif (qual)\n+\t\tsym->ctype.as = as;\n \treturn examine_node_type(sym);\n }\n \n-- \n2.51.0\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH RESEND2 2/4] add -Wformat",
      "normalized_subject": "add -Wformat",
      "message_count": 3,
      "participants": [
        "Ben Dooks"
      ],
      "categories": [
        "compiler_compat",
        "sparse_internals",
        "type_system"
      ],
      "first_date": "2025-10-20T15:39:16+00:00",
      "last_date": "2026-01-16T17:58:07+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176097479520723.mbox",
          "message_id": "<20251020153918.812235-3-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCH RESEND2 2/4] add -Wformat",
          "date": "2025-10-20 15:39:16+00:00",
          "date_str": "Mon, 20 Oct 2025 15:39:16 +0000",
          "body": "Add option to enable/disable format checking (and default it to off)\n\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\n options.c | 2 ++\n options.h | 1 +\n sparse.1  | 8 ++++++++\n 3 files changed, 11 insertions(+)\n\ndiff --git a/options.c b/options.c\nindex 6ee4d878..54ac00b4 100644\n--- a/options.c\n+++ b/options.c\n@@ -106,6 +106,7 @@ int Wflexible_array_array = 1;\n int Wflexible_array_nested = 0;\n int Wflexible_array_sizeof = 0;\n int Wflexible_array_union = 0;\n+int Wformat = 0;\n int Wimplicit_int = 1;\n int Winit_cstring = 0;\n int Wint_to_pointer_cast = 1;\n@@ -865,6 +866,7 @@ static const struct flag warnings[] = {\n \t{ \"flexible-array-nested\", &Wflexible_array_nested },\n \t{ \"flexible-array-sizeof\", &Wflexible_array_sizeof },\n \t{ \"flexible-array-union\", &Wflexible_array_union },\n+\t{ \"format\", &Wformat },\n \t{ \"implicit-int\", &Wimplicit_int },\n \t{ \"init-cstring\", &Winit_cstring },\n \t{ \"int-to-pointer-cast\", &Wint_to_pointer_cast },\ndiff --git a/options.h b/options.h\nindex c2a9551a..105c45d0 100644\n--- a/options.h\n+++ b/options.h\n@@ -106,6 +106,7 @@ extern int Wflexible_array_array;\n extern int Wflexible_array_nested;\n extern int Wflexible_array_sizeof;\n extern int Wflexible_array_union;\n+extern int Wformat;\n extern int Wimplicit_int;\n extern int Winit_cstring;\n extern int Wint_to_pointer_cast;\ndiff --git a/sparse.1 b/sparse.1\nindex 2fba7e7a..64b0571e 100644\n--- a/sparse.1\n+++ b/sparse.1\n@@ -285,6 +285,14 @@ To have any effect, at least one of \\fB-Wflexible-array-array\\fR,\n be enabled.\n \n Sparse does issue these warnings by default.\n+.B \\-Wformat\n+Warn about parameter mismatch to any variadic function which specifies\n+where the format string is specified with the \n+.BI __attribute__((format( type, message, va_start )))\n+attribute.\n+\n+Sparse does not issue these warnings by default. To turn them on, use\n+\\fB\\-W-format\\fR.\n .\n .TP\n .B \\-Winit\\-cstring\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/12/176642437229962.mbox",
          "message_id": "<20251222160034.96188-3-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCH v2 2/4] add -Wformat",
          "date": "2025-12-22 16:00:32+00:00",
          "date_str": "Mon, 22 Dec 2025 16:00:32 +0000",
          "body": "Add option to enable/disable format checking (and default it to off)\n\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\n options.c | 2 ++\n options.h | 1 +\n sparse.1  | 8 ++++++++\n 3 files changed, 11 insertions(+)\n\ndiff --git a/options.c b/options.c\nindex 6ee4d878..54ac00b4 100644\n--- a/options.c\n+++ b/options.c\n@@ -106,6 +106,7 @@ int Wflexible_array_array = 1;\n int Wflexible_array_nested = 0;\n int Wflexible_array_sizeof = 0;\n int Wflexible_array_union = 0;\n+int Wformat = 0;\n int Wimplicit_int = 1;\n int Winit_cstring = 0;\n int Wint_to_pointer_cast = 1;\n@@ -865,6 +866,7 @@ static const struct flag warnings[] = {\n \t{ \"flexible-array-nested\", &Wflexible_array_nested },\n \t{ \"flexible-array-sizeof\", &Wflexible_array_sizeof },\n \t{ \"flexible-array-union\", &Wflexible_array_union },\n+\t{ \"format\", &Wformat },\n \t{ \"implicit-int\", &Wimplicit_int },\n \t{ \"init-cstring\", &Winit_cstring },\n \t{ \"int-to-pointer-cast\", &Wint_to_pointer_cast },\ndiff --git a/options.h b/options.h\nindex c2a9551a..105c45d0 100644\n--- a/options.h\n+++ b/options.h\n@@ -106,6 +106,7 @@ extern int Wflexible_array_array;\n extern int Wflexible_array_nested;\n extern int Wflexible_array_sizeof;\n extern int Wflexible_array_union;\n+extern int Wformat;\n extern int Wimplicit_int;\n extern int Winit_cstring;\n extern int Wint_to_pointer_cast;\ndiff --git a/sparse.1 b/sparse.1\nindex 2fba7e7a..64b0571e 100644\n--- a/sparse.1\n+++ b/sparse.1\n@@ -285,6 +285,14 @@ To have any effect, at least one of \\fB-Wflexible-array-array\\fR,\n be enabled.\n \n Sparse does issue these warnings by default.\n+.B \\-Wformat\n+Warn about parameter mismatch to any variadic function which specifies\n+where the format string is specified with the \n+.BI __attribute__((format( type, message, va_start )))\n+attribute.\n+\n+Sparse does not issue these warnings by default. To turn them on, use\n+\\fB\\-W-format\\fR.\n .\n .TP\n .B \\-Winit\\-cstring\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2025",
          "month": "12"
        },
        {
          "filepath": "emails/2026/01/176858939911459.mbox",
          "message_id": "<20260116175809.6849-3-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCH v3 2/4] add -Wformat",
          "date": "2026-01-16 17:58:07+00:00",
          "date_str": "Fri, 16 Jan 2026 17:58:07 +0000",
          "body": "Add option to enable/disable format checking (and default it to off)\n\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\n options.c | 2 ++\n options.h | 1 +\n sparse.1  | 8 ++++++++\n 3 files changed, 11 insertions(+)\n\ndiff --git a/options.c b/options.c\nindex 6ee4d878..54ac00b4 100644\n--- a/options.c\n+++ b/options.c\n@@ -106,6 +106,7 @@ int Wflexible_array_array = 1;\n int Wflexible_array_nested = 0;\n int Wflexible_array_sizeof = 0;\n int Wflexible_array_union = 0;\n+int Wformat = 0;\n int Wimplicit_int = 1;\n int Winit_cstring = 0;\n int Wint_to_pointer_cast = 1;\n@@ -865,6 +866,7 @@ static const struct flag warnings[] = {\n \t{ \"flexible-array-nested\", &Wflexible_array_nested },\n \t{ \"flexible-array-sizeof\", &Wflexible_array_sizeof },\n \t{ \"flexible-array-union\", &Wflexible_array_union },\n+\t{ \"format\", &Wformat },\n \t{ \"implicit-int\", &Wimplicit_int },\n \t{ \"init-cstring\", &Winit_cstring },\n \t{ \"int-to-pointer-cast\", &Wint_to_pointer_cast },\ndiff --git a/options.h b/options.h\nindex c2a9551a..105c45d0 100644\n--- a/options.h\n+++ b/options.h\n@@ -106,6 +106,7 @@ extern int Wflexible_array_array;\n extern int Wflexible_array_nested;\n extern int Wflexible_array_sizeof;\n extern int Wflexible_array_union;\n+extern int Wformat;\n extern int Wimplicit_int;\n extern int Winit_cstring;\n extern int Wint_to_pointer_cast;\ndiff --git a/sparse.1 b/sparse.1\nindex 2fba7e7a..64b0571e 100644\n--- a/sparse.1\n+++ b/sparse.1\n@@ -285,6 +285,14 @@ To have any effect, at least one of \\fB-Wflexible-array-array\\fR,\n be enabled.\n \n Sparse does issue these warnings by default.\n+.B \\-Wformat\n+Warn about parameter mismatch to any variadic function which specifies\n+where the format string is specified with the \n+.BI __attribute__((format( type, message, va_start )))\n+attribute.\n+\n+Sparse does not issue these warnings by default. To turn them on, use\n+\\fB\\-W-format\\fR.\n .\n .TP\n .B \\-Winit\\-cstring\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Add printf/scanf -Wformat checking",
      "normalized_subject": "Add printf/scanf -Wformat checking",
      "message_count": 1,
      "participants": [
        "Ben Dooks"
      ],
      "categories": [
        "compiler_compat"
      ],
      "first_date": "2025-10-20T15:39:14+00:00",
      "last_date": "2025-10-20T15:39:14+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176097479420722.mbox",
          "message_id": "<20251020153918.812235-1-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "Add printf/scanf -Wformat checking",
          "date": "2025-10-20 15:39:14+00:00",
          "date_str": "Mon, 20 Oct 2025 15:39:14 +0000",
          "body": "[re-send as outgoing mail setup had a DKIM issue pointed out\nby Linus]\n\nThis series (which was initially sent back in 2020) adds the\nability to deal with __attribute__((format) and checking the\narguments to formatted variadic functions.\n\nI have been considering adding a -Wformat-linux to this as\nthe kernel now has a number of extra formatting options and\nchecking the type of these would be useful. An even nicer\nextension would be some way of informing the compiler/sparse\nof these at compile time (but would need to get agreement on\nhow to do this with the compilers too)\n\nAnother quesiton is to leave this as 4 patches or merge down?\n\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
      "normalized_subject": "overflow, tracing: Define the is_signed_type() macro once",
      "message_count": 22,
      "participants": [
        "Farber, Eliav",
        "Greg KH"
      ],
      "categories": [
        "sparse_internals",
        "type_system"
      ],
      "first_date": "2025-10-17T11:59:33+00:00",
      "last_date": "2025-10-17T13:21:18+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176070224211110.mbox",
          "message_id": "<2025101708-obtuse-ellipse-e355 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 11:59:33+00:00",
          "date_str": "Fri, 17 Oct 2025 11:59:33 +0000",
          "body": "On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> From: Bart Van Assche <bvanassche@acm.org>\n> \n> [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n\nThis isn't in 5.15.y, why is it needed in 5.10.y?\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070224311113.mbox",
          "message_id": "<2025101708-obtuse-ellipse-e355 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 11:59:33+00:00",
          "date_str": "Fri, 17 Oct 2025 11:59:33 +0000",
          "body": "On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> From: Bart Van Assche <bvanassche@acm.org>\n> \n> [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n\nThis isn't in 5.15.y, why is it needed in 5.10.y?\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070328311884.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070324111826.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070325111849.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070325611862.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070323811823.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070325511861.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070325111850.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070328511887.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070327511874.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176077663923146.mbox",
          "message_id": "<CH0PR18MB54337BD648C23CBE40C1060CC6F6A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 12:16:27+00:00",
          "date_str": "Fri, 17 Oct 2025 12:16:27 +0000",
          "body": "> On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > From: Bart Van Assche <bvanassche@acm.org>\n> >\n> > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n>\n> This isn't in 5.15.y, why is it needed in 5.10.y?\n\nThis is the mainline commit:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/i=\nnclude/linux/overflow.h?h=3Dv6.18-rc1&id=3D92d23c6e94157739b997cacce151586a=\n0d07bb8a\n\nThe commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\nthe one I used for the backport.\n\nAnd here is the corresponding commit in the 5.15.y branch:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/inc=\nlude/linux/overflow.h?h=3Dv5.15.194&id=3Ded6e37e30826b12572636c6bbfe6319233=\n690c90\nHowever, the commit message there references a different hash:\na49a64b5bf195381c09202c524f0f84b5f3e816f.\n\n---\nRegards, Eliav",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070712814892.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176077658923008.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070718414959.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070713014899.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070712814893.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070714014908.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070715014917.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070715014918.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070716614937.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176070712914896.mbox",
          "message_id": "<2025101740-scion-flavoring-3a21 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 01/27 5.10.y] overflow, tracing: Define the is_signed_type() macro once",
          "date": "2025-10-17 13:21:18+00:00",
          "date_str": "Fri, 17 Oct 2025 13:21:18 +0000",
          "body": "On Fri, Oct 17, 2025 at 12:16:27PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:53AM +0000, Eliav Farber wrote:\n> > > From: Bart Van Assche <bvanassche@acm.org>\n> > >\n> > > [ Upstream commit 92d23c6e94157739b997cacce151586a0d07bb8a ]\n> >\n> > This isn't in 5.15.y, why is it needed in 5.10.y?\n> \n> This is the mainline commit:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/include/linux/overflow.h?h=v6.18-rc1&id=92d23c6e94157739b997cacce151586a0d07bb8a\n> \n> The commit hash is 92d23c6e94157739b997cacce151586a0d07bb8a, which is\n> the one I used for the backport.\n> \n> And here is the corresponding commit in the 5.15.y branch:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/include/linux/overflow.h?h=v5.15.194&id=ed6e37e30826b12572636c6bbfe6319233690c90\n> However, the commit message there references a different hash:\n> a49a64b5bf195381c09202c524f0f84b5f3e816f.\n\nUgh, that hash is invalid, I missed that :(\n\nThanks for the info, I'll go work on queueing these up.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH v2 20/27 5.10.y] minmax: fix up min3() and max3() too",
      "normalized_subject": "minmax: fix up min3() and max3() too",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "type_system"
      ],
      "first_date": "2025-10-17T09:05:12+00:00",
      "last_date": "2025-10-17T09:05:12+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176069285602522.mbox",
          "message_id": "<20251017090519.46992-21-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 20/27 5.10.y] minmax: fix up min3() and max3() too",
          "date": "2025-10-17 09:05:12+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:12 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 21b136cc63d2a9ddd60d4699552b69c214b32964 ]\n\nDavid Laight pointed out that we should deal with the min3() and max3()\nmess too, which still does excessive expansion.\n\nAnd our current macros are actually rather broken.\n\nIn particular, the macros did this:\n\n  #define min3(x, y, z) min((typeof(x))min(x, y), z)\n  #define max3(x, y, z) max((typeof(x))max(x, y), z)\n\nand that not only is a nested expansion of possibly very complex\narguments with all that involves, the typing with that \"typeof()\" cast\nis completely wrong.\n\nFor example, imagine what happens in max3() if 'x' happens to be a\n'unsigned char', but 'y' and 'z' are 'unsigned long'.  The types are\ncompatible, and there's no warning - but the result is just random\ngarbage.\n\nNo, I don't think we've ever hit that issue in practice, but since we\nnow have sane infrastructure for doing this right, let's just use it.\nIt fixes any excessive expansion, and also avoids these kinds of broken\ntype issues.\n\nRequested-by: David Laight <David.Laight@aculab.com>\nAcked-by: Arnd Bergmann <arnd@kernel.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 12 ++++++++++--\n 1 file changed, 10 insertions(+), 2 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 41da6f85a407..98008dd92153 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -152,13 +152,20 @@\n #define umax(x, y)\t\\\n \t__careful_cmp(max, (x) + 0u + 0ul + 0ull, (y) + 0u + 0ul + 0ull)\n \n+#define __careful_op3(op, x, y, z, ux, uy, uz) ({\t\t\t\\\n+\t__auto_type ux = (x); __auto_type uy = (y);__auto_type uz = (z);\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(x,y,z,ux,uy,uz),\t\t\t\\\n+\t\t#op\"3(\"#x\", \"#y\", \"#z\") signedness error\");\t\t\\\n+\t__cmp(op, ux, __cmp(op, uy, uz)); })\n+\n /**\n  * min3 - return minimum of three values\n  * @x: first value\n  * @y: second value\n  * @z: third value\n  */\n-#define min3(x, y, z) min((typeof(x))min(x, y), z)\n+#define min3(x, y, z) \\\n+\t__careful_op3(min, x, y, z, __UNIQUE_ID(x_), __UNIQUE_ID(y_), __UNIQUE_ID(z_))\n \n /**\n  * max3 - return maximum of three values\n@@ -166,7 +173,8 @@\n  * @y: second value\n  * @z: third value\n  */\n-#define max3(x, y, z) max((typeof(x))max(x, y), z)\n+#define max3(x, y, z) \\\n+\t__careful_op3(max, x, y, z, __UNIQUE_ID(x_), __UNIQUE_ID(y_), __UNIQUE_ID(z_))\n \n /**\n  * min_not_zero - return the minimum that is _not_ zero, unless both are zero\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH v2 14/27 5.10.y] minmax: add a few more MIN_T/MAX_T users",
      "normalized_subject": "minmax: add a few more MIN_T/MAX_T users",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "sparse_internals"
      ],
      "first_date": "2025-10-17T09:05:06+00:00",
      "last_date": "2025-10-17T09:05:06+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176069251101977.mbox",
          "message_id": "<20251017090519.46992-15-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 14/27 5.10.y] minmax: add a few more MIN_T/MAX_T users",
          "date": "2025-10-17 09:05:06+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:06 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 4477b39c32fdc03363affef4b11d48391e6dc9ff ]\n\nCommit 3a7e02c040b1 (\"minmax: avoid overly complicated constant\nexpressions in VM code\") added the simpler MIN_T/MAX_T macros in order\nto avoid some excessive expansion from the rather complicated regular\nmin/max macros.\n\nThe complexity of those macros stems from two issues:\n\n (a) trying to use them in situations that require a C constant\n     expression (in static initializers and for array sizes)\n\n (b) the type sanity checking\n\nand MIN_T/MAX_T avoids both of these issues.\n\nNow, in the whole (long) discussion about all this, it was pointed out\nthat the whole type sanity checking is entirely unnecessary for\nmin_t/max_t which get a fixed type that the comparison is done in.\n\nBut that still leaves min_t/max_t unnecessarily complicated due to\nworries about the C constant expression case.\n\nHowever, it turns out that there really aren't very many cases that use\nmin_t/max_t for this, and we can just force-convert those.\n\nThis does exactly that.\n\nWhich in turn will then allow for much simpler implementations of\nmin_t()/max_t().  All the usual \"macros in all upper case will evaluate\nthe arguments multiple times\" rules apply.\n\nWe should do all the same things for the regular min/max() vs MIN/MAX()\ncases, but that has the added complexity of various drivers defining\ntheir own local versions of MIN/MAX, so that needs another level of\nfixes first.\n\nLink: https://lore.kernel.org/all/b47fad1d0cf8449886ad148f8c013dae@AcuMS.aculab.com/\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n arch/x86/mm/pgtable.c                             | 2 +-\n drivers/edac/sb_edac.c                            | 4 ++--\n drivers/gpu/drm/drm_color_mgmt.c                  | 2 +-\n drivers/md/dm-integrity.c                         | 2 +-\n drivers/net/ethernet/stmicro/stmmac/stmmac_main.c | 2 +-\n fs/erofs/zdata.h                                  | 2 +-\n net/ipv4/proc.c                                   | 2 +-\n net/ipv6/proc.c                                   | 2 +-\n 8 files changed, 9 insertions(+), 9 deletions(-)\n\ndiff --git a/arch/x86/mm/pgtable.c b/arch/x86/mm/pgtable.c\nindex 204b25ee26f0..27e8e3d6be48 100644\n--- a/arch/x86/mm/pgtable.c\n+++ b/arch/x86/mm/pgtable.c\n@@ -107,7 +107,7 @@ static inline void pgd_list_del(pgd_t *pgd)\n #define UNSHARED_PTRS_PER_PGD\t\t\t\t\\\n \t(SHARED_KERNEL_PMD ? KERNEL_PGD_BOUNDARY : PTRS_PER_PGD)\n #define MAX_UNSHARED_PTRS_PER_PGD\t\t\t\\\n-\tmax_t(size_t, KERNEL_PGD_BOUNDARY, PTRS_PER_PGD)\n+\tMAX_T(size_t, KERNEL_PGD_BOUNDARY, PTRS_PER_PGD)\n \n \n static void pgd_set_mm(pgd_t *pgd, struct mm_struct *mm)\ndiff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c\nindex 1522d4aa2ca6..714020e7405a 100644\n--- a/drivers/edac/sb_edac.c\n+++ b/drivers/edac/sb_edac.c\n@@ -109,8 +109,8 @@ static const u32 knl_interleave_list[] = {\n \t0x104, 0x10c, 0x114, 0x11c,   /* 20-23 */\n };\n #define MAX_INTERLEAVE\t\t\t\t\t\t\t\\\n-\t(max_t(unsigned int, ARRAY_SIZE(sbridge_interleave_list),\t\\\n-\t       max_t(unsigned int, ARRAY_SIZE(ibridge_interleave_list),\t\\\n+\t(MAX_T(unsigned int, ARRAY_SIZE(sbridge_interleave_list),\t\\\n+\t       MAX_T(unsigned int, ARRAY_SIZE(ibridge_interleave_list),\t\\\n \t\t     ARRAY_SIZE(knl_interleave_list))))\n \n struct interleave_pkg {\ndiff --git a/drivers/gpu/drm/drm_color_mgmt.c b/drivers/gpu/drm/drm_color_mgmt.c\nindex 138ff34b31db..4bc671484c05 100644\n--- a/drivers/gpu/drm/drm_color_mgmt.c\n+++ b/drivers/gpu/drm/drm_color_mgmt.c\n@@ -421,7 +421,7 @@ int drm_plane_create_color_properties(struct drm_plane *plane,\n {\n \tstruct drm_device *dev = plane->dev;\n \tstruct drm_property *prop;\n-\tstruct drm_prop_enum_list enum_list[max_t(int, DRM_COLOR_ENCODING_MAX,\n+\tstruct drm_prop_enum_list enum_list[MAX_T(int, DRM_COLOR_ENCODING_MAX,\n \t\t\t\t\t\t       DRM_COLOR_RANGE_MAX)];\n \tint i, len;\n \ndiff --git a/drivers/md/dm-integrity.c b/drivers/md/dm-integrity.c\nindex 07a7b4e51f0e..7fa3bf74747d 100644\n--- a/drivers/md/dm-integrity.c\n+++ b/drivers/md/dm-integrity.c\n@@ -2431,7 +2431,7 @@ static void do_journal_write(struct dm_integrity_c *ic, unsigned write_start,\n \t\t\t\t    unlikely(from_replay) &&\n #endif\n \t\t\t\t    ic->internal_hash) {\n-\t\t\t\t\tchar test_tag[max_t(size_t, HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n+\t\t\t\t\tchar test_tag[MAX_T(size_t, HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n \n \t\t\t\t\tintegrity_sector_checksum(ic, sec + ((l - j) << ic->sb->log2_sectors_per_block),\n \t\t\t\t\t\t\t\t  (char *)access_journal_data(ic, i, l), test_tag);\ndiff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c\nindex b8581a711514..e6fa2782d28f 100644\n--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c\n+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c\n@@ -2267,7 +2267,7 @@ static void stmmac_dma_interrupt(struct stmmac_priv *priv)\n \tu32 channels_to_check = tx_cha",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH v2 12/27 5.10.y] minmax: relax check to allow comparison between unsigned arguments and signe",
      "normalized_subject": "minmax: relax check to allow comparison between unsigned arguments and signe",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "sparse_internals"
      ],
      "first_date": "2025-10-17T09:05:04+00:00",
      "last_date": "2025-10-17T09:05:04+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176069275702382.mbox",
          "message_id": "<20251017090519.46992-13-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 12/27 5.10.y] minmax: relax check to allow comparison between unsigned arguments and signe",
          "date": "2025-10-17 09:05:04+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:04 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit 867046cc7027703f60a46339ffde91a1970f2901 ]\n\nAllow (for example) min(unsigned_var, 20).\n\nThe opposite min(signed_var, 20u) is still errored.\n\nSince a comparison between signed and unsigned never makes the unsigned\nvalue negative it is only necessary to adjust the __types_ok() test.\n\nLink: https://lkml.kernel.org/r/633b64e2f39e46bb8234809c5595b8c7@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Matthew Wilcox (Oracle) <willy@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 24 +++++++++++++++++-------\n 1 file changed, 17 insertions(+), 7 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 842c1db62ffe..2ec559284a9f 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -10,13 +10,18 @@\n /*\n  * min()/max()/clamp() macros must accomplish three things:\n  *\n- * - avoid multiple evaluations of the arguments (so side-effects like\n+ * - Avoid multiple evaluations of the arguments (so side-effects like\n  *   \"x++\" happen only once) when non-constant.\n- * - perform signed v unsigned type-checking (to generate compile\n- *   errors instead of nasty runtime surprises).\n- * - retain result as a constant expressions when called with only\n+ * - Retain result as a constant expressions when called with only\n  *   constant expressions (to avoid tripping VLA warnings in stack\n  *   allocation usage).\n+ * - Perform signed v unsigned type-checking (to generate compile\n+ *   errors instead of nasty runtime surprises).\n+ * - Unsigned char/short are always promoted to signed int and can be\n+ *   compared against signed or unsigned arguments.\n+ * - Unsigned arguments can be compared against non-negative signed constants.\n+ * - Comparison of a signed argument against an unsigned constant fails\n+ *   even if the constant is below __INT_MAX__ and could be cast to int.\n  */\n #define __typecheck(x, y) \\\n \t(!!(sizeof((typeof(x) *)1 == (typeof(y) *)1)))\n@@ -26,9 +31,14 @@\n \t__builtin_choose_expr(__is_constexpr(is_signed_type(typeof(x))),\t\\\n \t\tis_signed_type(typeof(x)), 0)\n \n-#define __types_ok(x, y) \t\t\t\\\n-\t(__is_signed(x) == __is_signed(y) ||\t\\\n-\t\t__is_signed((x) + 0) == __is_signed((y) + 0))\n+/* True for a non-negative signed int constant */\n+#define __is_noneg_int(x)\t\\\n+\t(__builtin_choose_expr(__is_constexpr(x) && __is_signed(x), x, -1) >= 0)\n+\n+#define __types_ok(x, y) \t\t\t\t\t\\\n+\t(__is_signed(x) == __is_signed(y) ||\t\t\t\\\n+\t\t__is_signed((x) + 0) == __is_signed((y) + 0) ||\t\\\n+\t\t__is_noneg_int(x) || __is_noneg_int(y))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: typeof() preserves address space information",
      "normalized_subject": "typeof() preserves address space information",
      "message_count": 2,
      "participants": [
        "Chris Li",
        "Uros Bizjak"
      ],
      "categories": [
        "type_system",
        "compiler_compat",
        "address_space"
      ],
      "first_date": "2025-10-16T15:31:02+00:00",
      "last_date": "2025-10-21T07:04:40+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/10/176062866824055.mbox",
          "message_id": "<CAFULd4ZV6OiDZF8zknddrxPRTD5vhSQE6nEux4dr+2p1A7N6uA () mail ! gmail ! com>",
          "author_name": "Uros Bizjak",
          "author_email": "ubizjak () gmail ! com",
          "subject": "typeof() preserves address space information",
          "date": "2025-10-16 15:31:02+00:00",
          "date_str": "Thu, 16 Oct 2025 15:31:02 +0000",
          "body": "The following testcase:\n\n--cut here--\n#ifdef __CHECKER__\n# define __seg_gs        __attribute__((address_space(__seg_gs)))\n# define __seg_fs        __attribute__((address_space(__seg_fs)))\n#endif\n\n#define __read(var) (*(volatile typeof(var) *)&(var))\n\nextern int __seg_gs m;\nint foo (void);\n\nint foo (void)\n{\n  return __read (m);\n}\n--cut here--\n\ncompiles with GCC (15+) without warnings, but sparse warns:\n\n_.c:13:10: warning: cast removes address space '__seg_gs' of expression\n\ntypeof () operator should preserve all qualifiers (const, volatile,\n__seg_gs, etc). OTOH, typeof_unqual () operator strips all qualifiers\nand returns unqualified type of what typeof () returns. Please see\nnotes of [1].\n\n[1] https://en.cppreference.com/w/c/language/typeof.html\n\nUros.\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176103018426393.mbox",
          "message_id": "<CACePvbU_NNkQVP9tMuu5vzcBsCApKV9+viWCEO6drwg3WhzVJg () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: typeof() preserves address space information",
          "date": "2025-10-21 07:04:40+00:00",
          "date_str": "Tue, 21 Oct 2025 07:04:40 +0000",
          "body": "On Thu, Oct 16, 2025 at 8:31=E2=80=AFAM Uros Bizjak <ubizjak@gmail.com> wro=\nte:\n>\n> The following testcase:\n>\n> --cut here--\n> #ifdef __CHECKER__\n> # define __seg_gs        __attribute__((address_space(__seg_gs)))\n> # define __seg_fs        __attribute__((address_space(__seg_fs)))\n> #endif\n>\n> #define __read(var) (*(volatile typeof(var) *)&(var))\n>\n> extern int __seg_gs m;\n> int foo (void);\n>\n> int foo (void)\n> {\n>   return __read (m);\n> }\n> --cut here--\n>\n> compiles with GCC (15+) without warnings, but sparse warns:\n>\n> _.c:13:10: warning: cast removes address space '__seg_gs' of expression\n>\n> typeof () operator should preserve all qualifiers (const, volatile,\n> __seg_gs, etc). OTOH, typeof_unqual () operator strips all qualifiers\n> and returns unqualified type of what typeof () returns. Please see\n> notes of [1].\n\nHi Uros, thanks for the detailed report.\n\nAnyone interested in turning the above test case into a  validation\ncheck? We can mark that test case as \"known to fail\" right now. We can\nthen give it to some sparse new comers as warm up projects to make\nsome failure test cases pass.\n\nChris\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
      "normalized_subject": "minmax: make generic MIN() and MAX() macros available everywhere",
      "message_count": 23,
      "participants": [
        "Farber, Eliav",
        "Greg KH"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-09-29T14:47:31+00:00",
      "last_date": "2025-09-29T18:39:00+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175915714928510.mbox",
          "message_id": "<2025092955-module-landfall-ed45 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 14:47:31+00:00",
          "date_str": "Mon, 29 Sep 2025 14:47:31 +0000",
          "body": "On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > >\n> > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> >\n> > <snip>\n> >\n> > As this didn't go into 6.6.y yet, I'll stop here on this series for now.\n> > Please fix up for newer kernels first and then resend these.\n> \n> For 6.6.y I backported 15 commits:\n> https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/#t\n> \n> Why weren't all of them picked?\n\nBecause one of them broke the build, as I wrote a week ago here:\n\thttps://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175915718828548.mbox",
          "message_id": "<2025092955-module-landfall-ed45 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 14:47:31+00:00",
          "date_str": "Mon, 29 Sep 2025 14:47:31 +0000",
          "body": "On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > >\n> > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> >\n> > <snip>\n> >\n> > As this didn't go into 6.6.y yet, I'll stop here on this series for now.\n> > Please fix up for newer kernels first and then resend these.\n> \n> For 6.6.y I backported 15 commits:\n> https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/#t\n> \n> Why weren't all of them picked?\n\nBecause one of them broke the build, as I wrote a week ago here:\n\thttps://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175915715028511.mbox",
          "message_id": "<2025092955-module-landfall-ed45 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 14:47:31+00:00",
          "date_str": "Mon, 29 Sep 2025 14:47:31 +0000",
          "body": "On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > >\n> > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> >\n> > <snip>\n> >\n> > As this didn't go into 6.6.y yet, I'll stop here on this series for now.\n> > Please fix up for newer kernels first and then resend these.\n> \n> For 6.6.y I backported 15 commits:\n> https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/#t\n> \n> Why weren't all of them picked?\n\nBecause one of them broke the build, as I wrote a week ago here:\n\thttps://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175915722428569.mbox",
          "message_id": "<2025092955-module-landfall-ed45 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 14:47:31+00:00",
          "date_str": "Mon, 29 Sep 2025 14:47:31 +0000",
          "body": "On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > >\n> > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> >\n> > <snip>\n> >\n> > As this didn't go into 6.6.y yet, I'll stop here on this series for now.\n> > Please fix up for newer kernels first and then resend these.\n> \n> For 6.6.y I backported 15 commits:\n> https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/#t\n> \n> Why weren't all of them picked?\n\nBecause one of them broke the build, as I wrote a week ago here:\n\thttps://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916639902360.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916640702391.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916641002395.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916642402413.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916640002365.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916639802357.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916640002366.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916673202625.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175916640202387.mbox",
          "message_id": "<e754fed7d53040fb92e1ef9b64c64f6e () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 17:21:58+00:00",
          "date_str": "Mon, 29 Sep 2025 17:21:58 +0000",
          "body": "> On Mon, Sep 29, 2025 at 02:39:26PM +0000, Farber, Eliav wrote:\n> > > On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> > > > From: Linus Torvalds <torvalds@linux-foundation.org>\n> > > >\n> > > > [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n> > >\n> > > <snip>\n> > >\n> > > As this didn't go into 6.6.y yet, I'll stop here on this series for n=\now.\n> > > Please fix up for newer kernels first and then resend these.\n> >\n> > For 6.6.y I backported 15 commits:\n> > https://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.co=\nm/T/#t\n> >\n> > Why weren't all of them picked?\n>\n> Because one of them broke the build, as I wrote a week ago here:\n>         https://lore.kernel.org/all/2025092209-owl-whisking-03e3@gregkh/\n\nFixed:\nhttps://lore.kernel.org/stable/20250929171733.20671-1-farbere@amazon.com/T/=\n#t\n\n---\nThanks, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917103905326.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917101605282.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917102505308.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917101805291.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175921005625576.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917102005301.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917103205315.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917101805292.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917101705287.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175917101005279.mbox",
          "message_id": "<f32d53131d0a4b61a7be4862c7a7f237 () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 07/19 v6.1.y] minmax: make generic MIN() and MAX() macros available everywhere",
          "date": "2025-09-29 18:39:00+00:00",
          "date_str": "Mon, 29 Sep 2025 18:39:00 +0000",
          "body": "On Wed, Sep 24, 2025 at 08:23:08PM +0000, Eliav Farber wrote:\n> From: Linus Torvalds <torvalds@linux-foundation.org>\n>\n> [ Upstream commit 1a251f52cfdc417c84411a056bc142cbd77baef4 ]\n\n<snip>\n\nAs this didn't go into 6.6.y yet, I'll stop here on this series for now.\nPlease fix up for newer kernels first and then resend these.\n\nThe fix for 6.6.y was applied also on 6.1.y:\nhttps://lore.kernel.org/stable/20250929183358.18982-1-farbere@amazon.com/\n\n---\nRegards, Eliav\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH] doc: update the instructions for mailing list subscription",
      "normalized_subject": "doc: update the instructions for mailing list subscription",
      "message_count": 2,
      "participants": [
        "Chris Li",
        "Changyuan Lyu"
      ],
      "categories": [
        "kernel_integration",
        "sparse_internals"
      ],
      "first_date": "2025-09-29T00:57:27+00:00",
      "last_date": "2025-09-29T06:17:56+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175910732228706.mbox",
          "message_id": "<20250929005727.18121-1-changyuan.lv () gmail ! com>",
          "author_name": "Changyuan Lyu",
          "author_email": "changyuan.lv () gmail ! com",
          "subject": "[PATCH] doc: update the instructions for mailing list subscription",
          "date": "2025-09-29 00:57:27+00:00",
          "date_str": "Mon, 29 Sep 2025 00:57:27 +0000",
          "body": "Majordomo commands are deprecated as per\nhttps://subspace.kernel.org/vger.kernel.org.html#what-happened-to-majordomo.\n\nSigned-off-by: Changyuan Lyu <changyuan.lv@gmail.com>\n---\n Documentation/index.rst | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n\ndiff --git a/Documentation/index.rst b/Documentation/index.rst\nindex e29a5643..4c810787 100644\n--- a/Documentation/index.rst\n+++ b/Documentation/index.rst\n@@ -56,8 +56,8 @@ You do not have to be subscribed to the list to send a message there.\n Previous discussions and bug reports are available on the list\n archives at https://marc.info/?l=linux-sparse.\n \n-To subscribe to the list, send an email with\n-``subscribe linux-sparse`` in the body to ``majordomo@vger.kernel.org``.\n+To subscribe to the list, send an email to ``linux-sparse+subscribe@vger.kernel.org``,\n+check `Subspace <https://subspace.kernel.org/subscribing.html>`_ for details.\n \n Bugs can also be reported and tracked via the `Linux kernel's bugzilla for sparse\n <https://bugzilla.kernel.org/enter_bug.cgi?component=Sparse&product=Tools>`_.\n-- \n2.50.1 (Apple Git-155)\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175912655908621.mbox",
          "message_id": "<CACePvbUD8DLgzdRe-nBujBSN4eynRyVCYw9W9-xM-N3mqkwurA () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] doc: update the instructions for mailing list subscription",
          "date": "2025-09-29 06:17:56+00:00",
          "date_str": "Mon, 29 Sep 2025 06:17:56 +0000",
          "body": "On Sun, Sep 28, 2025 at 5:57=E2=80=AFPM Changyuan Lyu <changyuan.lv@gmail.c=\nom> wrote:\n>\n> Majordomo commands are deprecated as per\n> https://subspace.kernel.org/vger.kernel.org.html#what-happened-to-majordo=\nmo.\n\nThanks,\n\nApplied and pushed to sparse-dev.\n\nChris\n\n>\n> Signed-off-by: Changyuan Lyu <changyuan.lv@gmail.com>\n> ---\n>  Documentation/index.rst | 4 ++--\n>  1 file changed, 2 insertions(+), 2 deletions(-)\n>\n> diff --git a/Documentation/index.rst b/Documentation/index.rst\n> index e29a5643..4c810787 100644\n> --- a/Documentation/index.rst\n> +++ b/Documentation/index.rst\n> @@ -56,8 +56,8 @@ You do not have to be subscribed to the list to send a =\nmessage there.\n>  Previous discussions and bug reports are available on the list\n>  archives at https://marc.info/?l=3Dlinux-sparse.\n>\n> -To subscribe to the list, send an email with\n> -``subscribe linux-sparse`` in the body to ``majordomo@vger.kernel.org``.\n> +To subscribe to the list, send an email to ``linux-sparse+subscribe@vger=\n.kernel.org``,\n> +check `Subspace <https://subspace.kernel.org/subscribing.html>`_ for det=\nails.\n>\n>  Bugs can also be reported and tracked via the `Linux kernel's bugzilla f=\nor sparse\n>  <https://bugzilla.kernel.org/enter_bug.cgi?component=3DSparse&product=3D=\nTools>`_.\n> --\n> 2.50.1 (Apple Git-155)\n>\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Sparse merge window is open",
      "normalized_subject": "Sparse merge window is open",
      "message_count": 1,
      "participants": [
        "Chris Li"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-09-28T04:45:16+00:00",
      "last_date": "2025-09-28T04:45:16+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175903459531294.mbox",
          "message_id": "<CACePvbUajv=xC0J4eKdVoskRvKQDwxrM4v17+6t1M42xsbQ-gg () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Sparse merge window is open",
          "date": "2025-09-28 04:45:16+00:00",
          "date_str": "Sun, 28 Sep 2025 04:45:16 +0000",
          "body": "Hi everyone,\n\nAfter a long break from sparse the project. I have fully returned back\nto resume the maintainer role on sparse. I want to thank Luc for\ntaking great care of the project while I am gone. Looking forward to\nthe pull request from him again.\n\nI am going through the mailing list for old patches that can be\napplied to sparse but I haven't found much yet.\n\nIf you have patches that can be applied to sparse, now is a good time\nto re-submit them. I want to cut a release after this round of merge\nwindow.\n\nRegarding the sparse vs sparse-dev repo. Here is how I intend to use\nthese two repo:\n1) sparse repo. This is the stable repo, the git history will not\nrewind. If something bad happens to the old commit, a revert commit\nwill be added to remove the problematic commit.\n2) sparse-dev repo. This repo is always using sparse stable repo as\nbase. However the change newer than the sparse stable repo is not\nguaranteed to be stable. I might rewind and re-apply a newer version\nof the patches. Consider it as a staging repo. I will merge (fast\nforward) from the sparse-dev to sparse at about weekly or bi-weekly\nbases. Testing please use the sparse-dev repo for the cutting edge\nchanges.\n\nIf you want to submit patches to sparse, recommend using the stable\nsparse repo as the base. Only use sparse-dev as base if there are very\nbleeding edge patches that only exist on sparse-dev.\n\nPull request please use the sparse repo as well.\n\nAnother issue I want to collect some feedback is that, the kernel has\nremove the sparse context checker:\nhttps://lore.kernel.org/linux-sparse/20250918140451.1289454-23-elver@google.com/\n\nDoes any once feel strongly removing the lock context code in sparse\nitself because the main usage case is now gone?\n\nChris\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: Project status",
      "normalized_subject": "Project status",
      "message_count": 1,
      "participants": [
        "Carlos Rodriguez-Fernandez"
      ],
      "categories": [
        "rfc_proposals",
        "sparse_internals"
      ],
      "first_date": "2025-09-25T16:37:05+00:00",
      "last_date": "2025-09-25T16:37:05+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175881809910341.mbox",
          "message_id": "<a7d63c3d-adcc-4d27-84bc-4681692ad7e7 () gmail ! com>",
          "author_name": "Carlos Rodriguez-Fernandez",
          "author_email": "carlosrodrifernandez () gmail ! com",
          "subject": "Re: Project status",
          "date": "2025-09-25 16:37:05+00:00",
          "date_str": "Thu, 25 Sep 2025 16:37:05 +0000",
          "body": "This is an OpenPGP/MIME signed message (RFC 4880 and 3156)\n--------------w0Xp5BPBCdhi3qzlOnarfRBB\nContent-Type: multipart/mixed; boundary=\"------------B08MkRfOdoNIXkw9Oto75agH\";\n protected-headers=\"v1\"\nFrom: Carlos Rodriguez-Fernandez <carlosrodrifernandez@gmail.com>\nTo: Chris Li <sparse@chrisli.org>\nCc: linux-sparse@vger.kernel.org\nMessage-ID: <a7d63c3d-adcc-4d27-84bc-4681692ad7e7@gmail.com>\nSubject: Re: Project status\nReferences: <09264d38-887f-4a12-961d-82da3b09ad57@gmail.com>\n <CACePvbXoyMRLwNJpui9GGf30T8UCzo5JT2jPTBQsSnBtT9kZYQ@mail.gmail.com>\nIn-Reply-To: <CACePvbXoyMRLwNJpui9GGf30T8UCzo5JT2jPTBQsSnBtT9kZYQ@mail.gmail.com>\n\n--------------B08MkRfOdoNIXkw9Oto75agH\nContent-Type: text/plain; charset=UTF-8; format=flowed\nContent-Transfer-Encoding: base64\n\nSGkgQ2hyaXMsDQoNCkkgaGF2ZSBub3RoaW5nIGluIHBhcnRpY3VsYXIsIGp1c3Qgd2FudGVk\nIHRvIGtub3cgaWYgdGhlIHByb2plY3Qgd2FzIA0KZ29pbmcgdW5tYWludGFpbmVkLiBJJ20g\nZ2xhZCB0byBoZWFyIGl0IGlzIGJlaW5nIHBpY2tlZCB1cC4NCg0KUmVnYXJkcywNCg0KQ2Fy\nbG9zIFIuRi4NCg0KT24gOS8yNS8yNSA5OjA4IEFNLCBDaHJpcyBMaSB3cm90ZToNCj4gSGkg\nQ2FybG9zLA0KPg0KPiBJIHdhcyB0aGUgc3BhcnNlIG1haW50YWluZXIgYmV0d2VlbiAyMDA5\nIHRvIDIwMTguIEkgYW0gYmFjayBhcyB0aGUNCj4gc3BhcnNlIG1haW50YWluZXIgc2luY2Ug\nbGFzdCB3ZWVrZW5kLg0KPg0KPiBTdGlsbCBjYXRjaGluZyB1cCB3aXRoIHRoaW5ncyBhbmQg\nZmluZGluZyB0aGUgbWlzc2luZyBwYXRjaCBpbiB0aGUNCj4gbWFpbCBsaXN0IHRvIGFwcGx5\nIHRvIHNwYXJzZS4gUGxlYXNlIGxldCBtZSBrbm93IGlmIHlvdSBoYXZlIGFueSB3aXNoDQo+\nIGxpc3Qgb3IgcGFydGljdWxhciBwYXRjaCB5b3Ugd2FudCBpbiB0aGUgbmV3IHNwYWNlIHJl\nbGVhc2UuIEkgY2FuIGN1dA0KPiBhIHNwYXJzZSByZWxlYXNlIGFmdGVyIHRoZSBpbml0aWFs\nIGJhdGNoZWQgY2F0Y2ggdXAuDQo+DQo+IENocmlzDQo+DQo+DQo+IE9uIEZyaSwgU2VwIDEy\nLCAyMDI1IGF0IDEwOjA44oCvUE0gQ2FybG9zIFJvZHJpZ3Vlei1GZXJuYW5kZXoNCj4gPGNh\ncmxvc3JvZHJpZmVybmFuZGV6QGdtYWlsLmNvbT4gd3JvdGU6DQo+PiBIaSwNCj4+DQo+PiBJ\nJ20gY3VycmVudGx5IG1haW50YWluaW5nIHRoaXMgcGFja2FnZSBpbiBGZWRvcmEgTGludXgs\nIGFuZCBJIHdhcw0KPj4gd29uZGVyaW5nIGFib3V0IHRoZSBzdGF0dXMgb2YgdGhpcyBwcm9q\nZWN0LiBJIHNlZSB0aGF0IHJlbGVhc2VzIHVzZWQgdG8NCj4+IGNvbWUgYSBmZXcgYSB5ZWFy\nLCBidXQgbm8gcmVsZWFzZSBoYXMgYmVlbiBkb25lIGZvciBhYm91dCA0IHllYXJzLA0KPj4g\naG93ZXZlciB0aGUgcGF0Y2hlcyBhcmUgc3RpbGwgY29taW5nIGluIHRoZSBtYWlsaW5nIGxp\nc3QgbGlrZSBpZiBpdCB3ZXJlDQo+PiBhY3RpdmVseSBiZWluZyBkZXZlbG9wZWQgc3RpbGwu\nIFdoYXQgaXMgdGhlIGN1cnJlbnQgc3RhdHVzIG9mIHRoaXMNCj4+IHByb2plY3Q/IFRoYW5r\nIHlvdSBmb3IgYW55IGluc2lnaHQuDQo+Pg0KPj4gUmVnYXJkcywNCj4+DQo+PiBDYXJsb3Mg\nUi5GLg0KPj4NCg==\n\n--------------B08MkRfOdoNIXkw9Oto75agH--\n\n--------------w0Xp5BPBCdhi3qzlOnarfRBB\nContent-Type: application/pgp-signature; name=\"OpenPGP_signature.asc\"\nContent-Description: OpenPGP digital signature\nContent-Disposition: attachment; filename=\"OpenPGP_signature.asc\"\n\n-----BEGIN PGP SIGNATURE-----\n\nwsD5BAABCAAjFiEELMV13GzPmqlwKY7rR+vtBcM3Wx8FAmjVb7EFAwAAAAAACgkQR+vtBcM3Wx+x\n3wv/ZXp1LGI+j8Pdko7rny0Fl6ye1B3Iip/8sAs9WddIWCzvJWz+1QqhWbxWKhaivVkB4z5RUy0+\ndpVPcp8SqDBjJb6P2AVQuQvDyj23F88dmWH4M+dgRlQYtT0x62GzhhSyjs1TMCHuqkby/jLX6CDK\nIl0BxchEoB8Rsj/zm6MBfNK6nBrVEZHIXpY9QmmzNnUxsL7VUNRd39+RjET+N8E51XUNkQBxoB2Q\nmmQGLgkUAK+ORyncaCxJ+okV6O3pUg9EI28aPuJLEpehvyEtG7MzthCX8417z2FHr4WNHln4dx8Q\nIdikNjsveqowhURA3591wucuxImnRwOK8Pb5rr7/Fsb4Kd3Xtefmf8Ni5fP8/WUhHTS5IQ0cO/Dx\n7u2DBuDUa0Ml0IADFZK1HI/UnGqB/VYi92vgXUIVIzPRHjYL0gXN+eosOLWpObYexmU9SPgmVjoR\n1xp6XeMIXd0gVbxOZ5/N24goCFeub2XGbkFcxhk7IuePiQCnwOnobEI/lvk2\n=UKmH\n-----END PGP SIGNATURE-----\n\n--------------w0Xp5BPBCdhi3qzlOnarfRBB--\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH 17/19 v6.1.y] minmax.h: move all the clamp() definitions after the min/max() ones",
      "normalized_subject": "minmax.h: move all the clamp() definitions after the min/max() ones",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:18+00:00",
      "last_date": "2025-10-17T09:05:17+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874618827954.mbox",
          "message_id": "<20250924202320.32333-18-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 17/19 v6.1.y] minmax.h: move all the clamp() definitions after the min/max() ones",
          "date": "2025-09-24 20:23:18+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:18 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit c3939872ee4a6b8bdcd0e813c66823b31e6e26f7 ]\n\nAt some point the definitions for clamp() got added in the middle of the\nones for min() and max().  Re-order the definitions so they are more\nsensibly grouped.\n\nLink: https://lkml.kernel.org/r/8bb285818e4846469121c8abc3dfb6e2@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 109 +++++++++++++++++++----------------------\n 1 file changed, 51 insertions(+), 58 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 91aa1b90c1bb..75fb7a6ad4c6 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -99,22 +99,6 @@\n #define __careful_cmp(op, x, y) \\\n \t__careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n \n-#define __clamp(val, lo, hi)\t\\\n-\t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n-\n-#define __clamp_once(val, lo, hi, uval, ulo, uhi) ({\t\t\t\t\\\n-\t__auto_type uval = (val);\t\t\t\t\t\t\\\n-\t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n-\t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n-\tBUILD_BUG_ON_MSG(statically_true(ulo > uhi),\t\t\t\t\\\n-\t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n-\t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n-\t__clamp(uval, ulo, uhi); })\n-\n-#define __careful_clamp(val, lo, hi) \\\n-\t__clamp_once(val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n-\n /**\n  * min - return minimum of two values of the same or compatible types\n  * @x: first value\n@@ -170,6 +154,22 @@\n #define max3(x, y, z) \\\n \t__careful_op3(max, x, y, z, __UNIQUE_ID(x_), __UNIQUE_ID(y_), __UNIQUE_ID(z_))\n \n+/**\n+ * min_t - return minimum of two values, using the specified type\n+ * @type: data type to use\n+ * @x: first value\n+ * @y: second value\n+ */\n+#define min_t(type, x, y) __cmp_once(min, type, x, y)\n+\n+/**\n+ * max_t - return maximum of two values, using the specified type\n+ * @type: data type to use\n+ * @x: first value\n+ * @y: second value\n+ */\n+#define max_t(type, x, y) __cmp_once(max, type, x, y)\n+\n /**\n  * min_not_zero - return the minimum that is _not_ zero, unless both are zero\n  * @x: value1\n@@ -180,6 +180,22 @@\n \ttypeof(y) __y = (y);\t\t\t\\\n \t__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })\n \n+#define __clamp(val, lo, hi)\t\\\n+\t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n+\n+#define __clamp_once(val, lo, hi, uval, ulo, uhi) ({\t\t\t\t\\\n+\t__auto_type uval = (val);\t\t\t\t\t\t\\\n+\t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n+\t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n+\tBUILD_BUG_ON_MSG(statically_true(ulo > uhi),\t\t\t\t\\\n+\t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n+\t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n+\t__clamp(uval, ulo, uhi); })\n+\n+#define __careful_clamp(val, lo, hi) \\\n+\t__clamp_once(val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n+\n /**\n  * clamp - return a value clamped to a given range with strict typechecking\n  * @val: current value\n@@ -191,28 +207,30 @@\n  */\n #define clamp(val, lo, hi) __careful_clamp(val, lo, hi)\n \n-/*\n- * ..and if you can't take the strict\n- * types, you can specify one yourself.\n- *\n- * Or not use min/max/clamp at all, of course.\n- */\n-\n /**\n- * min_t - return minimum of two values, using the specified type\n- * @type: data type to use\n- * @x: first value\n- * @y: second value\n+ * clamp_t - return a value clamped to a given range using a given type\n+ * @type: the type of variable to use\n+ * @val: current value\n+ * @lo: minimum allowable value\n+ * @hi: maximum allowable value\n+ *\n+ * This macro does no typechecking and uses temporary variables of type\n+ * @type to make all the comparisons.\n  */\n-#define min_t(type, x, y) __cmp_once(min, type, x, y)\n+#define clamp_t(type, val, lo, hi) __careful_clamp((type)(val), (type)(lo), (type)(hi))\n \n /**\n- * max_t - return maximum of two values, using the specified type\n- * @type: data type to use\n- * @x: first value\n- * @y: second value\n+ * clamp_val - return a value clamped to a given range using val's type\n+ * @val: current value\n+ * @lo: minimum allowable value\n+ * @hi: maximum allowable value\n+ *\n+ * This macro does no typechecking and uses temporary variables of whatever\n+ * type the input argument @val is.  This is useful when @val is an unsigned\n+ * type and @lo and @hi are literals that will otherwise be assigned a signed\n+ * integer type.\n  */\n-#define max_t(type, x, y) __cmp_once(max, t",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069337903171.mbox",
          "message_id": "<20251017090519.46992-26-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 25/27 5.10.y] minmax.h: move all the clamp() definitions after the min/max() ones",
          "date": "2025-10-17 09:05:17+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:17 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit c3939872ee4a6b8bdcd0e813c66823b31e6e26f7 ]\n\nAt some point the definitions for clamp() got added in the middle of the\nones for min() and max().  Re-order the definitions so they are more\nsensibly grouped.\n\nLink: https://lkml.kernel.org/r/8bb285818e4846469121c8abc3dfb6e2@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 109 +++++++++++++++++++----------------------\n 1 file changed, 51 insertions(+), 58 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 91aa1b90c1bb..75fb7a6ad4c6 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -99,22 +99,6 @@\n #define __careful_cmp(op, x, y) \\\n \t__careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n \n-#define __clamp(val, lo, hi)\t\\\n-\t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n-\n-#define __clamp_once(val, lo, hi, uval, ulo, uhi) ({\t\t\t\t\\\n-\t__auto_type uval = (val);\t\t\t\t\t\t\\\n-\t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n-\t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n-\tBUILD_BUG_ON_MSG(statically_true(ulo > uhi),\t\t\t\t\\\n-\t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n-\t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n-\t__clamp(uval, ulo, uhi); })\n-\n-#define __careful_clamp(val, lo, hi) \\\n-\t__clamp_once(val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n-\n /**\n  * min - return minimum of two values of the same or compatible types\n  * @x: first value\n@@ -170,6 +154,22 @@\n #define max3(x, y, z) \\\n \t__careful_op3(max, x, y, z, __UNIQUE_ID(x_), __UNIQUE_ID(y_), __UNIQUE_ID(z_))\n \n+/**\n+ * min_t - return minimum of two values, using the specified type\n+ * @type: data type to use\n+ * @x: first value\n+ * @y: second value\n+ */\n+#define min_t(type, x, y) __cmp_once(min, type, x, y)\n+\n+/**\n+ * max_t - return maximum of two values, using the specified type\n+ * @type: data type to use\n+ * @x: first value\n+ * @y: second value\n+ */\n+#define max_t(type, x, y) __cmp_once(max, type, x, y)\n+\n /**\n  * min_not_zero - return the minimum that is _not_ zero, unless both are zero\n  * @x: value1\n@@ -180,6 +180,22 @@\n \ttypeof(y) __y = (y);\t\t\t\\\n \t__x == 0 ? __y : ((__y == 0) ? __x : min(__x, __y)); })\n \n+#define __clamp(val, lo, hi)\t\\\n+\t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n+\n+#define __clamp_once(val, lo, hi, uval, ulo, uhi) ({\t\t\t\t\\\n+\t__auto_type uval = (val);\t\t\t\t\t\t\\\n+\t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n+\t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n+\tBUILD_BUG_ON_MSG(statically_true(ulo > uhi),\t\t\t\t\\\n+\t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n+\t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n+\t__clamp(uval, ulo, uhi); })\n+\n+#define __careful_clamp(val, lo, hi) \\\n+\t__clamp_once(val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n+\n /**\n  * clamp - return a value clamped to a given range with strict typechecking\n  * @val: current value\n@@ -191,28 +207,30 @@\n  */\n #define clamp(val, lo, hi) __careful_clamp(val, lo, hi)\n \n-/*\n- * ..and if you can't take the strict\n- * types, you can specify one yourself.\n- *\n- * Or not use min/max/clamp at all, of course.\n- */\n-\n /**\n- * min_t - return minimum of two values, using the specified type\n- * @type: data type to use\n- * @x: first value\n- * @y: second value\n+ * clamp_t - return a value clamped to a given range using a given type\n+ * @type: the type of variable to use\n+ * @val: current value\n+ * @lo: minimum allowable value\n+ * @hi: maximum allowable value\n+ *\n+ * This macro does no typechecking and uses temporary variables of type\n+ * @type to make all the comparisons.\n  */\n-#define min_t(type, x, y) __cmp_once(min, type, x, y)\n+#define clamp_t(type, val, lo, hi) __careful_clamp((type)(val), (type)(lo), (type)(hi))\n \n /**\n- * max_t - return maximum of two values, using the specified type\n- * @type: data type to use\n- * @x: first value\n- * @y: second value\n+ * clamp_val - return a value clamped to a given range using val's type\n+ * @val: current value\n+ * @lo: minimum allowable value\n+ * @hi: maximum allowable value\n+ *\n+ * This macro does no typechecking and uses temporary variables of whatever\n+ * type the input argument @val is.  This is useful when @val is an unsigned\n+ * type and @lo and @hi are literals that will otherwise be assigned a signed\n+ * integer type.\n  */\n-#define max_t(type, x, y) __cmp_once(max, t",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH 16/19 v6.1.y] minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()",
      "normalized_subject": "minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:17+00:00",
      "last_date": "2025-09-24T20:23:17+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874611327842.mbox",
          "message_id": "<20250924202320.32333-17-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 16/19 v6.1.y] minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()",
          "date": "2025-09-24 20:23:17+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:17 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit a5743f32baec4728711bbc01d6ac2b33d4c67040 ]\n\nUse BUILD_BUG_ON_MSG(statically_true(ulo > uhi), ...) for the sanity check\nof the bounds in clamp().  Gives better error coverage and one less\nexpansion of the arguments.\n\nLink: https://lkml.kernel.org/r/34d53778977747f19cce2abb287bb3e6@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 3 +--\n 1 file changed, 1 insertion(+), 2 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 6f7ea669d305..91aa1b90c1bb 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -106,8 +106,7 @@\n \t__auto_type uval = (val);\t\t\t\t\t\t\\\n \t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n \t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n-\tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n-\t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n+\tBUILD_BUG_ON_MSG(statically_true(ulo > uhi),\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n \tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n \t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH 15/19 v6.1.y] minmax.h: reduce the #define expansion of min(), max() and clamp()",
      "normalized_subject": "minmax.h: reduce the #define expansion of min(), max() and clamp()",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "sparse_internals",
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:16+00:00",
      "last_date": "2025-10-17T09:05:15+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874603427732.mbox",
          "message_id": "<20250924202320.32333-16-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 15/19 v6.1.y] minmax.h: reduce the #define expansion of min(), max() and clamp()",
          "date": "2025-09-24 20:23:16+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:16 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit b280bb27a9f7c91ddab730e1ad91a9c18a051f41 ]\n\nSince the test for signed values being non-negative only relies on\n__builtion_constant_p() (not is_constexpr()) it can use the 'ux' variable\ninstead of the caller supplied expression.  This means that the #define\nparameters are only expanded twice.  Once in the code and once quoted in\nthe error message.\n\nLink: https://lkml.kernel.org/r/051afc171806425da991908ed8688a98@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 24 ++++++++++++------------\n 1 file changed, 12 insertions(+), 12 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 24e4b372649a..6f7ea669d305 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -46,10 +46,10 @@\n  * comparison, and these expressions only need to be careful to not cause\n  * warnings for pointer use.\n  */\n-#define __signed_type_use(x, ux) (2 + __is_nonneg(x, ux))\n-#define __unsigned_type_use(x, ux) (1 + 2 * (sizeof(ux) < 4))\n-#define __sign_use(x, ux) (is_signed_type(typeof(ux)) ? \\\n-\t__signed_type_use(x, ux) : __unsigned_type_use(x, ux))\n+#define __signed_type_use(ux) (2 + __is_nonneg(ux))\n+#define __unsigned_type_use(ux) (1 + 2 * (sizeof(ux) < 4))\n+#define __sign_use(ux) (is_signed_type(typeof(ux)) ? \\\n+\t__signed_type_use(ux) : __unsigned_type_use(ux))\n \n /*\n  * Check whether a signed value is always non-negative.\n@@ -71,13 +71,13 @@\n #else\n   #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n #endif\n-#define __is_nonneg(x, ux) statically_true((__signed_type(ux))(x) >= 0)\n+#define __is_nonneg(ux) statically_true((__signed_type(ux))(ux) >= 0)\n \n-#define __types_ok(x, y, ux, uy) \\\n-\t(__sign_use(x, ux) & __sign_use(y, uy))\n+#define __types_ok(ux, uy) \\\n+\t(__sign_use(ux) & __sign_use(uy))\n \n-#define __types_ok3(x, y, z, ux, uy, uz) \\\n-\t(__sign_use(x, ux) & __sign_use(y, uy) & __sign_use(z, uz))\n+#define __types_ok3(ux, uy, uz) \\\n+\t(__sign_use(ux) & __sign_use(uy) & __sign_use(uz))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n@@ -92,7 +92,7 @@\n \n #define __careful_cmp_once(op, x, y, ux, uy) ({\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok(x, y, ux, uy),\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok(ux, uy),\t\t\\\n \t\t#op\"(\"#x\", \"#y\") signedness error\");\t\\\n \t__cmp(op, ux, uy); })\n \n@@ -109,7 +109,7 @@\n \tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n \t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(val, lo, hi, uval, ulo, uhi),\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n \t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n \t__clamp(uval, ulo, uhi); })\n \n@@ -149,7 +149,7 @@\n \n #define __careful_op3(op, x, y, z, ux, uy, uz) ({\t\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);__auto_type uz = (z);\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(x, y, z, ux, uy, uz),\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(ux, uy, uz),\t\t\t\\\n \t\t#op\"3(\"#x\", \"#y\", \"#z\") signedness error\");\t\t\\\n \t__cmp(op, ux, __cmp(op, uy, uz)); })\n \n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069329803074.mbox",
          "message_id": "<20251017090519.46992-24-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 23/27 5.10.y] minmax.h: reduce the #define expansion of min(), max() and clamp()",
          "date": "2025-10-17 09:05:15+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:15 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit b280bb27a9f7c91ddab730e1ad91a9c18a051f41 ]\n\nSince the test for signed values being non-negative only relies on\n__builtion_constant_p() (not is_constexpr()) it can use the 'ux' variable\ninstead of the caller supplied expression.  This means that the #define\nparameters are only expanded twice.  Once in the code and once quoted in\nthe error message.\n\nLink: https://lkml.kernel.org/r/051afc171806425da991908ed8688a98@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 24 ++++++++++++------------\n 1 file changed, 12 insertions(+), 12 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 24e4b372649a..6f7ea669d305 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -46,10 +46,10 @@\n  * comparison, and these expressions only need to be careful to not cause\n  * warnings for pointer use.\n  */\n-#define __signed_type_use(x, ux) (2 + __is_nonneg(x, ux))\n-#define __unsigned_type_use(x, ux) (1 + 2 * (sizeof(ux) < 4))\n-#define __sign_use(x, ux) (is_signed_type(typeof(ux)) ? \\\n-\t__signed_type_use(x, ux) : __unsigned_type_use(x, ux))\n+#define __signed_type_use(ux) (2 + __is_nonneg(ux))\n+#define __unsigned_type_use(ux) (1 + 2 * (sizeof(ux) < 4))\n+#define __sign_use(ux) (is_signed_type(typeof(ux)) ? \\\n+\t__signed_type_use(ux) : __unsigned_type_use(ux))\n \n /*\n  * Check whether a signed value is always non-negative.\n@@ -71,13 +71,13 @@\n #else\n   #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n #endif\n-#define __is_nonneg(x, ux) statically_true((__signed_type(ux))(x) >= 0)\n+#define __is_nonneg(ux) statically_true((__signed_type(ux))(ux) >= 0)\n \n-#define __types_ok(x, y, ux, uy) \\\n-\t(__sign_use(x, ux) & __sign_use(y, uy))\n+#define __types_ok(ux, uy) \\\n+\t(__sign_use(ux) & __sign_use(uy))\n \n-#define __types_ok3(x, y, z, ux, uy, uz) \\\n-\t(__sign_use(x, ux) & __sign_use(y, uy) & __sign_use(z, uz))\n+#define __types_ok3(ux, uy, uz) \\\n+\t(__sign_use(ux) & __sign_use(uy) & __sign_use(uz))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n@@ -92,7 +92,7 @@\n \n #define __careful_cmp_once(op, x, y, ux, uy) ({\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok(x, y, ux, uy),\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok(ux, uy),\t\t\\\n \t\t#op\"(\"#x\", \"#y\") signedness error\");\t\\\n \t__cmp(op, ux, uy); })\n \n@@ -109,7 +109,7 @@\n \tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n \t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(val, lo, hi, uval, ulo, uhi),\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(uval, ulo, uhi),\t\t\t\t\\\n \t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n \t__clamp(uval, ulo, uhi); })\n \n@@ -149,7 +149,7 @@\n \n #define __careful_op3(op, x, y, z, ux, uy, uz) ({\t\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);__auto_type uz = (z);\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(x, y, z, ux, uy, uz),\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(ux, uy, uz),\t\t\t\\\n \t\t#op\"3(\"#x\", \"#y\", \"#z\") signedness error\");\t\t\\\n \t__cmp(op, ux, __cmp(op, uy, uz)); })\n \n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH 13/19 v6.1.y] minmax.h: add whitespace around operators and after commas",
      "normalized_subject": "minmax.h: add whitespace around operators and after commas",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:14+00:00",
      "last_date": "2025-10-17T09:05:13+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874595827622.mbox",
          "message_id": "<20250924202320.32333-14-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 13/19 v6.1.y] minmax.h: add whitespace around operators and after commas",
          "date": "2025-09-24 20:23:14+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:14 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit 71ee9b16251ea4bf7c1fe222517c82bdb3220acc ]\n\nPatch series \"minmax.h: Cleanups and minor optimisations\".\n\nSome tidyups and minor changes to minmax.h.\n\nThis patch (of 7):\n\nLink: https://lkml.kernel.org/r/c50365d214e04f9ba256d417c8bebbc0@AcuMS.aculab.com\nLink: https://lkml.kernel.org/r/f04b2e1310244f62826267346fde0553@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 34 +++++++++++++++++-----------------\n 1 file changed, 17 insertions(+), 17 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 98008dd92153..51b0d988e322 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -51,10 +51,10 @@\n  * only need to be careful to not cause warnings for\n  * pointer use.\n  */\n-#define __signed_type_use(x,ux) (2+__is_nonneg(x,ux))\n-#define __unsigned_type_use(x,ux) (1+2*(sizeof(ux)<4))\n-#define __sign_use(x,ux) (is_signed_type(typeof(ux))? \\\n-\t__signed_type_use(x,ux):__unsigned_type_use(x,ux))\n+#define __signed_type_use(x, ux) (2 + __is_nonneg(x, ux))\n+#define __unsigned_type_use(x, ux) (1 + 2 * (sizeof(ux) < 4))\n+#define __sign_use(x, ux) (is_signed_type(typeof(ux)) ? \\\n+\t__signed_type_use(x, ux) : __unsigned_type_use(x, ux))\n \n /*\n  * To avoid warnings about casting pointers to integers\n@@ -74,15 +74,15 @@\n #ifdef CONFIG_64BIT\n   #define __signed_type(ux) long\n #else\n-  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux)>4,1LL,1L))\n+  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n #endif\n-#define __is_nonneg(x,ux) statically_true((__signed_type(ux))(x)>=0)\n+#define __is_nonneg(x, ux) statically_true((__signed_type(ux))(x) >= 0)\n \n-#define __types_ok(x,y,ux,uy) \\\n-\t(__sign_use(x,ux) & __sign_use(y,uy))\n+#define __types_ok(x, y, ux, uy) \\\n+\t(__sign_use(x, ux) & __sign_use(y, uy))\n \n-#define __types_ok3(x,y,z,ux,uy,uz) \\\n-\t(__sign_use(x,ux) & __sign_use(y,uy) & __sign_use(z,uz))\n+#define __types_ok3(x, y, z, ux, uy, uz) \\\n+\t(__sign_use(x, ux) & __sign_use(y, uy) & __sign_use(z, uz))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n@@ -97,7 +97,7 @@\n \n #define __careful_cmp_once(op, x, y, ux, uy) ({\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok(x,y,ux,uy),\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok(x, y, ux, uy),\t\\\n \t\t#op\"(\"#x\", \"#y\") signedness error\");\t\\\n \t__cmp(op, ux, uy); })\n \n@@ -114,7 +114,7 @@\n \tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n \t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(val,lo,hi,uval,ulo,uhi),\t\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(val, lo, hi, uval, ulo, uhi),\t\t\\\n \t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n \t__clamp(uval, ulo, uhi); })\n \n@@ -154,7 +154,7 @@\n \n #define __careful_op3(op, x, y, z, ux, uy, uz) ({\t\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);__auto_type uz = (z);\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(x,y,z,ux,uy,uz),\t\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(x, y, z, ux, uy, uz),\t\t\\\n \t\t#op\"3(\"#x\", \"#y\", \"#z\") signedness error\");\t\t\\\n \t__cmp(op, ux, __cmp(op, uy, uz)); })\n \n@@ -326,9 +326,9 @@ static inline bool in_range32(u32 val, u32 start, u32 len)\n  * Use these carefully: no type checking, and uses the arguments\n  * multiple times. Use for obvious constants only.\n  */\n-#define MIN(a,b) __cmp(min,a,b)\n-#define MAX(a,b) __cmp(max,a,b)\n-#define MIN_T(type,a,b) __cmp(min,(type)(a),(type)(b))\n-#define MAX_T(type,a,b) __cmp(max,(type)(a),(type)(b))\n+#define MIN(a, b) __cmp(min, a, b)\n+#define MAX(a, b) __cmp(max, a, b)\n+#define MIN_T(type, a, b) __cmp(min, (type)(a), (type)(b))\n+#define MAX_T(type, a, b) __cmp(max, (type)(a), (type)(b))\n \n #endif\t/* _LINUX_MINMAX_H */\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069290902608.mbox",
          "message_id": "<20251017090519.46992-22-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 21/27 5.10.y] minmax.h: add whitespace around operators and after commas",
          "date": "2025-10-17 09:05:13+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:13 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit 71ee9b16251ea4bf7c1fe222517c82bdb3220acc ]\n\nPatch series \"minmax.h: Cleanups and minor optimisations\".\n\nSome tidyups and minor changes to minmax.h.\n\nThis patch (of 7):\n\nLink: https://lkml.kernel.org/r/c50365d214e04f9ba256d417c8bebbc0@AcuMS.aculab.com\nLink: https://lkml.kernel.org/r/f04b2e1310244f62826267346fde0553@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 34 +++++++++++++++++-----------------\n 1 file changed, 17 insertions(+), 17 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 98008dd92153..51b0d988e322 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -51,10 +51,10 @@\n  * only need to be careful to not cause warnings for\n  * pointer use.\n  */\n-#define __signed_type_use(x,ux) (2+__is_nonneg(x,ux))\n-#define __unsigned_type_use(x,ux) (1+2*(sizeof(ux)<4))\n-#define __sign_use(x,ux) (is_signed_type(typeof(ux))? \\\n-\t__signed_type_use(x,ux):__unsigned_type_use(x,ux))\n+#define __signed_type_use(x, ux) (2 + __is_nonneg(x, ux))\n+#define __unsigned_type_use(x, ux) (1 + 2 * (sizeof(ux) < 4))\n+#define __sign_use(x, ux) (is_signed_type(typeof(ux)) ? \\\n+\t__signed_type_use(x, ux) : __unsigned_type_use(x, ux))\n \n /*\n  * To avoid warnings about casting pointers to integers\n@@ -74,15 +74,15 @@\n #ifdef CONFIG_64BIT\n   #define __signed_type(ux) long\n #else\n-  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux)>4,1LL,1L))\n+  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n #endif\n-#define __is_nonneg(x,ux) statically_true((__signed_type(ux))(x)>=0)\n+#define __is_nonneg(x, ux) statically_true((__signed_type(ux))(x) >= 0)\n \n-#define __types_ok(x,y,ux,uy) \\\n-\t(__sign_use(x,ux) & __sign_use(y,uy))\n+#define __types_ok(x, y, ux, uy) \\\n+\t(__sign_use(x, ux) & __sign_use(y, uy))\n \n-#define __types_ok3(x,y,z,ux,uy,uz) \\\n-\t(__sign_use(x,ux) & __sign_use(y,uy) & __sign_use(z,uz))\n+#define __types_ok3(x, y, z, ux, uy, uz) \\\n+\t(__sign_use(x, ux) & __sign_use(y, uy) & __sign_use(z, uz))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n@@ -97,7 +97,7 @@\n \n #define __careful_cmp_once(op, x, y, ux, uy) ({\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok(x,y,ux,uy),\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok(x, y, ux, uy),\t\\\n \t\t#op\"(\"#x\", \"#y\") signedness error\");\t\\\n \t__cmp(op, ux, uy); })\n \n@@ -114,7 +114,7 @@\n \tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n \t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(val,lo,hi,uval,ulo,uhi),\t\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(val, lo, hi, uval, ulo, uhi),\t\t\\\n \t\t\"clamp(\"#val\", \"#lo\", \"#hi\") signedness error\");\t\t\\\n \t__clamp(uval, ulo, uhi); })\n \n@@ -154,7 +154,7 @@\n \n #define __careful_op3(op, x, y, z, ux, uy, uz) ({\t\t\t\\\n \t__auto_type ux = (x); __auto_type uy = (y);__auto_type uz = (z);\\\n-\tBUILD_BUG_ON_MSG(!__types_ok3(x,y,z,ux,uy,uz),\t\t\t\\\n+\tBUILD_BUG_ON_MSG(!__types_ok3(x, y, z, ux, uy, uz),\t\t\\\n \t\t#op\"3(\"#x\", \"#y\", \"#z\") signedness error\");\t\t\\\n \t__cmp(op, ux, __cmp(op, uy, uz)); })\n \n@@ -326,9 +326,9 @@ static inline bool in_range32(u32 val, u32 start, u32 len)\n  * Use these carefully: no type checking, and uses the arguments\n  * multiple times. Use for obvious constants only.\n  */\n-#define MIN(a,b) __cmp(min,a,b)\n-#define MAX(a,b) __cmp(max,a,b)\n-#define MIN_T(type,a,b) __cmp(min,(type)(a),(type)(b))\n-#define MAX_T(type,a,b) __cmp(max,(type)(a),(type)(b))\n+#define MIN(a, b) __cmp(min, a, b)\n+#define MAX(a, b) __cmp(max, a, b)\n+#define MIN_T(type, a, b) __cmp(min, (type)(a), (type)(b))\n+#define MAX_T(type, a, b) __cmp(max, (type)(a), (type)(b))\n \n #endif\t/* _LINUX_MINMAX_H */\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH 11/19 v6.1.y] minmax: improve macro expansion and type checking",
      "normalized_subject": "minmax: improve macro expansion and type checking",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "sparse_internals",
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:12+00:00",
      "last_date": "2025-09-24T20:23:12+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874588127519.mbox",
          "message_id": "<20250924202320.32333-12-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 11/19 v6.1.y] minmax: improve macro expansion and type checking",
          "date": "2025-09-24 20:23:12+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:12 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 22f5468731491e53356ba7c028f0fdea20b18e2c ]\n\nThis clarifies the rules for min()/max()/clamp() type checking and makes\nthem a much more efficient macro expansion.\n\nIn particular, we now look at the type and range of the inputs to see\nwhether they work together, generating a mask of acceptable comparisons,\nand then just verifying that the inputs have a shared case:\n\n - an expression with a signed type can be used for\n    (1) signed comparisons\n    (2) unsigned comparisons if it is statically known to have a\n        non-negative value\n\n - an expression with an unsigned type can be used for\n    (3) unsigned comparison\n    (4) signed comparisons if the type is smaller than 'int' and thus\n        the C integer promotion rules will make it signed anyway\n\nHere rule (1) and (3) are obvious, and rule (2) is important in order to\nallow obvious trivial constants to be used together with unsigned\nvalues.\n\nRule (4) is not necessarily a good idea, but matches what we used to do,\nand we have extant cases of this situation in the kernel.  Notably with\nbcachefs having an expression like\n\n\tmin(bch2_bucket_sectors_dirty(a), ca->mi.bucket_size)\n\nwhere bch2_bucket_sectors_dirty() returns an 's64', and\n'ca->mi.bucket_size' is of type 'u16'.\n\nTechnically that bcachefs comparison is clearly sensible on a C type\nlevel, because the 'u16' will go through the normal C integer promotion,\nand become 'int', and then we're comparing two signed values and\neverything looks sane.\n\nHowever, it's not entirely clear that a 'min(s64,u16)' operation makes a\nlot of conceptual sense, and it's possible that we will remove rule (4).\nAfter all, the _reason_ we have these complicated type checks is exactly\nthat the C type promotion rules are not very intuitive.\n\nBut at least for now the rule is in place for backwards compatibility.\n\nAlso note that rule (2) existed before, but is hugely relaxed by this\ncommit.  It used to be true only for the simplest compile-time\nnon-negative integer constants.  The new macro model will allow cases\nwhere the compiler can trivially see that an expression is non-negative\neven if it isn't necessarily a constant.\n\nFor example, the amdgpu driver does\n\n\tmin_t(size_t, sizeof(fru_info->serial), pia[addr] & 0x3F));\n\nbecause our old 'min()' macro would see that 'pia[addr] & 0x3F' is of\ntype 'int' and clearly not a C constant expression, so doing a 'min()'\nwith a 'size_t' is a signedness violation.\n\nOur new 'min()' macro still sees that 'pia[addr] & 0x3F' is of type\n'int', but is smart enough to also see that it is clearly non-negative,\nand thus would allow that case without any complaints.\n\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/compiler.h |  9 +++++\n include/linux/minmax.h   | 74 ++++++++++++++++++++++++++++++++--------\n 2 files changed, 68 insertions(+), 15 deletions(-)\n\ndiff --git a/include/linux/compiler.h b/include/linux/compiler.h\nindex f6ea15821cea..a6a7be83fae6 100644\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -244,6 +244,15 @@ static inline void *offset_to_ptr(const int *off)\n  */\n #define is_signed_type(type) (((type)(-1)) < (__force type)1)\n \n+/*\n+ * Useful shorthand for \"is this condition known at compile-time?\"\n+ *\n+ * Note that the condition may involve non-constant values,\n+ * but the compiler may know enough about the details of the\n+ * values to determine that the condition is statically true.\n+ */\n+#define statically_true(x) (__builtin_constant_p(x) && (x))\n+\n /*\n  * This is needed in functions which generate the stack canary, see\n  * arch/x86/kernel/smpboot.c::start_secondary() for an example.\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex e3e4353df983..41da6f85a407 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -26,19 +26,63 @@\n #define __typecheck(x, y) \\\n \t(!!(sizeof((typeof(x) *)1 == (typeof(y) *)1)))\n \n-/* is_signed_type() isn't a constexpr for pointer types */\n-#define __is_signed(x) \t\t\t\t\t\t\t\t\\\n-\t__builtin_choose_expr(__is_constexpr(is_signed_type(typeof(x))),\t\\\n-\t\tis_signed_type(typeof(x)), 0)\n+/*\n+ * __sign_use for integer expressions:\n+ *   bit #0 set if ok for unsigned comparisons\n+ *   bit #1 set if ok for signed comparisons\n+ *\n+ * In particular, statically non-negative signed integer\n+ * expressions are ok for both.\n+ *\n+ * NOTE! Unsigned types smaller than 'int' are implicitly\n+ * converted to 'int' in expressions, and are accepted for\n+ * signed conversions for now. This is debatable.\n+ *\n+ * Note that 'x' is the original expression, and 'ux' is\n+ * the unique variable that contains the value.\n+ *\n+ * We use 'ux' for pure type checking, and 'x' for when\n+ * we need to look at the value (but without evaluating\n+ * it for side effects! Careful to only e",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "[PATCH 10/19 v6.1.y] minmax: don't use max() in situations that want a C constant expression",
      "normalized_subject": "minmax: don't use max() in situations that want a C constant expression",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-09-24T20:23:11+00:00",
      "last_date": "2025-10-17T09:05:09+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874577327350.mbox",
          "message_id": "<20250924202320.32333-11-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 10/19 v6.1.y] minmax: don't use max() in situations that want a C constant expression",
          "date": "2025-09-24 20:23:11+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:11 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit cb04e8b1d2f24c4c2c92f7b7529031fc35a16fed ]\n\nWe only had a couple of array[] declarations, and changing them to just\nuse 'MAX()' instead of 'max()' fixes the issue.\n\nThis will allow us to simplify our min/max macros enormously, since they\ncan now unconditionally use temporary variables to avoid using the\nargument values multiple times.\n\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c   | 2 +-\n drivers/input/touchscreen/cyttsp4_core.c | 2 +-\n drivers/irqchip/irq-sun6i-r.c            | 2 +-\n fs/btrfs/tree-checker.c                  | 2 +-\n lib/vsprintf.c                           | 2 +-\n 5 files changed, 5 insertions(+), 5 deletions(-)\n\ndiff --git a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c\nindex 768b6e7dbd77..fd1faa840ec0 100644\n--- a/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c\n+++ b/drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c\n@@ -700,7 +700,7 @@ static const char *smu_get_feature_name(struct smu_context *smu,\n size_t smu_cmn_get_pp_feature_mask(struct smu_context *smu,\n \t\t\t\t   char *buf)\n {\n-\tint8_t sort_feature[max(SMU_FEATURE_COUNT, SMU_FEATURE_MAX)];\n+\tint8_t sort_feature[MAX(SMU_FEATURE_COUNT, SMU_FEATURE_MAX)];\n \tuint64_t feature_mask;\n \tint i, feature_index;\n \tuint32_t count = 0;\ndiff --git a/drivers/input/touchscreen/cyttsp4_core.c b/drivers/input/touchscreen/cyttsp4_core.c\nindex dccbcb942fe5..936d69da3bda 100644\n--- a/drivers/input/touchscreen/cyttsp4_core.c\n+++ b/drivers/input/touchscreen/cyttsp4_core.c\n@@ -871,7 +871,7 @@ static void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_tch)\n \tstruct cyttsp4_touch tch;\n \tint sig;\n \tint i, j, t = 0;\n-\tint ids[max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH)];\n+\tint ids[MAX(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH)];\n \n \tmemset(ids, 0, si->si_ofs.tch_abs[CY_TCH_T].max * sizeof(int));\n \tfor (i = 0; i < num_cur_tch; i++) {\ndiff --git a/drivers/irqchip/irq-sun6i-r.c b/drivers/irqchip/irq-sun6i-r.c\nindex a01e44049415..99958d470d62 100644\n--- a/drivers/irqchip/irq-sun6i-r.c\n+++ b/drivers/irqchip/irq-sun6i-r.c\n@@ -270,7 +270,7 @@ static const struct irq_domain_ops sun6i_r_intc_domain_ops = {\n \n static int sun6i_r_intc_suspend(void)\n {\n-\tu32 buf[BITS_TO_U32(max(SUN6I_NR_TOP_LEVEL_IRQS, SUN6I_NR_MUX_BITS))];\n+\tu32 buf[BITS_TO_U32(MAX(SUN6I_NR_TOP_LEVEL_IRQS, SUN6I_NR_MUX_BITS))];\n \tint i;\n \n \t/* Wake IRQs are enabled during system sleep and shutdown. */\ndiff --git a/fs/btrfs/tree-checker.c b/fs/btrfs/tree-checker.c\nindex bf3822b25c58..cb76feac94a4 100644\n--- a/fs/btrfs/tree-checker.c\n+++ b/fs/btrfs/tree-checker.c\n@@ -608,7 +608,7 @@ static int check_dir_item(struct extent_buffer *leaf,\n \t\t */\n \t\tif (key->type == BTRFS_DIR_ITEM_KEY ||\n \t\t    key->type == BTRFS_XATTR_ITEM_KEY) {\n-\t\t\tchar namebuf[max(BTRFS_NAME_LEN, XATTR_NAME_MAX)];\n+\t\t\tchar namebuf[MAX(BTRFS_NAME_LEN, XATTR_NAME_MAX)];\n \n \t\t\tread_extent_buffer(leaf, namebuf,\n \t\t\t\t\t(unsigned long)(di + 1), name_len);\ndiff --git a/lib/vsprintf.c b/lib/vsprintf.c\nindex fa1c19701855..2b0b5f08b8fc 100644\n--- a/lib/vsprintf.c\n+++ b/lib/vsprintf.c\n@@ -1082,7 +1082,7 @@ char *resource_string(char *buf, char *end, struct resource *res,\n #define FLAG_BUF_SIZE\t\t(2 * sizeof(res->flags))\n #define DECODED_BUF_SIZE\tsizeof(\"[mem - 64bit pref window disabled]\")\n #define RAW_BUF_SIZE\t\tsizeof(\"[mem - flags 0x]\")\n-\tchar sym[max(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,\n+\tchar sym[MAX(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,\n \t\t     2*RSRC_BUF_SIZE + FLAG_BUF_SIZE + RAW_BUF_SIZE)];\n \n \tchar *p = sym, *pend = sym + sizeof(sym);\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069294602640.mbox",
          "message_id": "<20251017090519.46992-18-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 17/27 5.10.y] minmax: don't use max() in situations that want a C constant expression",
          "date": "2025-10-17 09:05:09+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:09 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit cb04e8b1d2f24c4c2c92f7b7529031fc35a16fed ]\n\nWe only had a couple of array[] declarations, and changing them to just\nuse 'MAX()' instead of 'max()' fixes the issue.\n\nThis will allow us to simplify our min/max macros enormously, since they\ncan now unconditionally use temporary variables to avoid using the\nargument values multiple times.\n\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n drivers/input/touchscreen/cyttsp4_core.c | 2 +-\n drivers/md/dm-integrity.c                | 4 ++--\n fs/btrfs/tree-checker.c                  | 2 +-\n lib/vsprintf.c                           | 2 +-\n 4 files changed, 5 insertions(+), 5 deletions(-)\n\ndiff --git a/drivers/input/touchscreen/cyttsp4_core.c b/drivers/input/touchscreen/cyttsp4_core.c\nindex 02a73d9a4def..c10140c9aafa 100644\n--- a/drivers/input/touchscreen/cyttsp4_core.c\n+++ b/drivers/input/touchscreen/cyttsp4_core.c\n@@ -857,7 +857,7 @@ static void cyttsp4_get_mt_touches(struct cyttsp4_mt_data *md, int num_cur_tch)\n \tstruct cyttsp4_touch tch;\n \tint sig;\n \tint i, j, t = 0;\n-\tint ids[max(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH)];\n+\tint ids[MAX(CY_TMA1036_MAX_TCH, CY_TMA4XX_MAX_TCH)];\n \n \tmemset(ids, 0, si->si_ofs.tch_abs[CY_TCH_T].max * sizeof(int));\n \tfor (i = 0; i < num_cur_tch; i++) {\ndiff --git a/drivers/md/dm-integrity.c b/drivers/md/dm-integrity.c\nindex 7fa3bf74747d..917ba18be77f 100644\n--- a/drivers/md/dm-integrity.c\n+++ b/drivers/md/dm-integrity.c\n@@ -1600,7 +1600,7 @@ static void integrity_metadata(struct work_struct *w)\n \t\tstruct bio *bio = dm_bio_from_per_bio_data(dio, sizeof(struct dm_integrity_io));\n \t\tchar *checksums;\n \t\tunsigned extra_space = unlikely(digest_size > ic->tag_size) ? digest_size - ic->tag_size : 0;\n-\t\tchar checksums_onstack[max((size_t)HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n+\t\tchar checksums_onstack[MAX(HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n \t\tsector_t sector;\n \t\tunsigned sectors_to_process;\n \n@@ -1882,7 +1882,7 @@ static bool __journal_read_write(struct dm_integrity_io *dio, struct bio *bio,\n \t\t\t\t} while (++s < ic->sectors_per_block);\n #ifdef INTERNAL_VERIFY\n \t\t\t\tif (ic->internal_hash) {\n-\t\t\t\t\tchar checksums_onstack[max((size_t)HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n+\t\t\t\t\tchar checksums_onstack[MAX(HASH_MAX_DIGESTSIZE, MAX_TAG_SIZE)];\n \n \t\t\t\t\tintegrity_sector_checksum(ic, logical_sector, mem + bv.bv_offset, checksums_onstack);\n \t\t\t\t\tif (unlikely(memcmp(checksums_onstack, journal_entry_tag(ic, je), ic->tag_size))) {\ndiff --git a/fs/btrfs/tree-checker.c b/fs/btrfs/tree-checker.c\nindex c28bb37688c6..fd4768c5e439 100644\n--- a/fs/btrfs/tree-checker.c\n+++ b/fs/btrfs/tree-checker.c\n@@ -587,7 +587,7 @@ static int check_dir_item(struct extent_buffer *leaf,\n \t\t */\n \t\tif (key->type == BTRFS_DIR_ITEM_KEY ||\n \t\t    key->type == BTRFS_XATTR_ITEM_KEY) {\n-\t\t\tchar namebuf[max(BTRFS_NAME_LEN, XATTR_NAME_MAX)];\n+\t\t\tchar namebuf[MAX(BTRFS_NAME_LEN, XATTR_NAME_MAX)];\n \n \t\t\tread_extent_buffer(leaf, namebuf,\n \t\t\t\t\t(unsigned long)(di + 1), name_len);\ndiff --git a/lib/vsprintf.c b/lib/vsprintf.c\nindex b08b8ee1bbc0..90372391ce90 100644\n--- a/lib/vsprintf.c\n+++ b/lib/vsprintf.c\n@@ -1078,7 +1078,7 @@ char *resource_string(char *buf, char *end, struct resource *res,\n #define FLAG_BUF_SIZE\t\t(2 * sizeof(res->flags))\n #define DECODED_BUF_SIZE\tsizeof(\"[mem - 64bit pref window disabled]\")\n #define RAW_BUF_SIZE\t\tsizeof(\"[mem - flags 0x]\")\n-\tchar sym[max(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,\n+\tchar sym[MAX(2*RSRC_BUF_SIZE + DECODED_BUF_SIZE,\n \t\t     2*RSRC_BUF_SIZE + FLAG_BUF_SIZE + RAW_BUF_SIZE)];\n \n \tchar *p = sym, *pend = sym + sizeof(sym);\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH 09/19 v6.1.y] minmax: simplify min()/max()/clamp() implementation",
      "normalized_subject": "minmax: simplify min()/max()/clamp() implementation",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "compiler_compat"
      ],
      "first_date": "2025-09-24T20:23:10+00:00",
      "last_date": "2025-10-17T09:05:10+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874574027294.mbox",
          "message_id": "<20250924202320.32333-10-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 09/19 v6.1.y] minmax: simplify min()/max()/clamp() implementation",
          "date": "2025-09-24 20:23:10+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:10 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit dc1c8034e31b14a2e5e212104ec508aec44ce1b9 ]\n\nNow that we no longer have any C constant expression contexts (ie array\nsize declarations or static initializers) that use min() or max(), we\ncan simpify the implementation by not having to worry about the result\nstaying as a C constant expression.\n\nSo now we can unconditionally just use temporary variables of the right\ntype, and get rid of the excessive expansion that used to come from the\nuse of\n\n   __builtin_choose_expr(__is_constexpr(...), ..\n\nto pick the specialized code for constant expressions.\n\nAnother expansion simplification is to pass the temporary variables (in\naddition to the original expression) to our __types_ok() macro.  That\nmay superficially look like it complicates the macro, but when we only\nwant the type of the expression, expanding the temporary variable names\nis much simpler and smaller than expanding the potentially complicated\noriginal expression.\n\nAs a result, on my machine, doing a\n\n  $ time make drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.i\n\ngoes from\n\n\treal\t0m16.621s\n\tuser\t0m15.360s\n\tsys\t0m1.221s\n\nto\n\n\treal\t0m2.532s\n\tuser\t0m2.091s\n\tsys\t0m0.452s\n\nbecause the token expansion goes down dramatically.\n\nIn particular, the longest line expansion (which was line 71 of that\n'ia_css_ynr.host.c' file) shrinks from 23,338kB (yes, 23MB for one\nsingle line) to \"just\" 1,444kB (now \"only\" 1.4MB).\n\nAnd yes, that line is still the line from hell, because it's doing\nmultiple levels of \"min()/max()\" expansion thanks to some of them being\nhidden inside the uDIGIT_FITTING() macro.\n\nLorenzo has a nice cleanup patch that makes that driver use inline\nfunctions instead of macros for sDIGIT_FITTING() and uDIGIT_FITTING(),\nwhich will fix that line once and for all, but the 16-fold reduction in\nthis case does show why we need to simplify these helpers.\n\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 43 ++++++++++++++++++++----------------------\n 1 file changed, 20 insertions(+), 23 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex fc384714da45..e3e4353df983 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -35,10 +35,10 @@\n #define __is_noneg_int(x)\t\\\n \t(__builtin_choose_expr(__is_constexpr(x) && __is_signed(x), x, -1) >= 0)\n \n-#define __types_ok(x, y) \t\t\t\t\t\\\n-\t(__is_signed(x) == __is_signed(y) ||\t\t\t\\\n-\t\t__is_signed((x) + 0) == __is_signed((y) + 0) ||\t\\\n-\t\t__is_noneg_int(x) || __is_noneg_int(y))\n+#define __types_ok(x, y, ux, uy) \t\t\t\t\\\n+\t(__is_signed(ux) == __is_signed(uy) ||\t\t\t\\\n+\t __is_signed((ux) + 0) == __is_signed((uy) + 0) ||\t\\\n+\t __is_noneg_int(x) || __is_noneg_int(y))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n@@ -51,34 +51,31 @@\n #define __cmp_once(op, type, x, y) \\\n \t__cmp_once_unique(op, type, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n \n-#define __careful_cmp_once(op, x, y) ({\t\t\t\\\n-\tstatic_assert(__types_ok(x, y),\t\t\t\\\n+#define __careful_cmp_once(op, x, y, ux, uy) ({\t\t\\\n+\t__auto_type ux = (x); __auto_type uy = (y);\t\\\n+\tstatic_assert(__types_ok(x, y, ux, uy),\t\t\\\n \t\t#op \"(\" #x \", \" #y \") signedness error, fix types or consider u\" #op \"() before \" #op \"_t()\"); \\\n-\t__cmp_once(op, __auto_type, x, y); })\n+\t__cmp(op, ux, uy); })\n \n-#define __careful_cmp(op, x, y)\t\t\t\t\t\\\n-\t__builtin_choose_expr(__is_constexpr((x) - (y)),\t\\\n-\t\t__cmp(op, x, y), __careful_cmp_once(op, x, y))\n+#define __careful_cmp(op, x, y) \\\n+\t__careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n \n #define __clamp(val, lo, hi)\t\\\n \t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n \n-#define __clamp_once(val, lo, hi, unique_val, unique_lo, unique_hi) ({\t\t\\\n-\ttypeof(val) unique_val = (val);\t\t\t\t\t\t\\\n-\ttypeof(lo) unique_lo = (lo);\t\t\t\t\t\t\\\n-\ttypeof(hi) unique_hi = (hi);\t\t\t\t\t\t\\\n+#define __clamp_once(val, lo, hi, uval, ulo, uhi) ({\t\t\t\t\\\n+\t__auto_type uval = (val);\t\t\t\t\t\t\\\n+\t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n+\t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n \tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n \t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tstatic_assert(__types_ok(val, lo), \"clamp() 'lo' signedness error\");\t\\\n-\tstatic_assert(__types_ok(val, hi), \"clamp() 'hi' signedness error\");\t\\\n-\t__clamp(unique_val, unique_lo, unique_hi); })\n-\n-#define __careful_clamp(val, lo, hi) ({\t\t\t\t\t\\\n-\t__builtin_choose_expr(__is_constexpr((val) - (lo) + (hi)),\t\\\n-\t\t__clamp(val, lo, hi),\t\t\t\t\t\\\n-\t\t__clamp_once(val, lo, hi, __UNIQUE_ID(__val),\t\t\\\n-\t\t\t     __UNIQUE_ID(__lo), __UNIQUE_ID(__hi))); })\n+\tstatic_assert(__types_ok(uval, lo, uval, ulo), \"clamp() 'lo' signedness error\");\t\\\n+\tstatic_assert(__types_ok(uval, hi, uval, uhi), \"clamp() 'hi' signedness error\");\t\\\n+\t__clamp(uval, ulo, uhi); })\n+\n+#define __careful_clamp(va",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069270202288.mbox",
          "message_id": "<20251017090519.46992-19-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 18/27 5.10.y] minmax: simplify min()/max()/clamp() implementation",
          "date": "2025-10-17 09:05:10+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:10 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit dc1c8034e31b14a2e5e212104ec508aec44ce1b9 ]\n\nNow that we no longer have any C constant expression contexts (ie array\nsize declarations or static initializers) that use min() or max(), we\ncan simpify the implementation by not having to worry about the result\nstaying as a C constant expression.\n\nSo now we can unconditionally just use temporary variables of the right\ntype, and get rid of the excessive expansion that used to come from the\nuse of\n\n   __builtin_choose_expr(__is_constexpr(...), ..\n\nto pick the specialized code for constant expressions.\n\nAnother expansion simplification is to pass the temporary variables (in\naddition to the original expression) to our __types_ok() macro.  That\nmay superficially look like it complicates the macro, but when we only\nwant the type of the expression, expanding the temporary variable names\nis much simpler and smaller than expanding the potentially complicated\noriginal expression.\n\nAs a result, on my machine, doing a\n\n  $ time make drivers/staging/media/atomisp/pci/isp/kernels/ynr/ynr_1.0/ia_css_ynr.host.i\n\ngoes from\n\n\treal\t0m16.621s\n\tuser\t0m15.360s\n\tsys\t0m1.221s\n\nto\n\n\treal\t0m2.532s\n\tuser\t0m2.091s\n\tsys\t0m0.452s\n\nbecause the token expansion goes down dramatically.\n\nIn particular, the longest line expansion (which was line 71 of that\n'ia_css_ynr.host.c' file) shrinks from 23,338kB (yes, 23MB for one\nsingle line) to \"just\" 1,444kB (now \"only\" 1.4MB).\n\nAnd yes, that line is still the line from hell, because it's doing\nmultiple levels of \"min()/max()\" expansion thanks to some of them being\nhidden inside the uDIGIT_FITTING() macro.\n\nLorenzo has a nice cleanup patch that makes that driver use inline\nfunctions instead of macros for sDIGIT_FITTING() and uDIGIT_FITTING(),\nwhich will fix that line once and for all, but the 16-fold reduction in\nthis case does show why we need to simplify these helpers.\n\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 43 ++++++++++++++++++++----------------------\n 1 file changed, 20 insertions(+), 23 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex fc384714da45..e3e4353df983 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -35,10 +35,10 @@\n #define __is_noneg_int(x)\t\\\n \t(__builtin_choose_expr(__is_constexpr(x) && __is_signed(x), x, -1) >= 0)\n \n-#define __types_ok(x, y) \t\t\t\t\t\\\n-\t(__is_signed(x) == __is_signed(y) ||\t\t\t\\\n-\t\t__is_signed((x) + 0) == __is_signed((y) + 0) ||\t\\\n-\t\t__is_noneg_int(x) || __is_noneg_int(y))\n+#define __types_ok(x, y, ux, uy) \t\t\t\t\\\n+\t(__is_signed(ux) == __is_signed(uy) ||\t\t\t\\\n+\t __is_signed((ux) + 0) == __is_signed((uy) + 0) ||\t\\\n+\t __is_noneg_int(x) || __is_noneg_int(y))\n \n #define __cmp_op_min <\n #define __cmp_op_max >\n@@ -51,34 +51,31 @@\n #define __cmp_once(op, type, x, y) \\\n \t__cmp_once_unique(op, type, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n \n-#define __careful_cmp_once(op, x, y) ({\t\t\t\\\n-\tstatic_assert(__types_ok(x, y),\t\t\t\\\n+#define __careful_cmp_once(op, x, y, ux, uy) ({\t\t\\\n+\t__auto_type ux = (x); __auto_type uy = (y);\t\\\n+\tstatic_assert(__types_ok(x, y, ux, uy),\t\t\\\n \t\t#op \"(\" #x \", \" #y \") signedness error, fix types or consider u\" #op \"() before \" #op \"_t()\"); \\\n-\t__cmp_once(op, __auto_type, x, y); })\n+\t__cmp(op, ux, uy); })\n \n-#define __careful_cmp(op, x, y)\t\t\t\t\t\\\n-\t__builtin_choose_expr(__is_constexpr((x) - (y)),\t\\\n-\t\t__cmp(op, x, y), __careful_cmp_once(op, x, y))\n+#define __careful_cmp(op, x, y) \\\n+\t__careful_cmp_once(op, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n \n #define __clamp(val, lo, hi)\t\\\n \t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n \n-#define __clamp_once(val, lo, hi, unique_val, unique_lo, unique_hi) ({\t\t\\\n-\ttypeof(val) unique_val = (val);\t\t\t\t\t\t\\\n-\ttypeof(lo) unique_lo = (lo);\t\t\t\t\t\t\\\n-\ttypeof(hi) unique_hi = (hi);\t\t\t\t\t\t\\\n+#define __clamp_once(val, lo, hi, uval, ulo, uhi) ({\t\t\t\t\\\n+\t__auto_type uval = (val);\t\t\t\t\t\t\\\n+\t__auto_type ulo = (lo);\t\t\t\t\t\t\t\\\n+\t__auto_type uhi = (hi);\t\t\t\t\t\t\t\\\n \tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n \t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n \t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\tstatic_assert(__types_ok(val, lo), \"clamp() 'lo' signedness error\");\t\\\n-\tstatic_assert(__types_ok(val, hi), \"clamp() 'hi' signedness error\");\t\\\n-\t__clamp(unique_val, unique_lo, unique_hi); })\n-\n-#define __careful_clamp(val, lo, hi) ({\t\t\t\t\t\\\n-\t__builtin_choose_expr(__is_constexpr((val) - (lo) + (hi)),\t\\\n-\t\t__clamp(val, lo, hi),\t\t\t\t\t\\\n-\t\t__clamp_once(val, lo, hi, __UNIQUE_ID(__val),\t\t\\\n-\t\t\t     __UNIQUE_ID(__lo), __UNIQUE_ID(__hi))); })\n+\tstatic_assert(__types_ok(uval, lo, uval, ulo), \"clamp() 'lo' signedness error\");\t\\\n+\tstatic_assert(__types_ok(uval, hi, uval, uhi), \"clamp() 'hi' signedness error\");\t\\\n+\t__clamp(uval, ulo, uhi); })\n+\n+#define __careful_clamp(va",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH 06/19 v6.1.y] minmax: simplify and clarify min_t()/max_t() implementation",
      "normalized_subject": "minmax: simplify and clarify min_t()/max_t() implementation",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:07+00:00",
      "last_date": "2025-10-17T09:05:07+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874564727180.mbox",
          "message_id": "<20250924202320.32333-7-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 06/19 v6.1.y] minmax: simplify and clarify min_t()/max_t() implementation",
          "date": "2025-09-24 20:23:07+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:07 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 017fa3e89187848fd056af757769c9e66ac3e93d ]\n\nThis simplifies the min_t() and max_t() macros by no longer making them\nwork in the context of a C constant expression.\n\nThat means that you can no longer use them for static initializers or\nfor array sizes in type definitions, but there were only a couple of\nsuch uses, and all of them were converted (famous last words) to use\nMIN_T/MAX_T instead.\n\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 19 +++++++++++--------\n 1 file changed, 11 insertions(+), 8 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a7ef65f78933..9c2848abc804 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -45,17 +45,20 @@\n \n #define __cmp(op, x, y)\t((x) __cmp_op_##op (y) ? (x) : (y))\n \n-#define __cmp_once(op, x, y, unique_x, unique_y) ({\t\\\n-\ttypeof(x) unique_x = (x);\t\t\t\\\n-\ttypeof(y) unique_y = (y);\t\t\t\\\n+#define __cmp_once_unique(op, type, x, y, ux, uy) \\\n+\t({ type ux = (x); type uy = (y); __cmp(op, ux, uy); })\n+\n+#define __cmp_once(op, type, x, y) \\\n+\t__cmp_once_unique(op, type, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n+\n+#define __careful_cmp_once(op, x, y) ({\t\t\t\\\n \tstatic_assert(__types_ok(x, y),\t\t\t\\\n \t\t#op \"(\" #x \", \" #y \") signedness error, fix types or consider u\" #op \"() before \" #op \"_t()\"); \\\n-\t__cmp(op, unique_x, unique_y); })\n+\t__cmp_once(op, __auto_type, x, y); })\n \n #define __careful_cmp(op, x, y)\t\t\t\t\t\\\n \t__builtin_choose_expr(__is_constexpr((x) - (y)),\t\\\n-\t\t__cmp(op, x, y),\t\t\t\t\\\n-\t\t__cmp_once(op, x, y, __UNIQUE_ID(__x), __UNIQUE_ID(__y)))\n+\t\t__cmp(op, x, y), __careful_cmp_once(op, x, y))\n \n #define __clamp(val, lo, hi)\t\\\n \t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n@@ -158,7 +161,7 @@\n  * @x: first value\n  * @y: second value\n  */\n-#define min_t(type, x, y)\t__careful_cmp(min, (type)(x), (type)(y))\n+#define min_t(type, x, y) __cmp_once(min, type, x, y)\n \n /**\n  * max_t - return maximum of two values, using the specified type\n@@ -166,7 +169,7 @@\n  * @x: first value\n  * @y: second value\n  */\n-#define max_t(type, x, y)\t__careful_cmp(max, (type)(x), (type)(y))\n+#define max_t(type, x, y) __cmp_once(max, type, x, y)\n \n /*\n  * Do not check the array parameter using __must_be_array().\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069254002009.mbox",
          "message_id": "<20251017090519.46992-16-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 15/27 5.10.y] minmax: simplify and clarify min_t()/max_t() implementation",
          "date": "2025-10-17 09:05:07+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:07 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 017fa3e89187848fd056af757769c9e66ac3e93d ]\n\nThis simplifies the min_t() and max_t() macros by no longer making them\nwork in the context of a C constant expression.\n\nThat means that you can no longer use them for static initializers or\nfor array sizes in type definitions, but there were only a couple of\nsuch uses, and all of them were converted (famous last words) to use\nMIN_T/MAX_T instead.\n\nCc: David Laight <David.Laight@aculab.com>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 19 +++++++++++--------\n 1 file changed, 11 insertions(+), 8 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex a7ef65f78933..9c2848abc804 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -45,17 +45,20 @@\n \n #define __cmp(op, x, y)\t((x) __cmp_op_##op (y) ? (x) : (y))\n \n-#define __cmp_once(op, x, y, unique_x, unique_y) ({\t\\\n-\ttypeof(x) unique_x = (x);\t\t\t\\\n-\ttypeof(y) unique_y = (y);\t\t\t\\\n+#define __cmp_once_unique(op, type, x, y, ux, uy) \\\n+\t({ type ux = (x); type uy = (y); __cmp(op, ux, uy); })\n+\n+#define __cmp_once(op, type, x, y) \\\n+\t__cmp_once_unique(op, type, x, y, __UNIQUE_ID(x_), __UNIQUE_ID(y_))\n+\n+#define __careful_cmp_once(op, x, y) ({\t\t\t\\\n \tstatic_assert(__types_ok(x, y),\t\t\t\\\n \t\t#op \"(\" #x \", \" #y \") signedness error, fix types or consider u\" #op \"() before \" #op \"_t()\"); \\\n-\t__cmp(op, unique_x, unique_y); })\n+\t__cmp_once(op, __auto_type, x, y); })\n \n #define __careful_cmp(op, x, y)\t\t\t\t\t\\\n \t__builtin_choose_expr(__is_constexpr((x) - (y)),\t\\\n-\t\t__cmp(op, x, y),\t\t\t\t\\\n-\t\t__cmp_once(op, x, y, __UNIQUE_ID(__x), __UNIQUE_ID(__y)))\n+\t\t__cmp(op, x, y), __careful_cmp_once(op, x, y))\n \n #define __clamp(val, lo, hi)\t\\\n \t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n@@ -158,7 +161,7 @@\n  * @x: first value\n  * @y: second value\n  */\n-#define min_t(type, x, y)\t__careful_cmp(min, (type)(x), (type)(y))\n+#define min_t(type, x, y) __cmp_once(min, type, x, y)\n \n /**\n  * max_t - return maximum of two values, using the specified type\n@@ -166,7 +169,7 @@\n  * @x: first value\n  * @y: second value\n  */\n-#define max_t(type, x, y)\t__careful_cmp(max, (type)(x), (type)(y))\n+#define max_t(type, x, y) __cmp_once(max, type, x, y)\n \n /*\n  * Do not check the array parameter using __must_be_array().\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH 05/19 v6.1.y] minmax: avoid overly complicated constant expressions in VM code",
      "normalized_subject": "minmax: avoid overly complicated constant expressions in VM code",
      "message_count": 2,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:06+00:00",
      "last_date": "2025-10-17T09:05:05+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874558927095.mbox",
          "message_id": "<20250924202320.32333-6-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 05/19 v6.1.y] minmax: avoid overly complicated constant expressions in VM code",
          "date": "2025-09-24 20:23:06+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:06 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 3a7e02c040b130b5545e4b115aada7bacd80a2b6 ]\n\nThe minmax infrastructure is overkill for simple constants, and can\ncause huge expansions because those simple constants are then used by\nother things.\n\nFor example, 'pageblock_order' is a core VM constant, but because it was\nimplemented using 'min_t()' and all the type-checking that involves, it\nactually expanded to something like 2.5kB of preprocessor noise.\n\nAnd when that simple constant was then used inside other expansions:\n\n  #define pageblock_nr_pages      (1UL << pageblock_order)\n  #define pageblock_start_pfn(pfn)  ALIGN_DOWN((pfn), pageblock_nr_pages)\n\nand we then use that inside a 'max()' macro:\n\n\tcase ISOLATE_SUCCESS:\n\t\tupdate_cached = false;\n\t\tlast_migrated_pfn = max(cc->zone->zone_start_pfn,\n\t\t\tpageblock_start_pfn(cc->migrate_pfn - 1));\n\nthe end result was that one statement expanding to 253kB in size.\n\nThere are probably other cases of this, but this one case certainly\nstood out.\n\nI've added 'MIN_T()' and 'MAX_T()' macros for this kind of \"core simple\nconstant with specific type\" use.  These macros skip the type checking,\nand as such need to be very sparingly used only for obvious cases that\nhave active issues like this.\n\nReported-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nLink: https://lore.kernel.org/all/36aa2cad-1db1-4abf-8dd2-fb20484aabc3@lucifer.local/\nCc: David Laight <David.Laight@aculab.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h          | 7 +++++++\n include/linux/pageblock-flags.h | 2 +-\n 2 files changed, 8 insertions(+), 1 deletion(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 2ec559284a9f..a7ef65f78933 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -270,4 +270,11 @@ static inline bool in_range32(u32 val, u32 start, u32 len)\n #define swap(a, b) \\\n \tdo { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)\n \n+/*\n+ * Use these carefully: no type checking, and uses the arguments\n+ * multiple times. Use for obvious constants only.\n+ */\n+#define MIN_T(type,a,b) __cmp(min,(type)(a),(type)(b))\n+#define MAX_T(type,a,b) __cmp(max,(type)(a),(type)(b))\n+\n #endif\t/* _LINUX_MINMAX_H */\ndiff --git a/include/linux/pageblock-flags.h b/include/linux/pageblock-flags.h\nindex 5f1ae07d724b..ccec17a67af8 100644\n--- a/include/linux/pageblock-flags.h\n+++ b/include/linux/pageblock-flags.h\n@@ -41,7 +41,7 @@ extern unsigned int pageblock_order;\n  * Huge pages are a constant size, but don't exceed the maximum allocation\n  * granularity.\n  */\n-#define pageblock_order\t\tmin_t(unsigned int, HUGETLB_PAGE_ORDER, MAX_ORDER - 1)\n+#define pageblock_order\t\tMIN_T(unsigned int, HUGETLB_PAGE_ORDER, MAX_ORDER - 1)\n \n #endif /* CONFIG_HUGETLB_PAGE_SIZE_VARIABLE */\n \n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069247201926.mbox",
          "message_id": "<20251017090519.46992-14-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 13/27 5.10.y] minmax: avoid overly complicated constant expressions in VM code",
          "date": "2025-10-17 09:05:05+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:05 +0000",
          "body": "From: Linus Torvalds <torvalds@linux-foundation.org>\n\n[ Upstream commit 3a7e02c040b130b5545e4b115aada7bacd80a2b6 ]\n\nThe minmax infrastructure is overkill for simple constants, and can\ncause huge expansions because those simple constants are then used by\nother things.\n\nFor example, 'pageblock_order' is a core VM constant, but because it was\nimplemented using 'min_t()' and all the type-checking that involves, it\nactually expanded to something like 2.5kB of preprocessor noise.\n\nAnd when that simple constant was then used inside other expansions:\n\n  #define pageblock_nr_pages      (1UL << pageblock_order)\n  #define pageblock_start_pfn(pfn)  ALIGN_DOWN((pfn), pageblock_nr_pages)\n\nand we then use that inside a 'max()' macro:\n\n\tcase ISOLATE_SUCCESS:\n\t\tupdate_cached = false;\n\t\tlast_migrated_pfn = max(cc->zone->zone_start_pfn,\n\t\t\tpageblock_start_pfn(cc->migrate_pfn - 1));\n\nthe end result was that one statement expanding to 253kB in size.\n\nThere are probably other cases of this, but this one case certainly\nstood out.\n\nI've added 'MIN_T()' and 'MAX_T()' macros for this kind of \"core simple\nconstant with specific type\" use.  These macros skip the type checking,\nand as such need to be very sparingly used only for obvious cases that\nhave active issues like this.\n\nReported-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nLink: https://lore.kernel.org/all/36aa2cad-1db1-4abf-8dd2-fb20484aabc3@lucifer.local/\nCc: David Laight <David.Laight@aculab.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 7 +++++++\n 1 file changed, 7 insertions(+)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 2ec559284a9f..a7ef65f78933 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -270,4 +270,11 @@ static inline bool in_range32(u32 val, u32 start, u32 len)\n #define swap(a, b) \\\n \tdo { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)\n \n+/*\n+ * Use these carefully: no type checking, and uses the arguments\n+ * multiple times. Use for obvious constants only.\n+ */\n+#define MIN_T(type,a,b) __cmp(min,(type)(a),(type)(b))\n+#define MAX_T(type,a,b) __cmp(max,(type)(a),(type)(b))\n+\n #endif\t/* _LINUX_MINMAX_H */\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH 04/19 v6.1.y] minmax: fix indentation of __cmp_once() and __clamp_once()",
      "normalized_subject": "minmax: fix indentation of __cmp_once() and __clamp_once()",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:05+00:00",
      "last_date": "2025-09-24T20:23:05+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874556427059.mbox",
          "message_id": "<20250924202320.32333-5-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 04/19 v6.1.y] minmax: fix indentation of __cmp_once() and __clamp_once()",
          "date": "2025-09-24 20:23:05+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:05 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit f4b84b2ff851f01d0fac619eadef47eb41648534 ]\n\nRemove the extra indentation and align continuation markers.\n\nLink: https://lkml.kernel.org/r/bed41317a05c498ea0209eafbcab45a5@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Matthew Wilcox (Oracle) <willy@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 30 +++++++++++++++---------------\n 1 file changed, 15 insertions(+), 15 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 62b0c0a3cf30..2ec559284a9f 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -46,11 +46,11 @@\n #define __cmp(op, x, y)\t((x) __cmp_op_##op (y) ? (x) : (y))\n \n #define __cmp_once(op, x, y, unique_x, unique_y) ({\t\\\n-\t\ttypeof(x) unique_x = (x);\t\t\\\n-\t\ttypeof(y) unique_y = (y);\t\t\\\n-\t\tstatic_assert(__types_ok(x, y),\t\t\\\n-\t\t\t#op \"(\" #x \", \" #y \") signedness error, fix types or consider u\" #op \"() before \" #op \"_t()\"); \\\n-\t\t__cmp(op, unique_x, unique_y); })\n+\ttypeof(x) unique_x = (x);\t\t\t\\\n+\ttypeof(y) unique_y = (y);\t\t\t\\\n+\tstatic_assert(__types_ok(x, y),\t\t\t\\\n+\t\t#op \"(\" #x \", \" #y \") signedness error, fix types or consider u\" #op \"() before \" #op \"_t()\"); \\\n+\t__cmp(op, unique_x, unique_y); })\n \n #define __careful_cmp(op, x, y)\t\t\t\t\t\\\n \t__builtin_choose_expr(__is_constexpr((x) - (y)),\t\\\n@@ -60,16 +60,16 @@\n #define __clamp(val, lo, hi)\t\\\n \t((val) >= (hi) ? (hi) : ((val) <= (lo) ? (lo) : (val)))\n \n-#define __clamp_once(val, lo, hi, unique_val, unique_lo, unique_hi) ({\t\\\n-\t\ttypeof(val) unique_val = (val);\t\t\t\t\\\n-\t\ttypeof(lo) unique_lo = (lo);\t\t\t\t\\\n-\t\ttypeof(hi) unique_hi = (hi);\t\t\t\t\\\n-\t\tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n-\t\t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n-\t\t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n-\t\tstatic_assert(__types_ok(val, lo), \"clamp() 'lo' signedness error\");\t\\\n-\t\tstatic_assert(__types_ok(val, hi), \"clamp() 'hi' signedness error\");\t\\\n-\t\t__clamp(unique_val, unique_lo, unique_hi); })\n+#define __clamp_once(val, lo, hi, unique_val, unique_lo, unique_hi) ({\t\t\\\n+\ttypeof(val) unique_val = (val);\t\t\t\t\t\t\\\n+\ttypeof(lo) unique_lo = (lo);\t\t\t\t\t\t\\\n+\ttypeof(hi) unique_hi = (hi);\t\t\t\t\t\t\\\n+\tstatic_assert(__builtin_choose_expr(__is_constexpr((lo) > (hi)), \t\\\n+\t\t\t(lo) <= (hi), true),\t\t\t\t\t\\\n+\t\t\"clamp() low limit \" #lo \" greater than high limit \" #hi);\t\\\n+\tstatic_assert(__types_ok(val, lo), \"clamp() 'lo' signedness error\");\t\\\n+\tstatic_assert(__types_ok(val, hi), \"clamp() 'hi' signedness error\");\t\\\n+\t__clamp(unique_val, unique_lo, unique_hi); })\n \n #define __careful_clamp(val, lo, hi) ({\t\t\t\t\t\\\n \t__builtin_choose_expr(__is_constexpr((val) - (lo) + (hi)),\t\\\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[PATCH 03/19 v6.1.y] minmax: deduplicate __unconst_integer_typeof()",
      "normalized_subject": "minmax: deduplicate __unconst_integer_typeof()",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:04+00:00",
      "last_date": "2025-09-24T20:23:04+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874551927006.mbox",
          "message_id": "<20250924202320.32333-4-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 03/19 v6.1.y] minmax: deduplicate __unconst_integer_typeof()",
          "date": "2025-09-24 20:23:04+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:04 +0000",
          "body": "From: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\n\n[ Upstream commit 5e57418a2031cd5e1863efdf3d7447a16a368172 ]\n\nIt appears that compiler_types.h already have an implementation of the\n__unconst_integer_typeof() called __unqual_scalar_typeof().  Use it\ninstead of the copy.\n\nLink: https://lkml.kernel.org/r/20230911154913.4176033-1-andriy.shevchenko@linux.intel.com\nSigned-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nAcked-by: Herve Codina <herve.codina@bootlin.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 25 ++-----------------------\n 1 file changed, 2 insertions(+), 23 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex aac0b7d23768..62b0c0a3cf30 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -168,27 +168,6 @@\n  */\n #define max_t(type, x, y)\t__careful_cmp(max, (type)(x), (type)(y))\n \n-/*\n- * Remove a const qualifier from integer types\n- * _Generic(foo, type-name: association, ..., default: association) performs a\n- * comparison against the foo type (not the qualified type).\n- * Do not use the const keyword in the type-name as it will not match the\n- * unqualified type of foo.\n- */\n-#define __unconst_integer_type_cases(type)\t\\\n-\tunsigned type:  (unsigned type)0,\t\\\n-\tsigned type:    (signed type)0\n-\n-#define __unconst_integer_typeof(x) typeof(\t\t\t\\\n-\t_Generic((x),\t\t\t\t\t\t\\\n-\t\tchar: (char)0,\t\t\t\t\t\\\n-\t\t__unconst_integer_type_cases(char),\t\t\\\n-\t\t__unconst_integer_type_cases(short),\t\t\\\n-\t\t__unconst_integer_type_cases(int),\t\t\\\n-\t\t__unconst_integer_type_cases(long),\t\t\\\n-\t\t__unconst_integer_type_cases(long long),\t\\\n-\t\tdefault: (x)))\n-\n /*\n  * Do not check the array parameter using __must_be_array().\n  * In the following legit use-case where the \"array\" passed is a simple pointer,\n@@ -203,13 +182,13 @@\n  * 'int *buff' and 'int buff[N]' types.\n  *\n  * The array can be an array of const items.\n- * typeof() keeps the const qualifier. Use __unconst_integer_typeof() in order\n+ * typeof() keeps the const qualifier. Use __unqual_scalar_typeof() in order\n  * to discard the const qualifier for the __element variable.\n  */\n #define __minmax_array(op, array, len) ({\t\t\t\t\\\n \ttypeof(&(array)[0]) __array = (array);\t\t\t\t\\\n \ttypeof(len) __len = (len);\t\t\t\t\t\\\n-\t__unconst_integer_typeof(__array[0]) __element = __array[--__len]; \\\n+\t__unqual_scalar_typeof(__array[0]) __element = __array[--__len];\\\n \twhile (__len--)\t\t\t\t\t\t\t\\\n \t\t__element = op(__element, __array[__len]);\t\t\\\n \t__element; })\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH 01/19 v6.1.y] minmax: add in_range() macro",
      "normalized_subject": "minmax: add in_range() macro",
      "message_count": 1,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-09-24T20:23:02+00:00",
      "last_date": "2025-09-24T20:23:02+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874540426864.mbox",
          "message_id": "<20250924202320.32333-2-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 01/19 v6.1.y] minmax: add in_range() macro",
          "date": "2025-09-24 20:23:02+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:02 +0000",
          "body": "From: \"Matthew Wilcox (Oracle)\" <willy@infradead.org>\n\n[ Upstream commit f9bff0e31881d03badf191d3b0005839391f5f2b ]\n\nPatch series \"New page table range API\", v6.\n\nThis patchset changes the API used by the MM to set up page table entries.\nThe four APIs are:\n\n    set_ptes(mm, addr, ptep, pte, nr)\n    update_mmu_cache_range(vma, addr, ptep, nr)\n    flush_dcache_folio(folio)\n    flush_icache_pages(vma, page, nr)\n\nflush_dcache_folio() isn't technically new, but no architecture\nimplemented it, so I've done that for them.  The old APIs remain around\nbut are mostly implemented by calling the new interfaces.\n\nThe new APIs are based around setting up N page table entries at once.\nThe N entries belong to the same PMD, the same folio and the same VMA, so\nptep++ is a legitimate operation, and locking is taken care of for you.\nSome architectures can do a better job of it than just a loop, but I have\nhesitated to make too deep a change to architectures I don't understand\nwell.\n\nOne thing I have changed in every architecture is that PG_arch_1 is now a\nper-folio bit instead of a per-page bit when used for dcache clean/dirty\ntracking.  This was something that would have to happen eventually, and it\nmakes sense to do it now rather than iterate over every page involved in a\ncache flush and figure out if it needs to happen.\n\nThe point of all this is better performance, and Fengwei Yin has measured\nimprovement on x86.  I suspect you'll see improvement on your architecture\ntoo.  Try the new will-it-scale test mentioned here:\nhttps://lore.kernel.org/linux-mm/20230206140639.538867-5-fengwei.yin@intel.com/\nYou'll need to run it on an XFS filesystem and have\nCONFIG_TRANSPARENT_HUGEPAGE set.\n\nThis patchset is the basis for much of the anonymous large folio work\nbeing done by Ryan, so it's received quite a lot of testing over the last\nfew months.\n\nThis patch (of 38):\n\nDetermine if a value lies within a range more efficiently (subtraction +\ncomparison vs two comparisons and an AND).  It also has useful (under some\ncircumstances) behaviour if the range exceeds the maximum value of the\ntype.  Convert all the conflicting definitions of in_range() within the\nkernel; some can use the generic definition while others need their own\ndefinition.\n\nLink: https://lkml.kernel.org/r/20230802151406.3735276-1-willy@infradead.org\nLink: https://lkml.kernel.org/r/20230802151406.3735276-2-willy@infradead.org\nSigned-off-by: Matthew Wilcox (Oracle) <willy@infradead.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n arch/arm/mm/pageattr.c                        |  6 ++---\n .../drm/arm/display/include/malidp_utils.h    |  2 +-\n .../display/komeda/komeda_pipeline_state.c    | 24 ++++++++---------\n drivers/gpu/drm/msm/adreno/a6xx_gmu.c         |  6 -----\n .../net/ethernet/chelsio/cxgb3/cxgb3_main.c   | 18 ++++++-------\n drivers/virt/acrn/ioreq.c                     |  4 +--\n fs/btrfs/misc.h                               |  2 --\n fs/ext2/balloc.c                              |  2 --\n fs/ext4/ext4.h                                |  2 --\n fs/ufs/util.h                                 |  6 -----\n include/linux/minmax.h                        | 27 +++++++++++++++++++\n lib/logic_pio.c                               |  3 ---\n net/netfilter/nf_nat_core.c                   |  6 ++---\n net/tipc/core.h                               |  2 +-\n net/tipc/link.c                               | 10 +++----\n .../selftests/bpf/progs/get_branch_snapshot.c |  4 +--\n 16 files changed, 65 insertions(+), 59 deletions(-)\n\ndiff --git a/arch/arm/mm/pageattr.c b/arch/arm/mm/pageattr.c\nindex c3c34fe714b0..064ad508c149 100644\n--- a/arch/arm/mm/pageattr.c\n+++ b/arch/arm/mm/pageattr.c\n@@ -25,7 +25,7 @@ static int change_page_range(pte_t *ptep, unsigned long addr, void *data)\n \treturn 0;\n }\n \n-static bool in_range(unsigned long start, unsigned long size,\n+static bool range_in_range(unsigned long start, unsigned long size,\n \tunsigned long range_start, unsigned long range_end)\n {\n \treturn start >= range_start && start < range_end &&\n@@ -63,8 +63,8 @@ static int change_memory_common(unsigned long addr, int numpages,\n \tif (!size)\n \t\treturn 0;\n \n-\tif (!in_range(start, size, MODULES_VADDR, MODULES_END) &&\n-\t    !in_range(start, size, VMALLOC_START, VMALLOC_END))\n+\tif (!range_in_range(start, size, MODULES_VADDR, MODULES_END) &&\n+\t    !range_in_range(start, size, VMALLOC_START, VMALLOC_END))\n \t\treturn -EINVAL;\n \n \treturn __change_memory_common(start, size, set_mask, clear_mask);\ndiff --git a/drivers/gpu/drm/arm/display/include/malidp_utils.h b/drivers/gpu/drm/arm/display/include/malidp_utils.h\nindex 49a1d7f3539c..9f83baac6ed8 100644\n--- a/drivers/gpu/drm/arm/display/include/malidp_utils.h\n+++ b/drivers/gpu/drm/arm/display/include/malidp_utils.h\n@@ -35,7 +35,7 @@ static inline void set_range(struct malidp_range *rg, u32 start, u32 end)\n \trg->end   = end;\n }\n \n-static inline bool in_range(struct malidp_range *rg, u32 v)\n+static inline bool ma",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH 00/19 v6.1.y] Backport minmax.h updates from v6.17-rc7",
      "normalized_subject": "Backport minmax.h updates from v6.17-rc7",
      "message_count": 21,
      "participants": [
        "Eliav Farber",
        "Farber, Eliav",
        "Greg KH"
      ],
      "categories": [
        "general",
        "compiler_compat",
        "rfc_proposals",
        "type_system"
      ],
      "first_date": "2025-09-24T20:23:01+00:00",
      "last_date": "2025-10-19T12:38:26+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175874533726794.mbox",
          "message_id": "<20250924202320.32333-1-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 00/19 v6.1.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-09-24 20:23:01+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:01 +0000",
          "body": "This series backports 19 patches to update minmax.h in the 6.1.y branch,\naligning it with v6.17-rc7.\n\nThe ultimate goal is to synchronize all longterm branches so that they\ninclude the full set of minmax.h changes.\n\nPrevious work to update 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/#t\n\nThe key motivation is to bring in commit d03eba99f5bf (\"minmax: allow\nmin()/max()/clamp() if the arguments have the same signedness\"), which\nis missing in older kernels.\n\nIn mainline, this change enables min()/max()/clamp() to accept mixed\nargument types, provided both have the same signedness. Without it,\nbackported patches that use these forms may trigger compiler warnings,\nwhich escalate to build failures when -Werror is enabled.\n\nAndy Shevchenko (1):\n  minmax: deduplicate __unconst_integer_typeof()\n\nDavid Laight (8):\n  minmax: fix indentation of __cmp_once() and __clamp_once()\n  minmax.h: add whitespace around operators and after commas\n  minmax.h: update some comments\n  minmax.h: reduce the #define expansion of min(), max() and clamp()\n  minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n  minmax.h: move all the clamp() definitions after the min/max() ones\n  minmax.h: simplify the variants of clamp()\n  minmax.h: remove some #defines that are only expanded once\n\nHerve Codina (1):\n  minmax: Introduce {min,max}_array()\n\nLinus Torvalds (8):\n  minmax: avoid overly complicated constant expressions in VM code\n  minmax: simplify and clarify min_t()/max_t() implementation\n  minmax: make generic MIN() and MAX() macros available everywhere\n  minmax: add a few more MIN_T/MAX_T users\n  minmax: simplify min()/max()/clamp() implementation\n  minmax: don't use max() in situations that want a C constant\n    expression\n  minmax: improve macro expansion and type checking\n  minmax: fix up min3() and max3() too\n\nMatthew Wilcox (Oracle) (1):\n  minmax: add in_range() macro\n\n arch/arm/mm/pageattr.c                        |   6 +-\n arch/um/drivers/mconsole_user.c               |   2 +\n arch/x86/mm/pgtable.c                         |   2 +-\n drivers/edac/sb_edac.c                        |   4 +-\n drivers/edac/skx_common.h                     |   1 -\n .../drm/amd/display/modules/hdcp/hdcp_ddc.c   |   2 +\n .../drm/amd/pm/powerplay/hwmgr/ppevvmath.h    |  14 +-\n drivers/gpu/drm/amd/pm/swsmu/smu_cmn.c        |   2 +-\n .../drm/arm/display/include/malidp_utils.h    |   2 +-\n .../display/komeda/komeda_pipeline_state.c    |  24 +-\n drivers/gpu/drm/drm_color_mgmt.c              |   2 +-\n drivers/gpu/drm/msm/adreno/a6xx_gmu.c         |   6 -\n drivers/gpu/drm/radeon/evergreen_cs.c         |   2 +\n drivers/hwmon/adt7475.c                       |  24 +-\n drivers/input/touchscreen/cyttsp4_core.c      |   2 +-\n drivers/irqchip/irq-sun6i-r.c                 |   2 +-\n drivers/md/dm-integrity.c                     |   2 +-\n drivers/media/dvb-frontends/stv0367_priv.h    |   3 +\n .../net/ethernet/chelsio/cxgb3/cxgb3_main.c   |  18 +-\n .../net/ethernet/stmicro/stmmac/stmmac_main.c |   2 +-\n drivers/net/fjes/fjes_main.c                  |   4 +-\n drivers/nfc/pn544/i2c.c                       |   2 -\n drivers/platform/x86/sony-laptop.c            |   1 -\n drivers/scsi/isci/init.c                      |   6 +-\n .../pci/hive_isp_css_include/math_support.h   |   5 -\n drivers/virt/acrn/ioreq.c                     |   4 +-\n fs/btrfs/misc.h                               |   2 -\n fs/btrfs/tree-checker.c                       |   2 +-\n fs/ext2/balloc.c                              |   2 -\n fs/ext4/ext4.h                                |   2 -\n fs/ufs/util.h                                 |   6 -\n include/linux/compiler.h                      |   9 +\n include/linux/minmax.h                        | 264 +++++++++++++-----\n include/linux/pageblock-flags.h               |   2 +-\n kernel/trace/preemptirq_delay_test.c          |   2 -\n lib/btree.c                                   |   1 -\n lib/decompress_unlzma.c                       |   2 +\n lib/logic_pio.c                               |   3 -\n lib/vsprintf.c                                |   2 +-\n mm/zsmalloc.c                                 |   1 -\n net/ipv4/proc.c                               |   2 +-\n net/ipv6/proc.c                               |   2 +-\n net/netfilter/nf_nat_core.c                   |   6 +-\n net/tipc/core.h                               |   2 +-\n net/tipc/link.c                               |  10 +-\n .../selftests/bpf/progs/get_branch_snapshot.c |   4 +-\n tools/testing/selftests/seccomp/seccomp_bpf.c |   2 +\n tools/testing/selftests/vm/mremap_test.c      |   2 +\n 48 files changed, 290 insertions(+), 184 deletions(-)\n\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176081796509071.mbox",
          "message_id": "<CH0PR18MB5433BB2E99395D2AC8B0E0FBC6F7A () CH0PR18MB5433 ! namprd18 ! prod ! outlook ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-18 20:07:32+00:00",
          "date_str": "Sat, 18 Oct 2025 20:07:32 +0000",
          "body": "PiBPbiBGcmksIE9jdCAxNywgMjAyNSBhdCAwOTowNDo1MkFNICswMDAwLCBFbGlhdiBGYXJiZXIg\nd3JvdGU6DQo+ID4gVGhpcyBzZXJpZXMgYmFja3BvcnRzIDI3IHBhdGNoZXMgdG8gdXBkYXRlIG1p\nbm1heC5oIGluIHRoZSA1LjEwLnkNCj4gPiBicmFuY2gsIGFsaWduaW5nIGl0IHdpdGggdjYuMTct\ncmM3Lg0KPiA+DQo+ID4gVGhlIHVsdGltYXRlIGdvYWwgaXMgdG8gc3luY2hyb25pemUgYWxsIGxv\nbmctdGVybSBicmFuY2hlcyBzbyB0aGF0IHRoZXkNCj4gPiBpbmNsdWRlIHRoZSBmdWxsIHNldCBv\nZiBtaW5tYXguaCBjaGFuZ2VzLg0KPiA+DQo+ID4gLSA2LjEyLnkgaGFzIGFscmVhZHkgYmVlbiBi\nYWNrcG9ydGVkOyB0aGUgY2hhbmdlcyBhcmUgaW5jbHVkZWQgaW4NCj4gPiAgIHY2LjEyLjQ5Lg0K\nPiA+IC0gNi42LnkgaGFzIGFscmVhZHkgYmVlbiBiYWNrcG9ydGVkOyB0aGUgY2hhbmdlcyBhcmUg\naW5jbHVkZWQgaW4NCj4gPiAgIHY2LjYuMTA5Lg0KPiA+IC0gNi4xLnkgaGFzIGFscmVhZHkgYmVl\nbiBiYWNrcG9ydGVkOyB0aGUgY2hhbmdlcyBhcmUgY3VycmVudGx5IGluIHRoZQ0KPiA+ICAgNi4x\nLXN0YWJsZSB0cmVlLg0KPiA+IC0gNS4xNS55IGhhcyBhbHJlYWR5IGJlZW4gYmFja3BvcnRlZDsg\ndGhlIGNoYW5nZXMgYXJlIGN1cnJlbnRseSBpbiB0aGUNCj4gPiAgIDUuMTUtc3RhYmxlIHRyZWUu\nDQo+DQo+IFdpdGggdGhpcyBzZXJpZXMgYXBwbGllZCwgb24gYW4gYXJtNjQgc2VydmVyLCBidWls\nZGluZyAnYWxsbW9kY29uZmlnJywgSQ0KPiBnZXQgdGhlIGZvbGxvd2luZyBidWlsZCBlcnJvci4N\nCj4NCj4gT2RkbHkgSSBkb24ndCBzZWUgaXQgb24gbXkgeDg2IHNlcnZlciwgcGVyaGFwcyBkdWUg\ndG8gZGlmZmVyZW50IGNvbXBpbGVyDQo+IHZlcnNpb25zPw0KPg0KPiBBbnkgaWRlYXM/DQoNClRo\naXMgbWFpbmxpbmUgY29tbWl0IGlzIG1pc3Npbmc6DQpodHRwczovL2dpdC5rZXJuZWwub3JnL3B1\nYi9zY20vbGludXgva2VybmVsL2dpdC90b3J2YWxkcy9saW51eC5naXQvY29tbWl0L2RyaXZlcnMv\nbmV0L3dpcmVsZXNzL3JhbGluay9ydDJ4MDAvcnQyODAwbGliLmM/aD12Ni4xOC1yYzEmaWQ9NjYw\nNjMwMzNmNzdlMTBiOTg1MjU4MTI2YTk3NTczZjg0YmI4ZDNiNA0KDQpUaGlzIGZpeCBhbHJlYWR5\nIGV4aXN0cyBpbiA1LjE1Lnk6DQpodHRwczovL2dpdC5rZXJuZWwub3JnL3B1Yi9zY20vbGludXgv\na2VybmVsL2dpdC9zdGFibGUvbGludXguZ2l0L2NvbW1pdC9kcml2ZXJzL25ldC93aXJlbGVzcy9y\nYWxpbmsvcnQyeDAwL3J0MjgwMGxpYi5jP2g9djUuMTUuMTk0JmlkPTJkM2NlZjNkN2E1ZGYyNjBh\nMTRhNjY3OWM0YWNhMGM5N2U1NzBlZTUNCuKApmJ1dCBpcyBtaXNzaW5nIGluIDUuMTAueS4NCg0K\nSSBub3cgYmFja3BvcnRlZCBpdCB0byA1LjEwLnkgaGVyZToNCmh0dHBzOi8vbG9yZS5rZXJuZWwu\nb3JnL3N0YWJsZS8yMDI1MTAxODE5NTk0NS4xODgyNS0xLWZhcmJlcmVAYW1hem9uLmNvbS9ULyN1\nDQoNClJlZ2FyZHMsIEVsaWF2DQoNCg0KPiBJbiBmdW5jdGlvbiDigJhydDI4MDBfdHhwb3dlcl90\nb19kZXbigJksDQo+ICAgICBpbmxpbmVkIGZyb20g4oCYcnQyODAwX2NvbmZpZ19jaGFubmVs4oCZ\nIGF0IC4uL2RyaXZlcnMvbmV0L3dpcmVsZXNzL3JhbGluay9ydDJ4MDAvcnQyODAwbGliLmM6NDAy\nMjoyNToNCj4uLy4uL2luY2x1ZGUvbGludXgvY29tcGlsZXJfdHlwZXMuaDozMDk6NDU6IGVycm9y\nOiBjYWxsIHRvIOKAmF9fY29tcGlsZXRpbWVfYXNzZXJ0XzExNjjigJkgZGVjbGFyZWQgd2l0aCBh\ndHRyaWJ1dGUgZXJyb3I6IGNsYW1wKCkgbG93IGxpbWl0IC03IGdyZWF0ZXIgdGhhbiBoaWdoIGxp\nbWl0IDE1DQo+ICAgMzA5IHwgICAgICAgICBfY29tcGlsZXRpbWVfYXNzZXJ0KGNvbmRpdGlvbiwg\nbXNnLCBfX2NvbXBpbGV0aW1lX2Fzc2VydF8sIF9fQ09VTlRFUl9fKQ0KPiAgICAgICB8ICAgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXg0KPi4vLi4vaW5jbHVkZS9s\naW51eC9jb21waWxlcl90eXBlcy5oOjI5MDoyNTogbm90ZTogaW4gZGVmaW5pdGlvbiBvZiBtYWNy\nbyDigJhfX2NvbXBpbGV0aW1lX2Fzc2VydOKAmQ0KPiAgIDI5MCB8ICAgICAgICAgICAgICAgICAg\nICAgICAgIHByZWZpeCAjIyBzdWZmaXgoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwN\nCj4gICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICBefn5+fn4NCj4uLy4uL2luY2x1ZGUv\nbGludXgvY29tcGlsZXJfdHlwZXMuaDozMDk6OTogbm90ZTogaW4gZXhwYW5zaW9uIG9mIG1hY3Jv\nIOKAmF9jb21waWxldGltZV9hc3NlcnTigJkNCj4gICAzMDkgfCAgICAgICAgIF9jb21waWxldGlt\nZV9hc3NlcnQoY29uZGl0aW9uLCBtc2csIF9fY29tcGlsZXRpbWVfYXNzZXJ0XywgX19DT1VOVEVS\nX18pDQo+ICAgICAgIHwgICAgICAgICBefn5+fn5+fn5+fn5+fn5+fn5+DQo+Li4vaW5jbHVkZS9s\naW51eC9idWlsZF9idWcuaDozOTozNzogbm90ZTogaW4gZXhwYW5zaW9uIG9mIG1hY3JvIOKAmGNv\nbXBpbGV0aW1lX2Fzc2VydOKAmQ0KPiAgICAzOSB8ICNkZWZpbmUgQlVJTERfQlVHX09OX01TRyhj\nb25kLCBtc2cpIGNvbXBpbGV0aW1lX2Fzc2VydCghKGNvbmQpLCBtc2cpDQo+ICAgICAgIHwgICAg\nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXn5+fn5+fn5+fn5+fn5+fn5+DQo+Li4v\naW5jbHVkZS9saW51eC9taW5tYXguaDoxODg6OTogbm90ZTogaW4gZXhwYW5zaW9uIG9mIG1hY3Jv\nIOKAmEJVSUxEX0JVR19PTl9NU0figJkNCj4gICAxODggfCAgICAgICAgIEJVSUxEX0JVR19PTl9N\nU0coc3RhdGljYWxseV90cnVlKHVsbyA+IHVoaSksICAgICAgICAgICAgICAgICAgICAgICAgICAg\nIFwNCj4gICAgICAgfCAgICAgICAgIF5+fn5+fn5+fn5+fn5+fn4NCj4uLi9pbmNsdWRlL2xpbnV4\nL21pbm1heC5oOjE5NTo5OiBub3RlOiBpbiBleHBhbnNpb24gb2YgbWFjcm8g4oCYX19jbGFtcF9v\nbmNl4oCZDQo+ICAgMTk1IHwgICAgICAgICBfX2NsYW1wX29uY2UodHlwZSwgdmFsLCBsbywgaGks\nIF9fVU5JUVVFX0lEKHZfKSwgX19VTklRVUVfSUQobF8pLCBfX1VOSVFVRV9JRChoXykpDQo+ICAg\nICAgIHwgICAgICAgICBefn5+fn5+fn5+fn4NCj4uLi9pbmNsdWRlL2xpbnV4L21pbm1heC5oOjIx\nODozNjogbm90ZTogaW4gZXhwYW5zaW9uIG9mIG1hY3JvIOKAmF9fY2FyZWZ1bF9jbGFtcOKAmQ0K\nPiAgIDIxOCB8ICNkZWZpbmUgY2xhbXBfdCh0eXBlLCB2YWwsIGxvLCBoaSkgX19jYXJlZnVsX2Ns\nYW1wKHR5cGUsIHZhbCwgbG8sIGhpKQ0KPiAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAg\nICAgICAgICAgICAgXn5+fn5+fn5+fn5+fn5+DQo+Li4vZHJpdmVycy9uZXQvd2lyZWxlc3MvcmFs\naW5rL3J0MngwMC9ydDI4MDBsaWIuYzozOTgwOjI0OiBub3RlOiBpbiBleHBhbnNpb24gb2YgbWFj\ncm8g4oCYY2xhbXBfdOKAmQ0KPiAgMzk4MCB8ICAgICAgICAgICAgICAgICByZXR1cm4gY2xhbXBf\ndChjaGFyLCB0eHBvd2VyLCBNSU5fQV9UWFBPV0VSLCBNQVhfQV9UWFBPV0VSKTsNCj4gICAgICAg\nfCAgICAgICAgICAgICAgICAgICAgICAgIF5+fn5+fn4NCj4gSW4gZnVuY3Rpb24g4oCYcnQyODAw\nX3R4cG93ZXJfdG9fZGV24oCZLA0KPiAgICAgaW5saW5lZCBmcm9tIOKAmHJ0MjgwMF9jb25maWdf\nY2hhbm5lbOKAmSBhdCAuLi9kcml2ZXJzL25ldC93aXJlbGVzcy9yYWxpbmsvcnQyeDAwL3J0",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176089486606248.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087732230429.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087730930408.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087731130422.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087730830398.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087730830399.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087731530426.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087731030413.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087731230423.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087734330439.mbox",
          "message_id": "<2025101929-curator-poplar-7460 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:37:40+00:00",
          "date_str": "Sun, 19 Oct 2025 12:37:40 +0000",
          "body": "On Sat, Oct 18, 2025 at 08:07:32PM +0000, Farber, Eliav wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > >\n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > >\n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> >\n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> >\n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> >\n> > Any ideas?\n> \n> This mainline commit is missing:\n> https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v6.18-rc1&id=66063033f77e10b985258126a97573f84bb8d3b4\n> \n> This fix already exists in 5.15.y:\n> https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/drivers/net/wireless/ralink/rt2x00/rt2800lib.c?h=v5.15.194&id=2d3cef3d7a5df260a14a6679c4aca0c97e570ee5\n> \u2026but is missing in 5.10.y.\n> \n> I now backported it to 5.10.y here:\n> https://lore.kernel.org/stable/20251018195945.18825-1-farbere@amazon.com/T/#u\n\nThanks,I've queued that up now.\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087737730493.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087736730475.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087735430459.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087737830496.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087735330458.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087737630488.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087735930471.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087735930467.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        },
        {
          "filepath": "emails/2025/10/176087740430506.mbox",
          "message_id": "<2025101905-matter-freezable-39e5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH v2 00/27 5.10.y] Backport minmax.h updates from v6.17-rc7",
          "date": "2025-10-19 12:38:26+00:00",
          "date_str": "Sun, 19 Oct 2025 12:38:26 +0000",
          "body": "On Fri, Oct 17, 2025 at 05:09:24PM +0100, Nathan Chancellor wrote:\n> On Fri, Oct 17, 2025 at 05:03:02PM +0200, Greg KH wrote:\n> > On Fri, Oct 17, 2025 at 09:04:52AM +0000, Eliav Farber wrote:\n> > > This series backports 27 patches to update minmax.h in the 5.10.y\n> > > branch, aligning it with v6.17-rc7.\n> > > \n> > > The ultimate goal is to synchronize all long-term branches so that they\n> > > include the full set of minmax.h changes.\n> > > \n> > > - 6.12.y has already been backported; the changes are included in\n> > >   v6.12.49.\n> > > - 6.6.y has already been backported; the changes are included in\n> > >   v6.6.109.\n> > > - 6.1.y has already been backported; the changes are currently in the\n> > >   6.1-stable tree.\n> > > - 5.15.y has already been backported; the changes are currently in the\n> > >   5.15-stable tree.\n> > \n> > With this series applied, on an arm64 server, building 'allmodconfig', I\n> > get the following build error.\n> > \n> > Oddly I don't see it on my x86 server, perhaps due to different compiler\n> > versions?\n> > \n> > Any ideas?\n> > \n> > thanks,\n> > \n> > greg k-h\n> > \n> > ------------------------\n> > \n> > In function \u2018rt2800_txpower_to_dev\u2019,\n> >     inlined from \u2018rt2800_config_channel\u2019 at ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:4022:25:\n> > ./../include/linux/compiler_types.h:309:45: error: call to \u2018__compiletime_assert_1168\u2019 declared with attribute error: clamp() low limit -7 greater than high limit 15\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |                                             ^\n> > ./../include/linux/compiler_types.h:290:25: note: in definition of macro \u2018__compiletime_assert\u2019\n> >   290 |                         prefix ## suffix();                             \\\n> >       |                         ^~~~~~\n> > ./../include/linux/compiler_types.h:309:9: note: in expansion of macro \u2018_compiletime_assert\u2019\n> >   309 |         _compiletime_assert(condition, msg, __compiletime_assert_, __COUNTER__)\n> >       |         ^~~~~~~~~~~~~~~~~~~\n> > ../include/linux/build_bug.h:39:37: note: in expansion of macro \u2018compiletime_assert\u2019\n> >    39 | #define BUILD_BUG_ON_MSG(cond, msg) compiletime_assert(!(cond), msg)\n> >       |                                     ^~~~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:188:9: note: in expansion of macro \u2018BUILD_BUG_ON_MSG\u2019\n> >   188 |         BUILD_BUG_ON_MSG(statically_true(ulo > uhi),                            \\\n> >       |         ^~~~~~~~~~~~~~~~\n> > ../include/linux/minmax.h:195:9: note: in expansion of macro \u2018__clamp_once\u2019\n> >   195 |         __clamp_once(type, val, lo, hi, __UNIQUE_ID(v_), __UNIQUE_ID(l_), __UNIQUE_ID(h_))\n> >       |         ^~~~~~~~~~~~\n> > ../include/linux/minmax.h:218:36: note: in expansion of macro \u2018__careful_clamp\u2019\n> >   218 | #define clamp_t(type, val, lo, hi) __careful_clamp(type, val, lo, hi)\n> >       |                                    ^~~~~~~~~~~~~~~\n> > ../drivers/net/wireless/ralink/rt2x00/rt2800lib.c:3980:24: note: in expansion of macro \u2018clamp_t\u2019\n> >  3980 |                 return clamp_t(char, txpower, MIN_A_TXPOWER, MAX_A_TXPOWER);\n> >       |                        ^~~~~~~\n> \n> Missing commit 3bc753c06dd0 (\"kbuild: treat char as always unsigned\")?\n\nThat's going to be messy to backport, it's not even in 6.1.y, so let's\nleave that alone if at all possible.\n\nthanks,\n\ngreg k-h\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
      "normalized_subject": "Compiler-Based Capability- and Locking-Analysis",
      "message_count": 18,
      "participants": [
        "Marco Elver",
        "Nathan Chancellor",
        "Christoph Hellwig"
      ],
      "categories": [
        "context_analysis",
        "general",
        "compiler_compat"
      ],
      "first_date": "2025-09-22T17:12:27+00:00",
      "last_date": "2025-11-14T13:22:01+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175856102603019.mbox",
          "message_id": "<20250922171227.GB12668 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-22 17:12:27+00:00",
          "date_str": "Mon, 22 Sep 2025 17:12:27 +0000",
          "body": "On Fri, Sep 19, 2025 at 10:20:37AM -0700, Bart Van Assche wrote:\n> locking annotations to kernel code. I ended up annotating multiple XFS\n> functions with NO_THREAD_SAFETY_ANALYSIS. Maybe the locking patterns in\n> XFS are too complex for compile-time analysis?\n\nIf our locking patterns are too complex for analysis, either the code or\nthe analysis has problems that need addressing.  Potentially both.\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175856102903027.mbox",
          "message_id": "<20250922171227.GB12668 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-22 17:12:27+00:00",
          "date_str": "Mon, 22 Sep 2025 17:12:27 +0000",
          "body": "On Fri, Sep 19, 2025 at 10:20:37AM -0700, Bart Van Assche wrote:\n> locking annotations to kernel code. I ended up annotating multiple XFS\n> functions with NO_THREAD_SAFETY_ANALYSIS. Maybe the locking patterns in\n> XFS are too complex for compile-time analysis?\n\nIf our locking patterns are too complex for analysis, either the code or\nthe analysis has problems that need addressing.  Potentially both.\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175856102903030.mbox",
          "message_id": "<20250922171227.GB12668 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-22 17:12:27+00:00",
          "date_str": "Mon, 22 Sep 2025 17:12:27 +0000",
          "body": "On Fri, Sep 19, 2025 at 10:20:37AM -0700, Bart Van Assche wrote:\n> locking annotations to kernel code. I ended up annotating multiple XFS\n> functions with NO_THREAD_SAFETY_ANALYSIS. Maybe the locking patterns in\n> XFS are too complex for compile-time analysis?\n\nIf our locking patterns are too complex for analysis, either the code or\nthe analysis has problems that need addressing.  Potentially both.\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175856103303036.mbox",
          "message_id": "<20250922171227.GB12668 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-22 17:12:27+00:00",
          "date_str": "Mon, 22 Sep 2025 17:12:27 +0000",
          "body": "On Fri, Sep 19, 2025 at 10:20:37AM -0700, Bart Van Assche wrote:\n> locking annotations to kernel code. I ended up annotating multiple XFS\n> functions with NO_THREAD_SAFETY_ANALYSIS. Maybe the locking patterns in\n> XFS are too complex for compile-time analysis?\n\nIf our locking patterns are too complex for analysis, either the code or\nthe analysis has problems that need addressing.  Potentially both.\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175865683702116.mbox",
          "message_id": "<20250923194915.GA2127565 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-23 19:49:15+00:00",
          "date_str": "Tue, 23 Sep 2025 19:49:15 +0000",
          "body": "On Mon, Sep 22, 2025 at 11:33:23AM +0200, Marco Elver wrote:\n> [1] https://github.com/llvm/llvm-project/pull/159921\n\nNow that this is merged, I have pushed an updated snapshot for x86_64:\n\nhttps://mirrors.edge.kernel.org/pub/tools/llvm/files/prerelease/llvm-22.0.0-ca2e8fc928ad103f46ca9f827e147c43db3a5c47-20250923-185804-x86_64.tar.xz\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175865689002150.mbox",
          "message_id": "<20250923194915.GA2127565 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-23 19:49:15+00:00",
          "date_str": "Tue, 23 Sep 2025 19:49:15 +0000",
          "body": "On Mon, Sep 22, 2025 at 11:33:23AM +0200, Marco Elver wrote:\n> [1] https://github.com/llvm/llvm-project/pull/159921\n\nNow that this is merged, I have pushed an updated snapshot for x86_64:\n\nhttps://mirrors.edge.kernel.org/pub/tools/llvm/files/prerelease/llvm-22.0.0-ca2e8fc928ad103f46ca9f827e147c43db3a5c47-20250923-185804-x86_64.tar.xz\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175865684102119.mbox",
          "message_id": "<20250923194915.GA2127565 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-09-23 19:49:15+00:00",
          "date_str": "Tue, 23 Sep 2025 19:49:15 +0000",
          "body": "On Mon, Sep 22, 2025 at 11:33:23AM +0200, Marco Elver wrote:\n> [1] https://github.com/llvm/llvm-project/pull/159921\n\nNow that this is merged, I have pushed an updated snapshot for x86_64:\n\nhttps://mirrors.edge.kernel.org/pub/tools/llvm/files/prerelease/llvm-22.0.0-ca2e8fc928ad103f46ca9f827e147c43db3a5c47-20250923-185804-x86_64.tar.xz\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176304393310113.mbox",
          "message_id": "<CANpmjNNoKiFEW2VfGM7rdak7O8__U3S+Esub9yM=9Tq=02d_ag () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-13 14:30:08+00:00",
          "date_str": "Thu, 13 Nov 2025 14:30:08 +0000",
          "body": "On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n[..]\n> I went with \"context guard\" to refer to the objects themselves, as that\n> doesn't look too odd. It does match the concept of \"guard\" in\n> <linux/cleanup.h>.\n>\n> See second attempt below.\n[..]\n\nI finally got around baking this into a renamed series, that now calls\nit \"Context Analysis\" - here's a preview:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n\nAs for when we should give this v4 another try: I'm 50/50 on sending\nthis now vs. waiting for final Clang 22 to be released (~March 2026).\n\nPreferences?\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176304394310143.mbox",
          "message_id": "<CANpmjNNoKiFEW2VfGM7rdak7O8__U3S+Esub9yM=9Tq=02d_ag () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-13 14:30:08+00:00",
          "date_str": "Thu, 13 Nov 2025 14:30:08 +0000",
          "body": "On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n[..]\n> I went with \"context guard\" to refer to the objects themselves, as that\n> doesn't look too odd. It does match the concept of \"guard\" in\n> <linux/cleanup.h>.\n>\n> See second attempt below.\n[..]\n\nI finally got around baking this into a renamed series, that now calls\nit \"Context Analysis\" - here's a preview:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n\nAs for when we should give this v4 another try: I'm 50/50 on sending\nthis now vs. waiting for final Clang 22 to be released (~March 2026).\n\nPreferences?\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176304392610099.mbox",
          "message_id": "<CANpmjNNoKiFEW2VfGM7rdak7O8__U3S+Esub9yM=9Tq=02d_ag () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-13 14:30:08+00:00",
          "date_str": "Thu, 13 Nov 2025 14:30:08 +0000",
          "body": "On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n[..]\n> I went with \"context guard\" to refer to the objects themselves, as that\n> doesn't look too odd. It does match the concept of \"guard\" in\n> <linux/cleanup.h>.\n>\n> See second attempt below.\n[..]\n\nI finally got around baking this into a renamed series, that now calls\nit \"Context Analysis\" - here's a preview:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n\nAs for when we should give this v4 another try: I'm 50/50 on sending\nthis now vs. waiting for final Clang 22 to be released (~March 2026).\n\nPreferences?\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176304349809643.mbox",
          "message_id": "<CANpmjNNoKiFEW2VfGM7rdak7O8__U3S+Esub9yM=9Tq=02d_ag () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-13 14:30:08+00:00",
          "date_str": "Thu, 13 Nov 2025 14:30:08 +0000",
          "body": "On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n[..]\n> I went with \"context guard\" to refer to the objects themselves, as that\n> doesn't look too odd. It does match the concept of \"guard\" in\n> <linux/cleanup.h>.\n>\n> See second attempt below.\n[..]\n\nI finally got around baking this into a renamed series, that now calls\nit \"Context Analysis\" - here's a preview:\nhttps://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n\nAs for when we should give this v4 another try: I'm 50/50 on sending\nthis now vs. waiting for final Clang 22 to be released (~March 2026).\n\nPreferences?\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176309439125295.mbox",
          "message_id": "<20251114043812.GC2566209 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 04:38:12+00:00",
          "date_str": "Fri, 14 Nov 2025 04:38:12 +0000",
          "body": "On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> [..]\n> > I went with \"context guard\" to refer to the objects themselves, as that\n> > doesn't look too odd. It does match the concept of \"guard\" in\n> > <linux/cleanup.h>.\n> >\n> > See second attempt below.\n> [..]\n> \n> I finally got around baking this into a renamed series, that now calls\n> it \"Context Analysis\" - here's a preview:\n> https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> \n> As for when we should give this v4 another try: I'm 50/50 on sending\n> this now vs. waiting for final Clang 22 to be released (~March 2026).\n> \n> Preferences?\n\nFor the record, I can continue to upload clang snapshots for testing and\nvalidating this plus the sooner this hits a tree that goes into -next,\nthe sooner the ClangBuiltLinux infrastructure can start testing it. I\nassume there will not need to be many compiler side fixes but if\n__counted_by has shown us anything, it is that getting this stuff\ndeployed and into the hands of people who want to use it is the only\nreal way to find corner cases to address. No strong objection from me if\nyou want to wait for clang-22 to actually be released though for more\naccess.\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176309435825256.mbox",
          "message_id": "<20251114043812.GC2566209 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 04:38:12+00:00",
          "date_str": "Fri, 14 Nov 2025 04:38:12 +0000",
          "body": "On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> [..]\n> > I went with \"context guard\" to refer to the objects themselves, as that\n> > doesn't look too odd. It does match the concept of \"guard\" in\n> > <linux/cleanup.h>.\n> >\n> > See second attempt below.\n> [..]\n> \n> I finally got around baking this into a renamed series, that now calls\n> it \"Context Analysis\" - here's a preview:\n> https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> \n> As for when we should give this v4 another try: I'm 50/50 on sending\n> this now vs. waiting for final Clang 22 to be released (~March 2026).\n> \n> Preferences?\n\nFor the record, I can continue to upload clang snapshots for testing and\nvalidating this plus the sooner this hits a tree that goes into -next,\nthe sooner the ClangBuiltLinux infrastructure can start testing it. I\nassume there will not need to be many compiler side fixes but if\n__counted_by has shown us anything, it is that getting this stuff\ndeployed and into the hands of people who want to use it is the only\nreal way to find corner cases to address. No strong objection from me if\nyou want to wait for clang-22 to actually be released though for more\naccess.\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176309436225260.mbox",
          "message_id": "<20251114043812.GC2566209 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 04:38:12+00:00",
          "date_str": "Fri, 14 Nov 2025 04:38:12 +0000",
          "body": "On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> [..]\n> > I went with \"context guard\" to refer to the objects themselves, as that\n> > doesn't look too odd. It does match the concept of \"guard\" in\n> > <linux/cleanup.h>.\n> >\n> > See second attempt below.\n> [..]\n> \n> I finally got around baking this into a renamed series, that now calls\n> it \"Context Analysis\" - here's a preview:\n> https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> \n> As for when we should give this v4 another try: I'm 50/50 on sending\n> this now vs. waiting for final Clang 22 to be released (~March 2026).\n> \n> Preferences?\n\nFor the record, I can continue to upload clang snapshots for testing and\nvalidating this plus the sooner this hits a tree that goes into -next,\nthe sooner the ClangBuiltLinux infrastructure can start testing it. I\nassume there will not need to be many compiler side fixes but if\n__counted_by has shown us anything, it is that getting this stuff\ndeployed and into the hands of people who want to use it is the only\nreal way to find corner cases to address. No strong objection from me if\nyou want to wait for clang-22 to actually be released though for more\naccess.\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176309441125309.mbox",
          "message_id": "<20251114043812.GC2566209 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 04:38:12+00:00",
          "date_str": "Fri, 14 Nov 2025 04:38:12 +0000",
          "body": "On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> [..]\n> > I went with \"context guard\" to refer to the objects themselves, as that\n> > doesn't look too odd. It does match the concept of \"guard\" in\n> > <linux/cleanup.h>.\n> >\n> > See second attempt below.\n> [..]\n> \n> I finally got around baking this into a renamed series, that now calls\n> it \"Context Analysis\" - here's a preview:\n> https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> \n> As for when we should give this v4 another try: I'm 50/50 on sending\n> this now vs. waiting for final Clang 22 to be released (~March 2026).\n> \n> Preferences?\n\nFor the record, I can continue to upload clang snapshots for testing and\nvalidating this plus the sooner this hits a tree that goes into -next,\nthe sooner the ClangBuiltLinux infrastructure can start testing it. I\nassume there will not need to be many compiler side fixes but if\n__counted_by has shown us anything, it is that getting this stuff\ndeployed and into the hands of people who want to use it is the only\nreal way to find corner cases to address. No strong objection from me if\nyou want to wait for clang-22 to actually be released though for more\naccess.\n\nCheers,\nNathan\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176312613521862.mbox",
          "message_id": "<CANpmjNPniOK9K6q2sx7KRrxckeAdCyVnTi4qwLqoFoYzYb7L2Q () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 13:22:01+00:00",
          "date_str": "Fri, 14 Nov 2025 13:22:01 +0000",
          "body": "On Fri, 14 Nov 2025 at 05:38, Nathan Chancellor <nathan@kernel.org> wrote:\n> On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> > On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> > [..]\n> > > I went with \"context guard\" to refer to the objects themselves, as that\n> > > doesn't look too odd. It does match the concept of \"guard\" in\n> > > <linux/cleanup.h>.\n> > >\n> > > See second attempt below.\n> > [..]\n> >\n> > I finally got around baking this into a renamed series, that now calls\n> > it \"Context Analysis\" - here's a preview:\n> > https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> >\n> > As for when we should give this v4 another try: I'm 50/50 on sending\n> > this now vs. waiting for final Clang 22 to be released (~March 2026).\n> >\n> > Preferences?\n>\n> For the record, I can continue to upload clang snapshots for testing and\n> validating this plus the sooner this hits a tree that goes into -next,\n> the sooner the ClangBuiltLinux infrastructure can start testing it. I\n> assume there will not need to be many compiler side fixes but if\n\nI hope so ... Famous last words. ;-)\n\n> __counted_by has shown us anything, it is that getting this stuff\n> deployed and into the hands of people who want to use it is the only\n> real way to find corner cases to address. No strong objection from me if\n> you want to wait for clang-22 to actually be released though for more\n> access.\n\nThanks, Nathan - having ClangBuiltLinux infra help test would be very helpful.\nUnless I hear otherwise, I can send v4 next week for review - in case\nof a v5 I will wait until ~March (as that coincides with Clang 22\nrelease, and for lack of time on my end between Jan and March).\nCould also skip the subsystem-enablement patches for now; only the\npatches until the MAINTAINERS patch are the bare minimum, the rest can\nbe taken later by individual maintainers.\n\nThanks,\n-- Marco\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176312614821874.mbox",
          "message_id": "<CANpmjNPniOK9K6q2sx7KRrxckeAdCyVnTi4qwLqoFoYzYb7L2Q () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 13:22:01+00:00",
          "date_str": "Fri, 14 Nov 2025 13:22:01 +0000",
          "body": "On Fri, 14 Nov 2025 at 05:38, Nathan Chancellor <nathan@kernel.org> wrote:\n> On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> > On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> > [..]\n> > > I went with \"context guard\" to refer to the objects themselves, as that\n> > > doesn't look too odd. It does match the concept of \"guard\" in\n> > > <linux/cleanup.h>.\n> > >\n> > > See second attempt below.\n> > [..]\n> >\n> > I finally got around baking this into a renamed series, that now calls\n> > it \"Context Analysis\" - here's a preview:\n> > https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> >\n> > As for when we should give this v4 another try: I'm 50/50 on sending\n> > this now vs. waiting for final Clang 22 to be released (~March 2026).\n> >\n> > Preferences?\n>\n> For the record, I can continue to upload clang snapshots for testing and\n> validating this plus the sooner this hits a tree that goes into -next,\n> the sooner the ClangBuiltLinux infrastructure can start testing it. I\n> assume there will not need to be many compiler side fixes but if\n\nI hope so ... Famous last words. ;-)\n\n> __counted_by has shown us anything, it is that getting this stuff\n> deployed and into the hands of people who want to use it is the only\n> real way to find corner cases to address. No strong objection from me if\n> you want to wait for clang-22 to actually be released though for more\n> access.\n\nThanks, Nathan - having ClangBuiltLinux infra help test would be very helpful.\nUnless I hear otherwise, I can send v4 next week for review - in case\nof a v5 I will wait until ~March (as that coincides with Clang 22\nrelease, and for lack of time on my end between Jan and March).\nCould also skip the subsystem-enablement patches for now; only the\npatches until the MAINTAINERS patch are the bare minimum, the rest can\nbe taken later by individual maintainers.\n\nThanks,\n-- Marco\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/176312625121980.mbox",
          "message_id": "<CANpmjNPniOK9K6q2sx7KRrxckeAdCyVnTi4qwLqoFoYzYb7L2Q () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v3 00/35] Compiler-Based Capability- and Locking-Analysis",
          "date": "2025-11-14 13:22:01+00:00",
          "date_str": "Fri, 14 Nov 2025 13:22:01 +0000",
          "body": "On Fri, 14 Nov 2025 at 05:38, Nathan Chancellor <nathan@kernel.org> wrote:\n> On Thu, Nov 13, 2025 at 03:30:08PM +0100, Marco Elver wrote:\n> > On Fri, 19 Sept 2025 at 11:10, Marco Elver <elver@google.com> wrote:\n> > [..]\n> > > I went with \"context guard\" to refer to the objects themselves, as that\n> > > doesn't look too odd. It does match the concept of \"guard\" in\n> > > <linux/cleanup.h>.\n> > >\n> > > See second attempt below.\n> > [..]\n> >\n> > I finally got around baking this into a renamed series, that now calls\n> > it \"Context Analysis\" - here's a preview:\n> > https://git.kernel.org/pub/scm/linux/kernel/git/melver/linux.git/log/?h=ctx-analysis/dev\n> >\n> > As for when we should give this v4 another try: I'm 50/50 on sending\n> > this now vs. waiting for final Clang 22 to be released (~March 2026).\n> >\n> > Preferences?\n>\n> For the record, I can continue to upload clang snapshots for testing and\n> validating this plus the sooner this hits a tree that goes into -next,\n> the sooner the ClangBuiltLinux infrastructure can start testing it. I\n> assume there will not need to be many compiler side fixes but if\n\nI hope so ... Famous last words. ;-)\n\n> __counted_by has shown us anything, it is that getting this stuff\n> deployed and into the hands of people who want to use it is the only\n> real way to find corner cases to address. No strong objection from me if\n> you want to wait for clang-22 to actually be released though for more\n> access.\n\nThanks, Nathan - having ClangBuiltLinux infra help test would be very helpful.\nUnless I hear otherwise, I can send v4 next week for review - in case\nof a v5 I will wait until ~March (as that coincides with Clang 22\nrelease, and for lack of time on my end between Jan and March).\nCould also skip the subsystem-enablement patches for now; only the\npatches until the MAINTAINERS patch are the bare minimum, the rest can\nbe taken later by individual maintainers.\n\nThanks,\n-- Marco\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH] vadidation: add used-to-be-signed unit tests",
      "normalized_subject": "vadidation: add used-to-be-signed unit tests",
      "message_count": 3,
      "participants": [
        "Chris Li",
        "Vincent Mailhol"
      ],
      "categories": [
        "rfc_proposals"
      ],
      "first_date": "2025-09-22T15:53:21+00:00",
      "last_date": "2025-09-24T17:47:05+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175855642231878.mbox",
          "message_id": "<20250922155415.3289196-1-mailhol () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH] vadidation: add used-to-be-signed unit tests",
          "date": "2025-09-22 15:53:21+00:00",
          "date_str": "Mon, 22 Sep 2025 15:53:21 +0000",
          "body": "Add unit tests for the new used-to-be-signed check as introduced in [1]:\n\nResults before applying [1]:\n\n  $ ./test-suite used-to-be-signed.c\n    TEST    used-to-be-signed (used-to-be-signed.c)\n  error: actual error text does not match expected error text.\n  error: see used-to-be-signed.c.error.* for further investigation.\n  --- used-to-be-signed.c.error.expected\t2025-09-23 00:50:07.079654644 +0900\n  +++ used-to-be-signed.c.error.got\t2025-09-23 00:50:07.073654719 +0900\n  @@ -1,8 +0,0 @@\n  -used-to-be-signed.c:8:19: warning: unsigned value that used to be signed checked against zero?\n  -used-to-be-signed.c:6:33: signed value source\n  -used-to-be-signed.c:11:17: warning: unsigned value that used to be signed checked against zero?\n  -used-to-be-signed.c:6:33: signed value source\n  -used-to-be-signed.c:14:20: warning: unsigned value that used to be signed checked against zero?\n  -used-to-be-signed.c:6:33: signed value source\n  -used-to-be-signed.c:17:18: warning: unsigned value that used to be signed checked against zero?\n  -used-to-be-signed.c:6:33: signed value source\n  error: FAIL: test 'used-to-be-signed.c' failed\n  KO: out of 1 tests, 0 passed, 1 failed\n\n...and after:\n\n  $ ./test-suite used-to-be-signed.c\n    TEST    used-to-be-signed (used-to-be-signed.c)\n  OK: out of 1 tests, 1 passed, 0 failed\n\n[1] Warn about \"unsigned value that used to be signed against zero\"\nLink: https://lore.kernel.org/linux-sparse/20250921061337.3047616-1-mailhol@kernel.org/\n\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nHi Chris,\n\nThanks for your guidance. I added more tests.\n\nBecause you asked me for my preference, I went for the single file.\nBut if you finally have a preference to split, tell me and I will\nupdate.\n---\n validation/used-to-be-signed.c | 49 ++++++++++++++++++++++++++++++++++\n 1 file changed, 49 insertions(+)\n create mode 100644 validation/used-to-be-signed.c\n\ndiff --git a/validation/used-to-be-signed.c b/validation/used-to-be-signed.c\nnew file mode 100644\nindex 00000000..75eab7f3\n--- /dev/null\n+++ b/validation/used-to-be-signed.c\n@@ -0,0 +1,49 @@\n+void error(void);\n+int check(void);\n+\n+static void positive_tests(unsigned int val)\n+{\n+\tunsigned int ret = check();\n+\n+\tif (ret < 0)\n+\t\terror();\n+\n+\tif (0 > ret)\n+\t\terror();\n+\n+\tif (ret >= 0)\n+\t\t/* Do stuff */;\n+\n+\tif (0 <= ret)\n+\t\t/* Do stuff */;\n+}\n+\n+static void negative_tests(unsigned int val)\n+{\n+\tif (val < 0 || val > 42)\n+\t\terror();\n+\n+\tif (0 > val || 42 < val)\n+\t\terror();\n+\n+\tif (val >= 0 && val < 42)\n+\t\t/* Do stuff */;\n+\n+\tif (0 <= val && 42 > val)\n+\t\t/* Do stuff */;\n+}\n+\n+/*\n+ * check-name: used-to-be-signed\n+ *\n+ * check-error-start\n+used-to-be-signed.c:8:19: warning: unsigned value that used to be signed checked against zero?\n+used-to-be-signed.c:6:33: signed value source\n+used-to-be-signed.c:11:17: warning: unsigned value that used to be signed checked against zero?\n+used-to-be-signed.c:6:33: signed value source\n+used-to-be-signed.c:14:20: warning: unsigned value that used to be signed checked against zero?\n+used-to-be-signed.c:6:33: signed value source\n+used-to-be-signed.c:17:18: warning: unsigned value that used to be signed checked against zero?\n+used-to-be-signed.c:6:33: signed value source\n+ * check-error-end\n+ */\n-- \n2.49.1\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175869732722076.mbox",
          "message_id": "<CACePvbXaHKH5Vp+j53pk6494pgDEABQpZ_gOo9_nmCZ4gjxUHw () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] vadidation: add used-to-be-signed unit tests",
          "date": "2025-09-24 07:03:57+00:00",
          "date_str": "Wed, 24 Sep 2025 07:03:57 +0000",
          "body": "On Mon, Sep 22, 2025 at 8:54=E2=80=AFAM Vincent Mailhol <mailhol@kernel.org=\n> wrote:\n>\n> Add unit tests for the new used-to-be-signed check as introduced in [1]:\n\nApplied and pushed on sparse-dev repo. Can you please take a look if I\nam doing it correctly on the sparse-dev?\nLinus has one more debug print line, can you add it for me and submit\nan incremental patch? It should be just a one liner. I will squash it\nwith your change. I can ping you on the other email as well.\n\nI intend to use sparse-dev as the unstable sparse developer repo. It\nwill always be based on sparse repo but the commit in sparse-dev can\nbe rewinded. Patches will sit in the sparse-dev for about a week then\nmove into sparse repo. The sparse repo is a stable repo, it will not\nrewind.\n\nBTW, the recommended base to submit the sparse patches is the stable\nsparse repo unless you depend on some bleeding edge feature only on\nsparse-dev repo. Pull request please base on the sparse repo not the\nunstable sparse-dev repo.\n\nThanks\n\nChris\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175873590619715.mbox",
          "message_id": "<CACePvbXLAtCjgdq5r43NCjk7bNfU3EgJ4naFj5ZiFRFkW+iQqA () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] vadidation: add used-to-be-signed unit tests",
          "date": "2025-09-24 17:47:05+00:00",
          "date_str": "Wed, 24 Sep 2025 17:47:05 +0000",
          "body": "On Wed, Sep 24, 2025 at 2:28=E2=80=AFAM Vincent Mailhol <mailhol@kernel.org=\n> wrote:\n>\n> On 24/09/2025 at 16:03, Chris Li wrote:\n> > On Mon, Sep 22, 2025 at 8:54=E2=80=AFAM Vincent Mailhol <mailhol@kernel=\n.org> wrote:\n> >>\n> >> Add unit tests for the new used-to-be-signed check as introduced in [1=\n]:\n> >\n> > Applied and pushed on sparse-dev repo. Can you please take a look if I\n> > am doing it correctly on the sparse-dev?\n>\n> I just checked out sparse-dev. I re-run the tests and everything looks fi=\nne!\n\nThanks for the confirmation.\n\n\n>\n> > Linus has one more debug print line, can you add it for me and submit\n> > an incremental patch? It should be just a one liner. I will squash it\n> > with your change. I can ping you on the other email as well.\n>\n> I replied in the other thread. That one line is already in the final patc=\nh ;)\n\nAck.\n\n>\n> > I intend to use sparse-dev as the unstable sparse developer repo. It\n> > will always be based on sparse repo but the commit in sparse-dev can\n> > be rewinded. Patches will sit in the sparse-dev for about a week then\n> > move into sparse repo. The sparse repo is a stable repo, it will not\n> > rewind.\n> >\n> > BTW, the recommended base to submit the sparse patches is the stable\n> > sparse repo unless you depend on some bleeding edge feature only on\n> > sparse-dev repo. Pull request please base on the sparse repo not the\n> > unstable sparse-dev repo.\n> Ack. At the moment, I am not planning to do more sparse development, this=\n patch\n> will likely be a one shot. But I will keep this in mind if I either decid=\ne to do\n> another contribution.\n\nThat is more of a note for the general sparse patch submission.\nAlignment for how to use the two sparse repo. I will send a separate\nemail to the sparse mailing list.\n\nThanks for your first two patches after I am back as the maintainer.\n\nChris\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "rfc_proposals"
    },
    {
      "subject": "[PATCH 15/15 6.6.y] minmax.h: remove some #defines that are only expanded once",
      "normalized_subject": "minmax.h: remove some #defines that are only expanded once",
      "message_count": 3,
      "participants": [
        "Eliav Farber"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-09-22T10:32:41+00:00",
      "last_date": "2025-10-17T09:05:19+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175853790717073.mbox",
          "message_id": "<20250922103241.16213-16-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 15/15 6.6.y] minmax.h: remove some #defines that are only expanded once",
          "date": "2025-09-22 10:32:41+00:00",
          "date_str": "Mon, 22 Sep 2025 10:32:41 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit 2b97aaf74ed534fb838d09867d09a3ca5d795208 ]\n\nThe bodies of __signed_type_use() and __unsigned_type_use() are much the\nsame size as their names - so put the bodies in the only line that expands\nthem.\n\nSimilarly __signed_type() is defined separately for 64bit and then used\nexactly once just below.\n\nChange the test for __signed_type from CONFIG_64BIT to one based on gcc\ndefined macros so that the code is valid if it gets used outside of a\nkernel build.\n\nLink: https://lkml.kernel.org/r/9386d1ebb8974fbabbed2635160c3975@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 14 ++++++--------\n 1 file changed, 6 insertions(+), 8 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 2bbdd5b5e07e..eaaf5c008e4d 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -46,10 +46,8 @@\n  * comparison, and these expressions only need to be careful to not cause\n  * warnings for pointer use.\n  */\n-#define __signed_type_use(ux) (2 + __is_nonneg(ux))\n-#define __unsigned_type_use(ux) (1 + 2 * (sizeof(ux) < 4))\n #define __sign_use(ux) (is_signed_type(typeof(ux)) ? \\\n-\t__signed_type_use(ux) : __unsigned_type_use(ux))\n+\t(2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n \n /*\n  * Check whether a signed value is always non-negative.\n@@ -57,7 +55,7 @@\n  * A cast is needed to avoid any warnings from values that aren't signed\n  * integer types (in which case the result doesn't matter).\n  *\n- * On 64-bit any integer or pointer type can safely be cast to 'long'.\n+ * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n  * must be used depending on the size of the value.\n@@ -66,12 +64,12 @@\n  * them, but we do not use s128 types in the kernel (we do use 'u128',\n  * but they are handled by the !is_signed_type() case).\n  */\n-#ifdef CONFIG_64BIT\n-  #define __signed_type(ux) long\n+#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n+#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n #else\n-  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n+#define __is_nonneg(ux) statically_true( \\\n+\t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n #endif\n-#define __is_nonneg(ux) statically_true((__signed_type(ux))(ux) >= 0)\n \n #define __types_ok(ux, uy) \\\n \t(__sign_use(ux) & __sign_use(uy))\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175874626828039.mbox",
          "message_id": "<20250924202320.32333-20-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH 19/19 v6.1.y] minmax.h: remove some #defines that are only expanded once",
          "date": "2025-09-24 20:23:20+00:00",
          "date_str": "Wed, 24 Sep 2025 20:23:20 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit 2b97aaf74ed534fb838d09867d09a3ca5d795208 ]\n\nThe bodies of __signed_type_use() and __unsigned_type_use() are much the\nsame size as their names - so put the bodies in the only line that expands\nthem.\n\nSimilarly __signed_type() is defined separately for 64bit and then used\nexactly once just below.\n\nChange the test for __signed_type from CONFIG_64BIT to one based on gcc\ndefined macros so that the code is valid if it gets used outside of a\nkernel build.\n\nLink: https://lkml.kernel.org/r/9386d1ebb8974fbabbed2635160c3975@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 14 ++++++--------\n 1 file changed, 6 insertions(+), 8 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 2bbdd5b5e07e..eaaf5c008e4d 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -46,10 +46,8 @@\n  * comparison, and these expressions only need to be careful to not cause\n  * warnings for pointer use.\n  */\n-#define __signed_type_use(ux) (2 + __is_nonneg(ux))\n-#define __unsigned_type_use(ux) (1 + 2 * (sizeof(ux) < 4))\n #define __sign_use(ux) (is_signed_type(typeof(ux)) ? \\\n-\t__signed_type_use(ux) : __unsigned_type_use(ux))\n+\t(2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n \n /*\n  * Check whether a signed value is always non-negative.\n@@ -57,7 +55,7 @@\n  * A cast is needed to avoid any warnings from values that aren't signed\n  * integer types (in which case the result doesn't matter).\n  *\n- * On 64-bit any integer or pointer type can safely be cast to 'long'.\n+ * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n  * must be used depending on the size of the value.\n@@ -66,12 +64,12 @@\n  * them, but we do not use s128 types in the kernel (we do use 'u128',\n  * but they are handled by the !is_signed_type() case).\n  */\n-#ifdef CONFIG_64BIT\n-  #define __signed_type(ux) long\n+#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n+#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n #else\n-  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n+#define __is_nonneg(ux) statically_true( \\\n+\t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n #endif\n-#define __is_nonneg(ux) statically_true((__signed_type(ux))(ux) >= 0)\n \n #define __types_ok(ux, uy) \\\n \t(__sign_use(ux) & __sign_use(uy))\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/10/176069351803368.mbox",
          "message_id": "<20251017090519.46992-28-farbere () amazon ! com>",
          "author_name": "Eliav Farber",
          "author_email": "farbere () amazon ! com",
          "subject": "[PATCH v2 27/27 5.10.y] minmax.h: remove some #defines that are only expanded once",
          "date": "2025-10-17 09:05:19+00:00",
          "date_str": "Fri, 17 Oct 2025 09:05:19 +0000",
          "body": "From: David Laight <David.Laight@ACULAB.COM>\n\n[ Upstream commit 2b97aaf74ed534fb838d09867d09a3ca5d795208 ]\n\nThe bodies of __signed_type_use() and __unsigned_type_use() are much the\nsame size as their names - so put the bodies in the only line that expands\nthem.\n\nSimilarly __signed_type() is defined separately for 64bit and then used\nexactly once just below.\n\nChange the test for __signed_type from CONFIG_64BIT to one based on gcc\ndefined macros so that the code is valid if it gets used outside of a\nkernel build.\n\nLink: https://lkml.kernel.org/r/9386d1ebb8974fbabbed2635160c3975@AcuMS.aculab.com\nSigned-off-by: David Laight <david.laight@aculab.com>\nCc: Andy Shevchenko <andriy.shevchenko@linux.intel.com>\nCc: Arnd Bergmann <arnd@kernel.org>\nCc: Christoph Hellwig <hch@infradead.org>\nCc: Dan Carpenter <dan.carpenter@linaro.org>\nCc: Jason A. Donenfeld <Jason@zx2c4.com>\nCc: Jens Axboe <axboe@kernel.dk>\nCc: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nCc: Mateusz Guzik <mjguzik@gmail.com>\nCc: Matthew Wilcox <willy@infradead.org>\nCc: Pedro Falcato <pedro.falcato@gmail.com>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Eliav Farber <farbere@amazon.com>\n---\n include/linux/minmax.h | 14 ++++++--------\n 1 file changed, 6 insertions(+), 8 deletions(-)\n\ndiff --git a/include/linux/minmax.h b/include/linux/minmax.h\nindex 2bbdd5b5e07e..eaaf5c008e4d 100644\n--- a/include/linux/minmax.h\n+++ b/include/linux/minmax.h\n@@ -46,10 +46,8 @@\n  * comparison, and these expressions only need to be careful to not cause\n  * warnings for pointer use.\n  */\n-#define __signed_type_use(ux) (2 + __is_nonneg(ux))\n-#define __unsigned_type_use(ux) (1 + 2 * (sizeof(ux) < 4))\n #define __sign_use(ux) (is_signed_type(typeof(ux)) ? \\\n-\t__signed_type_use(ux) : __unsigned_type_use(ux))\n+\t(2 + __is_nonneg(ux)) : (1 + 2 * (sizeof(ux) < 4)))\n \n /*\n  * Check whether a signed value is always non-negative.\n@@ -57,7 +55,7 @@\n  * A cast is needed to avoid any warnings from values that aren't signed\n  * integer types (in which case the result doesn't matter).\n  *\n- * On 64-bit any integer or pointer type can safely be cast to 'long'.\n+ * On 64-bit any integer or pointer type can safely be cast to 'long long'.\n  * But on 32-bit we need to avoid warnings about casting pointers to integers\n  * of different sizes without truncating 64-bit values so 'long' or 'long long'\n  * must be used depending on the size of the value.\n@@ -66,12 +64,12 @@\n  * them, but we do not use s128 types in the kernel (we do use 'u128',\n  * but they are handled by the !is_signed_type() case).\n  */\n-#ifdef CONFIG_64BIT\n-  #define __signed_type(ux) long\n+#if __SIZEOF_POINTER__ == __SIZEOF_LONG_LONG__\n+#define __is_nonneg(ux) statically_true((long long)(ux) >= 0)\n #else\n-  #define __signed_type(ux) typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L))\n+#define __is_nonneg(ux) statically_true( \\\n+\t(typeof(__builtin_choose_expr(sizeof(ux) > 4, 1LL, 1L)))(ux) >= 0)\n #endif\n-#define __is_nonneg(ux) statically_true((__signed_type(ux))(ux) >= 0)\n \n #define __types_ok(ux, uy) \\\n \t(__sign_use(ux) & __sign_use(uy))\n-- \n2.47.3\n\n",
          "year": "2025",
          "month": "10"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
      "normalized_subject": "Backport minmax.h updates from v6.17-rc6",
      "message_count": 23,
      "participants": [
        "Farber, Eliav",
        "Christian_K=C3=B6nig",
        "Greg KH"
      ],
      "categories": [
        "rfc_proposals",
        "type_system"
      ],
      "first_date": "2025-09-22T05:02:08+00:00",
      "last_date": "2025-09-22T10:45:37+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175852509207038.mbox",
          "message_id": "<2025092203-untreated-sloppily-23b5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 05:02:08+00:00",
          "date_str": "Mon, 22 Sep 2025 05:02:08 +0000",
          "body": "On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > This series includes a total of 27 patches, to align minmax.h of\n> > > v5.15.y with v6.17-rc6.\n> > >\n> > > The set consists of 24 commits that directly update minmax.h:\n> > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n> > >    once\")\n> >\n> > But this isn't in 5.15.y, so how is this syncing things up?\n> >\n> > I'm all for this, but I got confused here, at the first commit :)\n> \n> It's a typo.\n> It should be 5.10.y and not 5.15.y.\n> \n> > Some of these are also only in newer kernels, which, as you know, is\n> > generally a bad thing (i.e. I can't take patches only for older\n> > kernels.)\n> >\n> > I want these changes, as they are great, but can you perhaps provide\n> > patch series for newer kernels first so that I can then take these?\n> \n> So you'd first like first to align 6.16 with 6.17, then 6.15 with 6.16,\n> then 6.12 with 6.15, then 6.6 with 6.12, and so on until we eventually\n> align 5.10 and even 5.4?\n\nYes please!\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175851722602575.mbox",
          "message_id": "<2025092203-untreated-sloppily-23b5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 05:02:08+00:00",
          "date_str": "Mon, 22 Sep 2025 05:02:08 +0000",
          "body": "On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > This series includes a total of 27 patches, to align minmax.h of\n> > > v5.15.y with v6.17-rc6.\n> > >\n> > > The set consists of 24 commits that directly update minmax.h:\n> > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n> > >    once\")\n> >\n> > But this isn't in 5.15.y, so how is this syncing things up?\n> >\n> > I'm all for this, but I got confused here, at the first commit :)\n> \n> It's a typo.\n> It should be 5.10.y and not 5.15.y.\n> \n> > Some of these are also only in newer kernels, which, as you know, is\n> > generally a bad thing (i.e. I can't take patches only for older\n> > kernels.)\n> >\n> > I want these changes, as they are great, but can you perhaps provide\n> > patch series for newer kernels first so that I can then take these?\n> \n> So you'd first like first to align 6.16 with 6.17, then 6.15 with 6.16,\n> then 6.12 with 6.15, then 6.6 with 6.12, and so on until we eventually\n> align 5.10 and even 5.4?\n\nYes please!\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175851722502572.mbox",
          "message_id": "<2025092203-untreated-sloppily-23b5 () gregkh>",
          "author_name": "Greg KH",
          "author_email": "gregkh () linuxfoundation ! org",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 05:02:08+00:00",
          "date_str": "Mon, 22 Sep 2025 05:02:08 +0000",
          "body": "On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > This series includes a total of 27 patches, to align minmax.h of\n> > > v5.15.y with v6.17-rc6.\n> > >\n> > > The set consists of 24 commits that directly update minmax.h:\n> > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n> > >    once\")\n> >\n> > But this isn't in 5.15.y, so how is this syncing things up?\n> >\n> > I'm all for this, but I got confused here, at the first commit :)\n> \n> It's a typo.\n> It should be 5.10.y and not 5.15.y.\n> \n> > Some of these are also only in newer kernels, which, as you know, is\n> > generally a bad thing (i.e. I can't take patches only for older\n> > kernels.)\n> >\n> > I want these changes, as they are great, but can you perhaps provide\n> > patch series for newer kernels first so that I can then take these?\n> \n> So you'd first like first to align 6.16 with 6.17, then 6.15 with 6.16,\n> then 6.12 with 6.15, then 6.6 with 6.12, and so on until we eventually\n> align 5.10 and even 5.4?\n\nYes please!\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853065911317.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853069611350.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853066711330.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853067911340.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853066011322.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853065711310.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853067911339.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853064811301.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853066311327.mbox",
          "message_id": "<98c8f8f1-8261-4e28-855f-f26e0780030c () amd ! com>",
          "author_name": "Christian_K=C3=B6nig",
          "author_email": "christian.koenig () amd ! com",
          "subject": "Re: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 08:45:46+00:00",
          "date_str": "Mon, 22 Sep 2025 08:45:46 +0000",
          "body": "On 20.09.25 12:21, David Laight wrote:\n> On Fri, 19 Sep 2025 14:11:37 +0200\n> Christian K\u00f6nig <christian.koenig@amd.com> wrote:\n> \n>> On 19.09.25 12:17, Eliav Farber wrote:\n>>> This series includes a total of 27 patches, to align minmax.h of\n>>> v5.15.y with v6.17-rc6.\n>>>\n>>> The set consists of 24 commits that directly update minmax.h:\n>>> 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() macro\n>>>    once\")\n>>> 2) 5efcecd9a3b1 (\"minmax: sanity check constant bounds when clamping\")\n>>> 3) 2122e2a4efc2 (\"minmax: clamp more efficiently by avoiding extra\n>>>    comparison\")\n>>> 4) f9bff0e31881 (\"minmax: add in_range() macro\")\n>>> 5) c952c748c7a9 (\"minmax: Introduce {min,max}_array()\")\n>>> 6) 5e57418a2031 (\"minmax: deduplicate __unconst_integer_typeof()\")\n>>> 7) f6e9d38f8eb0 (\"minmax: fix header inclusions\")\n>>> 8) d03eba99f5bf (\"minmax: allow min()/max()/clamp() if the arguments\n>>>    have the same signedness.\")\n>>> 9) f4b84b2ff851 (\"minmax: fix indentation of __cmp_once() and\n>>>    __clamp_once()\")\n>>> 10) 4ead534fba42 (\"minmax: allow comparisons of 'int' against 'unsigned\n>>>     char/short'\")\n>>> 11) 867046cc7027 (\"minmax: relax check to allow comparison between\n>>>     unsigned arguments and signed constants\")\n>>> 12) 3a7e02c040b1 (\"minmax: avoid overly complicated constant\n>>>     expressions in VM code\")\n>>> 14) 017fa3e89187 (\"minmax: simplify and clarify min_t()/max_t()\n>>>     implementation\")\n>>> 15) 1a251f52cfdc (\"minmax: make generic MIN() and MAX() macros\n>>>     available everywhere\")\n>>> 18) dc1c8034e31b (\"minmax: simplify min()/max()/clamp()\n>>>     implementation\")\n>>> 19) 22f546873149 (\"minmax: improve macro expansion and type\n>>>     checking\")\n>>> 20) 21b136cc63d2 (\"minmax: fix up min3() and max3() too\")\n>>> 21) 71ee9b16251e (\"minmax.h: add whitespace around operators and after\n>>>     commas\")\n>>> 22) 10666e992048 (\"minmax.h: update some comments\")\n>>> 23) b280bb27a9f7 (\"minmax.h: reduce the #define expansion of min(),\n>>>     max() and clamp()\")\n>>> 24) a5743f32baec (\"minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi\n>>>     test in clamp()\")\n>>> 25) c3939872ee4a (\"minmax.h: move all the clamp() definitions after the\n>>>     min/max() ones\")\n>>> 26) 495bba17cdf9 (\"minmax.h: simplify the variants of clamp()\")\n>>> 27) 2b97aaf74ed5 (\"minmax.h: remove some #defines that are only\n>>>     expanded once\")\n>>>\n>>> 2 prerequisite commits that adjust users of MIN and MAX macros (to\n>>> prevent compilation issues):\n>>> 13) 4477b39c32fd (\"minmax: add a few more MIN_T/MAX_T users\")\n>>> 17) cb04e8b1d2f2 (\"minmax: don't use max() in situations that want a C\n>>>     constant expression\")\n>>>\n>>> 1 additional commit introduced to resolve a build failures during the\n>>> backport:\n>>> 16) lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> The primary motivation is to bring in commit (8).\n>>> In mainline, this change allows min()/max()/clamp() to accept mixed\n>>> argument types when both share the same signedness.\n>>> Backported patches to v5.10.y that use such forms trigger compiler\n>>> warnings, which in turn cause build failures when -Werror is enabled.\n>>>\n>>> Originaly I aligned 5.10.y to 5.15.y, but David Laight commented that I\n>>> need to pick up the later changes (from Linus) as well.\n>>>\n>>> Andy Shevchenko (2):\n>>>   minmax: deduplicate __unconst_integer_typeof()\n>>>   minmax: fix header inclusions\n>>>\n>>> Bart Van Assche (1):\n>>>   overflow, tracing: Define the is_signed_type() macro once\n>>>\n>>> David Laight (11):\n>>>   minmax: allow min()/max()/clamp() if the arguments have the same\n>>>     signedness.\n>>>   minmax: fix indentation of __cmp_once() and __clamp_once()\n>>>   minmax: allow comparisons of 'int' against 'unsigned char/short'\n>>>   minmax: relax check to allow comparison between unsigned arguments and\n>>>     signed constants\n>>>   minmax.h: add whitespace around operators and after commas\n>>>   minmax.h: update some comments\n>>>   minmax.h: reduce the #define expansion of min(), max() and clamp()\n>>>   minmax.h: use BUILD_BUG_ON_MSG() for the lo < hi test in clamp()\n>>>   minmax.h: move all the clamp() definitions after the min/max() ones\n>>>   minmax.h: simplify the variants of clamp()\n>>>   minmax.h: remove some #defines that are only expanded once\n>>>\n>>> Eliav Farber (1):\n>>>   lib: zstd: drop local MIN/MAX macros in favor of generic ones\n>>>\n>>> Herve Codina (1):\n>>>   minmax: Introduce {min,max}_array()\n>>>\n>>> Jason A. Donenfeld (2):\n>>>   minmax: sanity check constant bounds when clamping\n>>>   minmax: clamp more efficiently by avoiding extra comparison\n>>>\n>>> Linus Torvalds (8):\n>>>   minmax: avoid overly complicated constant expressions in VM code\n>>>   minmax: add a few more MIN_T/MAX_T users\n>>>   minmax: simplify and clarify min_t()/max_t() implementation\n>>>   minmax: make generic MIN() and MAX() macros available everywhere\n>>>   minmax: don't use max() in situations that want a C constant\n>>>     expression\n>>>   minmax: simplify mi",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853801917179.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853801317172.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175857035509405.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853804517206.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853803017184.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853805917212.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853804017196.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853781116955.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853796917129.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853801217171.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175853794917105.mbox",
          "message_id": "<df8d65b372864d149035eb1f016f08ae () amazon ! com>",
          "author_name": "Farber, Eliav",
          "author_email": "farbere () amazon ! com",
          "subject": "RE: [PATCH 00/27 5.10.y] Backport minmax.h updates from v6.17-rc6",
          "date": "2025-09-22 10:45:37+00:00",
          "date_str": "Mon, 22 Sep 2025 10:45:37 +0000",
          "body": "> On Sun, Sep 21, 2025 at 09:37:02PM +0000, Farber, Eliav wrote:\n> > > On Fri, Sep 19, 2025 at 10:17:00AM +0000, Eliav Farber wrote:\n> > > > This series includes a total of 27 patches, to align minmax.h of=20\n> > > > v5.15.y with v6.17-rc6.\n> > > >\n> > > > The set consists of 24 commits that directly update minmax.h:\n> > > > 1) 92d23c6e9415 (\"overflow, tracing: Define the is_signed_type() ma=\ncro\n> > > >    once\")\n> > >\n> > > But this isn't in 5.15.y, so how is this syncing things up?\n> > >\n> > > I'm all for this, but I got confused here, at the first commit :)\n> >\n> > It's a typo.\n> > It should be 5.10.y and not 5.15.y.\n> >\n> > > Some of these are also only in newer kernels, which, as you know, is=\n=20\n> > > generally a bad thing (i.e. I can't take patches only for older\n> > > kernels.)\n> > >\n> > > I want these changes, as they are great, but can you perhaps provide=\n=20\n> > > patch series for newer kernels first so that I can then take these?\n> >\n> > So you'd first like first to align 6.16 with 6.17, then 6.15 with=20\n> > 6.16, then 6.12 with 6.15, then 6.6 with 6.12, and so on until we=20\n> > eventually align 5.10 and even 5.4?\n>\n> Yes please!\n\nStable 6.16.8 didn't require any changs.\n\nI pulled the changes for 6.12.48:\nhttps://lore.kernel.org/stable/20250922103123.14538-1-farbere@amazon.com/T/=\n#t\nand 6.6.107:\nhttps://lore.kernel.org/stable/20250922103241.16213-1-farbere@amazon.com/T/=\n#t\n\nOnce approved, I'll continue with other longterm branches.\n\n---\nRegards, Eliav\n\n\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
      "normalized_subject": "Warn about \"unsigned value that used to be signed against zero\"",
      "message_count": 8,
      "participants": [
        "Chris Li",
        "Linus Torvalds",
        "Vincent Mailhol"
      ],
      "categories": [
        "general",
        "compiler_compat",
        "sparse_internals"
      ],
      "first_date": "2025-09-21T06:12:30+00:00",
      "last_date": "2025-09-24T17:44:35+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/09/175843510030313.mbox",
          "message_id": "<20250921061337.3047616-1-mailhol () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "[PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-21 06:12:30+00:00",
          "date_str": "Sun, 21 Sep 2025 06:12:30 +0000",
          "body": "Consider this first pattern:\n\n  void error(void);\n  int check(void);\n\n  void foo (void)\n  {\n  \tunsigned int ret;\n\n  \tret = check();\n  \tif (ret < 0)\n  \t\terror();\n  }\n\nHere, the comparison against zero is a tautology: ret, which is\nunsigned, can never be negative. Thus the compiler will remove the\nerror branch causing a bug.\n\nThis pattern is caught by clang and gcc's -Wtype-limits. *However*,\nthat diagnostic has many lost bullets. It will also complain on some\nlegitimate things such as in this second pattern:\n\n  void error(void);\n\n  void bar (unsigned int val)\n  {\n  \tif (val < 0 || val > 42)\n  \t\terror();\n  }\n\nHere, the author just want to do a range check. Yes, the\n\n  val < 0\n\ncomparison is a tautology, but that time, it does not result in faulty\ncode when optimised out by the compiler.\n\nThere is thus a need for a check that will catch the first pattern but\nthat will let the second one go through. The difference between the\ntwo patterns is that in the first one the value returned by the\ncheck() function used to be signed whereas in the second one val was\nalways unsigned to begin with.\n\nAdd a check in sparse to warn if a value which used to be signed gets\nassigned to an unsigned and then gets compared against zero, either\nval < 0 or val >= 0.\n\nAs pointed out by Linus in his original message, a few false positives\nremain, especially when many inline functions and macros get involved,\nbut the level of noise is nothing in comparison to the -Wtype-limits.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nLink: https://lore.kernel.org/all/CAHk-=wjQCbRA1UEag-1-9yn08KNNqerTj++SCbbW80At=rg5RQ@mail.gmail.com/\nSigned-off-by: Vincent Mailhol <mailhol@kernel.org>\n---\nHi Chris,\n\nI saw your email in which you announced your comeback. First of all,\nI wish you a warm welcome back!\n\nSecond, I would like to inaugurate your comeback with this patch. It\nwas posted by Linus in the middle of the huge thread about the Rust\nkernel policy, so I guess it did not catch the attention it\ndeserved. I have been using this locally for the last half year and it\nworks fine.\n\nSo, aside from a minor change as listed in below Changelog, this is\nbasically a resend.\n\nAs for the tags, I tagged Linus as Suggested-by and myself as the\nauthor. Not sure if this is the most appropriate tag, but adding\nLinus's Signed-off tag seems wrong, so this is the best tag I could\nthink of. Let me know if there is any more appropriate tag.\n\nChangelog:\n\nLinus's patch -> v2:\n\n  - Add a patch description\n\n  - Change warning message from\n\n      unsigned value that used to be signed checked for negative?\n\n    to\n\n      unsigned value that used to be signed checked against zero?\n\n    because the check catches both unsigned < 0 and unsigned >= 0\n    tautologies.\n\nLink: https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/sparse.git/commit/?id=46ee49478660\nLink: https://lore.kernel.org/all/CAHk-=wjQCbRA1UEag-1-9yn08KNNqerTj++SCbbW80At=rg5RQ@mail.gmail.com/\n---\n simplify.c | 41 +++++++++++++++++++++++++++++++++++++++--\n 1 file changed, 39 insertions(+), 2 deletions(-)\n\ndiff --git a/simplify.c b/simplify.c\nindex 3c4ace3c..68c5f9c7 100644\n--- a/simplify.c\n+++ b/simplify.c\n@@ -1167,6 +1167,43 @@ static int simplify_seteq_setne(struct instruction *insn, long long value)\n \treturn 0;\n }\n \n+static struct instruction *used_to_be_signed(struct instruction *insn)\n+{\n+\tpseudo_t pseudo = insn->src1;\n+\tstruct instruction *def;\n+\tstruct symbol *sym;\n+\n+\tif (pseudo->type != PSEUDO_REG)\n+\t\treturn NULL;\n+\tdef = pseudo->def;\n+\tif (!def)\n+\t\treturn NULL;\n+\n+\t// Did the value come from a sign-extension?\n+\t// If so, the source was clearly signed\n+\tif (def->opcode == OP_SEXT)\n+\t\treturn def;\n+\n+\t// Or was the op that generated the value signed?\n+\tsym = def->type;\n+\tif (sym && !(sym->ctype.modifiers & MOD_UNSIGNED))\n+\t\treturn def;\n+\n+\treturn NULL;\n+}\n+\n+static int simplify_unsigned_zero_compare(struct instruction *insn, int result)\n+{\n+\tstruct instruction *def = used_to_be_signed(insn);\n+\n+\tif (def) {\n+\t\twarning(insn->pos, \"unsigned value that used to be signed checked against zero?\");\n+\t\tinfo(def->pos, \"signed value source\");\n+\t}\n+\n+\treturn replace_with_pseudo(insn, value_pseudo(result));\n+}\n+\n static int simplify_compare_constant(struct instruction *insn, long long value)\n {\n \tunsigned size = insn->itype->bit_size;\n@@ -1228,7 +1265,7 @@ static int simplify_compare_constant(struct instruction *insn, long long value)\n \n \tcase OP_SET_B:\n \t\tif (!value)\t\t\t// (x < 0) --> 0\n-\t\t\treturn replace_with_pseudo(insn, value_pseudo(0));\n+\t\t\treturn simplify_unsigned_zero_compare(insn, 0);\n \t\tif (value == 1)\t\t\t// (x < 1) --> (x == 0)\n \t\t\treturn replace_binop_value(insn, OP_SET_EQ, 0);\n \t\telse if (value == bits)\t\t// (x < ~0) --> (x != ~0)\n@@ -1238,7 +1275,7 @@ static int simplify_compare_constant(struct instruction *insn, long long value)\n \t\tbreak;\n \tcase OP_SET_AE:\n \t\tif (!value)\t\t\t// (x >= 0) --> 1\n-\t\t\treturn replace_with_pseudo(insn, value_pseudo(1));\n+\t\t\treturn simplify_unsigned_zero_compare(insn,",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175846768210899.mbox",
          "message_id": "<CAHk-=wh2G3LxBZe-8MhNL7g+KS3BHR0z-vKFNaEeV=XQmyEwcQ () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-21 15:16:28+00:00",
          "date_str": "Sun, 21 Sep 2025 15:16:28 +0000",
          "body": "On Sat, 20 Sept 2025 at 23:13, Vincent Mailhol <mailhol@kernel.org> wrote:\n>\n> Add a check in sparse to warn if a value which used to be signed gets\n> assigned to an unsigned and then gets compared against zero, either\n> val < 0 or val >= 0.\n\nAck. I had forgotten about this patch, but I used it for a little bit\nin my private testing, and it seemed to work fairly well.\n\nIt had some false positives too, but the ones I looked at generally\nmade _sense_ to me.\n\nThey weren't always trivial to figure out, though (nor were the\nnon-false positives, for that matter). Because sometimes the signed\nsource was fairly far away from the unsigned use that it complained\nabout.\n\nThat's why I had added that\n\n        info(def->pos, \"signed value source\");\n\npart of the patch: it still didn't always make it entirely obvious,\nbut it helped a lot when the value came in from a mix of macros and\ninline functions, and it was hard to see what the source of the issue\nwas.\n\nEven with that information, it wasn't necessarily easy, but it was eas_ier_.\n\nBut I only used that patch for a couple of days and only looked at a\nfairly small handful of cases overall.\n\nI felt it was *enormously* much better than the insane and completely\n\"-Wtype-limits\" warning was, because that one warns for code that\ncannot sanely be improved (ie the \"fix\" for that warning is typically\nto remove a sane test that might be required in a macro in other\ncontexts or to just disallow some sane types).\n\nPut another way: it looked fine in my testing, and it matched my \"gut\nfeel\" for how things should work.\n\nBut I didn't use it enough to really know for sure and then I forgot\nabout it all.\n\nIf Vincent has been using it for months successfully, I think that's a\ngood sign that it wasn't _just_ my gut feeling.\n\n             Linus\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175854240920120.mbox",
          "message_id": "<CACePvbXRkT7wtc2nUttMVXWw7C5r_zLewj1fWkW=9pjAxagLkg () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-22 12:02:05+00:00",
          "date_str": "Mon, 22 Sep 2025 12:02:05 +0000",
          "body": "On Sat, Sep 20, 2025 at 11:13=E2=80=AFPM Vincent Mailhol <mailhol@kernel.or=\ng> wrote:\n>\n> Consider this first pattern:\n>\n>   void error(void);\n>   int check(void);\n>\n>   void foo (void)\n>   {\n>         unsigned int ret;\n>\n>         ret =3D check();\n>         if (ret < 0)\n>                 error();\n>   }\n>\n> Here, the comparison against zero is a tautology: ret, which is\n> unsigned, can never be negative. Thus the compiler will remove the\n> error branch causing a bug.\n>\n> This pattern is caught by clang and gcc's -Wtype-limits. *However*,\n> that diagnostic has many lost bullets. It will also complain on some\n> legitimate things such as in this second pattern:\n>\n>   void error(void);\n>\n>   void bar (unsigned int val)\n>   {\n>         if (val < 0 || val > 42)\n>                 error();\n>   }\n>\n> Here, the author just want to do a range check. Yes, the\n>\n>   val < 0\n>\n> comparison is a tautology, but that time, it does not result in faulty\n> code when optimised out by the compiler.\n>\n> There is thus a need for a check that will catch the first pattern but\n> that will let the second one go through. The difference between the\n> two patterns is that in the first one the value returned by the\n> check() function used to be signed whereas in the second one val was\n> always unsigned to begin with.\n\nSounds like a bit heuristic but if it helps to reduce the noise level\nthat seems worth it.\n\n>\n> Add a check in sparse to warn if a value which used to be signed gets\n> assigned to an unsigned and then gets compared against zero, either\n> val < 0 or val >=3D 0.\n>\n> As pointed out by Linus in his original message, a few false positives\n> remain, especially when many inline functions and macros get involved,\n> but the level of noise is nothing in comparison to the -Wtype-limits.\n\nCan you please add a few validation checks for  the positive and\nnegative case? You  can add it under the validation directory. With\nvalidation I can quickly catch the behavior change in the future.\n\n>\n> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>\n> Link: https://lore.kernel.org/all/CAHk-=3DwjQCbRA1UEag-1-9yn08KNNqerTj++S=\nCbbW80At=3Drg5RQ@mail.gmail.com/\n> Signed-off-by: Vincent Mailhol <mailhol@kernel.org>\n> ---\n> Hi Chris,\n>\n> I saw your email in which you announced your comeback. First of all,\n> I wish you a warm welcome back!\n>\n> Second, I would like to inaugurate your comeback with this patch. It\n\nThank you. I did apply the patch in my local git branch without any conflic=\nt.\n\nWaiting for your test case.\n\n> was posted by Linus in the middle of the huge thread about the Rust\n> kernel policy, so I guess it did not catch the attention it\n> deserved. I have been using this locally for the last half year and it\n> works fine.\n>\n> So, aside from a minor change as listed in below Changelog, this is\n> basically a resend.\n>\n> As for the tags, I tagged Linus as Suggested-by and myself as the\n> author. Not sure if this is the most appropriate tag, but adding\n> Linus's Signed-off tag seems wrong, so this is the best tag I could\n> think of. Let me know if there is any more appropriate tag.\n\nLooks good otherwise.\n\nChris\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175854292620648.mbox",
          "message_id": "<CACePvbVYFNANx8pi9v85FHMGU3rtN4zOmnqSe-Et=s8ngh0Ltw () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-22 12:10:43+00:00",
          "date_str": "Mon, 22 Sep 2025 12:10:43 +0000",
          "body": "On Sun, Sep 21, 2025 at 8:16=E2=80=AFAM Linus Torvalds\n<torvalds@linux-foundation.org> wrote:\n>\n> On Sat, 20 Sept 2025 at 23:13, Vincent Mailhol <mailhol@kernel.org> wrote=\n:\n> >\n> > Add a check in sparse to warn if a value which used to be signed gets\n> > assigned to an unsigned and then gets compared against zero, either\n> > val < 0 or val >=3D 0.\n>\n> Ack. I had forgotten about this patch, but I used it for a little bit\n> in my private testing, and it seemed to work fairly well.\n>\n> It had some false positives too, but the ones I looked at generally\n> made _sense_ to me.\n\nI think the false positive is kind of unavoidable there. Detecting\nsuch a case can be equivalent to the turing halting problem, which is\nimpossible to have a perfect rule or algrothium.\n\n>\n> They weren't always trivial to figure out, though (nor were the\n> non-false positives, for that matter). Because sometimes the signed\n> source was fairly far away from the unsigned use that it complained\n> about.\n>\n> That's why I had added that\n>\n>         info(def->pos, \"signed value source\");\n\nDo you want such a line in the final patch as well? Seems worth it.\n\n> part of the patch: it still didn't always make it entirely obvious,\n> but it helped a lot when the value came in from a mix of macros and\n> inline functions, and it was hard to see what the source of the issue\n> was.\n>\n> Even with that information, it wasn't necessarily easy, but it was eas_ie=\nr_.\n>\n> But I only used that patch for a couple of days and only looked at a\n> fairly small handful of cases overall.\n>\n> I felt it was *enormously* much better than the insane and completely\n> \"-Wtype-limits\" warning was, because that one warns for code that\n> cannot sanely be improved (ie the \"fix\" for that warning is typically\n> to remove a sane test that might be required in a macro in other\n> contexts or to just disallow some sane types).\n>\n> Put another way: it looked fine in my testing, and it matched my \"gut\n> feel\" for how things should work.\n>\n> But I didn't use it enough to really know for sure and then I forgot\n> about it all.\n>\n> If Vincent has been using it for months successfully, I think that's a\n> good sign that it wasn't _just_ my gut feeling.\n\nYes, I applied in my local git repo smoothly. Just waiting for the\ntest case now.\n\nChris\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175855297128900.mbox",
          "message_id": "<CACePvbWQVBNQAAreW-Mzkp8ircGtV+K=gNk39HmUC0TNDOBCwQ () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-22 14:58:04+00:00",
          "date_str": "Mon, 22 Sep 2025 14:58:04 +0000",
          "body": "On Mon, Sep 22, 2025 at 6:00=E2=80=AFAM Vincent Mailhol <mailhol@kernel.org=\n> wrote:\n>\n> On 22/09/2025 at 21:02, Chris Li wrote:\n>\n> (...)\n>\n> > Can you please add a few validation checks for  the positive and\n> > negative case? You  can add it under the validation directory. With\n> > validation I can quickly catch the behavior change in the future.\n>\n> No problem!\n>\n> Would something like that be OK?\n\nI was thinking \"used-to-be-signed-positive.c\" and\n\"used-to-be-signed-negative.c\".\nMerging them into one file is fine as well.\n\nIf you have other positive and negative test cases, maybe it makes\nsense to have positive and negative as separate files so make things\nobvious. Just one each is fine in one file as well, your call.\n\n> diff --git a/validation/used-to-be-signed.c b/validation/used-to-be-signe=\nd.c\n> new file mode 100644\n> index 00000000..75c0ca38\n> --- /dev/null\n> +++ b/validation/used-to-be-signed.c\n> @@ -0,0 +1,25 @@\n> +void error(void);\n> +int check(void);\n> +\n> +static void foo(unsigned int val)\n> +{\n> +       unsigned int ret;\n> +\n> +       /* Positive test case */\n> +       ret =3D check();\n> +       if (ret < 0)\n> +               error();\n> +\n> +       /* Negative test case */\n> +       if (val < 0 || val > 42)\n> +               error();\n> +}\n> +\n> +/*\n> + * check-name: used-to-be-signed\n> + *\n> + * check-error-start\n> +used-to-be-signed.c:10:19: warning: unsigned value that used to be signe=\nd\n> checked against zero?\n> +used-to-be-signed.c:9:20: signed value source\n> + * check-error-end\n> + */\n>\n> Output:\n>\n>   $ ./test-suite used-to-be-signed.c\n>     TEST    used-to-be-signed (used-to-be-signed.c)\n>   OK: out of 1 tests, 1 passed, 0 failed\n>\n>\n> Also, do you want the test in a separate patch or should I squash with pr=\nevious\n> patch?\n\nIdeally the test is before patch so it can show the before and after\neffect of the protagonist patch, making more test cases pass.\n\nChris\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175869751422158.mbox",
          "message_id": "<CACePvbUKV2rkYLeoQO9bWCon2qFkmKWGuh_NqvTccn=XZz7usw () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-24 07:07:10+00:00",
          "date_str": "Wed, 24 Sep 2025 07:07:10 +0000",
          "body": "On Mon, Sep 22, 2025 at 9:17=E2=80=AFAM Linus Torvalds\n<torvalds@linux-foundation.org> wrote:\n>\n> On Mon, 22 Sept 2025 at 05:10, Chris Li <sparse@chrisli.org> wrote:\n> >\n> > On Sun, Sep 21, 2025 at 8:16=E2=80=AFAM Linus Torvalds\n> > <torvalds@linux-foundation.org> wrote:\n> > >\n> > > That's why I had added that\n> > >\n> > >         info(def->pos, \"signed value source\");\n> >\n> > Do you want such a line in the final patch as well? Seems worth it.\n>\n> Oh, absolutely. Some of the cases it reported were really hard to\n> understand without it.\n>\n> If it ends up being noisy, there could possibly be some heuristic like\n> \"if the source is very close to the use that triggers it, don't bother\n> talking about it\", but that would be a later tweak.\n\nVincent, can you add the above info() line suggested by Linus as\nincremental or full patches?\n\nI will try out the patch folding on sparse-dev.\n\nChris\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175870393727363.mbox",
          "message_id": "<de44070e-e71e-4935-bd59-894b6833dbc5 () kernel ! org>",
          "author_name": "Vincent Mailhol",
          "author_email": "mailhol () kernel ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-24 08:54:26+00:00",
          "date_str": "Wed, 24 Sep 2025 08:54:26 +0000",
          "body": "On 24/09/2025 at 16:07, Chris Li wrote:\n> On Mon, Sep 22, 2025 at 9:17\u202fAM Linus Torvalds\n> <torvalds@linux-foundation.org> wrote:\n>>\n>> On Mon, 22 Sept 2025 at 05:10, Chris Li <sparse@chrisli.org> wrote:\n>>>\n>>> On Sun, Sep 21, 2025 at 8:16\u202fAM Linus Torvalds\n>>> <torvalds@linux-foundation.org> wrote:\n>>>>\n>>>> That's why I had added that\n>>>>\n>>>>         info(def->pos, \"signed value source\");\n>>>\n>>> Do you want such a line in the final patch as well? Seems worth it.\n>>\n>> Oh, absolutely. Some of the cases it reported were really hard to\n>> understand without it.\n>>\n>> If it ends up being noisy, there could possibly be some heuristic like\n>> \"if the source is very close to the use that triggers it, don't bother\n>> talking about it\", but that would be a later tweak.\n> \n> Vincent, can you add the above info() line suggested by Linus as\n> incremental or full patches?\n\nI think that there is a small confusion here. That line is already in the patch\ninside simplify_unsigned_zero_compare(). I think that Linus was just explaining\nwhy he added it in the original patch.\n\n\nYours sincerely,\nVincent Mailhol\n\n",
          "year": "2025",
          "month": "09"
        },
        {
          "filepath": "emails/2025/09/175873575919589.mbox",
          "message_id": "<CACePvbWW0amyEDsNUhsViRwDGpzPNNXX+rQ3PC2527Uj7PJi8A () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] Warn about \"unsigned value that used to be signed against zero\"",
          "date": "2025-09-24 17:44:35+00:00",
          "date_str": "Wed, 24 Sep 2025 17:44:35 +0000",
          "body": "On Wed, Sep 24, 2025 at 1:54=E2=80=AFAM Vincent Mailhol <mailhol@kernel.org=\n> wrote:\n>\n>\n> I think that there is a small confusion here. That line is already in the=\n patch\n> inside simplify_unsigned_zero_compare(). I think that Linus was just expl=\naining\n> why he added it in the original patch.\n\nAh, sorry for my confusion and thanks for the clarification.\n\nIt is all good then.\n\nChris\n",
          "year": "2025",
          "month": "09"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: [PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
      "normalized_subject": "arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
      "message_count": 7,
      "participants": [
        "H. Peter Anvin",
        "Dinh Nguyen"
      ],
      "categories": [
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2025-07-20T06:50:41+00:00",
      "last_date": "2025-07-22T16:40:47+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/07/175299432927265.mbox",
          "message_id": "<20250720065045.2859105-5-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-20 06:50:41+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:41 +0000",
          "body": "Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n\"auto\", and equivalently convert an adjacent cast to the analogous\nform.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n arch/nios2/include/asm/uaccess.h | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/arch/nios2/include/asm/uaccess.h b/arch/nios2/include/asm/uaccess.h\nindex b8299082adbe..6ccc9a232c23 100644\n--- a/arch/nios2/include/asm/uaccess.h\n+++ b/arch/nios2/include/asm/uaccess.h\n@@ -172,15 +172,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define __put_user(x, ptr)\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n-\t__auto_type __pu_ptr = (ptr);\t\t\t\t\t\\\n-\ttypeof(*__pu_ptr) __pu_val = (typeof(*__pu_ptr))(x);\t\t\\\n+\tauto __pu_ptr = (ptr);\t\t\t\t\t\t\\\n+\tauto __pu_val = (typeof(*__pu_ptr))(x);\t\t\t\t\\\n \t__put_user_common(__pu_val, __pu_ptr);\t\t\t\t\\\n })\n \n #define put_user(x, ptr)\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n-\t__auto_type __pu_ptr = (ptr);\t\t\t\t\t\\\n-\ttypeof(*__pu_ptr) __pu_val = (typeof(*__pu_ptr))(x);\t\t\\\n+\tauto __pu_ptr = (ptr);\t\t\t\t\t\t\\\n+\tauto __pu_val = (typeof(*__pu_ptr))(x);\t\t\t\t\\\n \taccess_ok(__pu_ptr, sizeof(*__pu_ptr)) ?\t\t\t\\\n \t\t__put_user_common(__pu_val, __pu_ptr) :\t\t\t\\\n \t\t-EFAULT;\t\t\t\t\t\t\\\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299432327255.mbox",
          "message_id": "<20250720065045.2859105-5-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-20 06:50:41+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:41 +0000",
          "body": "Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n\"auto\", and equivalently convert an adjacent cast to the analogous\nform.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n arch/nios2/include/asm/uaccess.h | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/arch/nios2/include/asm/uaccess.h b/arch/nios2/include/asm/uaccess.h\nindex b8299082adbe..6ccc9a232c23 100644\n--- a/arch/nios2/include/asm/uaccess.h\n+++ b/arch/nios2/include/asm/uaccess.h\n@@ -172,15 +172,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define __put_user(x, ptr)\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n-\t__auto_type __pu_ptr = (ptr);\t\t\t\t\t\\\n-\ttypeof(*__pu_ptr) __pu_val = (typeof(*__pu_ptr))(x);\t\t\\\n+\tauto __pu_ptr = (ptr);\t\t\t\t\t\t\\\n+\tauto __pu_val = (typeof(*__pu_ptr))(x);\t\t\t\t\\\n \t__put_user_common(__pu_val, __pu_ptr);\t\t\t\t\\\n })\n \n #define put_user(x, ptr)\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n-\t__auto_type __pu_ptr = (ptr);\t\t\t\t\t\\\n-\ttypeof(*__pu_ptr) __pu_val = (typeof(*__pu_ptr))(x);\t\t\\\n+\tauto __pu_ptr = (ptr);\t\t\t\t\t\t\\\n+\tauto __pu_val = (typeof(*__pu_ptr))(x);\t\t\t\t\\\n \taccess_ok(__pu_ptr, sizeof(*__pu_ptr)) ?\t\t\t\\\n \t\t__put_user_common(__pu_val, __pu_ptr) :\t\t\t\\\n \t\t-EFAULT;\t\t\t\t\t\t\\\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299434727288.mbox",
          "message_id": "<20250720065045.2859105-5-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-20 06:50:41+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:41 +0000",
          "body": "Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n\"auto\", and equivalently convert an adjacent cast to the analogous\nform.\n\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n arch/nios2/include/asm/uaccess.h | 8 ++++----\n 1 file changed, 4 insertions(+), 4 deletions(-)\n\ndiff --git a/arch/nios2/include/asm/uaccess.h b/arch/nios2/include/asm/uaccess.h\nindex b8299082adbe..6ccc9a232c23 100644\n--- a/arch/nios2/include/asm/uaccess.h\n+++ b/arch/nios2/include/asm/uaccess.h\n@@ -172,15 +172,15 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n #define __put_user(x, ptr)\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n-\t__auto_type __pu_ptr = (ptr);\t\t\t\t\t\\\n-\ttypeof(*__pu_ptr) __pu_val = (typeof(*__pu_ptr))(x);\t\t\\\n+\tauto __pu_ptr = (ptr);\t\t\t\t\t\t\\\n+\tauto __pu_val = (typeof(*__pu_ptr))(x);\t\t\t\t\\\n \t__put_user_common(__pu_val, __pu_ptr);\t\t\t\t\\\n })\n \n #define put_user(x, ptr)\t\t\t\t\t\t\\\n ({\t\t\t\t\t\t\t\t\t\\\n-\t__auto_type __pu_ptr = (ptr);\t\t\t\t\t\\\n-\ttypeof(*__pu_ptr) __pu_val = (typeof(*__pu_ptr))(x);\t\t\\\n+\tauto __pu_ptr = (ptr);\t\t\t\t\t\t\\\n+\tauto __pu_val = (typeof(*__pu_ptr))(x);\t\t\t\t\\\n \taccess_ok(__pu_ptr, sizeof(*__pu_ptr)) ?\t\t\t\\\n \t\t__put_user_common(__pu_val, __pu_ptr) :\t\t\t\\\n \t\t-EFAULT;\t\t\t\t\t\t\\\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175320240802105.mbox",
          "message_id": "<c73d2b1c-5f19-4e03-935c-71f68aa8bca7 () kernel ! org>",
          "author_name": "Dinh Nguyen",
          "author_email": "dinguyen () kernel ! org",
          "subject": "Re: [PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-22 16:40:47+00:00",
          "date_str": "Tue, 22 Jul 2025 16:40:47 +0000",
          "body": "On 7/20/25 01:50, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n> \"auto\", and equivalently convert an adjacent cast to the analogous\n> form.\n> \n> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>\n> Signed-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n> ---\n>   arch/nios2/include/asm/uaccess.h | 8 ++++----\n>   1 file changed, 4 insertions(+), 4 deletions(-)\n> \n\nAcked-by: Dinh Nguyen <dinguyen@kernel.org>\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175320240502099.mbox",
          "message_id": "<c73d2b1c-5f19-4e03-935c-71f68aa8bca7 () kernel ! org>",
          "author_name": "Dinh Nguyen",
          "author_email": "dinguyen () kernel ! org",
          "subject": "Re: [PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-22 16:40:47+00:00",
          "date_str": "Tue, 22 Jul 2025 16:40:47 +0000",
          "body": "On 7/20/25 01:50, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n> \"auto\", and equivalently convert an adjacent cast to the analogous\n> form.\n> \n> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>\n> Signed-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n> ---\n>   arch/nios2/include/asm/uaccess.h | 8 ++++----\n>   1 file changed, 4 insertions(+), 4 deletions(-)\n> \n\nAcked-by: Dinh Nguyen <dinguyen@kernel.org>\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175320239902077.mbox",
          "message_id": "<c73d2b1c-5f19-4e03-935c-71f68aa8bca7 () kernel ! org>",
          "author_name": "Dinh Nguyen",
          "author_email": "dinguyen () kernel ! org",
          "subject": "Re: [PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-22 16:40:47+00:00",
          "date_str": "Tue, 22 Jul 2025 16:40:47 +0000",
          "body": "On 7/20/25 01:50, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n> \"auto\", and equivalently convert an adjacent cast to the analogous\n> form.\n> \n> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>\n> Signed-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n> ---\n>   arch/nios2/include/asm/uaccess.h | 8 ++++----\n>   1 file changed, 4 insertions(+), 4 deletions(-)\n> \n\nAcked-by: Dinh Nguyen <dinguyen@kernel.org>\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175320240902108.mbox",
          "message_id": "<c73d2b1c-5f19-4e03-935c-71f68aa8bca7 () kernel ! org>",
          "author_name": "Dinh Nguyen",
          "author_email": "dinguyen () kernel ! org",
          "subject": "Re: [PATCH v2 4/7] arch/nios2: replace \"__auto_type\" and adjacent equivalent with \"auto\"",
          "date": "2025-07-22 16:40:47+00:00",
          "date_str": "Tue, 22 Jul 2025 16:40:47 +0000",
          "body": "On 7/20/25 01:50, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in arch/nios2/include/asm/uaccess.h with\n> \"auto\", and equivalently convert an adjacent cast to the analogous\n> form.\n> \n> Suggested-by: Linus Torvalds <torvalds@linux-foundation.org>\n> Signed-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n> ---\n>   arch/nios2/include/asm/uaccess.h | 8 ++++----\n>   1 file changed, 4 insertions(+), 4 deletions(-)\n> \n\nAcked-by: Dinh Nguyen <dinguyen@kernel.org>\n\n",
          "year": "2025",
          "month": "07"
        }
      ],
      "primary_category": "type_system"
    },
    {
      "subject": "[PATCH v2 3/7] fs/proc: replace \"__auto_type\" with \"const auto\"",
      "normalized_subject": "fs/proc: replace \"__auto_type\" with \"const auto\"",
      "message_count": 2,
      "participants": [
        "H. Peter Anvin"
      ],
      "categories": [
        "address_space"
      ],
      "first_date": "2025-07-20T06:50:40+00:00",
      "last_date": "2025-07-20T06:58:43+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/07/175299436327307.mbox",
          "message_id": "<20250720065045.2859105-4-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 3/7] fs/proc: replace \"__auto_type\" with \"const auto\"",
          "date": "2025-07-20 06:50:40+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:40 +0000",
          "body": "Replace use of \"__auto_type\" in fs/proc/inode.c with \"const auto\".\n\nSuggested-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\nReviewed-by: Alexey Dobriyan <adobriyan@gmail.com>\n---\n fs/proc/inode.c | 16 ++++++++--------\n 1 file changed, 8 insertions(+), 8 deletions(-)\n\ndiff --git a/fs/proc/inode.c b/fs/proc/inode.c\nindex 3604b616311c..1afa2dd2285b 100644\n--- a/fs/proc/inode.c\n+++ b/fs/proc/inode.c\n@@ -303,7 +303,7 @@ static ssize_t proc_reg_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n \n static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type read = pde->proc_ops->proc_read;\n+\tconst auto read = pde->proc_ops->proc_read;\n \tif (read)\n \t\treturn read(file, buf, count, ppos);\n \treturn -EIO;\n@@ -325,7 +325,7 @@ static ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count,\n \n static ssize_t pde_write(struct proc_dir_entry *pde, struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type write = pde->proc_ops->proc_write;\n+\tauto write = pde->proc_ops->proc_write;\n \tif (write)\n \t\treturn write(file, buf, count, ppos);\n \treturn -EIO;\n@@ -347,7 +347,7 @@ static ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t\n \n static __poll_t pde_poll(struct proc_dir_entry *pde, struct file *file, struct poll_table_struct *pts)\n {\n-\t__auto_type poll = pde->proc_ops->proc_poll;\n+\tauto poll = pde->proc_ops->proc_poll;\n \tif (poll)\n \t\treturn poll(file, pts);\n \treturn DEFAULT_POLLMASK;\n@@ -369,7 +369,7 @@ static __poll_t proc_reg_poll(struct file *file, struct poll_table_struct *pts)\n \n static long pde_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type ioctl = pde->proc_ops->proc_ioctl;\n+\tauto ioctl = pde->proc_ops->proc_ioctl;\n \tif (ioctl)\n \t\treturn ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -392,7 +392,7 @@ static long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigne\n #ifdef CONFIG_COMPAT\n static long pde_compat_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n+\tauto compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n \tif (compat_ioctl)\n \t\treturn compat_ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -414,7 +414,7 @@ static long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned\n \n static int pde_mmap(struct proc_dir_entry *pde, struct file *file, struct vm_area_struct *vma)\n {\n-\t__auto_type mmap = pde->proc_ops->proc_mmap;\n+\tauto mmap = pde->proc_ops->proc_mmap;\n \tif (mmap)\n \t\treturn mmap(file, vma);\n \treturn -EIO;\n@@ -497,7 +497,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)\n \tif (!use_pde(pde))\n \t\treturn -ENOENT;\n \n-\t__auto_type release = pde->proc_ops->proc_release;\n+\tauto release = pde->proc_ops->proc_release;\n \tif (release) {\n \t\tpdeo = kmem_cache_alloc(pde_opener_cache, GFP_KERNEL);\n \t\tif (!pdeo) {\n@@ -534,7 +534,7 @@ static int proc_reg_release(struct inode *inode, struct file *file)\n \tstruct pde_opener *pdeo;\n \n \tif (pde_is_permanent(pde)) {\n-\t\t__auto_type release = pde->proc_ops->proc_release;\n+\t\tauto release = pde->proc_ops->proc_release;\n \t\tif (release) {\n \t\t\treturn release(inode, file);\n \t\t}\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299475627417.mbox",
          "message_id": "<20250720065844.2860000-1-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2.1 3/7] fs/proc: replace \"__auto_type\" with \"const auto\"",
          "date": "2025-07-20 06:58:43+00:00",
          "date_str": "Sun, 20 Jul 2025 06:58:43 +0000",
          "body": "Replace use of \"__auto_type\" in fs/proc/inode.c with \"const auto\".\n\nSuggested-by: Alexey Dobriyan <adobriyan@gmail.com>\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\nReviewed-by: Alexey Dobriyan <adobriyan@gmail.com>\n---\n fs/proc/inode.c | 19 +++++++++----------\n 1 file changed, 9 insertions(+), 10 deletions(-)\n\n[ v2 of this patch was an obvious thinko, this is the correct one ]\n\ndiff --git a/fs/proc/inode.c b/fs/proc/inode.c\nindex 3604b616311c..8b90ab9b9cfc 100644\n--- a/fs/proc/inode.c\n+++ b/fs/proc/inode.c\n@@ -303,7 +303,7 @@ static ssize_t proc_reg_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n \n static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type read = pde->proc_ops->proc_read;\n+\tconst auto read = pde->proc_ops->proc_read;\n \tif (read)\n \t\treturn read(file, buf, count, ppos);\n \treturn -EIO;\n@@ -325,7 +325,7 @@ static ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count,\n \n static ssize_t pde_write(struct proc_dir_entry *pde, struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type write = pde->proc_ops->proc_write;\n+\tconst auto write = pde->proc_ops->proc_write;\n \tif (write)\n \t\treturn write(file, buf, count, ppos);\n \treturn -EIO;\n@@ -347,7 +347,7 @@ static ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t\n \n static __poll_t pde_poll(struct proc_dir_entry *pde, struct file *file, struct poll_table_struct *pts)\n {\n-\t__auto_type poll = pde->proc_ops->proc_poll;\n+\tconst auto poll = pde->proc_ops->proc_poll;\n \tif (poll)\n \t\treturn poll(file, pts);\n \treturn DEFAULT_POLLMASK;\n@@ -369,7 +369,7 @@ static __poll_t proc_reg_poll(struct file *file, struct poll_table_struct *pts)\n \n static long pde_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type ioctl = pde->proc_ops->proc_ioctl;\n+\tconst auto ioctl = pde->proc_ops->proc_ioctl;\n \tif (ioctl)\n \t\treturn ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -392,7 +392,7 @@ static long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigne\n #ifdef CONFIG_COMPAT\n static long pde_compat_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n+\tconst auto compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n \tif (compat_ioctl)\n \t\treturn compat_ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -414,7 +414,7 @@ static long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned\n \n static int pde_mmap(struct proc_dir_entry *pde, struct file *file, struct vm_area_struct *vma)\n {\n-\t__auto_type mmap = pde->proc_ops->proc_mmap;\n+\tconst auto mmap = pde->proc_ops->proc_mmap;\n \tif (mmap)\n \t\treturn mmap(file, vma);\n \treturn -EIO;\n@@ -497,7 +497,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)\n \tif (!use_pde(pde))\n \t\treturn -ENOENT;\n \n-\t__auto_type release = pde->proc_ops->proc_release;\n+\tconst auto release = pde->proc_ops->proc_release;\n \tif (release) {\n \t\tpdeo = kmem_cache_alloc(pde_opener_cache, GFP_KERNEL);\n \t\tif (!pdeo) {\n@@ -534,10 +534,9 @@ static int proc_reg_release(struct inode *inode, struct file *file)\n \tstruct pde_opener *pdeo;\n \n \tif (pde_is_permanent(pde)) {\n-\t\t__auto_type release = pde->proc_ops->proc_release;\n-\t\tif (release) {\n+\t\tconst auto release = pde->proc_ops->proc_release;\n+\t\tif (release)\n \t\t\treturn release(inode, file);\n-\t\t}\n \t\treturn 0;\n \t}\n \n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        }
      ],
      "primary_category": "address_space"
    },
    {
      "subject": "[PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
      "normalized_subject": "selftests/bpf: replace \"__auto_type\" with \"auto\"",
      "message_count": 7,
      "participants": [
        "H. Peter Anvin",
        "Eduard Zingerman"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-07-18T21:32:49+00:00",
      "last_date": "2025-07-21T22:13:07+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/07/175287446621854.mbox",
          "message_id": "<20250718213252.2384177-7-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-18 21:32:49+00:00",
          "date_str": "Fri, 18 Jul 2025 21:32:49 +0000",
          "body": "Replace instances of \"__auto_type\" with \"auto\" in:\n\n\ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n\nThis file does not seem to be including <linux/compiler_types.h>\ndirectly or indirectly, so copy the definition but guard it with\n!defined(auto).\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n tools/testing/selftests/bpf/prog_tests/socket_helpers.h | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\nindex e02cabcc814e..958b65aa29ea 100644\n--- a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n+++ b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n@@ -17,11 +17,16 @@\n #define VMADDR_CID_LOCAL 1\n #endif\n \n+/* include/linux/compiler_types.h */\n+#if __STDC_VERSION__ < 202311L && !defined(auto)\n+# define auto __auto_type\n+#endif\n+\n /* include/linux/cleanup.h */\n #define __get_and_null(p, nullvalue)                                           \\\n \t({                                                                     \\\n-\t\t__auto_type __ptr = &(p);                                      \\\n-\t\t__auto_type __val = *__ptr;                                    \\\n+\t\tauto __ptr = &(p);                                      \\\n+\t\tauto __val = *__ptr;                                    \\\n \t\t*__ptr = nullvalue;                                            \\\n \t\t__val;                                                         \\\n \t})\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299437527316.mbox",
          "message_id": "<20250720065045.2859105-7-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-20 06:50:43+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:43 +0000",
          "body": "Replace instances of \"__auto_type\" with \"auto\" in:\n\n\ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n\nThis file does not seem to be including <linux/compiler_types.h>\ndirectly or indirectly, so copy the definition but guard it with\n!defined(auto).\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n tools/testing/selftests/bpf/prog_tests/socket_helpers.h | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\nindex e02cabcc814e..0d59503a0c73 100644\n--- a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n+++ b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n@@ -17,11 +17,16 @@\n #define VMADDR_CID_LOCAL 1\n #endif\n \n+/* include/linux/compiler_types.h */\n+#if __STDC_VERSION__ < 202311L && !defined(auto)\n+# define auto __auto_type\n+#endif\n+\n /* include/linux/cleanup.h */\n #define __get_and_null(p, nullvalue)                                           \\\n \t({                                                                     \\\n-\t\t__auto_type __ptr = &(p);                                      \\\n-\t\t__auto_type __val = *__ptr;                                    \\\n+\t\tauto __ptr = &(p);\t\t\t\t\t       \\\n+\t\tauto __val = *__ptr;                                           \\\n \t\t*__ptr = nullvalue;                                            \\\n \t\t__val;                                                         \\\n \t})\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299434827289.mbox",
          "message_id": "<20250720065045.2859105-7-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-20 06:50:43+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:43 +0000",
          "body": "Replace instances of \"__auto_type\" with \"auto\" in:\n\n\ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n\nThis file does not seem to be including <linux/compiler_types.h>\ndirectly or indirectly, so copy the definition but guard it with\n!defined(auto).\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n tools/testing/selftests/bpf/prog_tests/socket_helpers.h | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\nindex e02cabcc814e..0d59503a0c73 100644\n--- a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n+++ b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n@@ -17,11 +17,16 @@\n #define VMADDR_CID_LOCAL 1\n #endif\n \n+/* include/linux/compiler_types.h */\n+#if __STDC_VERSION__ < 202311L && !defined(auto)\n+# define auto __auto_type\n+#endif\n+\n /* include/linux/cleanup.h */\n #define __get_and_null(p, nullvalue)                                           \\\n \t({                                                                     \\\n-\t\t__auto_type __ptr = &(p);                                      \\\n-\t\t__auto_type __val = *__ptr;                                    \\\n+\t\tauto __ptr = &(p);\t\t\t\t\t       \\\n+\t\tauto __val = *__ptr;                                           \\\n \t\t*__ptr = nullvalue;                                            \\\n \t\t__val;                                                         \\\n \t})\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299432127245.mbox",
          "message_id": "<20250720065045.2859105-7-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-20 06:50:43+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:43 +0000",
          "body": "Replace instances of \"__auto_type\" with \"auto\" in:\n\n\ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n\nThis file does not seem to be including <linux/compiler_types.h>\ndirectly or indirectly, so copy the definition but guard it with\n!defined(auto).\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n tools/testing/selftests/bpf/prog_tests/socket_helpers.h | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\nindex e02cabcc814e..0d59503a0c73 100644\n--- a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n+++ b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n@@ -17,11 +17,16 @@\n #define VMADDR_CID_LOCAL 1\n #endif\n \n+/* include/linux/compiler_types.h */\n+#if __STDC_VERSION__ < 202311L && !defined(auto)\n+# define auto __auto_type\n+#endif\n+\n /* include/linux/cleanup.h */\n #define __get_and_null(p, nullvalue)                                           \\\n \t({                                                                     \\\n-\t\t__auto_type __ptr = &(p);                                      \\\n-\t\t__auto_type __val = *__ptr;                                    \\\n+\t\tauto __ptr = &(p);\t\t\t\t\t       \\\n+\t\tauto __val = *__ptr;                                           \\\n \t\t*__ptr = nullvalue;                                            \\\n \t\t__val;                                                         \\\n \t})\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175299437827319.mbox",
          "message_id": "<20250720065045.2859105-7-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-20 06:50:43+00:00",
          "date_str": "Sun, 20 Jul 2025 06:50:43 +0000",
          "body": "Replace instances of \"__auto_type\" with \"auto\" in:\n\n\ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n\nThis file does not seem to be including <linux/compiler_types.h>\ndirectly or indirectly, so copy the definition but guard it with\n!defined(auto).\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n tools/testing/selftests/bpf/prog_tests/socket_helpers.h | 9 +++++++--\n 1 file changed, 7 insertions(+), 2 deletions(-)\n\ndiff --git a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\nindex e02cabcc814e..0d59503a0c73 100644\n--- a/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n+++ b/tools/testing/selftests/bpf/prog_tests/socket_helpers.h\n@@ -17,11 +17,16 @@\n #define VMADDR_CID_LOCAL 1\n #endif\n \n+/* include/linux/compiler_types.h */\n+#if __STDC_VERSION__ < 202311L && !defined(auto)\n+# define auto __auto_type\n+#endif\n+\n /* include/linux/cleanup.h */\n #define __get_and_null(p, nullvalue)                                           \\\n \t({                                                                     \\\n-\t\t__auto_type __ptr = &(p);                                      \\\n-\t\t__auto_type __val = *__ptr;                                    \\\n+\t\tauto __ptr = &(p);\t\t\t\t\t       \\\n+\t\tauto __val = *__ptr;                                           \\\n \t\t*__ptr = nullvalue;                                            \\\n \t\t__val;                                                         \\\n \t})\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175313594229230.mbox",
          "message_id": "<0d6e1144567e32bca049e4438395ac16da85124f.camel () gmail ! com>",
          "author_name": "Eduard Zingerman",
          "author_email": "eddyz87 () gmail ! com",
          "subject": "Re: [PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-21 22:13:07+00:00",
          "date_str": "Mon, 21 Jul 2025 22:13:07 +0000",
          "body": "On Sat, 2025-07-19 at 23:50 -0700, H. Peter Anvin wrote:\n> Replace instances of \"__auto_type\" with \"auto\" in:\n>=20\n> \ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n>=20\n> This file does not seem to be including <linux/compiler_types.h>\n> directly or indirectly, so copy the definition but guard it with\n> !defined(auto).\n>=20\n> Signed-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n> ---\n\nAcked-by: Eduard Zingerman <eddyz87@gmail.com>\n\n[...]\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175313594729233.mbox",
          "message_id": "<0d6e1144567e32bca049e4438395ac16da85124f.camel () gmail ! com>",
          "author_name": "Eduard Zingerman",
          "author_email": "eddyz87 () gmail ! com",
          "subject": "Re: [PATCH v2 6/7] selftests/bpf: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-21 22:13:07+00:00",
          "date_str": "Mon, 21 Jul 2025 22:13:07 +0000",
          "body": "On Sat, 2025-07-19 at 23:50 -0700, H. Peter Anvin wrote:\n> Replace instances of \"__auto_type\" with \"auto\" in:\n>=20\n> \ttools/testing/selftests/bpf/prog_tests/socket_helpers.h\n>=20\n> This file does not seem to be including <linux/compiler_types.h>\n> directly or indirectly, so copy the definition but guard it with\n> !defined(auto).\n>=20\n> Signed-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n> ---\n\nAcked-by: Eduard Zingerman <eddyz87@gmail.com>\n\n[...]\n",
          "year": "2025",
          "month": "07"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
      "normalized_subject": "fs/proc: replace \"__auto_type\" with \"auto\"",
      "message_count": 6,
      "participants": [
        "H. Peter Anvin",
        "Alexey Dobriyan"
      ],
      "categories": [
        "address_space"
      ],
      "first_date": "2025-07-18T21:32:46+00:00",
      "last_date": "2025-07-19T14:26:28+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/07/175287445921842.mbox",
          "message_id": "<20250718213252.2384177-4-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-18 21:32:46+00:00",
          "date_str": "Fri, 18 Jul 2025 21:32:46 +0000",
          "body": "Replace uses of \"__auto_type\" in fs/proc/inode.c with \"auto\".\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n fs/proc/inode.c | 16 ++++++++--------\n 1 file changed, 8 insertions(+), 8 deletions(-)\n\ndiff --git a/fs/proc/inode.c b/fs/proc/inode.c\nindex 3604b616311c..e5b150e70166 100644\n--- a/fs/proc/inode.c\n+++ b/fs/proc/inode.c\n@@ -303,7 +303,7 @@ static ssize_t proc_reg_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n \n static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type read = pde->proc_ops->proc_read;\n+\tauto read = pde->proc_ops->proc_read;\n \tif (read)\n \t\treturn read(file, buf, count, ppos);\n \treturn -EIO;\n@@ -325,7 +325,7 @@ static ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count,\n \n static ssize_t pde_write(struct proc_dir_entry *pde, struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type write = pde->proc_ops->proc_write;\n+\tauto write = pde->proc_ops->proc_write;\n \tif (write)\n \t\treturn write(file, buf, count, ppos);\n \treturn -EIO;\n@@ -347,7 +347,7 @@ static ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t\n \n static __poll_t pde_poll(struct proc_dir_entry *pde, struct file *file, struct poll_table_struct *pts)\n {\n-\t__auto_type poll = pde->proc_ops->proc_poll;\n+\tauto poll = pde->proc_ops->proc_poll;\n \tif (poll)\n \t\treturn poll(file, pts);\n \treturn DEFAULT_POLLMASK;\n@@ -369,7 +369,7 @@ static __poll_t proc_reg_poll(struct file *file, struct poll_table_struct *pts)\n \n static long pde_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type ioctl = pde->proc_ops->proc_ioctl;\n+\tauto ioctl = pde->proc_ops->proc_ioctl;\n \tif (ioctl)\n \t\treturn ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -392,7 +392,7 @@ static long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigne\n #ifdef CONFIG_COMPAT\n static long pde_compat_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n+\tauto compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n \tif (compat_ioctl)\n \t\treturn compat_ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -414,7 +414,7 @@ static long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned\n \n static int pde_mmap(struct proc_dir_entry *pde, struct file *file, struct vm_area_struct *vma)\n {\n-\t__auto_type mmap = pde->proc_ops->proc_mmap;\n+\tauto mmap = pde->proc_ops->proc_mmap;\n \tif (mmap)\n \t\treturn mmap(file, vma);\n \treturn -EIO;\n@@ -497,7 +497,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)\n \tif (!use_pde(pde))\n \t\treturn -ENOENT;\n \n-\t__auto_type release = pde->proc_ops->proc_release;\n+\tauto release = pde->proc_ops->proc_release;\n \tif (release) {\n \t\tpdeo = kmem_cache_alloc(pde_opener_cache, GFP_KERNEL);\n \t\tif (!pdeo) {\n@@ -534,7 +534,7 @@ static int proc_reg_release(struct inode *inode, struct file *file)\n \tstruct pde_opener *pdeo;\n \n \tif (pde_is_permanent(pde)) {\n-\t\t__auto_type release = pde->proc_ops->proc_release;\n+\t\tauto release = pde->proc_ops->proc_release;\n \t\tif (release) {\n \t\t\treturn release(inode, file);\n \t\t}\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175287453321927.mbox",
          "message_id": "<20250718213252.2384177-4-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-18 21:32:46+00:00",
          "date_str": "Fri, 18 Jul 2025 21:32:46 +0000",
          "body": "Replace uses of \"__auto_type\" in fs/proc/inode.c with \"auto\".\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n fs/proc/inode.c | 16 ++++++++--------\n 1 file changed, 8 insertions(+), 8 deletions(-)\n\ndiff --git a/fs/proc/inode.c b/fs/proc/inode.c\nindex 3604b616311c..e5b150e70166 100644\n--- a/fs/proc/inode.c\n+++ b/fs/proc/inode.c\n@@ -303,7 +303,7 @@ static ssize_t proc_reg_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n \n static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type read = pde->proc_ops->proc_read;\n+\tauto read = pde->proc_ops->proc_read;\n \tif (read)\n \t\treturn read(file, buf, count, ppos);\n \treturn -EIO;\n@@ -325,7 +325,7 @@ static ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count,\n \n static ssize_t pde_write(struct proc_dir_entry *pde, struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type write = pde->proc_ops->proc_write;\n+\tauto write = pde->proc_ops->proc_write;\n \tif (write)\n \t\treturn write(file, buf, count, ppos);\n \treturn -EIO;\n@@ -347,7 +347,7 @@ static ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t\n \n static __poll_t pde_poll(struct proc_dir_entry *pde, struct file *file, struct poll_table_struct *pts)\n {\n-\t__auto_type poll = pde->proc_ops->proc_poll;\n+\tauto poll = pde->proc_ops->proc_poll;\n \tif (poll)\n \t\treturn poll(file, pts);\n \treturn DEFAULT_POLLMASK;\n@@ -369,7 +369,7 @@ static __poll_t proc_reg_poll(struct file *file, struct poll_table_struct *pts)\n \n static long pde_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type ioctl = pde->proc_ops->proc_ioctl;\n+\tauto ioctl = pde->proc_ops->proc_ioctl;\n \tif (ioctl)\n \t\treturn ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -392,7 +392,7 @@ static long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigne\n #ifdef CONFIG_COMPAT\n static long pde_compat_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n+\tauto compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n \tif (compat_ioctl)\n \t\treturn compat_ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -414,7 +414,7 @@ static long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned\n \n static int pde_mmap(struct proc_dir_entry *pde, struct file *file, struct vm_area_struct *vma)\n {\n-\t__auto_type mmap = pde->proc_ops->proc_mmap;\n+\tauto mmap = pde->proc_ops->proc_mmap;\n \tif (mmap)\n \t\treturn mmap(file, vma);\n \treturn -EIO;\n@@ -497,7 +497,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)\n \tif (!use_pde(pde))\n \t\treturn -ENOENT;\n \n-\t__auto_type release = pde->proc_ops->proc_release;\n+\tauto release = pde->proc_ops->proc_release;\n \tif (release) {\n \t\tpdeo = kmem_cache_alloc(pde_opener_cache, GFP_KERNEL);\n \t\tif (!pdeo) {\n@@ -534,7 +534,7 @@ static int proc_reg_release(struct inode *inode, struct file *file)\n \tstruct pde_opener *pdeo;\n \n \tif (pde_is_permanent(pde)) {\n-\t\t__auto_type release = pde->proc_ops->proc_release;\n+\t\tauto release = pde->proc_ops->proc_release;\n \t\tif (release) {\n \t\t\treturn release(inode, file);\n \t\t}\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175287456921946.mbox",
          "message_id": "<20250718213252.2384177-4-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-18 21:32:46+00:00",
          "date_str": "Fri, 18 Jul 2025 21:32:46 +0000",
          "body": "Replace uses of \"__auto_type\" in fs/proc/inode.c with \"auto\".\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n fs/proc/inode.c | 16 ++++++++--------\n 1 file changed, 8 insertions(+), 8 deletions(-)\n\ndiff --git a/fs/proc/inode.c b/fs/proc/inode.c\nindex 3604b616311c..e5b150e70166 100644\n--- a/fs/proc/inode.c\n+++ b/fs/proc/inode.c\n@@ -303,7 +303,7 @@ static ssize_t proc_reg_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n \n static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type read = pde->proc_ops->proc_read;\n+\tauto read = pde->proc_ops->proc_read;\n \tif (read)\n \t\treturn read(file, buf, count, ppos);\n \treturn -EIO;\n@@ -325,7 +325,7 @@ static ssize_t proc_reg_read(struct file *file, char __user *buf, size_t count,\n \n static ssize_t pde_write(struct proc_dir_entry *pde, struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n {\n-\t__auto_type write = pde->proc_ops->proc_write;\n+\tauto write = pde->proc_ops->proc_write;\n \tif (write)\n \t\treturn write(file, buf, count, ppos);\n \treturn -EIO;\n@@ -347,7 +347,7 @@ static ssize_t proc_reg_write(struct file *file, const char __user *buf, size_t\n \n static __poll_t pde_poll(struct proc_dir_entry *pde, struct file *file, struct poll_table_struct *pts)\n {\n-\t__auto_type poll = pde->proc_ops->proc_poll;\n+\tauto poll = pde->proc_ops->proc_poll;\n \tif (poll)\n \t\treturn poll(file, pts);\n \treturn DEFAULT_POLLMASK;\n@@ -369,7 +369,7 @@ static __poll_t proc_reg_poll(struct file *file, struct poll_table_struct *pts)\n \n static long pde_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type ioctl = pde->proc_ops->proc_ioctl;\n+\tauto ioctl = pde->proc_ops->proc_ioctl;\n \tif (ioctl)\n \t\treturn ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -392,7 +392,7 @@ static long proc_reg_unlocked_ioctl(struct file *file, unsigned int cmd, unsigne\n #ifdef CONFIG_COMPAT\n static long pde_compat_ioctl(struct proc_dir_entry *pde, struct file *file, unsigned int cmd, unsigned long arg)\n {\n-\t__auto_type compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n+\tauto compat_ioctl = pde->proc_ops->proc_compat_ioctl;\n \tif (compat_ioctl)\n \t\treturn compat_ioctl(file, cmd, arg);\n \treturn -ENOTTY;\n@@ -414,7 +414,7 @@ static long proc_reg_compat_ioctl(struct file *file, unsigned int cmd, unsigned\n \n static int pde_mmap(struct proc_dir_entry *pde, struct file *file, struct vm_area_struct *vma)\n {\n-\t__auto_type mmap = pde->proc_ops->proc_mmap;\n+\tauto mmap = pde->proc_ops->proc_mmap;\n \tif (mmap)\n \t\treturn mmap(file, vma);\n \treturn -EIO;\n@@ -497,7 +497,7 @@ static int proc_reg_open(struct inode *inode, struct file *file)\n \tif (!use_pde(pde))\n \t\treturn -ENOENT;\n \n-\t__auto_type release = pde->proc_ops->proc_release;\n+\tauto release = pde->proc_ops->proc_release;\n \tif (release) {\n \t\tpdeo = kmem_cache_alloc(pde_opener_cache, GFP_KERNEL);\n \t\tif (!pdeo) {\n@@ -534,7 +534,7 @@ static int proc_reg_release(struct inode *inode, struct file *file)\n \tstruct pde_opener *pdeo;\n \n \tif (pde_is_permanent(pde)) {\n-\t\t__auto_type release = pde->proc_ops->proc_release;\n+\t\tauto release = pde->proc_ops->proc_release;\n \t\tif (release) {\n \t\t\treturn release(inode, file);\n \t\t}\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175293515008389.mbox",
          "message_id": "<63adc48b-9b81-4f35-9462-0de103474d13 () p183>",
          "author_name": "Alexey Dobriyan",
          "author_email": "adobriyan () gmail ! com",
          "subject": "Re: [PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-19 14:26:28+00:00",
          "date_str": "Sat, 19 Jul 2025 14:26:28 +0000",
          "body": "On Fri, Jul 18, 2025 at 02:32:46PM -0700, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in fs/proc/inode.c with \"auto\".\n\n>  static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n>  {\n> -\t__auto_type read = pde->proc_ops->proc_read;\n> +\tauto read = pde->proc_ops->proc_read;\n\nThanks! I'd prefer \"const auto\" but OK.\n\nReviewed-by: Alexey Dobriyan <adobriyan@gmail.com>\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175293513908382.mbox",
          "message_id": "<63adc48b-9b81-4f35-9462-0de103474d13 () p183>",
          "author_name": "Alexey Dobriyan",
          "author_email": "adobriyan () gmail ! com",
          "subject": "Re: [PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-19 14:26:28+00:00",
          "date_str": "Sat, 19 Jul 2025 14:26:28 +0000",
          "body": "On Fri, Jul 18, 2025 at 02:32:46PM -0700, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in fs/proc/inode.c with \"auto\".\n\n>  static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n>  {\n> -\t__auto_type read = pde->proc_ops->proc_read;\n> +\tauto read = pde->proc_ops->proc_read;\n\nThanks! I'd prefer \"const auto\" but OK.\n\nReviewed-by: Alexey Dobriyan <adobriyan@gmail.com>\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175293514908386.mbox",
          "message_id": "<63adc48b-9b81-4f35-9462-0de103474d13 () p183>",
          "author_name": "Alexey Dobriyan",
          "author_email": "adobriyan () gmail ! com",
          "subject": "Re: [PATCH 3/7] fs/proc: replace \"__auto_type\" with \"auto\"",
          "date": "2025-07-19 14:26:28+00:00",
          "date_str": "Sat, 19 Jul 2025 14:26:28 +0000",
          "body": "On Fri, Jul 18, 2025 at 02:32:46PM -0700, H. Peter Anvin wrote:\n> Replace uses of \"__auto_type\" in fs/proc/inode.c with \"auto\".\n\n>  static ssize_t pde_read(struct proc_dir_entry *pde, struct file *file, char __user *buf, size_t count, loff_t *ppos)\n>  {\n> -\t__auto_type read = pde->proc_ops->proc_read;\n> +\tauto read = pde->proc_ops->proc_read;\n\nThanks! I'd prefer \"const auto\" but OK.\n\nReviewed-by: Alexey Dobriyan <adobriyan@gmail.com>\n",
          "year": "2025",
          "month": "07"
        }
      ],
      "primary_category": "address_space"
    },
    {
      "subject": "[PATCH 1/7] compiler_types.h: add \"auto\" as a macro for \"__auto_type\"",
      "normalized_subject": "compiler_types.h: add \"auto\" as a macro for \"__auto_type\"",
      "message_count": 2,
      "participants": [
        "H. Peter Anvin",
        "Miguel Ojeda"
      ],
      "categories": [
        "rfc_proposals",
        "compiler_compat"
      ],
      "first_date": "2025-07-18T21:32:44+00:00",
      "last_date": "2025-07-20T16:36:01+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/07/175287448521879.mbox",
          "message_id": "<20250718213252.2384177-2-hpa () zytor ! com>",
          "author_name": "H. Peter Anvin",
          "author_email": "hpa () zytor ! com",
          "subject": "[PATCH 1/7] compiler_types.h: add \"auto\" as a macro for \"__auto_type\"",
          "date": "2025-07-18 21:32:44+00:00",
          "date_str": "Fri, 18 Jul 2025 21:32:44 +0000",
          "body": "\"auto\" was defined as a keyword back in the K&R days, but as a storage\ntype specifier.  No one ever used it, since it was and is the default\nstorage type for local variables.\n\nC++11 recycled the keyword to allow a type to be declared based on the\ntype of an initializer.  This was finally adopted into standard C in\nC23.\n\ngcc and clang provide the \"__auto_type\" alias keyword as an extension\nfor pre-C23, however, there is no reason to pollute the bulk of the\nsource base with this temporary keyword; instead define \"auto\" as a\nmacro unless the compiler is running in C23+ mode.\n\nThis macro is added in <linux/compiler_types.h> because that header is\nincluded in some of the tools headers, wheres <linux/compiler.h> is\nnot as it has a bunch of very kernel-specific things in it.\n\nSigned-off-by: H. Peter Anvin (Intel) <hpa@zytor.com>\n---\n include/linux/compiler_types.h | 13 +++++++++++++\n 1 file changed, 13 insertions(+)\n\ndiff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h\nindex 2b77d12e07b2..c8b1ee37934e 100644\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -13,6 +13,19 @@\n \n #ifndef __ASSEMBLY__\n \n+/*\n+ * C23 introduces \"auto\" as a standard way to define type-inferred\n+ * variables, but \"auto\" has been a (useless) keyword even since K&R C,\n+ * so it has always been \"namespace reserved.\"\n+ *\n+ * Until at some future time we require C23 support, we need the gcc\n+ * extension __auto_type, but there is no reason to put that elsewhere\n+ * in the source code.\n+ */\n+#if __STDC_VERSION__ < 202311L\n+# define auto __auto_type\n+#endif\n+\n /*\n  * Skipped when running bindgen due to a libclang issue;\n  * see https://github.com/rust-lang/rust-bindgen/issues/2244.\n-- \n2.50.1\n\n",
          "year": "2025",
          "month": "07"
        },
        {
          "filepath": "emails/2025/07/175302931906258.mbox",
          "message_id": "<CANiq72kE5AznnA81sb5S-KVx3VCef20zcMBfbRUO41g3uAtQ+Q () mail ! gmail ! com>",
          "author_name": "Miguel Ojeda",
          "author_email": "miguel.ojeda.sandonis () gmail ! com",
          "subject": "Re: [PATCH v2 1/7] compiler_types.h: add \"auto\" as a macro for \"__auto_type\"",
          "date": "2025-07-20 16:36:01+00:00",
          "date_str": "Sun, 20 Jul 2025 16:36:01 +0000",
          "body": "On Sun, Jul 20, 2025 at 8:52=E2=80=AFAM H. Peter Anvin <hpa@zytor.com> wrot=\ne:\n>\n> gcc and clang provide the \"__auto_type\" alias keyword as an extension\n> for pre-C23, however, there is no reason to pollute the bulk of the\n> source base with this temporary keyword; instead define \"auto\" as a\n> macro unless the compiler is running in C23+ mode.\n>\n> This macro is added in <linux/compiler_types.h> because that header is\n> included in some of the tools headers, wheres <linux/compiler.h> is\n> not as it has a bunch of very kernel-specific things in it.\n\nSounds good. I guess we could need a workaround if someone happened to\ninvent an attribute which requires using \"auto\" in it, since it is not\nreserved there in C23 AFAIU. So FWIW:\n\nAcked-by: Miguel Ojeda <ojeda@kernel.org>\n\n> + * so it has always been \"namespace reserved.\"\n\nNot sure what this means (could we just say reserved?).\n\nThanks!\n\nRelatedly, there are some proposed, further changes to `auto` for C2y:\n\n    https://www.open-std.org/jtc1/sc22/WG14/www/docs/n3579.htm\n\nCheers,\nMiguel\n",
          "year": "2025",
          "month": "07"
        }
      ],
      "primary_category": "rfc_proposals"
    },
    {
      "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
      "normalized_subject": "kbuild: Switch from -Wvla to -Wvla-larger-than=0",
      "message_count": 16,
      "participants": [
        "Nathan Chancellor",
        "Kees Cook",
        "Christoph Hellwig"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat"
      ],
      "first_date": "2025-04-18T21:32:39+00:00",
      "last_date": "2025-04-21T21:30:41+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/04/174501202918104.mbox",
          "message_id": "<20250418213235.work.532-kees () kernel ! org>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "[PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-18 21:32:39+00:00",
          "date_str": "Fri, 18 Apr 2025 21:32:39 +0000",
          "body": "Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\nFunction parameter VLAs[1] should be usable, but -Wvla will warn for\nthose. For example, this will produce a warning but it is not using a\nstack VLA:\n\n    int something(size_t n, int array[n]) { ...\n\nClang has no way yet to distinguish between the VLA types[2], so\ndepend on GCC for now to keep stack VLAs out of the tree by using GCC's\n-Wvla-larger-than=0 option (though GCC may split -Wvla[3] similarly to\nhow Clang is planning to).\n\nSwitch to -Wvla-larger-than=0 and adjust the two VLA-checking selftests\nto disable the updated option name.\n\nLink: https://en.cppreference.com/w/c/language/array [1]\nLink: https://github.com/llvm/llvm-project/issues/57098 [2]\nLink: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217 [3]\nSigned-off-by: Kees Cook <kees@kernel.org>\n---\nCc: Christoph Hellwig <hch@lst.de>\nCc: Masahiro Yamada <masahiroy@kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Andrey Ryabinin <ryabinin.a.a@gmail.com>\nCc: Alexander Potapenko <glider@google.com>\nCc: Andrey Konovalov <andreyknvl@gmail.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Vincenzo Frascino <vincenzo.frascino@arm.com>\nCc: Nathan Chancellor <nathan@kernel.org>\nCc: Nicolas Schier <nicolas.schier@linux.dev>\nCc: Nick Desaulniers <nick.desaulniers+lkml@gmail.com>\nCc: Bill Wendling <morbo@google.com>\nCc: Justin Stitt <justinstitt@google.com>\nCc: <kasan-dev@googlegroups.com>\nCc: <linux-mm@kvack.org>\nCc: <linux-kbuild@vger.kernel.org>\nCc: <llvm@lists.linux.dev>\n---\n lib/Makefile               | 2 +-\n mm/kasan/Makefile          | 2 +-\n scripts/Makefile.extrawarn | 9 +++++++--\n 3 files changed, 9 insertions(+), 4 deletions(-)\n\ndiff --git a/lib/Makefile b/lib/Makefile\nindex f07b24ce1b3f..37b6e5782ecb 100644\n--- a/lib/Makefile\n+++ b/lib/Makefile\n@@ -71,7 +71,7 @@ CFLAGS_test_bitops.o += -Werror\n obj-$(CONFIG_TEST_SYSCTL) += test_sysctl.o\n obj-$(CONFIG_TEST_IDA) += test_ida.o\n obj-$(CONFIG_TEST_UBSAN) += test_ubsan.o\n-CFLAGS_test_ubsan.o += $(call cc-disable-warning, vla)\n+CFLAGS_test_ubsan.o += $(call cc-option, -Wno-vla-larger-than)\n CFLAGS_test_ubsan.o += $(call cc-disable-warning, unused-but-set-variable)\n UBSAN_SANITIZE_test_ubsan.o := y\n obj-$(CONFIG_TEST_KSTRTOX) += test-kstrtox.o\ndiff --git a/mm/kasan/Makefile b/mm/kasan/Makefile\nindex 1a958e7c8a46..0e326116a70b 100644\n--- a/mm/kasan/Makefile\n+++ b/mm/kasan/Makefile\n@@ -35,7 +35,7 @@ CFLAGS_shadow.o := $(CC_FLAGS_KASAN_RUNTIME)\n CFLAGS_hw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n CFLAGS_sw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n \n-CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-disable-warning, vla)\n+CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-option, -Wno-vla-larger-than)\n ifndef CONFIG_CC_HAS_KASAN_MEMINTRINSIC_PREFIX\n # If compiler instruments memintrinsics by prefixing them with __asan/__hwasan,\n # we need to treat them normally (as builtins), otherwise the compiler won't\ndiff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn\nindex d75897559d18..0229b10c5d81 100644\n--- a/scripts/Makefile.extrawarn\n+++ b/scripts/Makefile.extrawarn\n@@ -45,8 +45,13 @@ endif\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-disable-warning, dangling-pointer)\n \n-# Variable Length Arrays (VLAs) should not be used anywhere in the kernel\n-KBUILD_CFLAGS += -Wvla\n+# Stack Variable Length Arrays (VLAs) must not be used in the kernel.\n+# Function array parameters should, however, be usable, but -Wvla will\n+# warn for those. Clang has no way yet to distinguish between the VLA\n+# types, so depend on GCC for now to keep stack VLAs out of the tree.\n+# https://github.com/llvm/llvm-project/issues/57098\n+# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217\n+KBUILD_CFLAGS += $(call cc-option,-Wvla-larger-than=0)\n \n # disable pointer signed / unsigned warnings in gcc 4.0\n KBUILD_CFLAGS += -Wno-pointer-sign\n-- \n2.34.1\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174501202718098.mbox",
          "message_id": "<20250418213235.work.532-kees () kernel ! org>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "[PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-18 21:32:39+00:00",
          "date_str": "Fri, 18 Apr 2025 21:32:39 +0000",
          "body": "Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\nFunction parameter VLAs[1] should be usable, but -Wvla will warn for\nthose. For example, this will produce a warning but it is not using a\nstack VLA:\n\n    int something(size_t n, int array[n]) { ...\n\nClang has no way yet to distinguish between the VLA types[2], so\ndepend on GCC for now to keep stack VLAs out of the tree by using GCC's\n-Wvla-larger-than=0 option (though GCC may split -Wvla[3] similarly to\nhow Clang is planning to).\n\nSwitch to -Wvla-larger-than=0 and adjust the two VLA-checking selftests\nto disable the updated option name.\n\nLink: https://en.cppreference.com/w/c/language/array [1]\nLink: https://github.com/llvm/llvm-project/issues/57098 [2]\nLink: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217 [3]\nSigned-off-by: Kees Cook <kees@kernel.org>\n---\nCc: Christoph Hellwig <hch@lst.de>\nCc: Masahiro Yamada <masahiroy@kernel.org>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Andrey Ryabinin <ryabinin.a.a@gmail.com>\nCc: Alexander Potapenko <glider@google.com>\nCc: Andrey Konovalov <andreyknvl@gmail.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Vincenzo Frascino <vincenzo.frascino@arm.com>\nCc: Nathan Chancellor <nathan@kernel.org>\nCc: Nicolas Schier <nicolas.schier@linux.dev>\nCc: Nick Desaulniers <nick.desaulniers+lkml@gmail.com>\nCc: Bill Wendling <morbo@google.com>\nCc: Justin Stitt <justinstitt@google.com>\nCc: <kasan-dev@googlegroups.com>\nCc: <linux-mm@kvack.org>\nCc: <linux-kbuild@vger.kernel.org>\nCc: <llvm@lists.linux.dev>\n---\n lib/Makefile               | 2 +-\n mm/kasan/Makefile          | 2 +-\n scripts/Makefile.extrawarn | 9 +++++++--\n 3 files changed, 9 insertions(+), 4 deletions(-)\n\ndiff --git a/lib/Makefile b/lib/Makefile\nindex f07b24ce1b3f..37b6e5782ecb 100644\n--- a/lib/Makefile\n+++ b/lib/Makefile\n@@ -71,7 +71,7 @@ CFLAGS_test_bitops.o += -Werror\n obj-$(CONFIG_TEST_SYSCTL) += test_sysctl.o\n obj-$(CONFIG_TEST_IDA) += test_ida.o\n obj-$(CONFIG_TEST_UBSAN) += test_ubsan.o\n-CFLAGS_test_ubsan.o += $(call cc-disable-warning, vla)\n+CFLAGS_test_ubsan.o += $(call cc-option, -Wno-vla-larger-than)\n CFLAGS_test_ubsan.o += $(call cc-disable-warning, unused-but-set-variable)\n UBSAN_SANITIZE_test_ubsan.o := y\n obj-$(CONFIG_TEST_KSTRTOX) += test-kstrtox.o\ndiff --git a/mm/kasan/Makefile b/mm/kasan/Makefile\nindex 1a958e7c8a46..0e326116a70b 100644\n--- a/mm/kasan/Makefile\n+++ b/mm/kasan/Makefile\n@@ -35,7 +35,7 @@ CFLAGS_shadow.o := $(CC_FLAGS_KASAN_RUNTIME)\n CFLAGS_hw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n CFLAGS_sw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n \n-CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-disable-warning, vla)\n+CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-option, -Wno-vla-larger-than)\n ifndef CONFIG_CC_HAS_KASAN_MEMINTRINSIC_PREFIX\n # If compiler instruments memintrinsics by prefixing them with __asan/__hwasan,\n # we need to treat them normally (as builtins), otherwise the compiler won't\ndiff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn\nindex d75897559d18..0229b10c5d81 100644\n--- a/scripts/Makefile.extrawarn\n+++ b/scripts/Makefile.extrawarn\n@@ -45,8 +45,13 @@ endif\n # These result in bogus false positives\n KBUILD_CFLAGS += $(call cc-disable-warning, dangling-pointer)\n \n-# Variable Length Arrays (VLAs) should not be used anywhere in the kernel\n-KBUILD_CFLAGS += -Wvla\n+# Stack Variable Length Arrays (VLAs) must not be used in the kernel.\n+# Function array parameters should, however, be usable, but -Wvla will\n+# warn for those. Clang has no way yet to distinguish between the VLA\n+# types, so depend on GCC for now to keep stack VLAs out of the tree.\n+# https://github.com/llvm/llvm-project/issues/57098\n+# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217\n+KBUILD_CFLAGS += $(call cc-option,-Wvla-larger-than=0)\n \n # disable pointer signed / unsigned warnings in gcc 4.0\n KBUILD_CFLAGS += -Wno-pointer-sign\n-- \n2.34.1\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174522641913162.mbox",
          "message_id": "<20250421091233.GA21118 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 09:12:33+00:00",
          "date_str": "Mon, 21 Apr 2025 09:12:33 +0000",
          "body": "Looks good:\n\nReviewed-by: Christoph Hellwig <hch@lst.de>\n\nNote that sparse currently also can't cope with VLAs including the\nprototype syntax, which also needs addressing.\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174522642213171.mbox",
          "message_id": "<20250421091233.GA21118 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 09:12:33+00:00",
          "date_str": "Mon, 21 Apr 2025 09:12:33 +0000",
          "body": "Looks good:\n\nReviewed-by: Christoph Hellwig <hch@lst.de>\n\nNote that sparse currently also can't cope with VLAs including the\nprototype syntax, which also needs addressing.\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174522642113168.mbox",
          "message_id": "<20250421091233.GA21118 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 09:12:33+00:00",
          "date_str": "Mon, 21 Apr 2025 09:12:33 +0000",
          "body": "Looks good:\n\nReviewed-by: Christoph Hellwig <hch@lst.de>\n\nNote that sparse currently also can't cope with VLAs including the\nprototype syntax, which also needs addressing.\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525191425715.mbox",
          "message_id": "<20250421161725.GA3253782 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:17:25+00:00",
          "date_str": "Mon, 21 Apr 2025 16:17:25 +0000",
          "body": "On Fri, Apr 18, 2025 at 02:32:39PM -0700, Kees Cook wrote:\n> Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\n> Function parameter VLAs[1] should be usable, but -Wvla will warn for\n> those. For example, this will produce a warning but it is not using a\n> stack VLA:\n> \n>     int something(size_t n, int array[n]) { ...\n> \n> Clang has no way yet to distinguish between the VLA types[2], so\n> depend on GCC for now to keep stack VLAs out of the tree by using GCC's\n> -Wvla-larger-than=0 option (though GCC may split -Wvla[3] similarly to\n> how Clang is planning to).\n> \n> Switch to -Wvla-larger-than=0 and adjust the two VLA-checking selftests\n> to disable the updated option name.\n> \n> Link: https://en.cppreference.com/w/c/language/array [1]\n> Link: https://github.com/llvm/llvm-project/issues/57098 [2]\n> Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217 [3]\n> Signed-off-by: Kees Cook <kees@kernel.org>\n\nReviewed-by: Nathan Chancellor <nathan@kernel.org>\n\n>  lib/Makefile               | 2 +-\n>  mm/kasan/Makefile          | 2 +-\n>  scripts/Makefile.extrawarn | 9 +++++++--\n>  3 files changed, 9 insertions(+), 4 deletions(-)\n> \n> diff --git a/lib/Makefile b/lib/Makefile\n> index f07b24ce1b3f..37b6e5782ecb 100644\n> --- a/lib/Makefile\n> +++ b/lib/Makefile\n> @@ -71,7 +71,7 @@ CFLAGS_test_bitops.o += -Werror\n>  obj-$(CONFIG_TEST_SYSCTL) += test_sysctl.o\n>  obj-$(CONFIG_TEST_IDA) += test_ida.o\n>  obj-$(CONFIG_TEST_UBSAN) += test_ubsan.o\n> -CFLAGS_test_ubsan.o += $(call cc-disable-warning, vla)\n> +CFLAGS_test_ubsan.o += $(call cc-option, -Wno-vla-larger-than)\n>  CFLAGS_test_ubsan.o += $(call cc-disable-warning, unused-but-set-variable)\n>  UBSAN_SANITIZE_test_ubsan.o := y\n>  obj-$(CONFIG_TEST_KSTRTOX) += test-kstrtox.o\n> diff --git a/mm/kasan/Makefile b/mm/kasan/Makefile\n> index 1a958e7c8a46..0e326116a70b 100644\n> --- a/mm/kasan/Makefile\n> +++ b/mm/kasan/Makefile\n> @@ -35,7 +35,7 @@ CFLAGS_shadow.o := $(CC_FLAGS_KASAN_RUNTIME)\n>  CFLAGS_hw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n>  CFLAGS_sw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n>  \n> -CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-disable-warning, vla)\n> +CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-option, -Wno-vla-larger-than)\n>  ifndef CONFIG_CC_HAS_KASAN_MEMINTRINSIC_PREFIX\n>  # If compiler instruments memintrinsics by prefixing them with __asan/__hwasan,\n>  # we need to treat them normally (as builtins), otherwise the compiler won't\n> diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn\n> index d75897559d18..0229b10c5d81 100644\n> --- a/scripts/Makefile.extrawarn\n> +++ b/scripts/Makefile.extrawarn\n> @@ -45,8 +45,13 @@ endif\n>  # These result in bogus false positives\n>  KBUILD_CFLAGS += $(call cc-disable-warning, dangling-pointer)\n>  \n> -# Variable Length Arrays (VLAs) should not be used anywhere in the kernel\n> -KBUILD_CFLAGS += -Wvla\n> +# Stack Variable Length Arrays (VLAs) must not be used in the kernel.\n> +# Function array parameters should, however, be usable, but -Wvla will\n> +# warn for those. Clang has no way yet to distinguish between the VLA\n> +# types, so depend on GCC for now to keep stack VLAs out of the tree.\n> +# https://github.com/llvm/llvm-project/issues/57098\n> +# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217\n> +KBUILD_CFLAGS += $(call cc-option,-Wvla-larger-than=0)\n>  \n>  # disable pointer signed / unsigned warnings in gcc 4.0\n>  KBUILD_CFLAGS += -Wno-pointer-sign\n> -- \n> 2.34.1\n> \n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525191125704.mbox",
          "message_id": "<20250421161725.GA3253782 () ax162>",
          "author_name": "Nathan Chancellor",
          "author_email": "nathan () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:17:25+00:00",
          "date_str": "Mon, 21 Apr 2025 16:17:25 +0000",
          "body": "On Fri, Apr 18, 2025 at 02:32:39PM -0700, Kees Cook wrote:\n> Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\n> Function parameter VLAs[1] should be usable, but -Wvla will warn for\n> those. For example, this will produce a warning but it is not using a\n> stack VLA:\n> \n>     int something(size_t n, int array[n]) { ...\n> \n> Clang has no way yet to distinguish between the VLA types[2], so\n> depend on GCC for now to keep stack VLAs out of the tree by using GCC's\n> -Wvla-larger-than=0 option (though GCC may split -Wvla[3] similarly to\n> how Clang is planning to).\n> \n> Switch to -Wvla-larger-than=0 and adjust the two VLA-checking selftests\n> to disable the updated option name.\n> \n> Link: https://en.cppreference.com/w/c/language/array [1]\n> Link: https://github.com/llvm/llvm-project/issues/57098 [2]\n> Link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217 [3]\n> Signed-off-by: Kees Cook <kees@kernel.org>\n\nReviewed-by: Nathan Chancellor <nathan@kernel.org>\n\n>  lib/Makefile               | 2 +-\n>  mm/kasan/Makefile          | 2 +-\n>  scripts/Makefile.extrawarn | 9 +++++++--\n>  3 files changed, 9 insertions(+), 4 deletions(-)\n> \n> diff --git a/lib/Makefile b/lib/Makefile\n> index f07b24ce1b3f..37b6e5782ecb 100644\n> --- a/lib/Makefile\n> +++ b/lib/Makefile\n> @@ -71,7 +71,7 @@ CFLAGS_test_bitops.o += -Werror\n>  obj-$(CONFIG_TEST_SYSCTL) += test_sysctl.o\n>  obj-$(CONFIG_TEST_IDA) += test_ida.o\n>  obj-$(CONFIG_TEST_UBSAN) += test_ubsan.o\n> -CFLAGS_test_ubsan.o += $(call cc-disable-warning, vla)\n> +CFLAGS_test_ubsan.o += $(call cc-option, -Wno-vla-larger-than)\n>  CFLAGS_test_ubsan.o += $(call cc-disable-warning, unused-but-set-variable)\n>  UBSAN_SANITIZE_test_ubsan.o := y\n>  obj-$(CONFIG_TEST_KSTRTOX) += test-kstrtox.o\n> diff --git a/mm/kasan/Makefile b/mm/kasan/Makefile\n> index 1a958e7c8a46..0e326116a70b 100644\n> --- a/mm/kasan/Makefile\n> +++ b/mm/kasan/Makefile\n> @@ -35,7 +35,7 @@ CFLAGS_shadow.o := $(CC_FLAGS_KASAN_RUNTIME)\n>  CFLAGS_hw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n>  CFLAGS_sw_tags.o := $(CC_FLAGS_KASAN_RUNTIME)\n>  \n> -CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-disable-warning, vla)\n> +CFLAGS_KASAN_TEST := $(CFLAGS_KASAN) $(call cc-option, -Wno-vla-larger-than)\n>  ifndef CONFIG_CC_HAS_KASAN_MEMINTRINSIC_PREFIX\n>  # If compiler instruments memintrinsics by prefixing them with __asan/__hwasan,\n>  # we need to treat them normally (as builtins), otherwise the compiler won't\n> diff --git a/scripts/Makefile.extrawarn b/scripts/Makefile.extrawarn\n> index d75897559d18..0229b10c5d81 100644\n> --- a/scripts/Makefile.extrawarn\n> +++ b/scripts/Makefile.extrawarn\n> @@ -45,8 +45,13 @@ endif\n>  # These result in bogus false positives\n>  KBUILD_CFLAGS += $(call cc-disable-warning, dangling-pointer)\n>  \n> -# Variable Length Arrays (VLAs) should not be used anywhere in the kernel\n> -KBUILD_CFLAGS += -Wvla\n> +# Stack Variable Length Arrays (VLAs) must not be used in the kernel.\n> +# Function array parameters should, however, be usable, but -Wvla will\n> +# warn for those. Clang has no way yet to distinguish between the VLA\n> +# types, so depend on GCC for now to keep stack VLAs out of the tree.\n> +# https://github.com/llvm/llvm-project/issues/57098\n> +# https://gcc.gnu.org/bugzilla/show_bug.cgi?id=98217\n> +KBUILD_CFLAGS += $(call cc-option,-Wvla-larger-than=0)\n>  \n>  # disable pointer signed / unsigned warnings in gcc 4.0\n>  KBUILD_CFLAGS += -Wno-pointer-sign\n> -- \n> 2.34.1\n> \n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525367627137.mbox",
          "message_id": "<202504210940.8B3E06C4F7 () keescook>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:43:06+00:00",
          "date_str": "Mon, 21 Apr 2025 16:43:06 +0000",
          "body": "On Mon, Apr 21, 2025 at 11:12:33AM +0200, Christoph Hellwig wrote:\n> Looks good:\n> \n> Reviewed-by: Christoph Hellwig <hch@lst.de>\n> \n> Note that sparse currently also can't cope with VLAs including the\n> prototype syntax, which also needs addressing.\n\nHm, it looks like it's been over a year since a commit to the sparse\ngit.\n\nLuc, are function prototypes with VLAs likely to be supported by sparse\nsoon?\n\n-- \nKees Cook\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525344926956.mbox",
          "message_id": "<202504210940.8B3E06C4F7 () keescook>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:43:06+00:00",
          "date_str": "Mon, 21 Apr 2025 16:43:06 +0000",
          "body": "On Mon, Apr 21, 2025 at 11:12:33AM +0200, Christoph Hellwig wrote:\n> Looks good:\n> \n> Reviewed-by: Christoph Hellwig <hch@lst.de>\n> \n> Note that sparse currently also can't cope with VLAs including the\n> prototype syntax, which also needs addressing.\n\nHm, it looks like it's been over a year since a commit to the sparse\ngit.\n\nLuc, are function prototypes with VLAs likely to be supported by sparse\nsoon?\n\n-- \nKees Cook\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525367727142.mbox",
          "message_id": "<202504210940.8B3E06C4F7 () keescook>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:43:06+00:00",
          "date_str": "Mon, 21 Apr 2025 16:43:06 +0000",
          "body": "On Mon, Apr 21, 2025 at 11:12:33AM +0200, Christoph Hellwig wrote:\n> Looks good:\n> \n> Reviewed-by: Christoph Hellwig <hch@lst.de>\n> \n> Note that sparse currently also can't cope with VLAs including the\n> prototype syntax, which also needs addressing.\n\nHm, it looks like it's been over a year since a commit to the sparse\ngit.\n\nLuc, are function prototypes with VLAs likely to be supported by sparse\nsoon?\n\n-- \nKees Cook\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525369827165.mbox",
          "message_id": "<202504210940.8B3E06C4F7 () keescook>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:43:06+00:00",
          "date_str": "Mon, 21 Apr 2025 16:43:06 +0000",
          "body": "On Mon, Apr 21, 2025 at 11:12:33AM +0200, Christoph Hellwig wrote:\n> Looks good:\n> \n> Reviewed-by: Christoph Hellwig <hch@lst.de>\n> \n> Note that sparse currently also can't cope with VLAs including the\n> prototype syntax, which also needs addressing.\n\nHm, it looks like it's been over a year since a commit to the sparse\ngit.\n\nLuc, are function prototypes with VLAs likely to be supported by sparse\nsoon?\n\n-- \nKees Cook\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174525374127217.mbox",
          "message_id": "<202504210940.8B3E06C4F7 () keescook>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 16:43:06+00:00",
          "date_str": "Mon, 21 Apr 2025 16:43:06 +0000",
          "body": "On Mon, Apr 21, 2025 at 11:12:33AM +0200, Christoph Hellwig wrote:\n> Looks good:\n> \n> Reviewed-by: Christoph Hellwig <hch@lst.de>\n> \n> Note that sparse currently also can't cope with VLAs including the\n> prototype syntax, which also needs addressing.\n\nHm, it looks like it's been over a year since a commit to the sparse\ngit.\n\nLuc, are function prototypes with VLAs likely to be supported by sparse\nsoon?\n\n-- \nKees Cook\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174527071403737.mbox",
          "message_id": "<174527103909.545282.5440977919378383304.b4-ty () kernel ! org>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 21:30:41+00:00",
          "date_str": "Mon, 21 Apr 2025 21:30:41 +0000",
          "body": "On Fri, 18 Apr 2025 14:32:39 -0700, Kees Cook wrote:\n> Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\n> Function parameter VLAs[1] should be usable, but -Wvla will warn for\n> those. For example, this will produce a warning but it is not using a\n> stack VLA:\n> \n>     int something(size_t n, int array[n]) { ...\n> \n> [...]\n\nApplied to for-next/hardening, thanks!\n\n[1/1] kbuild: Switch from -Wvla to -Wvla-larger-than=0\n      https://git.kernel.org/kees/c/9c2cfa10444c\n\nTake care,\n\n-- \nKees Cook\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174527071403736.mbox",
          "message_id": "<174527103909.545282.5440977919378383304.b4-ty () kernel ! org>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 21:30:41+00:00",
          "date_str": "Mon, 21 Apr 2025 21:30:41 +0000",
          "body": "On Fri, 18 Apr 2025 14:32:39 -0700, Kees Cook wrote:\n> Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\n> Function parameter VLAs[1] should be usable, but -Wvla will warn for\n> those. For example, this will produce a warning but it is not using a\n> stack VLA:\n> \n>     int something(size_t n, int array[n]) { ...\n> \n> [...]\n\nApplied to for-next/hardening, thanks!\n\n[1/1] kbuild: Switch from -Wvla to -Wvla-larger-than=0\n      https://git.kernel.org/kees/c/9c2cfa10444c\n\nTake care,\n\n-- \nKees Cook\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174527070903722.mbox",
          "message_id": "<174527103909.545282.5440977919378383304.b4-ty () kernel ! org>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 21:30:41+00:00",
          "date_str": "Mon, 21 Apr 2025 21:30:41 +0000",
          "body": "On Fri, 18 Apr 2025 14:32:39 -0700, Kees Cook wrote:\n> Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\n> Function parameter VLAs[1] should be usable, but -Wvla will warn for\n> those. For example, this will produce a warning but it is not using a\n> stack VLA:\n> \n>     int something(size_t n, int array[n]) { ...\n> \n> [...]\n\nApplied to for-next/hardening, thanks!\n\n[1/1] kbuild: Switch from -Wvla to -Wvla-larger-than=0\n      https://git.kernel.org/kees/c/9c2cfa10444c\n\nTake care,\n\n-- \nKees Cook\n\n",
          "year": "2025",
          "month": "04"
        },
        {
          "filepath": "emails/2025/04/174527071603738.mbox",
          "message_id": "<174527103909.545282.5440977919378383304.b4-ty () kernel ! org>",
          "author_name": "Kees Cook",
          "author_email": "kees () kernel ! org",
          "subject": "Re: [PATCH] kbuild: Switch from -Wvla to -Wvla-larger-than=0",
          "date": "2025-04-21 21:30:41+00:00",
          "date_str": "Mon, 21 Apr 2025 21:30:41 +0000",
          "body": "On Fri, 18 Apr 2025 14:32:39 -0700, Kees Cook wrote:\n> Variable Length Arrays (VLAs) on the stack must not be used in the kernel.\n> Function parameter VLAs[1] should be usable, but -Wvla will warn for\n> those. For example, this will produce a warning but it is not using a\n> stack VLA:\n> \n>     int something(size_t n, int array[n]) { ...\n> \n> [...]\n\nApplied to for-next/hardening, thanks!\n\n[1/1] kbuild: Switch from -Wvla to -Wvla-larger-than=0\n      https://git.kernel.org/kees/c/9c2cfa10444c\n\nTake care,\n\n-- \nKees Cook\n\n",
          "year": "2025",
          "month": "04"
        }
      ],
      "primary_category": "kernel_integration"
    },
    {
      "subject": "Re: Issue with Setting Up Sparse",
      "normalized_subject": "Issue with Setting Up Sparse",
      "message_count": 1,
      "participants": [
        "Dan Carpenter"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2025-03-12T15:11:48+00:00",
      "last_date": "2025-03-12T15:11:48+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/03/174179202218144.mbox",
          "message_id": "<aa5d1aa2-1d27-468c-b9b5-38fee37d1179 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: Issue with Setting Up Sparse",
          "date": "2025-03-12 15:11:48+00:00",
          "date_str": "Wed, 12 Mar 2025 15:11:48 +0000",
          "body": "On Wed, Mar 12, 2025 at 06:04:02PM +0400, Edgar Khachatryan wrote:\n> My name is Edgar Khachatryan, and I am a student currently working on a\n> project that involves static analysis using Sparse. I have encountered an\n> issue where running Sparse with the command \"sparse file.c\" does not detect\n> simple memory issues such as memory leaks, double frees, or use-after-free\n> errors in a single file.\n\nSparse doesn't look for those kinds of bugs.  You're better off using\nSmatch for that.\n\nWith Smatch, I've never really looked for memory leaks.  It's quite a\nhard problem and I've never been able to do it in a useful way without\nintroducing a lot of false positives.\n\n$ ./smatch test.c\ntest.c:4:18: warning: non-ANSI function declaration of function 'memory_leak'\ntest.c:13:18: warning: non-ANSI function declaration of function 'double_free'\ntest.c:23:21: warning: non-ANSI function declaration of function 'use_after_free'\ntest.c:33:10: warning: non-ANSI function declaration of function 'main'\ntest.c:20 double_free() error: double free of 'ptr'\ntest.c:30 use_after_free() error: dereferencing freed memory 'ptr'\n$\n\nBut the other problem with Smatch is that it's only ever really used on\nthe kernel so user space support is proof of concept quality.  I had to\npush a quick patch it to make it find the use after free bug.  I use\na different check for check_free_strict.c module for kernel code.\nhttps://github.com/error27/smatch/commit/993d157ab147720b558f0f6293dd4acfeb0d2a18\n\nregards,\ndan carpenter\n",
          "year": "2025",
          "month": "03"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH net-next v2] af_unix: Fix undefined 'other' error",
      "normalized_subject": "af_unix: Fix undefined 'other' error",
      "message_count": 1,
      "participants": [
        "Purva Yeshi"
      ],
      "categories": [
        "kernel_integration",
        "sparse_internals"
      ],
      "first_date": "2025-02-18T13:49:01+00:00",
      "last_date": "2025-02-18T13:49:01+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/02/173988596818210.mbox",
          "message_id": "<0dcf0f9d-6ced-4fdd-9dc0-083ff161354f () gmail ! com>",
          "author_name": "Purva Yeshi",
          "author_email": "purvayeshi550 () gmail ! com",
          "subject": "Re: [PATCH net-next v2] af_unix: Fix undefined 'other' error",
          "date": "2025-02-18 13:49:01+00:00",
          "date_str": "Tue, 18 Feb 2025 13:49:01 +0000",
          "body": "On 18/02/25 18:51, Simon Horman wrote:\n> On Mon, Feb 17, 2025 at 05:14:14PM +0300, Dan Carpenter wrote:\n>> On Mon, Feb 17, 2025 at 11:15:15AM +0000, Simon Horman wrote:\n>>> So, hypothetically, Smatch could be enhanced and there wouldn't be any\n>>> locking warnings with this patch applied?\n>>\n>> Heh.  No.  What I meant to say was that none of this has anything to do\n>> with Smatch.  This is all Sparse stuff.  But also I see now that my email\n>> was wrong...\n>>\n>> What happened is that we changed unix_sk() and that meant Sparse couldn't\n>> parse the annotations and prints \"error: undefined identifier 'other'\".\n>> The error disables Sparse checking for the file.\n>>\n>> When we fix the error then the checking is enabled again.  The v1 patch\n>> which changes the annotation is better than the v2 patch because then\n>> it's 9 warnings vs 11 warnings.\n>>\n>> The warnings are all false positives.  All old warnings are false\n>> positives.  And again, these are all Sparse warnings, not Smatch.  Smatch\n>> doesn't care about annotations.  Smatch has different bugs completely.\n>> ;)\n> \n> Thanks for clarifying :)\n> \n> Based on the above I'd advocate accepting the code changes in v2 [*].\n> And live with the warnings.\n> \n> Which I think is to say that Iwashima-san was right all along.\n> \n> Reviewed-by: Simon Horman <horms@kernel.org>\n> \n> [*] Purva, please post a v3 that updates the commit message as per\n>      Jakub's request elsewhere in this thread:\n>      https://lore.kernel.org/all/20250212104845.2396abcf@kernel.org/\n> \n\nThanks for the review and clarification! I'll prepare v3 with no \ntrailing double spaces and a more detailed description.\n\nBest regards,\nPurva\n",
          "year": "2025",
          "month": "02"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
      "normalized_subject": "[geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
      "message_count": 8,
      "participants": [
        "kernel test robot",
        "Geert Uytterhoeven",
        "Linus Torvalds"
      ],
      "categories": [
        "kernel_integration",
        "sparse_internals",
        "type_system",
        "compiler_compat",
        "rfc_proposals"
      ],
      "first_date": "2025-01-01T07:06:55+00:00",
      "last_date": "2025-01-08T18:10:48+00:00",
      "year": 2025,
      "messages": [
        {
          "filepath": "emails/2025/01/173571501818380.mbox",
          "message_id": "<202501011517.5edVb87Z-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "[geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-01 07:06:55+00:00",
          "date_str": "Wed, 01 Jan 2025 07:06:55 +0000",
          "body": "Hi Greg,\n\nFirst bad commit (maybe != root cause):\n\ntree:   https://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k.git master\nhead:   17810b1de0e9e5c1000cf8f5b4787ad930b0353e\ncommit: e96424b86d5098f44279399b85551e0f84a1c9e9 [2/2] m68k: Use kernel's generic muldi3 libgcc function\nconfig: m68k-randconfig-r122-20250101 (https://download.01.org/0day-ci/archive/20250101/202501011517.5edVb87Z-lkp@intel.com/config)\ncompiler: m68k-linux-gcc (GCC) 14.2.0\nreproduce: (https://download.01.org/0day-ci/archive/20250101/202501011517.5edVb87Z-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202501011517.5edVb87Z-lkp@intel.com/\n\nsparse warnings: (new ones prefixed by >>)\n>> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n>> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n>> lib/muldi3.c:53:28: sparse: sparse: not addressable\n>> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (11)\n>> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (11)\n\nvim +53 lib/muldi3.c\n\nb35cd9884fa5d8 Palmer Dabbelt 2017-05-23  48  \nb35cd9884fa5d8 Palmer Dabbelt 2017-05-23  49  long long notrace __muldi3(long long u, long long v)\nb35cd9884fa5d8 Palmer Dabbelt 2017-05-23  50  {\nb35cd9884fa5d8 Palmer Dabbelt 2017-05-23  51  \tconst DWunion uu = {.ll = u};\nb35cd9884fa5d8 Palmer Dabbelt 2017-05-23  52  \tconst DWunion vv = {.ll = v};\nb35cd9884fa5d8 Palmer Dabbelt 2017-05-23 @53  \tDWunion w = {.ll = __umulsidi3(uu.s.low, vv.s.low)};\n\n:::::: The code at line 53 was first introduced by commit\n:::::: b35cd9884fa5d81c9d5e7f57c9d03264ae2bd835 lib: Add shared copies of some GCC library routines\n\n:::::: TO: Palmer Dabbelt <palmer@dabbelt.com>\n:::::: CC: Palmer Dabbelt <palmer@dabbelt.com>\n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n\n\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173585380500890.mbox",
          "message_id": "<202501030516.uZrwnuQQ-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "[geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-02 21:39:36+00:00",
          "date_str": "Thu, 02 Jan 2025 21:39:36 +0000",
          "body": "Hi Greg,\n\nFirst bad commit (maybe != root cause):\n\ntree:   https://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k.git master\nhead:   17810b1de0e9e5c1000cf8f5b4787ad930b0353e\ncommit: e96424b86d5098f44279399b85551e0f84a1c9e9 [2/2] m68k: Use kernel's generic muldi3 libgcc function\nconfig: m68k-randconfig-r122-20250101 (https://download.01.org/0day-ci/archive/20250103/202501030516.uZrwnuQQ-lkp@intel.com/config)\ncompiler: m68k-linux-gcc (GCC) 14.2.0\nreproduce: (https://download.01.org/0day-ci/archive/20250103/202501030516.uZrwnuQQ-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202501030516.uZrwnuQQ-lkp@intel.com/\n\nsparse warnings: (new ones prefixed by >>)\n>> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n>> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n>> lib/muldi3.c:53:28: sparse: sparse: not addressable\n>> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (11)\n>> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (11)\n\nvim +53 lib/muldi3.c\n\nb35cd9884fa5d81 Palmer Dabbelt 2017-05-23  48  \nb35cd9884fa5d81 Palmer Dabbelt 2017-05-23  49  long long notrace __muldi3(long long u, long long v)\nb35cd9884fa5d81 Palmer Dabbelt 2017-05-23  50  {\nb35cd9884fa5d81 Palmer Dabbelt 2017-05-23  51  \tconst DWunion uu = {.ll = u};\nb35cd9884fa5d81 Palmer Dabbelt 2017-05-23  52  \tconst DWunion vv = {.ll = v};\nb35cd9884fa5d81 Palmer Dabbelt 2017-05-23 @53  \tDWunion w = {.ll = __umulsidi3(uu.s.low, vv.s.low)};\n\n:::::: The code at line 53 was first introduced by commit\n:::::: b35cd9884fa5d81c9d5e7f57c9d03264ae2bd835 lib: Add shared copies of some GCC library routines\n\n:::::: TO: Palmer Dabbelt <palmer@dabbelt.com>\n:::::: CC: Palmer Dabbelt <palmer@dabbelt.com>\n\n-- \n0-DAY CI Kernel Test Service\nhttps://github.com/intel/lkp-tests/wiki\n\n\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173589594216952.mbox",
          "message_id": "<CAMuHMdW-DYPp_2nAaBdvgoa6Yr9et2cNS_260H-9H_CT4yEasw () mail ! gmail ! com>",
          "author_name": "Geert Uytterhoeven",
          "author_email": "geert () linux-m68k ! org",
          "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-03 09:21:25+00:00",
          "date_str": "Fri, 03 Jan 2025 09:21:25 +0000",
          "body": "Hi Kernel test robot,\n\nCC linux-sparse\n\nOn Thu, Jan 2, 2025 at 10:40=E2=80=AFPM kernel test robot <lkp@intel.com> w=\nrote:\n> First bad commit (maybe !=3D root cause):\n>\n> tree:   https://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k.=\ngit master\n> head:   17810b1de0e9e5c1000cf8f5b4787ad930b0353e\n> commit: e96424b86d5098f44279399b85551e0f84a1c9e9 [2/2] m68k: Use kernel's=\n generic muldi3 libgcc function\n> config: m68k-randconfig-r122-20250101 (https://download.01.org/0day-ci/ar=\nchive/20250103/202501030516.uZrwnuQQ-lkp@intel.com/config)\n> compiler: m68k-linux-gcc (GCC) 14.2.0\n> reproduce: (https://download.01.org/0day-ci/archive/20250103/202501030516=\n.uZrwnuQQ-lkp@intel.com/reproduce)\n>\n> If you fix the issue in a separate patch/commit (i.e. not just a new vers=\nion of\n> the same patch/commit), kindly add following tags\n> | Reported-by: kernel test robot <lkp@intel.com>\n> | Closes: https://lore.kernel.org/oe-kbuild-all/202501030516.uZrwnuQQ-lkp=\n@intel.com/\n>\n> sparse warnings: (new ones prefixed by >>)\n> >> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n> >> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n> >> lib/muldi3.c:53:28: sparse: sparse: not addressable\n> >> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (=\n11)\n> >> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (=\n11)\n>\n> vim +53 lib/muldi3.c\n>\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  48\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  49  long long notrace __muldi3=\n(long long u, long long v)\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  50  {\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  51   const DWunion uu =3D {.ll=\n =3D u};\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  52   const DWunion vv =3D {.ll=\n =3D v};\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23 @53   DWunion w =3D {.ll =3D __=\numulsidi3(uu.s.low, vv.s.low)};\n>\n> :::::: The code at line 53 was first introduced by commit\n> :::::: b35cd9884fa5d81c9d5e7f57c9d03264ae2bd835 lib: Add shared copies of=\n some GCC library routines\n\nThanks for the report!\n\nComparing m68k to the other two architectures that use\nGENERIC_LIB_MULDI3 (csky and xtensa), and to microblaze (which has\nits own arch/microblaze/lib/muldi3.c), that don't trigger this error,\nthe difference is that m68k uses inline assembler in its umul_ppmm()\nimplementation. I don't see anything that's wrong with it, though.\n\nPerhaps this is an issue with sparse?\n\nGr{oetje,eeting}s,\n\n                        Geert\n\n--=20\nGeert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k=\n.org\n\nIn personal conversations with technical people, I call myself a hacker. Bu=\nt\nwhen I'm talking to journalists I just say \"programmer\" or something like t=\nhat.\n                                -- Linus Torvalds\n\n\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173589595816975.mbox",
          "message_id": "<CAMuHMdW-DYPp_2nAaBdvgoa6Yr9et2cNS_260H-9H_CT4yEasw () mail ! gmail ! com>",
          "author_name": "Geert Uytterhoeven",
          "author_email": "geert () linux-m68k ! org",
          "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-03 09:21:25+00:00",
          "date_str": "Fri, 03 Jan 2025 09:21:25 +0000",
          "body": "Hi Kernel test robot,\n\nCC linux-sparse\n\nOn Thu, Jan 2, 2025 at 10:40=E2=80=AFPM kernel test robot <lkp@intel.com> w=\nrote:\n> First bad commit (maybe !=3D root cause):\n>\n> tree:   https://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k.=\ngit master\n> head:   17810b1de0e9e5c1000cf8f5b4787ad930b0353e\n> commit: e96424b86d5098f44279399b85551e0f84a1c9e9 [2/2] m68k: Use kernel's=\n generic muldi3 libgcc function\n> config: m68k-randconfig-r122-20250101 (https://download.01.org/0day-ci/ar=\nchive/20250103/202501030516.uZrwnuQQ-lkp@intel.com/config)\n> compiler: m68k-linux-gcc (GCC) 14.2.0\n> reproduce: (https://download.01.org/0day-ci/archive/20250103/202501030516=\n.uZrwnuQQ-lkp@intel.com/reproduce)\n>\n> If you fix the issue in a separate patch/commit (i.e. not just a new vers=\nion of\n> the same patch/commit), kindly add following tags\n> | Reported-by: kernel test robot <lkp@intel.com>\n> | Closes: https://lore.kernel.org/oe-kbuild-all/202501030516.uZrwnuQQ-lkp=\n@intel.com/\n>\n> sparse warnings: (new ones prefixed by >>)\n> >> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n> >> lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue\n> >> lib/muldi3.c:53:28: sparse: sparse: not addressable\n> >> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (=\n11)\n> >> lib/muldi3.c:53:28: sparse: sparse: generating address of non-lvalue (=\n11)\n>\n> vim +53 lib/muldi3.c\n>\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  48\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  49  long long notrace __muldi3=\n(long long u, long long v)\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  50  {\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  51   const DWunion uu =3D {.ll=\n =3D u};\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23  52   const DWunion vv =3D {.ll=\n =3D v};\n> b35cd9884fa5d81 Palmer Dabbelt 2017-05-23 @53   DWunion w =3D {.ll =3D __=\numulsidi3(uu.s.low, vv.s.low)};\n>\n> :::::: The code at line 53 was first introduced by commit\n> :::::: b35cd9884fa5d81c9d5e7f57c9d03264ae2bd835 lib: Add shared copies of=\n some GCC library routines\n\nThanks for the report!\n\nComparing m68k to the other two architectures that use\nGENERIC_LIB_MULDI3 (csky and xtensa), and to microblaze (which has\nits own arch/microblaze/lib/muldi3.c), that don't trigger this error,\nthe difference is that m68k uses inline assembler in its umul_ppmm()\nimplementation. I don't see anything that's wrong with it, though.\n\nPerhaps this is an issue with sparse?\n\nGr{oetje,eeting}s,\n\n                        Geert\n\n--=20\nGeert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k=\n.org\n\nIn personal conversations with technical people, I call myself a hacker. Bu=\nt\nwhen I'm talking to journalists I just say \"programmer\" or something like t=\nhat.\n                                -- Linus Torvalds\n\n\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173611367727386.mbox",
          "message_id": "<CAHk-=wj4tYCytRshQGkWSNmZS=59PtKEUpG7f4Sy_46n+WYtXw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-05 21:51:21+00:00",
          "date_str": "Sun, 05 Jan 2025 21:51:21 +0000",
          "body": "On Fri, 3 Jan 2025 at 01:22, Geert Uytterhoeven <geert@linux-m68k.org> wrote:\n>\n> Perhaps this is an issue with sparse?\n\nNo, this is just m68k doing disgusting things that happen to work with\ngcc, because gcc considers casts to be lvalues (which in turn is comes\nfrom some horrid C++ thing, since in C++ casting is a whole magical\nextra complexity).\n\nIOW, this m68k pattern is horrendous, and sparse quite reasonably\ncomplains about it:\n\n  #define umul_ppmm(w1, w0, u, v) \\\n    __asm__ (\"mulu%.l %3,%1:%0\"                                           \\\n             : \"=d\" ((USItype)(w0)),                                      \\\n               \"=d\" ((USItype)(w1))                                       \\\n             : \"%0\" ((USItype)(u)),                                       \\\n               \"dmi\" ((USItype)(v)))\n\nnotice how it has two register outputs (the \"=d\"), and the destination\nof said output is not a proper lvalue, but a cast expression.\n\nI think you could just remove the cast. Afaik the w0/w1 arguments come from\n\n#define __umulsidi3(u, v) \\\n  ({DIunion __w;                                                        \\\n    umul_ppmm (__w.s.high, __w.s.low, u, v);                            \\\n    __w.ll; })\n\nand __w.s.high and __w.s.low are from struct DIstruct, which uses\n\"SItype\". So all the cast does is to change the signedness of the\nvariable, but that has no *meaning* when you assign to it and the\nsizes match.\n\nAlternatively, you could just use the right types explicitly and write\nthe umul_ppmm() macro something like\n\n#define umul_ppmm(w1, w0, u, v) do {            \\\n        USItype __w0, __w1;                     \\\n        __asm__ (\"mulu%.l %3,%1:%0\"             \\\n                : \"=d\" (__w0)                   \\\n                  \"=d\" (__w1)                   \\\n                : \"%0\" ((USItype)(u)),          \\\n                  \"dmi\" ((USItype)(v)));        \\\n        w0 = __w0; w1 = __w1; } while (0)\n\nNOTE! UNTESTED! Treat the above as a \"something like this, perhaps\".\n\n              Linus\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173611367827389.mbox",
          "message_id": "<CAHk-=wj4tYCytRshQGkWSNmZS=59PtKEUpG7f4Sy_46n+WYtXw () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-05 21:51:21+00:00",
          "date_str": "Sun, 05 Jan 2025 21:51:21 +0000",
          "body": "On Fri, 3 Jan 2025 at 01:22, Geert Uytterhoeven <geert@linux-m68k.org> wrote:\n>\n> Perhaps this is an issue with sparse?\n\nNo, this is just m68k doing disgusting things that happen to work with\ngcc, because gcc considers casts to be lvalues (which in turn is comes\nfrom some horrid C++ thing, since in C++ casting is a whole magical\nextra complexity).\n\nIOW, this m68k pattern is horrendous, and sparse quite reasonably\ncomplains about it:\n\n  #define umul_ppmm(w1, w0, u, v) \\\n    __asm__ (\"mulu%.l %3,%1:%0\"                                           \\\n             : \"=d\" ((USItype)(w0)),                                      \\\n               \"=d\" ((USItype)(w1))                                       \\\n             : \"%0\" ((USItype)(u)),                                       \\\n               \"dmi\" ((USItype)(v)))\n\nnotice how it has two register outputs (the \"=d\"), and the destination\nof said output is not a proper lvalue, but a cast expression.\n\nI think you could just remove the cast. Afaik the w0/w1 arguments come from\n\n#define __umulsidi3(u, v) \\\n  ({DIunion __w;                                                        \\\n    umul_ppmm (__w.s.high, __w.s.low, u, v);                            \\\n    __w.ll; })\n\nand __w.s.high and __w.s.low are from struct DIstruct, which uses\n\"SItype\". So all the cast does is to change the signedness of the\nvariable, but that has no *meaning* when you assign to it and the\nsizes match.\n\nAlternatively, you could just use the right types explicitly and write\nthe umul_ppmm() macro something like\n\n#define umul_ppmm(w1, w0, u, v) do {            \\\n        USItype __w0, __w1;                     \\\n        __asm__ (\"mulu%.l %3,%1:%0\"             \\\n                : \"=d\" (__w0)                   \\\n                  \"=d\" (__w1)                   \\\n                : \"%0\" ((USItype)(u)),          \\\n                  \"dmi\" ((USItype)(v)));        \\\n        w0 = __w0; w1 = __w1; } while (0)\n\nNOTE! UNTESTED! Treat the above as a \"something like this, perhaps\".\n\n              Linus\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173634576623819.mbox",
          "message_id": "<CAMuHMdVLQ2z=U1YJ18GsnJcej2mwGg02GVtKQLQKr0yNtA-7Hg () mail ! gmail ! com>",
          "author_name": "Geert Uytterhoeven",
          "author_email": "geert () linux-m68k ! org",
          "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-08 14:19:38+00:00",
          "date_str": "Wed, 08 Jan 2025 14:19:38 +0000",
          "body": "Hi Linus,\n\nOn Sun, Jan 5, 2025 at 10:51=E2=80=AFPM Linus Torvalds\n<torvalds@linux-foundation.org> wrote:\n> On Fri, 3 Jan 2025 at 01:22, Geert Uytterhoeven <geert@linux-m68k.org> wr=\note:\n> > Perhaps this is an issue with sparse?\n>\n> No, this is just m68k doing disgusting things that happen to work with\n> gcc, because gcc considers casts to be lvalues (which in turn is comes\n> from some horrid C++ thing, since in C++ casting is a whole magical\n> extra complexity).\n>\n> IOW, this m68k pattern is horrendous, and sparse quite reasonably\n> complains about it:\n>\n>   #define umul_ppmm(w1, w0, u, v) \\\n>     __asm__ (\"mulu%.l %3,%1:%0\"                                          =\n \\\n>              : \"=3Dd\" ((USItype)(w0)),                                   =\n   \\\n>                \"=3Dd\" ((USItype)(w1))                                    =\n   \\\n>              : \"%0\" ((USItype)(u)),                                      =\n \\\n>                \"dmi\" ((USItype)(v)))\n>\n> notice how it has two register outputs (the \"=3Dd\"), and the destination\n> of said output is not a proper lvalue, but a cast expression.\n>\n> I think you could just remove the cast. Afaik the w0/w1 arguments come fr=\nom\n>\n> #define __umulsidi3(u, v) \\\n>   ({DIunion __w;                                                        \\\n>     umul_ppmm (__w.s.high, __w.s.low, u, v);                            \\\n>     __w.ll; })\n>\n> and __w.s.high and __w.s.low are from struct DIstruct, which uses\n> \"SItype\". So all the cast does is to change the signedness of the\n> variable, but that has no *meaning* when you assign to it and the\n> sizes match.\n>\n> Alternatively, you could just use the right types explicitly and write\n> the umul_ppmm() macro something like\n>\n> #define umul_ppmm(w1, w0, u, v) do {            \\\n>         USItype __w0, __w1;                     \\\n>         __asm__ (\"mulu%.l %3,%1:%0\"             \\\n>                 : \"=3Dd\" (__w0)                   \\\n>                   \"=3Dd\" (__w1)                   \\\n>                 : \"%0\" ((USItype)(u)),          \\\n>                   \"dmi\" ((USItype)(v)));        \\\n>         w0 =3D __w0; w1 =3D __w1; } while (0)\n>\n> NOTE! UNTESTED! Treat the above as a \"something like this, perhaps\".\n\nThank you, using intermediate variables instead of casts for the output\noperands gets rid of the lvalue-related sparse warnings.\nThat leaves us with the \"not addressable\" sparse error.  Apparently\nthat goes away by dropping the cast on the last input operand,\nso I will introduce intermediate variables for all input operands, too.\n\nGr{oetje,eeting}s,\n\n                        Geert\n\n--=20\nGeert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k=\n.org\n\nIn personal conversations with technical people, I call myself a hacker. Bu=\nt\nwhen I'm talking to journalists I just say \"programmer\" or something like t=\nhat.\n                                -- Linus Torvalds\n",
          "year": "2025",
          "month": "01"
        },
        {
          "filepath": "emails/2025/01/173635964301113.mbox",
          "message_id": "<CAHk-=whmhoFfty4GoAnN6u1K2EsjhWkoS767fa-+Lsf1Ya6A+w () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [geert-m68k:master 2/2] lib/muldi3.c:53:28: sparse: sparse: asm output is not an lvalue",
          "date": "2025-01-08 18:10:48+00:00",
          "date_str": "Wed, 08 Jan 2025 18:10:48 +0000",
          "body": "On Wed, 8 Jan 2025 at 06:19, Geert Uytterhoeven <geert@linux-m68k.org> wrote:\n>\n> That leaves us with the \"not addressable\" sparse error.\n\nHmm. That one is actually a sparse mis-feature.\n\nSparse sees that\n\n          \"dmi\" ((USItype)(v))\n\ninput, and the 'm' makes it go \"it's a memory location\" and that makes\nsparse go \"it must be addressable\".\n\nBut for asm inputs, it just means that the compiler should *put* the\nthing in memory to be an input.\n\nAnd this is hidden on x86, because sparse recognizes \"r\" for register,\nand says \"if it can be either a register or memory, I don't require\nmemory\". So there's various x86 inline asm that does something like\n\n        \"rm\" (0)\n\nand sparse won't complain about the zero not being addressable.\n\nBut in your case, just making the inputs lvalues will fix the sparse\nproblem, so I guess that's the right thing to do. I sadly don't see\nsparse being fixed because we don't have a maintainer..\n\n                 Linus\n",
          "year": "2025",
          "month": "01"
        }
      ],
      "primary_category": "sparse_internals"
    }
  ]
}