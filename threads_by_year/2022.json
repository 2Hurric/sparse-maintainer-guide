{
  "year": "2022",
  "stats": {
    "total_threads": 4,
    "total_messages": 25,
    "categories": {
      "address_space": 4
    }
  },
  "threads": [
    {
      "subject": "address_space and noderef on non-pointer types",
      "normalized_subject": "address_space and noderef on non-pointer types",
      "message_count": 1,
      "participants": [
        "David Malcolm"
      ],
      "categories": [
        "compiler_compat",
        "address_space"
      ],
      "first_date": "2022-10-13T19:37:16+00:00",
      "last_date": "2022-10-13T19:37:16+00:00",
      "year": 2022,
      "messages": [
        {
          "filepath": "emails/2022/10/166568947129411.mbox",
          "message_id": "<e583356b104fbef6940a06bf360aa59c42bba3c2.camel () redhat ! com>",
          "author_name": "David Malcolm",
          "author_email": "dmalcolm () redhat ! com",
          "subject": "address_space and noderef on non-pointer types",
          "date": "2022-10-13 19:37:16+00:00",
          "date_str": "Thu, 13 Oct 2022 19:37:16 +0000",
          "body": "Is it valid to apply the sparse attributes 'noderef' or 'address_space'\nto non-pointers, and if so, what does this mean?\n\nI see examples of using them on non-pointers in sparse's own test\nsuite.\n\nFor example, in:\nhttps://git.kernel.org/pub/scm/devel/sparse/sparse.git/tree/validation/type=\n-attribute-as.c\n\"struct s\" is annotated with\n  __attribute__((address_space(__as)))\n\nSimilarly, there's\nhttps://git.kernel.org/pub/scm/devel/sparse/sparse.git/tree/validation/node=\nref.c#n18\nwhere sparse accepts:\n  struct x __A x;\ne.g.:\n  struct x __attribute__((noderef)) x;\n\nThe docs for noderef:=20\nhttps://git.kernel.org/pub/scm/devel/sparse/sparse.git/tree/Documentation/a=\nnnotations.rst#n54\nsay:\n\"This attribute is to be used on a r-value to specify it cannot be\ndereferenced. A pointer so annotated is in all other aspects exactly\nlike a pointer  but trying to actually access anything through it will\ncause a warning.\"\nWhat is the intended meaning of \"noderef\" for a non-pointer?\n\nSimilarly, the docs for \"address_space\" say:\n\"This attribute is to be used on pointers to specify that its target is\nin address space *name* (an identifier or a constant integer).\"\n\nbut don't specify what it means to use in on a non-pointer.\n\nSorry if this is a silly question.\n\nThe background here is that I'm a GCC developer and have been\nexperimenting with implementing some sparse attributes and warnings\n\"natively\" in GCC; see e.g. the RFE in GCC bugzilla for implementing\naddress_space, noderef and force here:\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=3D59850 ; I'm trying to get\nmy patched GCC to handle Sparse's own test suite and hence running into\nthis issue.\n\nThanks\nDave\n",
          "year": "2022",
          "month": "10"
        }
      ],
      "primary_category": "address_space"
    },
    {
      "subject": "[RFC 0/2] refcount: attempt to avoid imbalance warnings",
      "normalized_subject": "refcount: attempt to avoid imbalance warnings",
      "message_count": 8,
      "participants": [
        "Bart Van Assche",
        "Peter Zijlstra",
        "Linus Torvalds",
        "Alexander Aring"
      ],
      "categories": [
        "kernel_integration",
        "context_analysis",
        "sparse_internals",
        "address_space",
        "compiler_compat",
        "rfc_proposals"
      ],
      "first_date": "2022-06-30T13:59:32+00:00",
      "last_date": "2025-02-08T02:52:48+00:00",
      "year": 2022,
      "messages": [
        {
          "filepath": "emails/2022/07/165659842505190.mbox",
          "message_id": "<20220630135934.1799248-1-aahringo () redhat ! com>",
          "author_name": "Alexander Aring",
          "author_email": "aahringo () redhat ! com",
          "subject": "[RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2022-06-30 13:59:32+00:00",
          "date_str": "Thu, 30 Jun 2022 13:59:32 +0000",
          "body": "Hi,\n\nThis patch tries to avoid some sparse warnings related to\nrefcount_dec_and_lock() and kref_put_lock().\n\nI send this patch series as RFC because it was necessary to do a kref\nchange after adding __cond_lock() to refcount_dec_and_lock()\nfunctionality.\n\nFor me it looks like we do a lot of acrobatics to avoid sparse warnings\nhere and I really don't know if it's worth the offer. However this is\nwhat I have now...\n\n- Alex\n\nAlexander Aring (2):\n  refcount: add __cond_lock() for conditional lock refcount API\n  kref: move kref_put_lock() callback to caller\n\n include/linux/kref.h     | 24 ++++++++----------------\n include/linux/refcount.h | 21 ++++++++++++++++-----\n lib/refcount.c           | 23 ++++++++++++-----------\n 3 files changed, 36 insertions(+), 32 deletions(-)\n\n-- \n2.31.1\n",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2022/07/165660718910559.mbox",
          "message_id": "<CAHk-=wjZfO9hGqJ2_hGQG3U_XzSh9_XaXze=HgPdvJbgrvASfA () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2022-06-30 16:34:10+00:00",
          "date_str": "Thu, 30 Jun 2022 16:34:10 +0000",
          "body": "--000000000000db535805e2acd76b\nContent-Type: text/plain; charset=\"UTF-8\"\n\nOn Thu, Jun 30, 2022 at 6:59 AM Alexander Aring <aahringo@redhat.com> wrote:\n>\n> I send this patch series as RFC because it was necessary to do a kref\n> change after adding __cond_lock() to refcount_dec_and_lock()\n> functionality.\n\nCan you try something like this instead?\n\nThis is two separate patches - one for sparse, and one for the kernel.\n\nThis is only *very* lightly tested (ie I tested it on a single kernel\nfile that used refcount_dec_and_lock())\n\n                Linus\n\n--000000000000db535805e2acd76b\nContent-Type: text/x-patch; charset=\"US-ASCII\"; name=\"sparse.patch\"\nContent-Disposition: attachment; filename=\"sparse.patch\"\nContent-Transfer-Encoding: base64\nContent-ID: <f_l518xtgt0>\nX-Attachment-Id: f_l518xtgt0\n\nIGxpbmVhcml6ZS5jICAgICAgICAgIHwgMjQgKysrKysrKysrKysrKysrKysrKysrKy0tCiB2YWxp\nZGF0aW9uL2NvbnRleHQuYyB8IDE1ICsrKysrKysrKysrKysrKwogMiBmaWxlcyBjaGFuZ2VkLCAz\nNyBpbnNlcnRpb25zKCspLCAyIGRlbGV0aW9ucygtKQoKZGlmZiAtLWdpdCBhL2xpbmVhcml6ZS5j\nIGIvbGluZWFyaXplLmMKaW5kZXggZDlhZWQ2MWIuLjhkZDAwNWFmIDEwMDY0NAotLS0gYS9saW5l\nYXJpemUuYworKysgYi9saW5lYXJpemUuYwpAQCAtMTUzNyw2ICsxNTM3LDggQEAgc3RhdGljIHBz\nZXVkb190IGxpbmVhcml6ZV9jYWxsX2V4cHJlc3Npb24oc3RydWN0IGVudHJ5cG9pbnQgKmVwLCBz\ndHJ1Y3QgZXhwcmVzc2kKIAlhZGRfb25lX2luc24oZXAsIGluc24pOwogCiAJaWYgKGN0eXBlKSB7\nCisJCXN0cnVjdCBiYXNpY19ibG9jayAqcG9zdF9jYWxsID0gTlVMTDsKKwogCQlGT1JfRUFDSF9Q\nVFIoY3R5cGUtPmNvbnRleHRzLCBjb250ZXh0KSB7CiAJCQlpbnQgaW4gPSBjb250ZXh0LT5pbjsK\nIAkJCWludCBvdXQgPSBjb250ZXh0LT5vdXQ7CkBAIC0xNTQ3LDggKzE1NDksMjEgQEAgc3RhdGlj\nIHBzZXVkb190IGxpbmVhcml6ZV9jYWxsX2V4cHJlc3Npb24oc3RydWN0IGVudHJ5cG9pbnQgKmVw\nLCBzdHJ1Y3QgZXhwcmVzc2kKIAkJCQlpbiA9IDA7CiAJCQl9CiAJCQlpZiAob3V0IDwgMCkgewot\nCQkJCWNoZWNrID0gMDsKLQkJCQlvdXQgPSAwOworCQkJCXN0cnVjdCBiYXNpY19ibG9jayAqc2V0\nX2NvbnRleHQ7CisJCQkJaWYgKHJldHZhbCA9PSBWT0lEKSB7CisJCQkJCXdhcm5pbmcoZXhwci0+\ncG9zLCAibm9uc2Vuc2ljYWwgY29uZGl0aW9uYWwgb3V0cHV0IGNvbnRleHQgd2l0aCBubyBjb25k\naXRpb24iKTsKKwkJCQkJYnJlYWs7CisJCQkJfQorCQkJCWlmIChjaGVjayB8fCBpbikgeworCQkJ\nCQl3YXJuaW5nKGV4cHItPnBvcywgIm5vbnNlbnNpY2FsIGNvbmRpdGlvbmFsIGlucHV0IGNvbnRl\neHQiKTsKKwkJCQkJYnJlYWs7CisJCQkJfQorCQkJCWlmICghcG9zdF9jYWxsKQorCQkJCQlwb3N0\nX2NhbGwgPSBhbGxvY19iYXNpY19ibG9jayhlcCwgZXhwci0+cG9zKTsKKwkJCQlzZXRfY29udGV4\ndCA9IGFsbG9jX2Jhc2ljX2Jsb2NrKGVwLCBleHByLT5wb3MpOworCQkJCWFkZF9icmFuY2goZXAs\nIHJldHZhbCwgc2V0X2NvbnRleHQsIHBvc3RfY2FsbCk7CisJCQkJc2V0X2FjdGl2ZWJsb2NrKGVw\nLCBzZXRfY29udGV4dCk7CisJCQkJb3V0ID0gLW91dDsKIAkJCX0KIAkJCWNvbnRleHRfZGlmZiA9\nIG91dCAtIGluOwogCQkJaWYgKGNoZWNrIHx8IGNvbnRleHRfZGlmZikgewpAQCAtMTU2MCw2ICsx\nNTc1LDExIEBAIHN0YXRpYyBwc2V1ZG9fdCBsaW5lYXJpemVfY2FsbF9leHByZXNzaW9uKHN0cnVj\ndCBlbnRyeXBvaW50ICplcCwgc3RydWN0IGV4cHJlc3NpCiAJCQl9CiAJCX0gRU5EX0ZPUl9FQUNI\nX1BUUihjb250ZXh0KTsKIAorCQlpZiAocG9zdF9jYWxsKSB7CisJCQlhZGRfZ290byhlcCwgcG9z\ndF9jYWxsKTsKKwkJCXNldF9hY3RpdmVibG9jayhlcCwgcG9zdF9jYWxsKTsKKwkJfQorCiAJCWlm\nIChjdHlwZS0+bW9kaWZpZXJzICYgTU9EX05PUkVUVVJOKQogCQkJYWRkX3VucmVhY2hhYmxlKGVw\nKTsKIAl9CmRpZmYgLS1naXQgYS92YWxpZGF0aW9uL2NvbnRleHQuYyBiL3ZhbGlkYXRpb24vY29u\ndGV4dC5jCmluZGV4IGI5NTAwZGM3Li5mODk2MmYxOSAxMDA2NDQKLS0tIGEvdmFsaWRhdGlvbi9j\nb250ZXh0LmMKKysrIGIvdmFsaWRhdGlvbi9jb250ZXh0LmMKQEAgLTEwLDYgKzEwLDEwIEBAIHN0\nYXRpYyB2b2lkIHIodm9pZCkgX19hdHRyaWJ1dGVfXygoY29udGV4dCgxLDApKSkKIAlfX2NvbnRl\neHRfXygtMSk7CiB9CiAKKy8vIE5lZ2F0aXZlIG91dHB1dCBtZWFucyAiY29uZGl0aW9uYWwgcG9z\naXRpdmUgb3V0cHV0IgorZXh0ZXJuIGludCBjb25kX2dldCh2b2lkKSBfX2F0dHJpYnV0ZSgoY29u\ndGV4dCgwLC0xKSkpOworZXh0ZXJuIHZvaWQgbm9uc2Vuc2ljYWxfY29uZF9nZXQodm9pZCkgX19h\ndHRyaWJ1dGUoKGNvbnRleHQoMCwtMSkpKTsKKwogZXh0ZXJuIGludCBfY2EoaW50IGZhaWwpOwog\nI2RlZmluZSBjYShmYWlsKSBfX2NvbmRfbG9jayhfY2EoZmFpbCkpCiAKQEAgLTE5LDYgKzIzLDE3\nIEBAIHN0YXRpYyB2b2lkIGdvb2RfcGFpcmVkMSh2b2lkKQogCXIoKTsKIH0KIAorc3RhdGljIHZv\naWQgZ29vZF9jb25kaXRpb25hbCh2b2lkKQoreworCWlmIChjb25kX2dldCgpKQorCQlyKCk7Cit9\nCisKK3N0YXRpYyB2b2lkIG5vbnNlbnNpY2FsX2NvbmRpdGlvbmFsKHZvaWQpCit7CisJbm9uc2Vu\nc2ljYWxfY29uZF9nZXQoKTsKK30KKwogc3RhdGljIHZvaWQgZ29vZF9wYWlyZWQyKHZvaWQpCiB7\nCiAJYSgpOwo=\n--000000000000db535805e2acd76b\nContent-Type: text/x-patch; charset=\"US-ASCII\"; name=\"kernel.patch\"\nContent-Disposition: attachment; filename=\"kernel.patch\"\nContent-Transfer-Encoding: base64\nContent-ID: <f_l518xy841>\nX-Attachment-Id: f_l518xy841\n\nIGluY2x1ZGUvbGludXgvY29tcGlsZXJfdHlwZXMuaCB8IDIgKysKIGluY2x1ZGUvbGludXgvcmVm\nY291bnQuaCAgICAgICB8IDYgKysrLS0tCiAyIGZpbGVzIGNoYW5nZWQsIDUgaW5zZXJ0aW9ucygr\nKSwgMyBkZWxldGlvbnMoLSkKCmRpZmYgLS1naXQgYS9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX3R5\ncGVzLmggYi9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX3R5cGVzLmgKaW5kZXggZDA4ZGZjYjBhYzY4\nLi40ZjJhODE5ZmQ2MGEgMTAwNjQ0Ci0tLSBhL2luY2x1ZGUvbGludXgvY29tcGlsZXJfdHlwZXMu\naAorKysgYi9pbmNsdWRlL2xpbnV4L2NvbXBpbGVyX3R5cGVzLmgKQEAgLTI0LDYgKzI0LDcgQEAg\nc3RhdGljIGlubGluZSB2b2lkIF9fY2hrX2lvX3B0cihjb25zdCB2b2xhdGlsZSB2b2lkIF9faW9t\nZW0gKnB0cikgeyB9CiAvKiBjb250ZXh0L2xvY2tpbmcgKi8KICMgZGVmaW5lIF9fbXVzdF9ob2xk\nKHgpCV9fYXR0cmlidXRlX18oKGNvbnRleHQoeCwxLDEpKSkKICMgZGVmaW5lIF9fYWNxdWlyZXMo\neCkJX19hdHRyaWJ1dGVfXygoY29udGV4dCh4LDAsMSkpKQorIyBkZWZpbmUgX19jb25kX2FjcXVp\ncmVzKHgpIF9fYX",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2022/07/165666523822977.mbox",
          "message_id": "<Yr60tWxN4P568x3W () worktop ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2022-07-01 08:47:49+00:00",
          "date_str": "Fri, 01 Jul 2022 08:47:49 +0000",
          "body": "On Thu, Jun 30, 2022 at 09:34:10AM -0700, Linus Torvalds wrote:\n\nNot commenting on sparse, since I'm not much qualified there, however,\n\n>  include/linux/compiler_types.h | 2 ++\n>  include/linux/refcount.h       | 6 +++---\n>  2 files changed, 5 insertions(+), 3 deletions(-)\n> \n> diff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h\n> index d08dfcb0ac68..4f2a819fd60a 100644\n> --- a/include/linux/compiler_types.h\n> +++ b/include/linux/compiler_types.h\n> @@ -24,6 +24,7 @@ static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n>  /* context/locking */\n>  # define __must_hold(x)\t__attribute__((context(x,1,1)))\n>  # define __acquires(x)\t__attribute__((context(x,0,1)))\n> +# define __cond_acquires(x) __attribute__((context(x,0,-1)))\n>  # define __releases(x)\t__attribute__((context(x,1,0)))\n>  # define __acquire(x)\t__context__(x,1)\n>  # define __release(x)\t__context__(x,-1)\n> @@ -50,6 +51,7 @@ static inline void __chk_io_ptr(const volatile void __iomem *ptr) { }\n>  /* context/locking */\n>  # define __must_hold(x)\n>  # define __acquires(x)\n> +# define __cond_acquires(x)\n>  # define __releases(x)\n>  # define __acquire(x)\t(void)0\n>  # define __release(x)\t(void)0\n> diff --git a/include/linux/refcount.h b/include/linux/refcount.h\n> index b8a6e387f8f9..a62fcca97486 100644\n> --- a/include/linux/refcount.h\n> +++ b/include/linux/refcount.h\n> @@ -361,9 +361,9 @@ static inline void refcount_dec(refcount_t *r)\n>  \n>  extern __must_check bool refcount_dec_if_one(refcount_t *r);\n>  extern __must_check bool refcount_dec_not_one(refcount_t *r);\n> -extern __must_check bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock);\n> -extern __must_check bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock);\n> +extern __must_check bool refcount_dec_and_mutex_lock(refcount_t *r, struct mutex *lock) __cond_acquires(lock);\n> +extern __must_check bool refcount_dec_and_lock(refcount_t *r, spinlock_t *lock) __cond_acquires(lock);\n>  extern __must_check bool refcount_dec_and_lock_irqsave(refcount_t *r,\n>  \t\t\t\t\t\t       spinlock_t *lock,\n> -\t\t\t\t\t\t       unsigned long *flags);\n> +\t\t\t\t\t\t       unsigned long *flags) __cond_acquires(lock);\n>  #endif /* _LINUX_REFCOUNT_H */\n\n\nYES!, thank you!",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2022/07/165667714929802.mbox",
          "message_id": "<CAK-6q+jkNbotWK7cFsNGO+B+ApcdUd7+_4mdcF8=00YsDAATTA () mail ! gmail ! com>",
          "author_name": "Alexander Aring",
          "author_email": "aahringo () redhat ! com",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2022-07-01 12:07:01+00:00",
          "date_str": "Fri, 01 Jul 2022 12:07:01 +0000",
          "body": "Hi,\n\nOn Thu, Jun 30, 2022 at 12:34 PM Linus Torvalds\n<torvalds@linux-foundation.org> wrote:\n>\n> On Thu, Jun 30, 2022 at 6:59 AM Alexander Aring <aahringo@redhat.com> wrote:\n> >\n> > I send this patch series as RFC because it was necessary to do a kref\n> > change after adding __cond_lock() to refcount_dec_and_lock()\n> > functionality.\n>\n> Can you try something like this instead?\n>\n> This is two separate patches - one for sparse, and one for the kernel.\n>\n> This is only *very* lightly tested (ie I tested it on a single kernel\n> file that used refcount_dec_and_lock())\n>\n\nyes that avoids the warnings for fs/dlm.c by calling unlock() when the\nkref_put_lock() returns true.\n\nHowever there exists other users of kref_put_lock() which drops a\nsparse warning now after those patches e.g.  net/sunrpc/svcauth.c.\nI think I can explain why. It is that kref_put_lock() has a release\ncallback and it's _optional_ that this release callback calls the\nunlock(). If the release callback calls unlock() then the user of\nkref_put_lock() signals this with a releases() annotation of the\npassed release callback.\n\nIt seems that sparse is not detecting this annotation anymore when\nit's passed as callback and the function pointer parameter declaration\nof kref_put_lock() does not have such annotation. The annotation gets\n\"dropped\" then.\n\nIf I change the parameter order and add a annotation to the release\ncallback, like:\n\n__kref_put_lock(struct kref *kref, spinlock_t *lock,\n               void (*release)(struct kref *kref) __releases(lock))\n#define kref_put_lock(kref, release, lock) __kref_put_lock(kref, lock, release)\n\nthe problem is gone but forces every user to release the lock in the\nrelease callback which isn't required and also cuts the API because\nthe lock which you want to call unlock() on can be not part of your\ncontainer_of(kref) struct.\n\nThen I did a similar thing before which would solve it for every user\nbecause there is simply no function pointer passed as parameter and\nthe annotation gets never \"dropped\":\n\n#define kref_put_lock(kref, release, lock) \\\n(refcount_dec_and_lock(&(kref)->refcount, lock) ? ({ release(kref); 1; }) : 0)\n\nMaybe a functionality of forwarding function annotation if passed as a\nfunction pointer (function pointer declared without annotations) as in\ne.g. kref_put_lock() can be added into sparse?\n\n- Alex\n",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2022/07/165670248712458.mbox",
          "message_id": "<CAK-6q+i67rNeioq+=MzLyCJ_fh7DvDVWOHA02oOasKocvkhXSw () mail ! gmail ! com>",
          "author_name": "Alexander Aring",
          "author_email": "aahringo () redhat ! com",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2022-07-01 19:09:00+00:00",
          "date_str": "Fri, 01 Jul 2022 19:09:00 +0000",
          "body": "Hi,\n\nOn Fri, Jul 1, 2022 at 8:07 AM Alexander Aring <aahringo@redhat.com> wrote:\n>\n> Hi,\n>\n> On Thu, Jun 30, 2022 at 12:34 PM Linus Torvalds\n> <torvalds@linux-foundation.org> wrote:\n> >\n> > On Thu, Jun 30, 2022 at 6:59 AM Alexander Aring <aahringo@redhat.com> wrote:\n> > >\n> > > I send this patch series as RFC because it was necessary to do a kref\n> > > change after adding __cond_lock() to refcount_dec_and_lock()\n> > > functionality.\n> >\n> > Can you try something like this instead?\n> >\n> > This is two separate patches - one for sparse, and one for the kernel.\n> >\n> > This is only *very* lightly tested (ie I tested it on a single kernel\n> > file that used refcount_dec_and_lock())\n> >\n>\n> yes that avoids the warnings for fs/dlm.c by calling unlock() when the\n> kref_put_lock() returns true.\n>\n> However there exists other users of kref_put_lock() which drops a\n> sparse warning now after those patches e.g.  net/sunrpc/svcauth.c.\n> I think I can explain why. It is that kref_put_lock() has a release\n> callback and it's _optional_ that this release callback calls the\n> unlock(). If the release callback calls unlock() then the user of\n> kref_put_lock() signals this with a releases() annotation of the\n> passed release callback.\n>\n> It seems that sparse is not detecting this annotation anymore when\n> it's passed as callback and the function pointer parameter declaration\n> of kref_put_lock() does not have such annotation. The annotation gets\n> \"dropped\" then.\n>\n> If I change the parameter order and add a annotation to the release\n> callback, like:\n>\n> __kref_put_lock(struct kref *kref, spinlock_t *lock,\n>                void (*release)(struct kref *kref) __releases(lock))\n> #define kref_put_lock(kref, release, lock) __kref_put_lock(kref, lock, release)\n>\n> the problem is gone but forces every user to release the lock in the\n> release callback which isn't required and also cuts the API because\n> the lock which you want to call unlock() on can be not part of your\n> container_of(kref) struct.\n>\n> Then I did a similar thing before which would solve it for every user\n> because there is simply no function pointer passed as parameter and\n> the annotation gets never \"dropped\":\n>\n> #define kref_put_lock(kref, release, lock) \\\n> (refcount_dec_and_lock(&(kref)->refcount, lock) ? ({ release(kref); 1; }) : 0)\n>\n> Maybe a functionality of forwarding function annotation if passed as a\n> function pointer (function pointer declared without annotations) as in\n> e.g. kref_put_lock() can be added into sparse?\n\nI think the explanation above is not quite right. I am questioning\nmyself now why it was working before... and I guess the answer is that\nit was working for kref_put_lock() with the callback __releases()\nhandling. It has somehow now an additional acquire() because the\n__cond_acquires() change.\n\nBefore the patch:\n\nno warnings:\n\nvoid foo_release(struct kref *kref)\n__releases(&foo_lock)\n{\n        ...\n        unlock(foo_lock);\n}\n\n...\nkref_put_lock(&foo->kref, foo_release, &foo_lock);\n\nshows context imbalance warnings:\n\nvoid foo_release(struct kref *kref) { }\n\nif (kref_put_lock(&foo->kref, foo_release, &foo_lock))\n        unlock(foo_lock);\n\nAfter the patch it's vice versa of showing warnings or not about\ncontext imbalances.\n\n- Alex\n",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2022/07/173898292611534.mbox",
          "message_id": "<e56577db-b94c-4f38-868b-dd3be65f780d () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2025-02-08 02:52:48+00:00",
          "date_str": "Sat, 08 Feb 2025 02:52:48 +0000",
          "body": "On 6/30/22 9:34 AM, Linus Torvalds wrote:\n> On Thu, Jun 30, 2022 at 6:59 AM Alexander Aring <aahringo@redhat.com> wrote:\n>>\n>> I send this patch series as RFC because it was necessary to do a kref\n>> change after adding __cond_lock() to refcount_dec_and_lock()\n>> functionality.\n> \n> Can you try something like this instead?\n> \n> This is two separate patches - one for sparse, and one for the kernel.\n> \n> This is only *very* lightly tested (ie I tested it on a single kernel\n> file that used refcount_dec_and_lock())\n> \n>                  Linus\n\n(replying to an email from two years ago -- see also\nhttps://lore.kernel.org/linux-kernel/CAHk-=wjZfO9hGqJ2_hGQG3U_XzSh9_XaXze=HgPdvJbgrvASfA@mail.gmail.com/)\n\nHi Luc,\n\nAre there any plans to add support for __cond_acquires() in sparse?\n\nMarco Elver (Cc-ed) and I are looking into enabling the Clang \n-Wthread-safety compiler flag for Linux kernel code. If we want to keep the\nsparse locking annotations, a first step would be to convert all\n__cond_lock() annotations into __cond_acquires(). When I tried to make\nthat change I noticed that sparse does not yet support\n__cond_acquires(). Hence my question about the plan to support\n__cond_acquires() in sparse?\n\nThanks,\n\nBart.\n",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2022/07/173898292711535.mbox",
          "message_id": "<e56577db-b94c-4f38-868b-dd3be65f780d () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2025-02-08 02:52:48+00:00",
          "date_str": "Sat, 08 Feb 2025 02:52:48 +0000",
          "body": "On 6/30/22 9:34 AM, Linus Torvalds wrote:\n> On Thu, Jun 30, 2022 at 6:59 AM Alexander Aring <aahringo@redhat.com> wrote:\n>>\n>> I send this patch series as RFC because it was necessary to do a kref\n>> change after adding __cond_lock() to refcount_dec_and_lock()\n>> functionality.\n> \n> Can you try something like this instead?\n> \n> This is two separate patches - one for sparse, and one for the kernel.\n> \n> This is only *very* lightly tested (ie I tested it on a single kernel\n> file that used refcount_dec_and_lock())\n> \n>                  Linus\n\n(replying to an email from two years ago -- see also\nhttps://lore.kernel.org/linux-kernel/CAHk-=wjZfO9hGqJ2_hGQG3U_XzSh9_XaXze=HgPdvJbgrvASfA@mail.gmail.com/)\n\nHi Luc,\n\nAre there any plans to add support for __cond_acquires() in sparse?\n\nMarco Elver (Cc-ed) and I are looking into enabling the Clang \n-Wthread-safety compiler flag for Linux kernel code. If we want to keep the\nsparse locking annotations, a first step would be to convert all\n__cond_lock() annotations into __cond_acquires(). When I tried to make\nthat change I noticed that sparse does not yet support\n__cond_acquires(). Hence my question about the plan to support\n__cond_acquires() in sparse?\n\nThanks,\n\nBart.\n",
          "year": "2022",
          "month": "07"
        },
        {
          "filepath": "emails/2025/02/173898292611534.mbox",
          "message_id": "<e56577db-b94c-4f38-868b-dd3be65f780d () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [RFC 0/2] refcount: attempt to avoid imbalance warnings",
          "date": "2025-02-08 02:52:48+00:00",
          "date_str": "Sat, 08 Feb 2025 02:52:48 +0000",
          "body": "On 6/30/22 9:34 AM, Linus Torvalds wrote:\n> On Thu, Jun 30, 2022 at 6:59 AM Alexander Aring <aahringo@redhat.com> wrote:\n>>\n>> I send this patch series as RFC because it was necessary to do a kref\n>> change after adding __cond_lock() to refcount_dec_and_lock()\n>> functionality.\n> \n> Can you try something like this instead?\n> \n> This is two separate patches - one for sparse, and one for the kernel.\n> \n> This is only *very* lightly tested (ie I tested it on a single kernel\n> file that used refcount_dec_and_lock())\n> \n>                  Linus\n\n(replying to an email from two years ago -- see also\nhttps://lore.kernel.org/linux-kernel/CAHk-=wjZfO9hGqJ2_hGQG3U_XzSh9_XaXze=HgPdvJbgrvASfA@mail.gmail.com/)\n\nHi Luc,\n\nAre there any plans to add support for __cond_acquires() in sparse?\n\nMarco Elver (Cc-ed) and I are looking into enabling the Clang \n-Wthread-safety compiler flag for Linux kernel code. If we want to keep the\nsparse locking annotations, a first step would be to convert all\n__cond_lock() annotations into __cond_acquires(). When I tried to make\nthat change I noticed that sparse does not yet support\n__cond_acquires(). Hence my question about the plan to support\n__cond_acquires() in sparse?\n\nThanks,\n\nBart.\n",
          "year": "2025",
          "month": "02"
        }
      ],
      "primary_category": "address_space"
    },
    {
      "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
      "normalized_subject": "[linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
      "message_count": 14,
      "participants": [
        "Luc Van Oostenryck",
        "Geert Uytterhoeven"
      ],
      "categories": [
        "type_system",
        "compiler_compat",
        "sparse_internals",
        "address_space"
      ],
      "first_date": "2022-05-20T12:46:20+00:00",
      "last_date": "2022-05-22T11:57:00+00:00",
      "year": 2022,
      "messages": [
        {
          "filepath": "emails/2022/05/165305076101344.mbox",
          "message_id": "<CAMuHMdVx7r-4TVV9uVJppT-7ZAriov01BUNk4ghU9Bs4uY28vQ () mail ! gmail ! com>",
          "author_name": "Geert Uytterhoeven",
          "author_email": "geert () linux-m68k ! org",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-20 12:46:20+00:00",
          "date_str": "Fri, 20 May 2022 12:46:20 +0000",
          "body": "On Fri, May 20, 2022 at 2:40 PM Geert Uytterhoeven <geert@linux-m68k.org> wrote:\n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > On 5/18/22 17:55, kernel test robot wrote:\n> > > tree/branch: https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git master\n> > > branch HEAD: 736ee37e2e8eed7fe48d0a37ee5a709514d478b3  Add linux-next specific files for 20220518\n> > >\n> > > Error/Warning reports:\n> > >\n> > > https://lore.kernel.org/linux-mm/202204291924.vTGZmerI-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205041248.WgCwPcEV-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205122113.uLKzd3SZ-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205172344.3GFeaum1-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205190527.o9wVEvHI-lkp@intel.com\n> > >\n> > > Error/Warning: (recently discovered and may have been fixed)\n> > >\n> > [ .. ]\n> > > drivers/hwmon/nct6775-platform.c:199:9: sparse:    unsigned char\n> > > drivers/hwmon/nct6775-platform.c:199:9: sparse:    void\n> >\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n> >\n> > in arch/m68k/include/asm/raw_io.h. I have no idea what the\n> > \"(void)\" is for,\n>\n> The \"(void)\" makes sure there is no return value.\n> Which matters if the result of a function returning void is propagated\n> to another function returning void.\n\nWhich, FTR, sparse also doesn't like:\n\n    error: return expression in void function\n\nGr{oetje,eeting}s,\n\n                        Geert\n\n--\nGeert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k.org\n\nIn personal conversations with technical people, I call myself a hacker. But\nwhen I'm talking to journalists I just say \"programmer\" or something like that.\n                                -- Linus Torvalds",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165305076001338.mbox",
          "message_id": "<CAMuHMdVx7r-4TVV9uVJppT-7ZAriov01BUNk4ghU9Bs4uY28vQ () mail ! gmail ! com>",
          "author_name": "Geert Uytterhoeven",
          "author_email": "geert () linux-m68k ! org",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-20 12:46:20+00:00",
          "date_str": "Fri, 20 May 2022 12:46:20 +0000",
          "body": "On Fri, May 20, 2022 at 2:40 PM Geert Uytterhoeven <geert@linux-m68k.org> wrote:\n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > On 5/18/22 17:55, kernel test robot wrote:\n> > > tree/branch: https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git master\n> > > branch HEAD: 736ee37e2e8eed7fe48d0a37ee5a709514d478b3  Add linux-next specific files for 20220518\n> > >\n> > > Error/Warning reports:\n> > >\n> > > https://lore.kernel.org/linux-mm/202204291924.vTGZmerI-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205041248.WgCwPcEV-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205122113.uLKzd3SZ-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205172344.3GFeaum1-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205190527.o9wVEvHI-lkp@intel.com\n> > >\n> > > Error/Warning: (recently discovered and may have been fixed)\n> > >\n> > [ .. ]\n> > > drivers/hwmon/nct6775-platform.c:199:9: sparse:    unsigned char\n> > > drivers/hwmon/nct6775-platform.c:199:9: sparse:    void\n> >\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n> >\n> > in arch/m68k/include/asm/raw_io.h. I have no idea what the\n> > \"(void)\" is for,\n>\n> The \"(void)\" makes sure there is no return value.\n> Which matters if the result of a function returning void is propagated\n> to another function returning void.\n\nWhich, FTR, sparse also doesn't like:\n\n    error: return expression in void function\n\nGr{oetje,eeting}s,\n\n                        Geert\n\n--\nGeert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k.org\n\nIn personal conversations with technical people, I call myself a hacker. But\nwhen I'm talking to journalists I just say \"programmer\" or something like that.\n                                -- Linus Torvalds",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165305076001340.mbox",
          "message_id": "<CAMuHMdVx7r-4TVV9uVJppT-7ZAriov01BUNk4ghU9Bs4uY28vQ () mail ! gmail ! com>",
          "author_name": "Geert Uytterhoeven",
          "author_email": "geert () linux-m68k ! org",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-20 12:46:20+00:00",
          "date_str": "Fri, 20 May 2022 12:46:20 +0000",
          "body": "On Fri, May 20, 2022 at 2:40 PM Geert Uytterhoeven <geert@linux-m68k.org> wrote:\n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > On 5/18/22 17:55, kernel test robot wrote:\n> > > tree/branch: https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git master\n> > > branch HEAD: 736ee37e2e8eed7fe48d0a37ee5a709514d478b3  Add linux-next specific files for 20220518\n> > >\n> > > Error/Warning reports:\n> > >\n> > > https://lore.kernel.org/linux-mm/202204291924.vTGZmerI-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205041248.WgCwPcEV-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205122113.uLKzd3SZ-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205172344.3GFeaum1-lkp@intel.com\n> > > https://lore.kernel.org/linux-mm/202205190527.o9wVEvHI-lkp@intel.com\n> > >\n> > > Error/Warning: (recently discovered and may have been fixed)\n> > >\n> > [ .. ]\n> > > drivers/hwmon/nct6775-platform.c:199:9: sparse:    unsigned char\n> > > drivers/hwmon/nct6775-platform.c:199:9: sparse:    void\n> >\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n> >\n> > in arch/m68k/include/asm/raw_io.h. I have no idea what the\n> > \"(void)\" is for,\n>\n> The \"(void)\" makes sure there is no return value.\n> Which matters if the result of a function returning void is propagated\n> to another function returning void.\n\nWhich, FTR, sparse also doesn't like:\n\n    error: return expression in void function\n\nGr{oetje,eeting}s,\n\n                        Geert\n\n--\nGeert Uytterhoeven -- There's lots of Linux beyond ia32 -- geert@linux-m68k.org\n\nIn personal conversations with technical people, I call myself a hacker. But\nwhen I'm talking to journalists I just say \"programmer\" or something like that.\n                                -- Linus Torvalds",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165321979631876.mbox",
          "message_id": "<20220522114418.vcirenoehfx4efas () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:44:18+00:00",
          "date_str": "Sun, 22 May 2022 11:44:18 +0000",
          "body": "On Fri, May 20, 2022 at 02:40:20PM +0200, Geert Uytterhoeven wrote:\n> Hi G\u00fcnter\n> \n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n\nNot directly related to the root cause but the cast on the LHS is over-complex.\n*) If the types are correct, 'addr' should always be a 'u8 __iomem *'. Casting\n   it to an unsigned long will throw away all type checking: pointers of\n   any size, of any address space, any kind of integer, any scalar value will\n   be silently be accepted.\n*) Then, when casting an integer to a pointer '__force' is unneeded because\n   it's meaningless (because the integer has no type info about the pointee).\n\nThe most correct way to write the above would be:\n\tstatic inline void out_8(u8 __iomem *addr, ... b)\n\t{\n\t\t*((__force volatile u8 *)addr) = b;\n\t}\nthis way, you can typecheck 'addr' (but maybe it's the idea/the argument is\nnot always type clean?).\nOtherwise, if the cast to unsigned long is kept, '__force' can be removed.\n \n> \n> Indeed.\n> \n> For the sparse people:\n> \n> The full error is:\n> \n>         drivers/net/appletalk/cops.c:382:17: error: incompatible types\n> in conditional expression (different base types):\n>         drivers/net/appletalk/cops.c:382:17:    unsigned char\n>         drivers/net/appletalk/cops.c:382:17:    void\n> \n> Basically, sparse doesn't like \"a ? b : c\", if the return types of\n> b and c don't match, even if the resulting value is not used.\n\nWell, you know that the motivation for sparse was to be stricter than GCC.\nIn this case it's simply what is required by the standard:\n\t    \n    n1570 (C11) 6.5.15\n\tOne of the following shall hold for the second and third operands:\n\t\u2014 both operands have arithmetic type;\n\t\u2014 both operands have the same structure or union type;\n\t\u2014 both operands have void type;\n\t\u2014 both operands are pointers to qualified or unqualified versions\n          of compatible types;\n\t\u2014 one operand is a pointer and the other is a null pointer constant; or\n\t\u2014 one operand is a pointer to an object type and the other is a\n          pointer to a qualified or unqualified version of void.\n\nAlso, yes, the type checking is independent from the fact of being used\nor not (because the type of an expression must be know before any kind\nof processing can be done on its value).\n\n> E.g. outb() on m68k:\n> \n>     #define outb(val, port) (((port) < 1024 && ISA_TYPE ==\n> ISA_TYPE_ENEC) ? isa_rom_outb((val), (port)) : isa_outb((val),\n> (port)))\n> \n> where isa_rom_outb() leads to rom_out_8() returning u8, while\n> isa_outb() leads to the out_8() that includes the cast to void.\n> \n> So the best solution seems to be to add more \"(void)\" casts, to e.g.\n> rom_out_8() and friends?\n\nI kinda think so, yes (I suppose that rom_out_8() is never used as\nreturning a non-void value). But in truth, I think it's the excessive use\nof relatively complex macros that is the real problem (an using a conditional\nexpression not for its value but for its side-effects). Can't outb() be\nwritten as something like:\n\tstatic inline void outb(....) {\n\t\tif (port < 1024 && ISA_TYPE == ISA_TYPE_ENEC)\n\t\t\tisa_rom_outb(val, port);\n\t\telse\n\t\t\tisa_outb(val, port);\n\t}\n\nWith this you have better type checking, no trickery, no need for extra\ncasts, no problems with double evaluation, it's more readable (to me), ...\nBut yes, I suppose it's not really simple to convert all this. Sorry for\nno being more helpful.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165321979531866.mbox",
          "message_id": "<20220522114418.vcirenoehfx4efas () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:44:18+00:00",
          "date_str": "Sun, 22 May 2022 11:44:18 +0000",
          "body": "On Fri, May 20, 2022 at 02:40:20PM +0200, Geert Uytterhoeven wrote:\n> Hi G\u00fcnter\n> \n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n\nNot directly related to the root cause but the cast on the LHS is over-complex.\n*) If the types are correct, 'addr' should always be a 'u8 __iomem *'. Casting\n   it to an unsigned long will throw away all type checking: pointers of\n   any size, of any address space, any kind of integer, any scalar value will\n   be silently be accepted.\n*) Then, when casting an integer to a pointer '__force' is unneeded because\n   it's meaningless (because the integer has no type info about the pointee).\n\nThe most correct way to write the above would be:\n\tstatic inline void out_8(u8 __iomem *addr, ... b)\n\t{\n\t\t*((__force volatile u8 *)addr) = b;\n\t}\nthis way, you can typecheck 'addr' (but maybe it's the idea/the argument is\nnot always type clean?).\nOtherwise, if the cast to unsigned long is kept, '__force' can be removed.\n \n> \n> Indeed.\n> \n> For the sparse people:\n> \n> The full error is:\n> \n>         drivers/net/appletalk/cops.c:382:17: error: incompatible types\n> in conditional expression (different base types):\n>         drivers/net/appletalk/cops.c:382:17:    unsigned char\n>         drivers/net/appletalk/cops.c:382:17:    void\n> \n> Basically, sparse doesn't like \"a ? b : c\", if the return types of\n> b and c don't match, even if the resulting value is not used.\n\nWell, you know that the motivation for sparse was to be stricter than GCC.\nIn this case it's simply what is required by the standard:\n\t    \n    n1570 (C11) 6.5.15\n\tOne of the following shall hold for the second and third operands:\n\t\u2014 both operands have arithmetic type;\n\t\u2014 both operands have the same structure or union type;\n\t\u2014 both operands have void type;\n\t\u2014 both operands are pointers to qualified or unqualified versions\n          of compatible types;\n\t\u2014 one operand is a pointer and the other is a null pointer constant; or\n\t\u2014 one operand is a pointer to an object type and the other is a\n          pointer to a qualified or unqualified version of void.\n\nAlso, yes, the type checking is independent from the fact of being used\nor not (because the type of an expression must be know before any kind\nof processing can be done on its value).\n\n> E.g. outb() on m68k:\n> \n>     #define outb(val, port) (((port) < 1024 && ISA_TYPE ==\n> ISA_TYPE_ENEC) ? isa_rom_outb((val), (port)) : isa_outb((val),\n> (port)))\n> \n> where isa_rom_outb() leads to rom_out_8() returning u8, while\n> isa_outb() leads to the out_8() that includes the cast to void.\n> \n> So the best solution seems to be to add more \"(void)\" casts, to e.g.\n> rom_out_8() and friends?\n\nI kinda think so, yes (I suppose that rom_out_8() is never used as\nreturning a non-void value). But in truth, I think it's the excessive use\nof relatively complex macros that is the real problem (an using a conditional\nexpression not for its value but for its side-effects). Can't outb() be\nwritten as something like:\n\tstatic inline void outb(....) {\n\t\tif (port < 1024 && ISA_TYPE == ISA_TYPE_ENEC)\n\t\t\tisa_rom_outb(val, port);\n\t\telse\n\t\t\tisa_outb(val, port);\n\t}\n\nWith this you have better type checking, no trickery, no need for extra\ncasts, no problems with double evaluation, it's more readable (to me), ...\nBut yes, I suppose it's not really simple to convert all this. Sorry for\nno being more helpful.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165321979531867.mbox",
          "message_id": "<20220522114418.vcirenoehfx4efas () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:44:18+00:00",
          "date_str": "Sun, 22 May 2022 11:44:18 +0000",
          "body": "On Fri, May 20, 2022 at 02:40:20PM +0200, Geert Uytterhoeven wrote:\n> Hi G\u00fcnter\n> \n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n\nNot directly related to the root cause but the cast on the LHS is over-complex.\n*) If the types are correct, 'addr' should always be a 'u8 __iomem *'. Casting\n   it to an unsigned long will throw away all type checking: pointers of\n   any size, of any address space, any kind of integer, any scalar value will\n   be silently be accepted.\n*) Then, when casting an integer to a pointer '__force' is unneeded because\n   it's meaningless (because the integer has no type info about the pointee).\n\nThe most correct way to write the above would be:\n\tstatic inline void out_8(u8 __iomem *addr, ... b)\n\t{\n\t\t*((__force volatile u8 *)addr) = b;\n\t}\nthis way, you can typecheck 'addr' (but maybe it's the idea/the argument is\nnot always type clean?).\nOtherwise, if the cast to unsigned long is kept, '__force' can be removed.\n \n> \n> Indeed.\n> \n> For the sparse people:\n> \n> The full error is:\n> \n>         drivers/net/appletalk/cops.c:382:17: error: incompatible types\n> in conditional expression (different base types):\n>         drivers/net/appletalk/cops.c:382:17:    unsigned char\n>         drivers/net/appletalk/cops.c:382:17:    void\n> \n> Basically, sparse doesn't like \"a ? b : c\", if the return types of\n> b and c don't match, even if the resulting value is not used.\n\nWell, you know that the motivation for sparse was to be stricter than GCC.\nIn this case it's simply what is required by the standard:\n\t    \n    n1570 (C11) 6.5.15\n\tOne of the following shall hold for the second and third operands:\n\t\u2014 both operands have arithmetic type;\n\t\u2014 both operands have the same structure or union type;\n\t\u2014 both operands have void type;\n\t\u2014 both operands are pointers to qualified or unqualified versions\n          of compatible types;\n\t\u2014 one operand is a pointer and the other is a null pointer constant; or\n\t\u2014 one operand is a pointer to an object type and the other is a\n          pointer to a qualified or unqualified version of void.\n\nAlso, yes, the type checking is independent from the fact of being used\nor not (because the type of an expression must be know before any kind\nof processing can be done on its value).\n\n> E.g. outb() on m68k:\n> \n>     #define outb(val, port) (((port) < 1024 && ISA_TYPE ==\n> ISA_TYPE_ENEC) ? isa_rom_outb((val), (port)) : isa_outb((val),\n> (port)))\n> \n> where isa_rom_outb() leads to rom_out_8() returning u8, while\n> isa_outb() leads to the out_8() that includes the cast to void.\n> \n> So the best solution seems to be to add more \"(void)\" casts, to e.g.\n> rom_out_8() and friends?\n\nI kinda think so, yes (I suppose that rom_out_8() is never used as\nreturning a non-void value). But in truth, I think it's the excessive use\nof relatively complex macros that is the real problem (an using a conditional\nexpression not for its value but for its side-effects). Can't outb() be\nwritten as something like:\n\tstatic inline void outb(....) {\n\t\tif (port < 1024 && ISA_TYPE == ISA_TYPE_ENEC)\n\t\t\tisa_rom_outb(val, port);\n\t\telse\n\t\t\tisa_outb(val, port);\n\t}\n\nWith this you have better type checking, no trickery, no need for extra\ncasts, no problems with double evaluation, it's more readable (to me), ...\nBut yes, I suppose it's not really simple to convert all this. Sorry for\nno being more helpful.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165325371310852.mbox",
          "message_id": "<20220522114418.vcirenoehfx4efas () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:44:18+00:00",
          "date_str": "Sun, 22 May 2022 11:44:18 +0000",
          "body": "On Fri, May 20, 2022 at 02:40:20PM +0200, Geert Uytterhoeven wrote:\n> Hi G\u00fcnter\n> \n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n\nNot directly related to the root cause but the cast on the LHS is over-complex.\n*) If the types are correct, 'addr' should always be a 'u8 __iomem *'. Casting\n   it to an unsigned long will throw away all type checking: pointers of\n   any size, of any address space, any kind of integer, any scalar value will\n   be silently be accepted.\n*) Then, when casting an integer to a pointer '__force' is unneeded because\n   it's meaningless (because the integer has no type info about the pointee).\n\nThe most correct way to write the above would be:\n\tstatic inline void out_8(u8 __iomem *addr, ... b)\n\t{\n\t\t*((__force volatile u8 *)addr) = b;\n\t}\nthis way, you can typecheck 'addr' (but maybe it's the idea/the argument is\nnot always type clean?).\nOtherwise, if the cast to unsigned long is kept, '__force' can be removed.\n \n> \n> Indeed.\n> \n> For the sparse people:\n> \n> The full error is:\n> \n>         drivers/net/appletalk/cops.c:382:17: error: incompatible types\n> in conditional expression (different base types):\n>         drivers/net/appletalk/cops.c:382:17:    unsigned char\n>         drivers/net/appletalk/cops.c:382:17:    void\n> \n> Basically, sparse doesn't like \"a ? b : c\", if the return types of\n> b and c don't match, even if the resulting value is not used.\n\nWell, you know that the motivation for sparse was to be stricter than GCC.\nIn this case it's simply what is required by the standard:\n\t    \n    n1570 (C11) 6.5.15\n\tOne of the following shall hold for the second and third operands:\n\t\u2014 both operands have arithmetic type;\n\t\u2014 both operands have the same structure or union type;\n\t\u2014 both operands have void type;\n\t\u2014 both operands are pointers to qualified or unqualified versions\n          of compatible types;\n\t\u2014 one operand is a pointer and the other is a null pointer constant; or\n\t\u2014 one operand is a pointer to an object type and the other is a\n          pointer to a qualified or unqualified version of void.\n\nAlso, yes, the type checking is independent from the fact of being used\nor not (because the type of an expression must be know before any kind\nof processing can be done on its value).\n\n> E.g. outb() on m68k:\n> \n>     #define outb(val, port) (((port) < 1024 && ISA_TYPE ==\n> ISA_TYPE_ENEC) ? isa_rom_outb((val), (port)) : isa_outb((val),\n> (port)))\n> \n> where isa_rom_outb() leads to rom_out_8() returning u8, while\n> isa_outb() leads to the out_8() that includes the cast to void.\n> \n> So the best solution seems to be to add more \"(void)\" casts, to e.g.\n> rom_out_8() and friends?\n\nI kinda think so, yes (I suppose that rom_out_8() is never used as\nreturning a non-void value). But in truth, I think it's the excessive use\nof relatively complex macros that is the real problem (an using a conditional\nexpression not for its value but for its side-effects). Can't outb() be\nwritten as something like:\n\tstatic inline void outb(....) {\n\t\tif (port < 1024 && ISA_TYPE == ISA_TYPE_ENEC)\n\t\t\tisa_rom_outb(val, port);\n\t\telse\n\t\t\tisa_outb(val, port);\n\t}\n\nWith this you have better type checking, no trickery, no need for extra\ncasts, no problems with double evaluation, it's more readable (to me), ...\nBut yes, I suppose it's not really simple to convert all this. Sorry for\nno being more helpful.\n\nBest regards,\n-- Luc\n",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165321979631878.mbox",
          "message_id": "<20220522114418.vcirenoehfx4efas () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:44:18+00:00",
          "date_str": "Sun, 22 May 2022 11:44:18 +0000",
          "body": "On Fri, May 20, 2022 at 02:40:20PM +0200, Geert Uytterhoeven wrote:\n> Hi G\u00fcnter\n> \n> On Thu, May 19, 2022 at 8:48 AM Guenter Roeck <linux@roeck-us.net> wrote:\n> > This is getting tiresome. Every driver using outb() on m68k will\n> > experience that \"problem\". As far as I can see, it is caused by\n> >\n> > #define out_8(addr,b) (void)((*(__force volatile u8 *) (unsigned long)(addr)) = (b))\n\nNot directly related to the root cause but the cast on the LHS is over-complex.\n*) If the types are correct, 'addr' should always be a 'u8 __iomem *'. Casting\n   it to an unsigned long will throw away all type checking: pointers of\n   any size, of any address space, any kind of integer, any scalar value will\n   be silently be accepted.\n*) Then, when casting an integer to a pointer '__force' is unneeded because\n   it's meaningless (because the integer has no type info about the pointee).\n\nThe most correct way to write the above would be:\n\tstatic inline void out_8(u8 __iomem *addr, ... b)\n\t{\n\t\t*((__force volatile u8 *)addr) = b;\n\t}\nthis way, you can typecheck 'addr' (but maybe it's the idea/the argument is\nnot always type clean?).\nOtherwise, if the cast to unsigned long is kept, '__force' can be removed.\n \n> \n> Indeed.\n> \n> For the sparse people:\n> \n> The full error is:\n> \n>         drivers/net/appletalk/cops.c:382:17: error: incompatible types\n> in conditional expression (different base types):\n>         drivers/net/appletalk/cops.c:382:17:    unsigned char\n>         drivers/net/appletalk/cops.c:382:17:    void\n> \n> Basically, sparse doesn't like \"a ? b : c\", if the return types of\n> b and c don't match, even if the resulting value is not used.\n\nWell, you know that the motivation for sparse was to be stricter than GCC.\nIn this case it's simply what is required by the standard:\n\t    \n    n1570 (C11) 6.5.15\n\tOne of the following shall hold for the second and third operands:\n\t\u2014 both operands have arithmetic type;\n\t\u2014 both operands have the same structure or union type;\n\t\u2014 both operands have void type;\n\t\u2014 both operands are pointers to qualified or unqualified versions\n          of compatible types;\n\t\u2014 one operand is a pointer and the other is a null pointer constant; or\n\t\u2014 one operand is a pointer to an object type and the other is a\n          pointer to a qualified or unqualified version of void.\n\nAlso, yes, the type checking is independent from the fact of being used\nor not (because the type of an expression must be know before any kind\nof processing can be done on its value).\n\n> E.g. outb() on m68k:\n> \n>     #define outb(val, port) (((port) < 1024 && ISA_TYPE ==\n> ISA_TYPE_ENEC) ? isa_rom_outb((val), (port)) : isa_outb((val),\n> (port)))\n> \n> where isa_rom_outb() leads to rom_out_8() returning u8, while\n> isa_outb() leads to the out_8() that includes the cast to void.\n> \n> So the best solution seems to be to add more \"(void)\" casts, to e.g.\n> rom_out_8() and friends?\n\nI kinda think so, yes (I suppose that rom_out_8() is never used as\nreturning a non-void value). But in truth, I think it's the excessive use\nof relatively complex macros that is the real problem (an using a conditional\nexpression not for its value but for its side-effects). Can't outb() be\nwritten as something like:\n\tstatic inline void outb(....) {\n\t\tif (port < 1024 && ISA_TYPE == ISA_TYPE_ENEC)\n\t\t\tisa_rom_outb(val, port);\n\t\telse\n\t\t\tisa_outb(val, port);\n\t}\n\nWith this you have better type checking, no trickery, no need for extra\ncasts, no problems with double evaluation, it's more readable (to me), ...\nBut yes, I suppose it's not really simple to convert all this. Sorry for\nno being more helpful.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165328710222462.mbox",
          "message_id": "<20220522115700.vg4hsytav74sy3x6 () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:57:00+00:00",
          "date_str": "Sun, 22 May 2022 11:57:00 +0000",
          "body": "On Fri, May 20, 2022 at 02:46:20PM +0200, Geert Uytterhoeven wrote:\n> > The \"(void)\" makes sure there is no return value.\n> > Which matters if the result of a function returning void is propagated\n> > to another function returning void.\n> \n> Which, FTR, sparse also doesn't like:\n> \n>     error: return expression in void function\n\n\nYou should get this message only if the expression is itself not void.\nFor example:\n\t$ cat test.c\n\textern void fun(void);\n\t\n\tstatic void ko(int *ptr)\n\t{\n\t\treturn *ptr;\n\t}\n\t\n\tstatic void ok1(int *ptr)\n\t{\n\t\treturn (void) *ptr;\n\t}\n\t\n\tstatic void ok2(int *ptr)\n\t{\n\t\treturn fun();\n\t}\n\t$ sparse test.c\n\ttest.c:5:16: error: return expression in void function\n\nIOW, sparse warn only for the ko() but not for ok1() or ok2().\n\nIf you have a case whee it s not the case, please send me the\npre-processed file and I'll be glad to investigate.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165322055932174.mbox",
          "message_id": "<20220522115700.vg4hsytav74sy3x6 () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:57:00+00:00",
          "date_str": "Sun, 22 May 2022 11:57:00 +0000",
          "body": "On Fri, May 20, 2022 at 02:46:20PM +0200, Geert Uytterhoeven wrote:\n> > The \"(void)\" makes sure there is no return value.\n> > Which matters if the result of a function returning void is propagated\n> > to another function returning void.\n> \n> Which, FTR, sparse also doesn't like:\n> \n>     error: return expression in void function\n\n\nYou should get this message only if the expression is itself not void.\nFor example:\n\t$ cat test.c\n\textern void fun(void);\n\t\n\tstatic void ko(int *ptr)\n\t{\n\t\treturn *ptr;\n\t}\n\t\n\tstatic void ok1(int *ptr)\n\t{\n\t\treturn (void) *ptr;\n\t}\n\t\n\tstatic void ok2(int *ptr)\n\t{\n\t\treturn fun();\n\t}\n\t$ sparse test.c\n\ttest.c:5:16: error: return expression in void function\n\nIOW, sparse warn only for the ko() but not for ok1() or ok2().\n\nIf you have a case whee it s not the case, please send me the\npre-processed file and I'll be glad to investigate.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165325461411203.mbox",
          "message_id": "<20220522115700.vg4hsytav74sy3x6 () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:57:00+00:00",
          "date_str": "Sun, 22 May 2022 11:57:00 +0000",
          "body": "On Fri, May 20, 2022 at 02:46:20PM +0200, Geert Uytterhoeven wrote:\n> > The \"(void)\" makes sure there is no return value.\n> > Which matters if the result of a function returning void is propagated\n> > to another function returning void.\n> \n> Which, FTR, sparse also doesn't like:\n> \n>     error: return expression in void function\n\n\nYou should get this message only if the expression is itself not void.\nFor example:\n\t$ cat test.c\n\textern void fun(void);\n\t\n\tstatic void ko(int *ptr)\n\t{\n\t\treturn *ptr;\n\t}\n\t\n\tstatic void ok1(int *ptr)\n\t{\n\t\treturn (void) *ptr;\n\t}\n\t\n\tstatic void ok2(int *ptr)\n\t{\n\t\treturn fun();\n\t}\n\t$ sparse test.c\n\ttest.c:5:16: error: return expression in void function\n\nIOW, sparse warn only for the ko() but not for ok1() or ok2().\n\nIf you have a case whee it s not the case, please send me the\npre-processed file and I'll be glad to investigate.\n\nBest regards,\n-- Luc\n",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165322055732167.mbox",
          "message_id": "<20220522115700.vg4hsytav74sy3x6 () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:57:00+00:00",
          "date_str": "Sun, 22 May 2022 11:57:00 +0000",
          "body": "On Fri, May 20, 2022 at 02:46:20PM +0200, Geert Uytterhoeven wrote:\n> > The \"(void)\" makes sure there is no return value.\n> > Which matters if the result of a function returning void is propagated\n> > to another function returning void.\n> \n> Which, FTR, sparse also doesn't like:\n> \n>     error: return expression in void function\n\n\nYou should get this message only if the expression is itself not void.\nFor example:\n\t$ cat test.c\n\textern void fun(void);\n\t\n\tstatic void ko(int *ptr)\n\t{\n\t\treturn *ptr;\n\t}\n\t\n\tstatic void ok1(int *ptr)\n\t{\n\t\treturn (void) *ptr;\n\t}\n\t\n\tstatic void ok2(int *ptr)\n\t{\n\t\treturn fun();\n\t}\n\t$ sparse test.c\n\ttest.c:5:16: error: return expression in void function\n\nIOW, sparse warn only for the ko() but not for ok1() or ok2().\n\nIf you have a case whee it s not the case, please send me the\npre-processed file and I'll be glad to investigate.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165322055732168.mbox",
          "message_id": "<20220522115700.vg4hsytav74sy3x6 () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:57:00+00:00",
          "date_str": "Sun, 22 May 2022 11:57:00 +0000",
          "body": "On Fri, May 20, 2022 at 02:46:20PM +0200, Geert Uytterhoeven wrote:\n> > The \"(void)\" makes sure there is no return value.\n> > Which matters if the result of a function returning void is propagated\n> > to another function returning void.\n> \n> Which, FTR, sparse also doesn't like:\n> \n>     error: return expression in void function\n\n\nYou should get this message only if the expression is itself not void.\nFor example:\n\t$ cat test.c\n\textern void fun(void);\n\t\n\tstatic void ko(int *ptr)\n\t{\n\t\treturn *ptr;\n\t}\n\t\n\tstatic void ok1(int *ptr)\n\t{\n\t\treturn (void) *ptr;\n\t}\n\t\n\tstatic void ok2(int *ptr)\n\t{\n\t\treturn fun();\n\t}\n\t$ sparse test.c\n\ttest.c:5:16: error: return expression in void function\n\nIOW, sparse warn only for the ko() but not for ok1() or ok2().\n\nIf you have a case whee it s not the case, please send me the\npre-processed file and I'll be glad to investigate.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        },
        {
          "filepath": "emails/2022/05/165322055832171.mbox",
          "message_id": "<20220522115700.vg4hsytav74sy3x6 () mail>",
          "author_name": "Luc Van Oostenryck",
          "author_email": "luc.vanoostenryck () gmail ! com",
          "subject": "Re: [linux-next:master] BUILD REGRESSION 736ee37e2e8eed7fe48d0a37ee5a709514d478b3",
          "date": "2022-05-22 11:57:00+00:00",
          "date_str": "Sun, 22 May 2022 11:57:00 +0000",
          "body": "On Fri, May 20, 2022 at 02:46:20PM +0200, Geert Uytterhoeven wrote:\n> > The \"(void)\" makes sure there is no return value.\n> > Which matters if the result of a function returning void is propagated\n> > to another function returning void.\n> \n> Which, FTR, sparse also doesn't like:\n> \n>     error: return expression in void function\n\n\nYou should get this message only if the expression is itself not void.\nFor example:\n\t$ cat test.c\n\textern void fun(void);\n\t\n\tstatic void ko(int *ptr)\n\t{\n\t\treturn *ptr;\n\t}\n\t\n\tstatic void ok1(int *ptr)\n\t{\n\t\treturn (void) *ptr;\n\t}\n\t\n\tstatic void ok2(int *ptr)\n\t{\n\t\treturn fun();\n\t}\n\t$ sparse test.c\n\ttest.c:5:16: error: return expression in void function\n\nIOW, sparse warn only for the ko() but not for ok1() or ok2().\n\nIf you have a case whee it s not the case, please send me the\npre-processed file and I'll be glad to investigate.\n\nBest regards,\n-- Luc",
          "year": "2022",
          "month": "05"
        }
      ],
      "primary_category": "address_space"
    },
    {
      "subject": "[PATCH v3 2/2] Documentation: dev-tools: Enhance static analysis section with discussion",
      "normalized_subject": "Documentation: dev-tools: Enhance static analysis section with discussion",
      "message_count": 2,
      "participants": [
        "Dan Carpenter",
        "Marcelo Schmitt"
      ],
      "categories": [
        "type_system",
        "general",
        "sparse_internals",
        "address_space"
      ],
      "first_date": "2022-03-30T21:49:59+00:00",
      "last_date": "2022-03-31T08:14:10+00:00",
      "year": 2022,
      "messages": [
        {
          "filepath": "emails/2022/03/164867701432696.mbox",
          "message_id": "<62f461a20600b95e694016c4e5348ef2e260fa87.1648674305.git.marcelo.schmitt1 () gmail ! com>",
          "author_name": "Marcelo Schmitt",
          "author_email": "marcelo.schmitt1 () gmail ! com",
          "subject": "[PATCH v3 2/2] Documentation: dev-tools: Enhance static analysis section with discussion",
          "date": "2022-03-30 21:49:59+00:00",
          "date_str": "Wed, 30 Mar 2022 21:49:59 +0000",
          "body": "Enhance the static analysis tools section with a discussion on when to\nuse each of them.\n\nThis was mainly taken from Dan Carpenter and Julia Lawall's comments on\na previous documentation patch for static analysis tools.\n\nLore: https://lore.kernel.org/linux-doc/20220329090911.GX3293@kadam/T/#mb97770c8e938095aadc3ee08f4ac7fe32ae386e6\n\nSigned-off-by: Marcelo Schmitt <marcelo.schmitt1@gmail.com>\nAcked-by: David Gow <davidgow@google.com>\nCc: Dan Carpenter <dan.carpenter@oracle.com>\nCc: Julia Lawall <julia.lawall@inria.fr>\n---\nChange log v2 -> v3:\n- Changed the paragraph about Sparse to make it sound better (hopefully)\n- Minor adjusts to make the considerations about Coccinelle sound better\n  and be precise\n\n Documentation/dev-tools/testing-overview.rst | 32 ++++++++++++++++++++\n 1 file changed, 32 insertions(+)\n\ndiff --git a/Documentation/dev-tools/testing-overview.rst b/Documentation/dev-tools/testing-overview.rst\nindex b5e02dd3fd94..0aaf6ea53608 100644\n--- a/Documentation/dev-tools/testing-overview.rst\n+++ b/Documentation/dev-tools/testing-overview.rst\n@@ -146,3 +146,35 @@ Documentation/dev-tools/coccinelle.rst documentation page for details.\n \n Beware, though, that static analysis tools suffer from **false positives**.\n Errors and warns need to be evaluated carefully before attempting to fix them.\n+\n+When to use Sparse and Smatch\n+-----------------------------\n+\n+Sparse does type checking, such as verifying that annotated variables do not\n+cause endianness bugs, detecting places that use ``__user`` pointers improperly,\n+and analyzing the compatibility of symbol initializers.\n+\n+Smatch does flow analysis and, if allowed to build the function database, it\n+also does cross function analysis. Smatch tries to answer questions like where\n+is this buffer allocated? How big is it? Can this index be controlled by the\n+user? Is this variable larger than that variable?\n+\n+It's generally easier to write checks in Smatch than it is to write checks in\n+Sparse. Nevertheless, there are some overlaps between Sparse and Smatch checks.\n+\n+Strong points of Smatch and Coccinelle\n+--------------------------------------\n+\n+Coccinelle is probably the easiest for writing checks. It works before the\n+pre-processor so it's easier to check for bugs in macros using Coccinelle.\n+Coccinelle also creates patches for you, which no other tool does.\n+\n+For example, with Coccinelle you can do a mass conversion from\n+``kmalloc(x * size, GFP_KERNEL)`` to ``kmalloc_array(x, size, GFP_KERNEL)``, and\n+that's really useful. If you just created a Smatch warning and try to push the\n+work of converting on to the maintainers they would be annoyed. You'd have to\n+argue about each warning if can really overflow or not.\n+\n+Coccinelle does no analysis of variable values, which is the strong point of\n+Smatch. On the other hand, Coccinelle allows you to do simple things in a simple\n+way.\n-- \n2.35.1\n",
          "year": "2022",
          "month": "03"
        },
        {
          "filepath": "emails/2022/03/164871447015766.mbox",
          "message_id": "<20220331081409.GY12805 () kadam>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () oracle ! com",
          "subject": "Re: [PATCH v2 2/2] Documentation: dev-tools: Enhance static analysis section with discussion",
          "date": "2022-03-31 08:14:10+00:00",
          "date_str": "Thu, 31 Mar 2022 08:14:10 +0000",
          "body": "On Wed, Mar 30, 2022 at 10:48:13AM +0800, David Gow wrote:\n> > +\n> > +Smatch does flow analysis and, if allowed to build the function database, it\n> > +also does cross function analysis. Smatch tries to answer questions like where\n> > +is this buffer allocated? How big is it? Can this index be controlled by the\n> > +user? Is this variable larger than that variable?\n> > +\n> > +It's generally easier to write checks in Smatch than it is to write checks in\n> > +Sparse. Nevertheless, there are some overlaps between Sparse and Smatch checks\n> > +because there is no reason for re-implementing Sparse's check in Smatch.\n> \n> This last sentence isn't totally clear to me. Should this \"because\" be \"so\"?\n> \n\nI stopped reading your email when you wrote \"Cheers, David\" but I should\nhave scrolled down.\n\nThere is not very much overlap between Sparse and Smatch.  Both have a\nwarning for if (!x & y).  That is a tiny thing.  The big overlap is when\nit comes to the locking checks.  The Smatch check for locking is\nhonestly way better and more capable.\n\nI always run both Sparse and Smatch on my patches.  I should run\nCoccinelle as well, but I'm more familiar with Sparse and Smatch.\n\nregards,\ndan carpenter\n",
          "year": "2022",
          "month": "03"
        }
      ],
      "primary_category": "address_space"
    }
  ]
}