{
  "year": "2026",
  "stats": {
    "total_threads": 16,
    "total_messages": 107,
    "categories": {
      "sparse_internals": 2,
      "compiler_compat": 4,
      "general": 6,
      "rfc_proposals": 1,
      "kernel_integration": 2,
      "context_analysis": 1
    }
  },
  "threads": [
    {
      "subject": "[PATCH] sparse/pre-process: don't update next->pos in collect_arg()",
      "normalized_subject": "sparse/pre-process: don't update next->pos in collect_arg()",
      "message_count": 1,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2026-01-18T14:55:19+00:00",
      "last_date": "2026-01-18T14:55:19+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176875090412320.mbox",
          "message_id": "<aWz0V_zQ47afKFJy () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/pre-process: don't update next->pos in collect_arg()",
          "date": "2026-01-18 14:55:19+00:00",
          "date_str": "Sun, 18 Jan 2026 14:55:19 +0000",
          "body": "I don't quite understand why the expand() -> collect_arg() path\nupdates ->pos for each token in the input *list, but this breaks\ndissect and thus semind.\n\nChange collect_arg() to update next->pos only if \"preprocess_only\"\nis true, the \"if (preprocess_only)\" block in sparse_tokenstream()\nrelies on the current behaviour.\n\nTest-case:\n\n\t$ cat -n PP_POS.c\n\t     1\t#define READ_ONCE(x) x\n\t     2\t#define WRITE_ONCE(x, y) x = y\n\t     3\n\t     4\tint R, W;\n\t     5\n\t     6\tvoid func(void)\n\t     7\t{\n\t     8\t  WRITE_ONCE(\n\t     9\t     W,\n\t    10\t     READ_ONCE(R)\n\t    11\t  );\n\t    12\t}\n\n\t$ ./test-dissect PP_POS.c\n\t   4:5                    def   v R                                int\n\t   4:8                    def   v W                                int\n\t   6:6                    def   f func                             void ( ... )\n\t   8:3   func             -w-   v W                                int\n\t   8:3   func             -r-   v R                                int\n\nThe reported positions of the usage of R and W are wrong, and thus\n./semind doesn't work:\n\n\t$ ./semind add PP_POS.c\n\t$ ./semind search -l PP_POS.c:10:16\n\nWith this patch:\n\n\t$ ./test-dissect PP_POS.c\n\t   4:5                    def   v R                                int\n\t   4:8                    def   v W                                int\n\t   6:6                    def   f func                             void ( ... )\n\t   9:6   func             -w-   v W                                int\n\t  10:16  func             -r-   v R                                int\n\n\t$ ./semind add PP_POS.c\n\t$ ./semind search -l PP_POS.c:10:16\n\t(def) PP_POS.c\t4\t5\t\tint R, W;\n\t(-r-) PP_POS.c\t10\t16\tfunc\tREAD_ONCE(R)\n\nSee also the changes in validation/parsing/attr-cleanup.c and\nvalidation/sizeof-void.c, the updated positions look more correct.\n\nSuggested-by: Chris Li <sparse@chrisli.org>\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n pre-process.c                     | 9 ++++++---\n validation/parsing/attr-cleanup.c | 2 +-\n validation/sizeof-void.c          | 2 +-\n 3 files changed, 8 insertions(+), 5 deletions(-)\n\ndiff --git a/pre-process.c b/pre-process.c\nindex 3fb25082..5ab4810d 100644\n--- a/pre-process.c\n+++ b/pre-process.c\n@@ -294,9 +294,12 @@ static struct token *collect_arg(struct token *prev, int vararg, struct position\n \t\t} else if (match_op(next, ',') && !nesting && !vararg) {\n \t\t\tbreak;\n \t\t}\n-\t\tnext->pos.stream = pos->stream;\n-\t\tnext->pos.line = pos->line;\n-\t\tnext->pos.pos = pos->pos;\n+\t\t/* See \"if (preprocess_only)\" in sparse_tokenstream() */\n+\t\tif (preprocess_only) {\n+\t\t\tnext->pos.stream = pos->stream;\n+\t\t\tnext->pos.line = pos->line;\n+\t\t\tnext->pos.pos = pos->pos;\n+\t\t}\n \t\tnext->pos.newline = 0;\n \t\tp = &next->next;\n \t}\ndiff --git a/validation/parsing/attr-cleanup.c b/validation/parsing/attr-cleanup.c\nindex ac64649c..fa3cb1ca 100644\n--- a/validation/parsing/attr-cleanup.c\n+++ b/validation/parsing/attr-cleanup.c\n@@ -24,7 +24,7 @@ int test(int n)\n  * check-command: sparse -Wunknown-attribute $file\n  *\n  * check-error-start\n-parsing/attr-cleanup.c:10:17: error: argument is not an identifier\n+parsing/attr-cleanup.c:10:27: error: argument is not an identifier\n parsing/attr-cleanup.c:11:39: error: an argument is expected for attribute 'cleanup'\n parsing/attr-cleanup.c:12:40: error: an argument is expected for attribute 'cleanup'\n parsing/attr-cleanup.c:13:43: error: Expected ) after attribute's argument'\ndiff --git a/validation/sizeof-void.c b/validation/sizeof-void.c\nindex 0fd917a2..6792ff02 100644\n--- a/validation/sizeof-void.c\n+++ b/validation/sizeof-void.c\n@@ -36,7 +36,7 @@ sizeof-void.c:16:14: warning: expression using sizeof(void)\n sizeof-void.c:17:14: warning: expression using sizeof(void)\n sizeof-void.c:18:14: warning: expression using sizeof(void)\n sizeof-void.c:19:14: warning: expression using sizeof(void)\n-sizeof-void.c:20:14: warning: expression using sizeof(void)\n+sizeof-void.c:20:27: warning: expression using sizeof(void)\n sizeof-void.c:21:14: warning: expression using sizeof(void)\n sizeof-void.c:22:14: warning: expression using sizeof(void)\n sizeof-void.c:23:14: warning: expression using sizeof(void)\n-- \n2.52.0\n\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH v2 3/3] module: Add compile-time check for embedded NUL characters",
      "normalized_subject": "module: Add compile-time check for embedded NUL characters",
      "message_count": 1,
      "participants": [
        "Chris Li"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2026-01-16T23:35:06+00:00",
      "last_date": "2026-01-16T23:35:06+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176860929328180.mbox",
          "message_id": "<CACePvbU5Pqo=bw_j8arOq16o1JBOSwPtuMZBVozy4FV7YsSLGw () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH v2 3/3] module: Add compile-time check for embedded NUL characters",
          "date": "2026-01-16 23:35:06+00:00",
          "date_str": "Fri, 16 Jan 2026 23:35:06 +0000",
          "body": "On Fri, Dec 19, 2025 at 6:59=E2=80=AFAM Matthieu Baerts <matttbe@kernel.org=\n> wrote:\n>\n> Hi Dan, Daniel\n>\n> On 19/12/2025 13:44, Dan Carpenter wrote:\n> > On Fri, Dec 19, 2025 at 01:29:21PM +0100, Matthieu Baerts wrote:\n> >> net/mptcp/crypto_test.c:72:1: error: bad integer constant expression\n> >> net/mptcp/crypto_test.c:72:1: error: static assertion failed: \"MODULE_=\nINFO(license, ...) contains embedded NUL byte\"\n> >> net/mptcp/crypto_test.c:73:1: error: bad integer constant expression\n> >> net/mptcp/crypto_test.c:73:1: error: static assertion failed: \"MODULE_=\nINFO(description, ...) contains embedded NUL byte\"\n> >\n> > There was a fix for that posted.  Let me ping them to see if anyone is\n> > planning to send an actual patch.\n\nShould I wait for the actual patch for sparse?\n\n> >\n> > https://lore.kernel.org/all/20251211175101.GA3405942@google.com/\n>\n> Thank you both for your reply! I didn't think about looking at the v1.\n>\n> I confirm that Sami's patch silences the errors on my side. Thanks!\n\nThanks for the report.\n\nChris\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH] sparse: update MAINTAINERS info.",
      "normalized_subject": "sparse: update MAINTAINERS info.",
      "message_count": 1,
      "participants": [
        "Chris Li"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2026-01-16T23:31:30+00:00",
      "last_date": "2026-01-16T23:31:30+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176860910927986.mbox",
          "message_id": "<CACePvbVNiWKOHxT0GAtFUp7QcP7t43RZnZR75yM_SR28a6TNvA () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] sparse: update MAINTAINERS info.",
          "date": "2026-01-16 23:31:30+00:00",
          "date_str": "Fri, 16 Jan 2026 23:31:30 +0000",
          "body": "Acked-by: Chris LI <sparse@chrisli.org>\n\nChris\n\nOn Wed, Dec 17, 2025 at 10:09=E2=80=AFPM Randy Dunlap <rdunlap@infradead.or=\ng> wrote:\n>\n> Chris Li is back as sparse maintainer.\n>\n> See https://git.kernel.org/pub/scm/devel/sparse/sparse.git/commit/?id=3D6=\n7f0a03cee4637e495151c48a02be642a158cbbb\n>\n> Signed-off-by: Randy Dunlap <rdunlap@infradead.org>\n> ---\n> Cc: Chris Li <sparse@chrisli.org>\n> Cc: Andrew Morton <akpm@linux-foundation.org>\n> Cc: linux-sparse@vger.kernel.org\n> ---\n>  MAINTAINERS |    2 +-\n>  1 file changed, 1 insertion(+), 1 deletion(-)\n>\n> --- linux-next-20251217.orig/MAINTAINERS\n> +++ linux-next-20251217/MAINTAINERS\n> @@ -24595,7 +24595,7 @@ F:      drivers/tty/vcc.c\n>  F:     include/linux/sunserialcore.h\n>\n>  SPARSE CHECKER\n> -M:     \"Luc Van Oostenryck\" <luc.vanoostenryck@gmail.com>\n> +M:     Chris Li <sparse@chrisli.org>\n>  L:     linux-sparse@vger.kernel.org\n>  S:     Maintained\n>  W:     https://sparse.docs.kernel.org/\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH] sparse: add the new m_pos member into struct expression{EXPR_DEREF}",
      "normalized_subject": "sparse: add the new m_pos member into struct expression{EXPR_DEREF}",
      "message_count": 1,
      "participants": [
        "Chris Li"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2026-01-16T22:55:34+00:00",
      "last_date": "2026-01-16T22:55:34+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176860695526609.mbox",
          "message_id": "<CACePvbWfwsu_gEUqfg47joLpD=UmO5Rj7hyoJFgiLzv5LyRFCw () mail ! gmail ! com>",
          "author_name": "Chris Li",
          "author_email": "sparse () chrisli ! org",
          "subject": "Re: [PATCH] sparse: add the new m_pos member into struct expression{EXPR_DEREF}",
          "date": "2026-01-16 22:55:34+00:00",
          "date_str": "Fri, 16 Jan 2026 22:55:34 +0000",
          "body": "Hi Oleg,\n\nApplied to sparse-dev.\n\nChris\n\n\n\nChris\n\nOn Tue, Dec 16, 2025 at 5:40=E2=80=AFAM Oleg Nesterov <oleg@redhat.com> wro=\nte:\n>\n> Test-case:\n>\n>         $ cat -n MEMPOS.c\n>              1  struct T {\n>              2   int mem;\n>              3  } X;\n>              4\n>              5  void func(struct T *x)\n>              6  {\n>              7   x -> mem =3D 1;\n>              8   X .  mem =3D 2;\n>              9  }\n>\n>         $ ./test-dissect MEMPOS.c | grep -F T.mem\n>            2:6                    def   m T.mem                          =\n  int\n>            7:4   func             -w-   m T.mem                          =\n  int\n>            8:4   func             -w-   m T.mem                          =\n  int\n>\n> Note that the reported position of .mem usage is wrong. This is because\n> do_expression(EXPR_DEREF) uses &expr->pos which is position of TOKEN_SPEC=\nIAL,\n> not the position of the next token (mem).\n>\n> This also breaks \"semind search -l\" (search by location)\n>\n>         $ ./semind add MEMPOS.c\n>         $ ./semind search -l MEMPOS.c:7:7\n>\n> reports nothing.\n>\n> With this patch:\n>\n>         $ ./test-dissect MEMPOS.c | grep -F T.mem\n>            2:6                    def   m T.mem                          =\n  int\n>            7:7   func             -w-   m T.mem                          =\n  int\n>            8:7   func             -w-   m T.mem                          =\n  int\n>\n>         $ ./semind add MEMPOS.c\n>         $ ./semind search -l MEMPOS.c:7:7\n>         (def) MEMPOS.c  2       6                int mem;\n>         (-w-) MEMPOS.c  7       7       func     x -> mem =3D 1;\n>         (-w-) MEMPOS.c  8       7       func     X .  mem =3D 2;\n>\n> Signed-off-by: Oleg Nesterov <oleg@redhat.com>\n> ---\n>  dissect.c    | 2 +-\n>  expression.c | 1 +\n>  expression.h | 1 +\n>  3 files changed, 3 insertions(+), 1 deletion(-)\n>\n> diff --git a/dissect.c b/dissect.c\n> index 9419c593..a6003afa 100644\n> --- a/dissect.c\n> +++ b/dissect.c\n> @@ -454,7 +454,7 @@ again:\n>                         p_mode =3D U_R_VAL;\n>                 p_type =3D do_expression(p_mode, expr->deref);\n>\n> -               ret =3D report_member(mode, &expr->pos, p_type,\n> +               ret =3D report_member(mode, &expr->m_pos, p_type,\n>                         lookup_member(p_type, expr->member, NULL));\n>         }\n>\n> diff --git a/expression.c b/expression.c\n> index 727e7056..b23107da 100644\n> --- a/expression.c\n> +++ b/expression.c\n> @@ -605,6 +605,7 @@ static struct token *postfix_expression(struct token =\n*token, struct expression *\n>                                 break;\n>                         }\n>                         deref->member =3D token->ident;\n> +                       deref->m_pos =3D token->pos;\n>                         token =3D token->next;\n>                         expr =3D deref;\n>                         continue;\n> diff --git a/expression.h b/expression.h\n> index 8bf40d32..ce8a29ce 100644\n> --- a/expression.h\n> +++ b/expression.h\n> @@ -202,6 +202,7 @@ struct expression {\n>                 struct /* deref_arg */ {\n>                         struct expression *deref;\n>                         struct ident *member;\n> +                       struct position m_pos;\n>                 };\n>                 // EXPR_SLICE\n>                 struct /* slice */ {\n> --\n> 2.52.0\n>\n>\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH] compiler: Use __typeof_unqual__() for __unqual_scalar_typeof()",
      "normalized_subject": "compiler: Use __typeof_unqual__() for __unqual_scalar_typeof()",
      "message_count": 4,
      "participants": [
        "Ian Rogers",
        "Thomas Gleixner"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat",
        "sparse_internals",
        "type_system"
      ],
      "first_date": "2026-01-16T18:18:16+00:00",
      "last_date": "2026-01-17T05:25:19+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176859028912296.mbox",
          "message_id": "<87ecnp2zh3.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "[PATCH] compiler: Use __typeof_unqual__() for __unqual_scalar_typeof()",
          "date": "2026-01-16 18:18:16+00:00",
          "date_str": "Fri, 16 Jan 2026 18:18:16 +0000",
          "body": "From: Peter Zijlstra <peterz@infradead.org>\n\nThe recent changes to get_unaligned() resulted in a new sparse warning:\n\n   net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n   net/rds/ib_cm.c:96:35: sparse:     expected void *\n   net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n \nThe updated get_unaligned_t() uses __unqual_scalar_typeof() to get an\nunqualified type. This works correctly for the compilers, but fails for\nsparse when the data type is __be64 (or any other __beNN variant).\n\nOn sparse runs (C=[12]) __beNN types are annotated with\n__attribute__((bitwise)).\n\nThat annotation allows sparse to detect incompatible operations on __beNN\nvariables, but it also prevents sparse from evaluating the _Generic() in\n__unqual_scalar_typeof() and map __beNN to a unqualified scalar type, so it\nends up with the default, i.e. the original qualified type of a 'const\n__beNN' pointer. That then ends up as the first pointer argument to\nbuiltin_memcpy(), which obviously causes the above sparse warnings.\n\nThe sparse git tree supports typeof_unqual() now, which allows to use it\ninstead of the _Generic() based __unqual_scalar_typeof(). With that sparse\ncorrectly evaluates the unqualified type and keeps the __beNN logic intact.\n\nThe downside is that this requires a top of tree sparse build and an old\nsparse version will emit a metric ton of incomprehensible error messages\nbefore it dies with a segfault.\n\nTherefore implement a sanity check which validates that the checker is\navailable and capable of handling typeof_unqual(). Emit a warning if not so\nthe user can take informed action.\n\n[ tglx: Move the evaluation of USE_TYPEOF_UNQUAL to compiler_types.h so it is\n  \tset before use and implement the sanity checker ]\n\nReported-by: kernel test robot <lkp@intel.com>\nSigned-off-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Thomas Gleixner <tglx@kernel.org>\nCloses: https://lore.kernel.org/oe-kbuild-all/202601150001.sKSN644a-lkp@intel.com/\n---\n Makefile                       |    8 ++++++++\n include/linux/compiler.h       |   10 ----------\n include/linux/compiler_types.h |   11 +++++++++++\n scripts/checker-valid.sh       |   19 +++++++++++++++++++\n 4 files changed, 38 insertions(+), 10 deletions(-)\n\n--- a/Makefile\n+++ b/Makefile\n@@ -1178,6 +1178,14 @@ ifdef CONFIG_CC_IS_CLANG\n KBUILD_USERLDFLAGS += --ld-path=$(LD)\n endif\n \n+# Validate the checker is available and functional\n+ifneq ($(KBUILD_CHECKSRC), 0)\n+  ifneq ($(shell $(srctree)/scripts/checker-valid.sh $(CHECK)), 1)\n+    $(warning C=$(KBUILD_CHECKSRC) specified, but $(CHECK) is not available or not up to date)\n+    KBUILD_CHECKSRC = 0\n+  endif\n+endif\n+\n # make the checker run with the right architecture\n CHECKFLAGS += --arch=$(ARCH)\n \n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -231,16 +231,6 @@ void ftrace_likely_update(struct ftrace_\n \t\t\t\t\"must be non-C-string (not NUL-terminated)\")\n \n /*\n- * Use __typeof_unqual__() when available.\n- *\n- * XXX: Remove test for __CHECKER__ once\n- * sparse learns about __typeof_unqual__().\n- */\n-#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n-# define USE_TYPEOF_UNQUAL 1\n-#endif\n-\n-/*\n  * Define TYPEOF_UNQUAL() to use __typeof_unqual__() as typeof\n  * operator when available, to return an unqualified type of the exp.\n  */\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -562,6 +562,13 @@ struct ftrace_likely_data {\n #define asm_inline asm\n #endif\n \n+/*\n+ * Use __typeof_unqual__() when available.\n+ */\n+#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n+# define USE_TYPEOF_UNQUAL 1\n+#endif\n+\n /* Are two types/vars the same type (ignoring qualifiers)? */\n #define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n \n@@ -569,6 +576,7 @@ struct ftrace_likely_data {\n  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n  *\t\t\t       non-scalar types unchanged.\n  */\n+#ifndef USE_TYPEOF_UNQUAL\n /*\n  * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n  * is not type-compatible with 'signed char', and we define a separate case.\n@@ -586,6 +594,9 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n \t\t\t default: (x)))\n+#else\n+#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n+#endif\n \n /* Is this type a native word size -- useful for atomic operations */\n #define __native_word(t) \\\n--- /dev/null\n+++ b/scripts/checker-valid.sh\n@@ -0,0 +1,19 @@\n+#!/bin/sh -eu\n+# SPDX-License-Identifier: GPL-2.0\n+\n+[ ! -x \"$(command -v \"$1\")\" ] && exit 1\n+\n+tmp_file=$(mktemp)\n+trap \"rm -f $tmp_file\" EXIT\n+\n+cat << EOF >$tmp_file\n+static inline int u(const int *q)\n+{\n+\t__typeof_unqual__(*q) v = *q;\n+\treturn v;\n+}\n+EOF\n+\n+# sparse happily exits with 0 on error so validate\n+# there is none on stderr. Use awk as grep is a pain with sh -e\n+$1 $tmp_file 2>&1 | awk -v c=1 '/",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176859028612292.mbox",
          "message_id": "<87ecnp2zh3.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "[PATCH] compiler: Use __typeof_unqual__() for __unqual_scalar_typeof()",
          "date": "2026-01-16 18:18:16+00:00",
          "date_str": "Fri, 16 Jan 2026 18:18:16 +0000",
          "body": "From: Peter Zijlstra <peterz@infradead.org>\n\nThe recent changes to get_unaligned() resulted in a new sparse warning:\n\n   net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n   net/rds/ib_cm.c:96:35: sparse:     expected void *\n   net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n \nThe updated get_unaligned_t() uses __unqual_scalar_typeof() to get an\nunqualified type. This works correctly for the compilers, but fails for\nsparse when the data type is __be64 (or any other __beNN variant).\n\nOn sparse runs (C=[12]) __beNN types are annotated with\n__attribute__((bitwise)).\n\nThat annotation allows sparse to detect incompatible operations on __beNN\nvariables, but it also prevents sparse from evaluating the _Generic() in\n__unqual_scalar_typeof() and map __beNN to a unqualified scalar type, so it\nends up with the default, i.e. the original qualified type of a 'const\n__beNN' pointer. That then ends up as the first pointer argument to\nbuiltin_memcpy(), which obviously causes the above sparse warnings.\n\nThe sparse git tree supports typeof_unqual() now, which allows to use it\ninstead of the _Generic() based __unqual_scalar_typeof(). With that sparse\ncorrectly evaluates the unqualified type and keeps the __beNN logic intact.\n\nThe downside is that this requires a top of tree sparse build and an old\nsparse version will emit a metric ton of incomprehensible error messages\nbefore it dies with a segfault.\n\nTherefore implement a sanity check which validates that the checker is\navailable and capable of handling typeof_unqual(). Emit a warning if not so\nthe user can take informed action.\n\n[ tglx: Move the evaluation of USE_TYPEOF_UNQUAL to compiler_types.h so it is\n  \tset before use and implement the sanity checker ]\n\nReported-by: kernel test robot <lkp@intel.com>\nSigned-off-by: Peter Zijlstra <peterz@infradead.org>\nSigned-off-by: Thomas Gleixner <tglx@kernel.org>\nCloses: https://lore.kernel.org/oe-kbuild-all/202601150001.sKSN644a-lkp@intel.com/\n---\n Makefile                       |    8 ++++++++\n include/linux/compiler.h       |   10 ----------\n include/linux/compiler_types.h |   11 +++++++++++\n scripts/checker-valid.sh       |   19 +++++++++++++++++++\n 4 files changed, 38 insertions(+), 10 deletions(-)\n\n--- a/Makefile\n+++ b/Makefile\n@@ -1178,6 +1178,14 @@ ifdef CONFIG_CC_IS_CLANG\n KBUILD_USERLDFLAGS += --ld-path=$(LD)\n endif\n \n+# Validate the checker is available and functional\n+ifneq ($(KBUILD_CHECKSRC), 0)\n+  ifneq ($(shell $(srctree)/scripts/checker-valid.sh $(CHECK)), 1)\n+    $(warning C=$(KBUILD_CHECKSRC) specified, but $(CHECK) is not available or not up to date)\n+    KBUILD_CHECKSRC = 0\n+  endif\n+endif\n+\n # make the checker run with the right architecture\n CHECKFLAGS += --arch=$(ARCH)\n \n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -231,16 +231,6 @@ void ftrace_likely_update(struct ftrace_\n \t\t\t\t\"must be non-C-string (not NUL-terminated)\")\n \n /*\n- * Use __typeof_unqual__() when available.\n- *\n- * XXX: Remove test for __CHECKER__ once\n- * sparse learns about __typeof_unqual__().\n- */\n-#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n-# define USE_TYPEOF_UNQUAL 1\n-#endif\n-\n-/*\n  * Define TYPEOF_UNQUAL() to use __typeof_unqual__() as typeof\n  * operator when available, to return an unqualified type of the exp.\n  */\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -562,6 +562,13 @@ struct ftrace_likely_data {\n #define asm_inline asm\n #endif\n \n+/*\n+ * Use __typeof_unqual__() when available.\n+ */\n+#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n+# define USE_TYPEOF_UNQUAL 1\n+#endif\n+\n /* Are two types/vars the same type (ignoring qualifiers)? */\n #define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n \n@@ -569,6 +576,7 @@ struct ftrace_likely_data {\n  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n  *\t\t\t       non-scalar types unchanged.\n  */\n+#ifndef USE_TYPEOF_UNQUAL\n /*\n  * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n  * is not type-compatible with 'signed char', and we define a separate case.\n@@ -586,6 +594,9 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n \t\t\t default: (x)))\n+#else\n+#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n+#endif\n \n /* Is this type a native word size -- useful for atomic operations */\n #define __native_word(t) \\\n--- /dev/null\n+++ b/scripts/checker-valid.sh\n@@ -0,0 +1,19 @@\n+#!/bin/sh -eu\n+# SPDX-License-Identifier: GPL-2.0\n+\n+[ ! -x \"$(command -v \"$1\")\" ] && exit 1\n+\n+tmp_file=$(mktemp)\n+trap \"rm -f $tmp_file\" EXIT\n+\n+cat << EOF >$tmp_file\n+static inline int u(const int *q)\n+{\n+\t__typeof_unqual__(*q) v = *q;\n+\treturn v;\n+}\n+EOF\n+\n+# sparse happily exits with 0 on error so validate\n+# there is none on stderr. Use awk as grep is a pain with sh -e\n+$1 $tmp_file 2>&1 | awk -v c=1 '/",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176863030207995.mbox",
          "message_id": "<CAP-5=fUDQ6NTLWVfA2B+3022D6fZjvAksKH5EJ9Agnd1Qzvobw () mail ! gmail ! com>",
          "author_name": "Ian Rogers",
          "author_email": "irogers () google ! com",
          "subject": "Re: [PATCH] compiler: Use __typeof_unqual__() for __unqual_scalar_typeof()",
          "date": "2026-01-17 05:25:19+00:00",
          "date_str": "Sat, 17 Jan 2026 05:25:19 +0000",
          "body": "On Fri, Jan 16, 2026 at 10:18=E2=80=AFAM Thomas Gleixner <tglx@kernel.org> =\nwrote:\n>\n> From: Peter Zijlstra <peterz@infradead.org>\n>\n> The recent changes to get_unaligned() resulted in a new sparse warning:\n>\n>    net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (d=\nifferent modifiers) @@     expected void * @@     got restricted __be64 con=\nst * @@\n>    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>\n> The updated get_unaligned_t() uses __unqual_scalar_typeof() to get an\n> unqualified type. This works correctly for the compilers, but fails for\n> sparse when the data type is __be64 (or any other __beNN variant).\n>\n> On sparse runs (C=3D[12]) __beNN types are annotated with\n> __attribute__((bitwise)).\n>\n> That annotation allows sparse to detect incompatible operations on __beNN\n> variables, but it also prevents sparse from evaluating the _Generic() in\n> __unqual_scalar_typeof() and map __beNN to a unqualified scalar type, so =\nit\n> ends up with the default, i.e. the original qualified type of a 'const\n> __beNN' pointer. That then ends up as the first pointer argument to\n> builtin_memcpy(), which obviously causes the above sparse warnings.\n>\n> The sparse git tree supports typeof_unqual() now, which allows to use it\n> instead of the _Generic() based __unqual_scalar_typeof(). With that spars=\ne\n> correctly evaluates the unqualified type and keeps the __beNN logic intac=\nt.\n\nWow, that's painful. Congratulations on finding the root case.\n\nAcked-by: Ian Rogers <irogers@google.com>\n\nThanks,\nIan\n\n> The downside is that this requires a top of tree sparse build and an old\n> sparse version will emit a metric ton of incomprehensible error messages\n> before it dies with a segfault.\n>\n> Therefore implement a sanity check which validates that the checker is\n> available and capable of handling typeof_unqual(). Emit a warning if not =\nso\n> the user can take informed action.\n>\n> [ tglx: Move the evaluation of USE_TYPEOF_UNQUAL to compiler_types.h so i=\nt is\n>         set before use and implement the sanity checker ]\n>\n> Reported-by: kernel test robot <lkp@intel.com>\n> Signed-off-by: Peter Zijlstra <peterz@infradead.org>\n> Signed-off-by: Thomas Gleixner <tglx@kernel.org>\n> Closes: https://lore.kernel.org/oe-kbuild-all/202601150001.sKSN644a-lkp@i=\nntel.com/\n> ---\n>  Makefile                       |    8 ++++++++\n>  include/linux/compiler.h       |   10 ----------\n>  include/linux/compiler_types.h |   11 +++++++++++\n>  scripts/checker-valid.sh       |   19 +++++++++++++++++++\n>  4 files changed, 38 insertions(+), 10 deletions(-)\n>\n> --- a/Makefile\n> +++ b/Makefile\n> @@ -1178,6 +1178,14 @@ ifdef CONFIG_CC_IS_CLANG\n>  KBUILD_USERLDFLAGS +=3D --ld-path=3D$(LD)\n>  endif\n>\n> +# Validate the checker is available and functional\n> +ifneq ($(KBUILD_CHECKSRC), 0)\n> +  ifneq ($(shell $(srctree)/scripts/checker-valid.sh $(CHECK)), 1)\n> +    $(warning C=3D$(KBUILD_CHECKSRC) specified, but $(CHECK) is not avai=\nlable or not up to date)\n> +    KBUILD_CHECKSRC =3D 0\n> +  endif\n> +endif\n> +\n>  # make the checker run with the right architecture\n>  CHECKFLAGS +=3D --arch=3D$(ARCH)\n>\n> --- a/include/linux/compiler.h\n> +++ b/include/linux/compiler.h\n> @@ -231,16 +231,6 @@ void ftrace_likely_update(struct ftrace_\n>                                 \"must be non-C-string (not NUL-terminated=\n)\")\n>\n>  /*\n> - * Use __typeof_unqual__() when available.\n> - *\n> - * XXX: Remove test for __CHECKER__ once\n> - * sparse learns about __typeof_unqual__().\n> - */\n> -#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n> -# define USE_TYPEOF_UNQUAL 1\n> -#endif\n> -\n> -/*\n>   * Define TYPEOF_UNQUAL() to use __typeof_unqual__() as typeof\n>   * operator when available, to return an unqualified type of the exp.\n>   */\n> --- a/include/linux/compiler_types.h\n> +++ b/include/linux/compiler_types.h\n> @@ -562,6 +562,13 @@ struct ftrace_likely_data {\n>  #define asm_inline asm\n>  #endif\n>\n> +/*\n> + * Use __typeof_unqual__() when available.\n> + */\n> +#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n> +# define USE_TYPEOF_UNQUAL 1\n> +#endif\n> +\n>  /* Are two types/vars the same type (ignoring qualifiers)? */\n>  #define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof=\n(b))\n>\n> @@ -569,6 +576,7 @@ struct ftrace_likely_data {\n>   * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leavi=\nng\n>   *                            non-scalar types unchanged.\n>   */\n> +#ifndef USE_TYPEOF_UNQUAL\n>  /*\n>   * Prefer C11 _Generic for better compile-times and simpler code. Note: =\n'char'\n>   * is not type-compatible with 'signed char', and we define a separate c=\nase.\n> @@ -586,6 +594,9 @@ struct ftrace_likely_data {\n>                          __scalar_type_to_expr_cases(long),             \\\n>                          __scalar_type_to_expr_cases(long long),        \\\n>                          default: (x)))\n> +#else\n> +#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n> +",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176863030707998.mbox",
          "message_id": "<CAP-5=fUDQ6NTLWVfA2B+3022D6fZjvAksKH5EJ9Agnd1Qzvobw () mail ! gmail ! com>",
          "author_name": "Ian Rogers",
          "author_email": "irogers () google ! com",
          "subject": "Re: [PATCH] compiler: Use __typeof_unqual__() for __unqual_scalar_typeof()",
          "date": "2026-01-17 05:25:19+00:00",
          "date_str": "Sat, 17 Jan 2026 05:25:19 +0000",
          "body": "On Fri, Jan 16, 2026 at 10:18=E2=80=AFAM Thomas Gleixner <tglx@kernel.org> =\nwrote:\n>\n> From: Peter Zijlstra <peterz@infradead.org>\n>\n> The recent changes to get_unaligned() resulted in a new sparse warning:\n>\n>    net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (d=\nifferent modifiers) @@     expected void * @@     got restricted __be64 con=\nst * @@\n>    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>\n> The updated get_unaligned_t() uses __unqual_scalar_typeof() to get an\n> unqualified type. This works correctly for the compilers, but fails for\n> sparse when the data type is __be64 (or any other __beNN variant).\n>\n> On sparse runs (C=3D[12]) __beNN types are annotated with\n> __attribute__((bitwise)).\n>\n> That annotation allows sparse to detect incompatible operations on __beNN\n> variables, but it also prevents sparse from evaluating the _Generic() in\n> __unqual_scalar_typeof() and map __beNN to a unqualified scalar type, so =\nit\n> ends up with the default, i.e. the original qualified type of a 'const\n> __beNN' pointer. That then ends up as the first pointer argument to\n> builtin_memcpy(), which obviously causes the above sparse warnings.\n>\n> The sparse git tree supports typeof_unqual() now, which allows to use it\n> instead of the _Generic() based __unqual_scalar_typeof(). With that spars=\ne\n> correctly evaluates the unqualified type and keeps the __beNN logic intac=\nt.\n\nWow, that's painful. Congratulations on finding the root case.\n\nAcked-by: Ian Rogers <irogers@google.com>\n\nThanks,\nIan\n\n> The downside is that this requires a top of tree sparse build and an old\n> sparse version will emit a metric ton of incomprehensible error messages\n> before it dies with a segfault.\n>\n> Therefore implement a sanity check which validates that the checker is\n> available and capable of handling typeof_unqual(). Emit a warning if not =\nso\n> the user can take informed action.\n>\n> [ tglx: Move the evaluation of USE_TYPEOF_UNQUAL to compiler_types.h so i=\nt is\n>         set before use and implement the sanity checker ]\n>\n> Reported-by: kernel test robot <lkp@intel.com>\n> Signed-off-by: Peter Zijlstra <peterz@infradead.org>\n> Signed-off-by: Thomas Gleixner <tglx@kernel.org>\n> Closes: https://lore.kernel.org/oe-kbuild-all/202601150001.sKSN644a-lkp@i=\nntel.com/\n> ---\n>  Makefile                       |    8 ++++++++\n>  include/linux/compiler.h       |   10 ----------\n>  include/linux/compiler_types.h |   11 +++++++++++\n>  scripts/checker-valid.sh       |   19 +++++++++++++++++++\n>  4 files changed, 38 insertions(+), 10 deletions(-)\n>\n> --- a/Makefile\n> +++ b/Makefile\n> @@ -1178,6 +1178,14 @@ ifdef CONFIG_CC_IS_CLANG\n>  KBUILD_USERLDFLAGS +=3D --ld-path=3D$(LD)\n>  endif\n>\n> +# Validate the checker is available and functional\n> +ifneq ($(KBUILD_CHECKSRC), 0)\n> +  ifneq ($(shell $(srctree)/scripts/checker-valid.sh $(CHECK)), 1)\n> +    $(warning C=3D$(KBUILD_CHECKSRC) specified, but $(CHECK) is not avai=\nlable or not up to date)\n> +    KBUILD_CHECKSRC =3D 0\n> +  endif\n> +endif\n> +\n>  # make the checker run with the right architecture\n>  CHECKFLAGS +=3D --arch=3D$(ARCH)\n>\n> --- a/include/linux/compiler.h\n> +++ b/include/linux/compiler.h\n> @@ -231,16 +231,6 @@ void ftrace_likely_update(struct ftrace_\n>                                 \"must be non-C-string (not NUL-terminated=\n)\")\n>\n>  /*\n> - * Use __typeof_unqual__() when available.\n> - *\n> - * XXX: Remove test for __CHECKER__ once\n> - * sparse learns about __typeof_unqual__().\n> - */\n> -#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n> -# define USE_TYPEOF_UNQUAL 1\n> -#endif\n> -\n> -/*\n>   * Define TYPEOF_UNQUAL() to use __typeof_unqual__() as typeof\n>   * operator when available, to return an unqualified type of the exp.\n>   */\n> --- a/include/linux/compiler_types.h\n> +++ b/include/linux/compiler_types.h\n> @@ -562,6 +562,13 @@ struct ftrace_likely_data {\n>  #define asm_inline asm\n>  #endif\n>\n> +/*\n> + * Use __typeof_unqual__() when available.\n> + */\n> +#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n> +# define USE_TYPEOF_UNQUAL 1\n> +#endif\n> +\n>  /* Are two types/vars the same type (ignoring qualifiers)? */\n>  #define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof=\n(b))\n>\n> @@ -569,6 +576,7 @@ struct ftrace_likely_data {\n>   * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leavi=\nng\n>   *                            non-scalar types unchanged.\n>   */\n> +#ifndef USE_TYPEOF_UNQUAL\n>  /*\n>   * Prefer C11 _Generic for better compile-times and simpler code. Note: =\n'char'\n>   * is not type-compatible with 'signed char', and we define a separate c=\nase.\n> @@ -586,6 +594,9 @@ struct ftrace_likely_data {\n>                          __scalar_type_to_expr_cases(long),             \\\n>                          __scalar_type_to_expr_cases(long long),        \\\n>                          default: (x)))\n> +#else\n> +#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n> +",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
      "normalized_subject": "[tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
      "message_count": 21,
      "participants": [
        "Ian Rogers",
        "Thomas Gleixner",
        "Peter Zijlstra",
        "Linus Torvalds"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2026-01-14T17:51:14+00:00",
      "last_date": "2026-01-16T11:25:53+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176841589602625.mbox",
          "message_id": "<CAP-5=fUyAtf9PQqYvagByK+-=-mN-T1zuLmxuvsPFVVHT3qLXA () mail ! gmail ! com>",
          "author_name": "Ian Rogers",
          "author_email": "irogers () google ! com",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-14 17:51:14+00:00",
          "date_str": "Wed, 14 Jan 2026 17:51:14 +0000",
          "body": "On Wed, Jan 14, 2026 at 8:37=E2=80=AFAM kernel test robot <lkp@intel.com> w=\nrote:\n>\n> tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git timer=\ns/vdso\n> head:   759a1f97373f25770cf438d9fb5f2bddf4d77a54\n> commit: e04a494143bab7ea804fe1ebe286701ee8288e4a [12/14] vdso: Switch get=\n/put_unaligned() from packed struct to memcpy()\n> config: x86_64-randconfig-122-20260114 (https://download.01.org/0day-ci/a=\nrchive/20260115/202601150001.sKSN644a-lkp@intel.com/config)\n> compiler: clang version 20.1.8 (https://github.com/llvm/llvm-project 87f0=\n227cb60147a26a1eeb4fb06e3b505e9c7261)\n> rustc: rustc 1.88.0 (6b00bc388 2025-06-23)\n> reproduce (this is a W=3D1 build): (https://download.01.org/0day-ci/archi=\nve/20260115/202601150001.sKSN644a-lkp@intel.com/reproduce)\n>\n> If you fix the issue in a separate patch/commit (i.e. not just a new vers=\nion of\n> the same patch/commit), kindly add following tags\n> | Reported-by: kernel test robot <lkp@intel.com>\n> | Closes: https://lore.kernel.org/oe-kbuild-all/202601150001.sKSN644a-lkp=\n@intel.com/\n>\n> sparse warnings: (new ones prefixed by >>)\n> >> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (d=\nifferent modifiers) @@     expected void * @@     got restricted __be64 con=\nst * @@\n>    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (=\ndifferent modifiers) @@     expected void * @@     got restricted __be64 co=\nnst * @@\n>    net/rds/ib_cm.c:103:27: sparse:     expected void *\n>    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n>\n> vim +96 net/rds/ib_cm.c\n>\n> ec16227e14141e Andy Grover                  2009-02-24   69\n> ec16227e14141e Andy Grover                  2009-02-24   70  /*\n> ec16227e14141e Andy Grover                  2009-02-24   71   * Connectio=\nn established.\n> ec16227e14141e Andy Grover                  2009-02-24   72   * We get he=\nre for both outgoing and incoming connection.\n> ec16227e14141e Andy Grover                  2009-02-24   73   */\n> ec16227e14141e Andy Grover                  2009-02-24   74  void rds_ib_=\ncm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *even=\nt)\n> ec16227e14141e Andy Grover                  2009-02-24   75  {\n> ec16227e14141e Andy Grover                  2009-02-24   76     struct rd=\ns_ib_connection *ic =3D conn->c_transport_data;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   77     const uni=\non rds_ib_conn_priv *dp =3D NULL;\n\nHere dp is a pointer to a constant value.\n\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   78     __be64 ac=\nk_seq =3D 0;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   79     __be32 cr=\nedit =3D 0;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   80     u8 major =\n=3D 0;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   81     u8 minor =\n=3D 0;\n> ec16227e14141e Andy Grover                  2009-02-24   82     int err;\n> ec16227e14141e Andy Grover                  2009-02-24   83\n> ec16227e14141e Andy Grover                  2009-02-24   84     dp =3D ev=\nent->param.conn.private_data;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   85     if (conn-=\n>c_isv6) {\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   86             i=\nf (event->param.conn.private_data_len >=3D\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   87              =\n   sizeof(struct rds6_ib_connect_private)) {\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   88              =\n       major =3D dp->ricp_v6.dp_protocol_major;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   89              =\n       minor =3D dp->ricp_v6.dp_protocol_minor;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   90              =\n       credit =3D dp->ricp_v6.dp_credit;\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   91              =\n       /* dp structure start is not guaranteed to be 8 bytes\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   92              =\n        * aligned.  Since dp_ack_seq is 64-bit extended load\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   93              =\n        * operations can be used so go through get_unaligned\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   94              =\n        * to avoid unaligned errors.\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23   95              =\n        */\n> eee2fa6ab32251 Ka-Cheong Poon               2018-07-23  @96              =\n       ack_seq =3D get_unaligned(&dp->ricp_v6.dp_ack_seq);\n\nThis is a warned about get_unaligned reported here.\n\nIn my patch:\n\n+/**\n+ * __get_unaligned_t - read an unaligned value from memory.\n+ * @type:      the type to load from the pointer.\n+ * @ptr:       the pointer to load from.\n+ *\n+ * Use memcpy to affect an unaligned type sized load avoiding\nundefined behavior\n+ * from approaches li",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176842384008225.mbox",
          "message_id": "<874ioohsft.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-14 20:04:22+00:00",
          "date_str": "Wed, 14 Jan 2026 20:04:22 +0000",
          "body": "On Wed, Jan 14 2026 at 09:51, Ian Rogers wrote:\n> On Wed, Jan 14, 2026 at 8:37=E2=80=AFAM kernel test robot <lkp@intel.com>=\n wrote:\n> I think there are 2 options:\n> 1) ignore the new sparse warning as tech debt for later clean up,\n> 2) modify the cast to be \"const void*\" instead of \"void *\" and play\n> more wac-a-mole.\n\nOption #3:\n\nYou might have tried the 'const void*' cast and figured out that sparse\nis still unhappy. I actually did, but I didn't try to figure out why as\nthat's really not my duty.\n\n> My preference would be 1 as I have a suspicion I played 2 and thought\n> the non-const cast was best (hence it being in the patch) given other\n> issues.\n\nPreferences based on suspicions are not really usefull. Please go and\nfigure out what's going on and either fix it in the kernel code or tell\nthe sparse folks what they are missing.\n\nLeaving it unresolved and handwaved away is not an option.\n\nThanks,\n\n        tglx\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176842740410152.mbox",
          "message_id": "<CAP-5=fVGnY37bCOUHx_tCgQ=K55CcSOzs98Hg2Mh7KF4Mbya+g () mail ! gmail ! com>",
          "author_name": "Ian Rogers",
          "author_email": "irogers () google ! com",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-14 21:03:31+00:00",
          "date_str": "Wed, 14 Jan 2026 21:03:31 +0000",
          "body": "On Wed, Jan 14, 2026 at 12:04=E2=80=AFPM Thomas Gleixner <tglx@kernel.org> =\nwrote:\n>\n> On Wed, Jan 14 2026 at 09:51, Ian Rogers wrote:\n> > On Wed, Jan 14, 2026 at 8:37=E2=80=AFAM kernel test robot <lkp@intel.co=\nm> wrote:\n> > I think there are 2 options:\n> > 1) ignore the new sparse warning as tech debt for later clean up,\n> > 2) modify the cast to be \"const void*\" instead of \"void *\" and play\n> > more wac-a-mole.\n>\n> Option #3:\n>\n> You might have tried the 'const void*' cast and figured out that sparse\n> is still unhappy. I actually did, but I didn't try to figure out why as\n> that's really not my duty.\n>\n> > My preference would be 1 as I have a suspicion I played 2 and thought\n> > the non-const cast was best (hence it being in the patch) given other\n> > issues.\n>\n> Preferences based on suspicions are not really usefull. Please go and\n> figure out what's going on and either fix it in the kernel code or tell\n> the sparse folks what they are missing.\n>\n> Leaving it unresolved and handwaved away is not an option.\n\nI'd like to call this option, play a bunch of wac-a-mole but then\nstill don't really progress. I had tried out I believe all the options\n6 months ago where the builds were clean. There's always 1 more tool\nthat's going to raise its head and complain about types, my motivation\nremains clang and gcc for user space copies of this code so we don't\nneed to propagate -fno-strict-aliasing into places like perf. Tbh, I'm\nnot going to be able to look at this for a while so I'd suggest just\ndropping the patches.\n\nThanks,\nIan\n\n> Thanks,\n>\n>         tglx\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176842888611160.mbox",
          "message_id": "<871pjrj36d.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-14 21:27:06+00:00",
          "date_str": "Wed, 14 Jan 2026 21:27:06 +0000",
          "body": "On Wed, Jan 14 2026 at 13:03, Ian Rogers wrote:\n> On Wed, Jan 14, 2026 at 12:04=E2=80=AFPM Thomas Gleixner <tglx@kernel.org=\n> wrote:\n>> > My preference would be 1 as I have a suspicion I played 2 and thought\n>> > the non-const cast was best (hence it being in the patch) given other\n>> > issues.\n>>\n>> Preferences based on suspicions are not really usefull. Please go and\n>> figure out what's going on and either fix it in the kernel code or tell\n>> the sparse folks what they are missing.\n>>\n>> Leaving it unresolved and handwaved away is not an option.\n>\n> I'd like to call this option, play a bunch of wac-a-mole but then\n\nI'm not familiar enough with internet slang, but to my limited knowledge\nit's spelled 'Whack-a-mole'. That aside:\n\n     \"Whack-a-mole\" without a real conclusive explanation is really a\n      lame excuse, actually it's beyond lame.\n\n> still don't really progress. I had tried out I believe all the options\n> 6 months ago where the builds were clean. There's always 1 more tool\n> that's going to raise its head and complain about types, my motivation\n> remains clang and gcc for user space copies of this code so we don't\n> need to propagate -fno-strict-aliasing into places like perf.\n\nSo because your motivation ends there and other tools which raise their\nugly heads are not relevant to you ...\n\n> Tbh, I'm not going to be able to look at this for a while so I'd\n> suggest just dropping the patches.\n\n... everything stays with the status quo, i.e. unresolved.\n\nThat makes a lot of sense - NOT!\n\nThanks for wasting my time to deal with your patches and welcome to my\nextremly short ignore list!\n\nYour's grumpy\n\n       Thomas\n\n\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176842995211896.mbox",
          "message_id": "<CAP-5=fWgReuXY5im5-qCMBmryZHkRcZCLTkU6YzOSGJwufnYJg () mail ! gmail ! com>",
          "author_name": "Ian Rogers",
          "author_email": "irogers () google ! com",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-14 21:42:06+00:00",
          "date_str": "Wed, 14 Jan 2026 21:42:06 +0000",
          "body": "On Wed, Jan 14, 2026 at 1:27=E2=80=AFPM Thomas Gleixner <tglx@kernel.org> w=\nrote:\n>\n> On Wed, Jan 14 2026 at 13:03, Ian Rogers wrote:\n> > On Wed, Jan 14, 2026 at 12:04=E2=80=AFPM Thomas Gleixner <tglx@kernel.o=\nrg> wrote:\n> >> > My preference would be 1 as I have a suspicion I played 2 and though=\nt\n> >> > the non-const cast was best (hence it being in the patch) given othe=\nr\n> >> > issues.\n> >>\n> >> Preferences based on suspicions are not really usefull. Please go and\n> >> figure out what's going on and either fix it in the kernel code or tel=\nl\n> >> the sparse folks what they are missing.\n> >>\n> >> Leaving it unresolved and handwaved away is not an option.\n> >\n> > I'd like to call this option, play a bunch of wac-a-mole but then\n>\n> I'm not familiar enough with internet slang, but to my limited knowledge\n> it's spelled 'Whack-a-mole'. That aside:\n>\n>      \"Whack-a-mole\" without a real conclusive explanation is really a\n>       lame excuse, actually it's beyond lame.\n>\n> > still don't really progress. I had tried out I believe all the options\n> > 6 months ago where the builds were clean. There's always 1 more tool\n> > that's going to raise its head and complain about types, my motivation\n> > remains clang and gcc for user space copies of this code so we don't\n> > need to propagate -fno-strict-aliasing into places like perf.\n>\n> So because your motivation ends there and other tools which raise their\n> ugly heads are not relevant to you ...\n>\n> > Tbh, I'm not going to be able to look at this for a while so I'd\n> > suggest just dropping the patches.\n>\n> ... everything stays with the status quo, i.e. unresolved.\n>\n> That makes a lot of sense - NOT!\n>\n> Thanks for wasting my time to deal with your patches and welcome to my\n> extremly short ignore list!\n\nThe patches have been through 5 versions with considerable hurdles\njumped, testing my ending, both kernel building and user space tool\nbuilding and running with sanitizers, etc. My work commitments mean I\ncan't just leap up and say I'm going to explore the ramifications of\nmoving the (void*) to (const void*) in all these combinations again,\nbut as a a const lover (even having published papers on it [1]) I\ndoubt the choice of using \"void*\" rather than \"const void*\" is likely\nno accident. Even if I come up with a new series, waiting months for\nany kind of review, merging, feedback, .. I'm just left in limbo and I\nlose the context that I've built up and we end up here. In perf\nchanges we often end up with good patches vs perfect patches and I\ndon't believe with these patches we'll ever get perfect, hence saying\nwe should move forward even with the sparse regression that may only\nbe fixable with #ifdef DOING_A_SPARSE_BUILD... Given the bar seems to\nbe perfect, I'm recommending just dropping the patches.\n\nSorry to be on your ignore list,\nIan\n\n[1] https://research.manchester.ac.uk/en/publications/constraint-based-opti=\nmization-of-stationary-fields/\n\n> Your's grumpy\n>\n>        Thomas\n>\n>\n>\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176850820106805.mbox",
          "message_id": "<87v7h23cb0.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 19:28:51+00:00",
          "date_str": "Thu, 15 Jan 2026 19:28:51 +0000",
          "body": "On Thu, Jan 15 2026 at 00:36, kernel test robot wrote:\n\nCc+ sparse folks.\n\n> sparse warnings: (new ones prefixed by >>)\n>>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>    net/rds/ib_cm.c:103:27: sparse:     expected void *\n>    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n\nAfter staring a while at it, it turns out that get_unaligned_t(), which\nuses __unqual_scalar_typeof() to get an unqualified type makes sparse\nunhappy when the data type is __be64 (or any other __beNN variant).\n\n__beNN is annotated with __attribute__((bitwise)) when sparse is invoked\n(#ifdef CHECKER). That allows sparse to detect incompatible math\noperations with __beNN variables.\n\nThat annotation also causes the type comparison in the sparse _Generic()\nevaluation to fail so that it ends up with the default, i.e. the\noriginal qualified type of a 'const __beNN' pointer. That then ends up as\nthe first pointer argument to builtin_memcpy(), which obviously causes\nthe above sparse warnings.\n\nThe easiest solution would be to force cast the pointer to void * when\nCHECKER is defined, but that reduces coverage.\n\nI've come up with the below, but it's clearly a hack... __CAST_SPARSE()\nis required as sparse otherwise complains about storing __u64 in __be64.\n\nThanks,\n\n        tglx\n---\n include/linux/compiler_types.h |   10 ++++++++++\n include/vdso/unaligned.h       |   16 +++++++++++-----\n 2 files changed, 21 insertions(+), 5 deletions(-)\n\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -577,6 +577,15 @@ struct ftrace_likely_data {\n \t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n \t\tsigned type:\t(signed type)0\n \n+#ifdef __CHECKER__\n+#define __be_types_expr_cases()\t\t\t\t\t\t\\\n+\t__be16: (__u16)0,\t\t\t\t\t\t\\\n+\t__be32: (__u32)0,\t\t\t\t\t\t\\\n+\t__be64: (__u64)0,\n+#else\n+#define __be_types_expr_cases()\n+#endif\n+\n #define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n \t\t_Generic((x),\t\t\t\t\t\t\\\n \t\t\t char:\t(char)0,\t\t\t\t\\\n@@ -585,6 +594,7 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n+\t\t\t __be_types_expr_cases()\t\t\t\\\n \t\t\t default: (x)))\n \n /* Is this type a native word size -- useful for atomic operations */\n--- a/include/vdso/unaligned.h\n+++ b/include/vdso/unaligned.h\n@@ -4,6 +4,12 @@\n \n #include <linux/compiler_types.h>\n \n+#ifdef __CHECKER__\n+#define __CAST_SPARSE(type) (type __force)\n+#else\n+#define __CAST_SPARSE(type)\n+#endif\n+\n /**\n  * __get_unaligned_t - read an unaligned value from memory.\n  * @type:\tthe type to load from the pointer.\n@@ -17,12 +23,12 @@\n  * expression rather than type, a pointer is used to avoid warnings about mixing\n  * the use of 0 and NULL. The void* cast silences ubsan warnings.\n  */\n-#define __get_unaligned_t(type, ptr) ({\t\t\t\t\t\\\n-\ttype *__get_unaligned_ctrl_type __always_unused = NULL;\t\t\\\n+#define __get_unaligned_t(type, ptr) ({\t\t\t\t\t\t\\\n+\ttype *__get_unaligned_ctrl_type __always_unused = NULL;\t\t\t\\\n \t__unqual_scalar_typeof(*__get_unaligned_ctrl_type) __get_unaligned_val; \\\n-\t__builtin_memcpy(&__get_unaligned_val, (void *)(ptr),\t\t\\\n-\t\t\t sizeof(__get_unaligned_val));\t\t\t\\\n-\t__get_unaligned_val;\t\t\t\t\t\t\\\n+\t__builtin_memcpy(&__get_unaligned_val, (void *)(ptr),\t\t\t\\\n+\t\t\t sizeof(__get_unaligned_val));\t\t\t\t\\\n+\t__CAST_SPARSE(type) __get_unaligned_val;\t\t\t\t\\\n })\n \n /**\n\n\n\n\n    \n\n      \n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176850819806802.mbox",
          "message_id": "<87v7h23cb0.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 19:28:51+00:00",
          "date_str": "Thu, 15 Jan 2026 19:28:51 +0000",
          "body": "On Thu, Jan 15 2026 at 00:36, kernel test robot wrote:\n\nCc+ sparse folks.\n\n> sparse warnings: (new ones prefixed by >>)\n>>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>    net/rds/ib_cm.c:103:27: sparse:     expected void *\n>    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n\nAfter staring a while at it, it turns out that get_unaligned_t(), which\nuses __unqual_scalar_typeof() to get an unqualified type makes sparse\nunhappy when the data type is __be64 (or any other __beNN variant).\n\n__beNN is annotated with __attribute__((bitwise)) when sparse is invoked\n(#ifdef CHECKER). That allows sparse to detect incompatible math\noperations with __beNN variables.\n\nThat annotation also causes the type comparison in the sparse _Generic()\nevaluation to fail so that it ends up with the default, i.e. the\noriginal qualified type of a 'const __beNN' pointer. That then ends up as\nthe first pointer argument to builtin_memcpy(), which obviously causes\nthe above sparse warnings.\n\nThe easiest solution would be to force cast the pointer to void * when\nCHECKER is defined, but that reduces coverage.\n\nI've come up with the below, but it's clearly a hack... __CAST_SPARSE()\nis required as sparse otherwise complains about storing __u64 in __be64.\n\nThanks,\n\n        tglx\n---\n include/linux/compiler_types.h |   10 ++++++++++\n include/vdso/unaligned.h       |   16 +++++++++++-----\n 2 files changed, 21 insertions(+), 5 deletions(-)\n\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -577,6 +577,15 @@ struct ftrace_likely_data {\n \t\tunsigned type:\t(unsigned type)0,\t\t\t\\\n \t\tsigned type:\t(signed type)0\n \n+#ifdef __CHECKER__\n+#define __be_types_expr_cases()\t\t\t\t\t\t\\\n+\t__be16: (__u16)0,\t\t\t\t\t\t\\\n+\t__be32: (__u32)0,\t\t\t\t\t\t\\\n+\t__be64: (__u64)0,\n+#else\n+#define __be_types_expr_cases()\n+#endif\n+\n #define __unqual_scalar_typeof(x) typeof(\t\t\t\t\\\n \t\t_Generic((x),\t\t\t\t\t\t\\\n \t\t\t char:\t(char)0,\t\t\t\t\\\n@@ -585,6 +594,7 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(int),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n+\t\t\t __be_types_expr_cases()\t\t\t\\\n \t\t\t default: (x)))\n \n /* Is this type a native word size -- useful for atomic operations */\n--- a/include/vdso/unaligned.h\n+++ b/include/vdso/unaligned.h\n@@ -4,6 +4,12 @@\n \n #include <linux/compiler_types.h>\n \n+#ifdef __CHECKER__\n+#define __CAST_SPARSE(type) (type __force)\n+#else\n+#define __CAST_SPARSE(type)\n+#endif\n+\n /**\n  * __get_unaligned_t - read an unaligned value from memory.\n  * @type:\tthe type to load from the pointer.\n@@ -17,12 +23,12 @@\n  * expression rather than type, a pointer is used to avoid warnings about mixing\n  * the use of 0 and NULL. The void* cast silences ubsan warnings.\n  */\n-#define __get_unaligned_t(type, ptr) ({\t\t\t\t\t\\\n-\ttype *__get_unaligned_ctrl_type __always_unused = NULL;\t\t\\\n+#define __get_unaligned_t(type, ptr) ({\t\t\t\t\t\t\\\n+\ttype *__get_unaligned_ctrl_type __always_unused = NULL;\t\t\t\\\n \t__unqual_scalar_typeof(*__get_unaligned_ctrl_type) __get_unaligned_val; \\\n-\t__builtin_memcpy(&__get_unaligned_val, (void *)(ptr),\t\t\\\n-\t\t\t sizeof(__get_unaligned_val));\t\t\t\\\n-\t__get_unaligned_val;\t\t\t\t\t\t\\\n+\t__builtin_memcpy(&__get_unaligned_val, (void *)(ptr),\t\t\t\\\n+\t\t\t sizeof(__get_unaligned_val));\t\t\t\t\\\n+\t__CAST_SPARSE(type) __get_unaligned_val;\t\t\t\t\\\n })\n \n /**\n\n\n\n\n    \n\n      \n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176851441213122.mbox",
          "message_id": "<20260115211120.GD831050 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 21:11:20+00:00",
          "date_str": "Thu, 15 Jan 2026 21:11:20 +0000",
          "body": "On Thu, Jan 15, 2026 at 08:28:51PM +0100, Thomas Gleixner wrote:\n> On Thu, Jan 15 2026 at 00:36, kernel test robot wrote:\n> \n> Cc+ sparse folks.\n> \n> > sparse warnings: (new ones prefixed by >>)\n> >>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n> >    net/rds/ib_cm.c:96:35: sparse:     expected void *\n> >    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n> >    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n> >    net/rds/ib_cm.c:103:27: sparse:     expected void *\n> >    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n> \n> After staring a while at it, it turns out that get_unaligned_t(), which\n> uses __unqual_scalar_typeof() to get an unqualified type makes sparse\n> unhappy when the data type is __be64 (or any other __beNN variant).\n> \n> __beNN is annotated with __attribute__((bitwise)) when sparse is invoked\n> (#ifdef CHECKER). That allows sparse to detect incompatible math\n> operations with __beNN variables.\n> \n\nPer:\n\n  https://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git/commit/?id=dc9efe442b8949234a6599fdc94dc7221dd040e1\n\nit seems Sparse now knows about __typeof_unqual__; and it looks like the\nimplementation does what you want here (although I've not tested it).\n\nSomething like so perhaps, which then mandates the very latest Sparse.\n\n---\ndiff --git a/include/linux/compiler.h b/include/linux/compiler.h\nindex 04487c9bd751..7e0583ceb49f 100644\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -232,11 +232,8 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,\n \n /*\n  * Use __typeof_unqual__() when available.\n- *\n- * XXX: Remove test for __CHECKER__ once\n- * sparse learns about __typeof_unqual__().\n  */\n-#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n+#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n # define USE_TYPEOF_UNQUAL 1\n #endif\n \ndiff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h\nindex d3318a3c2577..a37d832d99a8 100644\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -569,6 +569,7 @@ struct ftrace_likely_data {\n  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n  *\t\t\t       non-scalar types unchanged.\n  */\n+#ifndef USE_TYPEOF_UNQUAL\n /*\n  * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n  * is not type-compatible with 'signed char', and we define a separate case.\n@@ -586,6 +587,9 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n \t\t\t default: (x)))\n+#else\n+#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n+#endif\n \n /* Is this type a native word size -- useful for atomic operations */\n #define __native_word(t) \\\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176851440113080.mbox",
          "message_id": "<20260115211120.GD831050 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 21:11:20+00:00",
          "date_str": "Thu, 15 Jan 2026 21:11:20 +0000",
          "body": "On Thu, Jan 15, 2026 at 08:28:51PM +0100, Thomas Gleixner wrote:\n> On Thu, Jan 15 2026 at 00:36, kernel test robot wrote:\n> \n> Cc+ sparse folks.\n> \n> > sparse warnings: (new ones prefixed by >>)\n> >>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n> >    net/rds/ib_cm.c:96:35: sparse:     expected void *\n> >    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n> >    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n> >    net/rds/ib_cm.c:103:27: sparse:     expected void *\n> >    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n> \n> After staring a while at it, it turns out that get_unaligned_t(), which\n> uses __unqual_scalar_typeof() to get an unqualified type makes sparse\n> unhappy when the data type is __be64 (or any other __beNN variant).\n> \n> __beNN is annotated with __attribute__((bitwise)) when sparse is invoked\n> (#ifdef CHECKER). That allows sparse to detect incompatible math\n> operations with __beNN variables.\n> \n\nPer:\n\n  https://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git/commit/?id=dc9efe442b8949234a6599fdc94dc7221dd040e1\n\nit seems Sparse now knows about __typeof_unqual__; and it looks like the\nimplementation does what you want here (although I've not tested it).\n\nSomething like so perhaps, which then mandates the very latest Sparse.\n\n---\ndiff --git a/include/linux/compiler.h b/include/linux/compiler.h\nindex 04487c9bd751..7e0583ceb49f 100644\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -232,11 +232,8 @@ void ftrace_likely_update(struct ftrace_likely_data *f, int val,\n \n /*\n  * Use __typeof_unqual__() when available.\n- *\n- * XXX: Remove test for __CHECKER__ once\n- * sparse learns about __typeof_unqual__().\n  */\n-#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n+#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n # define USE_TYPEOF_UNQUAL 1\n #endif\n \ndiff --git a/include/linux/compiler_types.h b/include/linux/compiler_types.h\nindex d3318a3c2577..a37d832d99a8 100644\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -569,6 +569,7 @@ struct ftrace_likely_data {\n  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n  *\t\t\t       non-scalar types unchanged.\n  */\n+#ifndef USE_TYPEOF_UNQUAL\n /*\n  * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n  * is not type-compatible with 'signed char', and we define a separate case.\n@@ -586,6 +587,9 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n \t\t\t default: (x)))\n+#else\n+#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n+#endif\n \n /* Is this type a native word size -- useful for atomic operations */\n #define __native_word(t) \\\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176851474713347.mbox",
          "message_id": "<CAHk-=wg9pxiKm3kcZ0XQrFvz6fFek_A1WGqRh9yeghx3pE2d3w () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 21:19:14+00:00",
          "date_str": "Thu, 15 Jan 2026 21:19:14 +0000",
          "body": "On Thu, 15 Jan 2026 at 13:13, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> Something like so perhaps, which then mandates the very latest Sparse.\n\nAck. We want that compiler_tpes.h change for the real compilers that\nsupport __typeof_unqual__ anyway.\n\nEventually we can just force that everywhere, but as Al pointed out in\nanother thread, we're not quite there yet (ie we'd need clang-19.0.1\nand gcc-8.4 to be able to just switch entirely over to\n__typeof_unqual__).\n\nFor sparse users, I think we should have the policy that we just don't\nsupport older versions at all, since it just gets too painful.\n\n                 Linus\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176851474713344.mbox",
          "message_id": "<CAHk-=wg9pxiKm3kcZ0XQrFvz6fFek_A1WGqRh9yeghx3pE2d3w () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 21:19:14+00:00",
          "date_str": "Thu, 15 Jan 2026 21:19:14 +0000",
          "body": "On Thu, 15 Jan 2026 at 13:13, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> Something like so perhaps, which then mandates the very latest Sparse.\n\nAck. We want that compiler_tpes.h change for the real compilers that\nsupport __typeof_unqual__ anyway.\n\nEventually we can just force that everywhere, but as Al pointed out in\nanother thread, we're not quite there yet (ie we'd need clang-19.0.1\nand gcc-8.4 to be able to just switch entirely over to\n__typeof_unqual__).\n\nFor sparse users, I think we should have the policy that we just don't\nsupport older versions at all, since it just gets too painful.\n\n                 Linus\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176851543213877.mbox",
          "message_id": "<20260115213054.GF831050 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 21:30:54+00:00",
          "date_str": "Thu, 15 Jan 2026 21:30:54 +0000",
          "body": "On Thu, Jan 15, 2026 at 01:19:14PM -0800, Linus Torvalds wrote:\n\n> Eventually we can just force that everywhere, but as Al pointed out in\n> another thread, we're not quite there yet (ie we'd need clang-19.0.1\n> and gcc-8.4 to be able to just switch entirely over to\n> __typeof_unqual__).\n\nGCC-14 :-/ The GCC-8.4 one was the function return value trick.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176851543313880.mbox",
          "message_id": "<20260115213054.GF831050 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 21:30:54+00:00",
          "date_str": "Thu, 15 Jan 2026 21:30:54 +0000",
          "body": "On Thu, Jan 15, 2026 at 01:19:14PM -0800, Linus Torvalds wrote:\n\n> Eventually we can just force that everywhere, but as Al pointed out in\n> another thread, we're not quite there yet (ie we'd need clang-19.0.1\n> and gcc-8.4 to be able to just switch entirely over to\n> __typeof_unqual__).\n\nGCC-14 :-/ The GCC-8.4 one was the function return value trick.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176852092818361.mbox",
          "message_id": "<87ms2e32gw.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 23:01:19+00:00",
          "date_str": "Thu, 15 Jan 2026 23:01:19 +0000",
          "body": "On Thu, Jan 15 2026 at 22:11, Peter Zijlstra wrote:\n\n> On Thu, Jan 15, 2026 at 08:28:51PM +0100, Thomas Gleixner wrote:\n>> On Thu, Jan 15 2026 at 00:36, kernel test robot wrote:\n>> \n>> Cc+ sparse folks.\n>> \n>> > sparse warnings: (new ones prefixed by >>)\n>> >>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>> >    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>> >    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>> >    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>> >    net/rds/ib_cm.c:103:27: sparse:     expected void *\n>> >    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n>> \n>> After staring a while at it, it turns out that get_unaligned_t(), which\n>> uses __unqual_scalar_typeof() to get an unqualified type makes sparse\n>> unhappy when the data type is __be64 (or any other __beNN variant).\n>> \n>> __beNN is annotated with __attribute__((bitwise)) when sparse is invoked\n>> (#ifdef CHECKER). That allows sparse to detect incompatible math\n>> operations with __beNN variables.\n>> \n>\n> Per:\n>\n>   https://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git/commit/?id=dc9efe442b8949234a6599fdc94dc7221dd040e1\n>\n> it seems Sparse now knows about __typeof_unqual__; and it looks like the\n> implementation does what you want here (although I've not tested it).\n>\n> Something like so perhaps, which then mandates the very latest Sparse.\n\nI tried that before and sparse is still upset:\n\n  net/rds/ib_cm.c:96:35: warning: incorrect type in argument 1 (different modifiers)\n  net/rds/ib_cm.c:96:35:    expected void *\n  net/rds/ib_cm.c:96:35:    got restricted __be64 const *\n  net/rds/ib_cm.c:103:27: warning: incorrect type in argument 1 (different modifiers)\n  net/rds/ib_cm.c:103:27:    expected void *\n  net/rds/ib_cm.c:103:27:    got restricted __be64 const *\n\nThis time I looked deeper and it seems that USE_TYPEOF_UNQUAL is not\nset.\n\nIf I force it to be set and use a proper compiler and top of tree\nsparse, everything seems to be happy.\n\nFiguring that out is something for tomorrow...\n\nThanks,\n\n        tglx\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176852092418354.mbox",
          "message_id": "<87ms2e32gw.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 23:01:19+00:00",
          "date_str": "Thu, 15 Jan 2026 23:01:19 +0000",
          "body": "On Thu, Jan 15 2026 at 22:11, Peter Zijlstra wrote:\n\n> On Thu, Jan 15, 2026 at 08:28:51PM +0100, Thomas Gleixner wrote:\n>> On Thu, Jan 15 2026 at 00:36, kernel test robot wrote:\n>> \n>> Cc+ sparse folks.\n>> \n>> > sparse warnings: (new ones prefixed by >>)\n>> >>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>> >    net/rds/ib_cm.c:96:35: sparse:     expected void *\n>> >    net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n>> >    net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n>> >    net/rds/ib_cm.c:103:27: sparse:     expected void *\n>> >    net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n>> \n>> After staring a while at it, it turns out that get_unaligned_t(), which\n>> uses __unqual_scalar_typeof() to get an unqualified type makes sparse\n>> unhappy when the data type is __be64 (or any other __beNN variant).\n>> \n>> __beNN is annotated with __attribute__((bitwise)) when sparse is invoked\n>> (#ifdef CHECKER). That allows sparse to detect incompatible math\n>> operations with __beNN variables.\n>> \n>\n> Per:\n>\n>   https://git.kernel.org/pub/scm/devel/sparse/sparse-dev.git/commit/?id=dc9efe442b8949234a6599fdc94dc7221dd040e1\n>\n> it seems Sparse now knows about __typeof_unqual__; and it looks like the\n> implementation does what you want here (although I've not tested it).\n>\n> Something like so perhaps, which then mandates the very latest Sparse.\n\nI tried that before and sparse is still upset:\n\n  net/rds/ib_cm.c:96:35: warning: incorrect type in argument 1 (different modifiers)\n  net/rds/ib_cm.c:96:35:    expected void *\n  net/rds/ib_cm.c:96:35:    got restricted __be64 const *\n  net/rds/ib_cm.c:103:27: warning: incorrect type in argument 1 (different modifiers)\n  net/rds/ib_cm.c:103:27:    expected void *\n  net/rds/ib_cm.c:103:27:    got restricted __be64 const *\n\nThis time I looked deeper and it seems that USE_TYPEOF_UNQUAL is not\nset.\n\nIf I force it to be set and use a proper compiler and top of tree\nsparse, everything seems to be happy.\n\nFiguring that out is something for tomorrow...\n\nThanks,\n\n        tglx\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176852102718466.mbox",
          "message_id": "<CAHk-=wgXxY4NTZW8rcrXqx3h=j+t2445VWccbpywXYdoL_V0qA () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 23:03:52+00:00",
          "date_str": "Thu, 15 Jan 2026 23:03:52 +0000",
          "body": "On Thu, 15 Jan 2026 at 13:31, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> GCC-14 :-/ The GCC-8.4 one was the function return value trick.\n\nRight you are. And yeah, us moving on to gcc-14 as a minimum version\nis not imminent.\n\nStill, while we can't force it, lots of distros are on gcc-15, so\nwhile we'd have the _Generic() macro as a fallback for older versions,\nat least most developers would hopefully get the nice clean modern\n__typeof_unqual__ thing...\n\n           Linus\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176852102618465.mbox",
          "message_id": "<CAHk-=wgXxY4NTZW8rcrXqx3h=j+t2445VWccbpywXYdoL_V0qA () mail ! gmail ! com>",
          "author_name": "Linus Torvalds",
          "author_email": "torvalds () linux-foundation ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-15 23:03:52+00:00",
          "date_str": "Thu, 15 Jan 2026 23:03:52 +0000",
          "body": "On Thu, 15 Jan 2026 at 13:31, Peter Zijlstra <peterz@infradead.org> wrote:\n>\n> GCC-14 :-/ The GCC-8.4 one was the function return value trick.\n\nRight you are. And yeah, us moving on to gcc-14 as a minimum version\nis not imminent.\n\nStill, while we can't force it, lots of distros are on gcc-15, so\nwhile we'd have the _Generic() macro as a fallback for older versions,\nat least most developers would hopefully get the nice clean modern\n__typeof_unqual__ thing...\n\n           Linus\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176855487510308.mbox",
          "message_id": "<20260116082812.GH830755 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-16 08:28:12+00:00",
          "date_str": "Fri, 16 Jan 2026 08:28:12 +0000",
          "body": "On Thu, Jan 15, 2026 at 03:03:52PM -0800, Linus Torvalds wrote:\n> On Thu, 15 Jan 2026 at 13:31, Peter Zijlstra <peterz@infradead.org> wrote:\n> >\n> > GCC-14 :-/ The GCC-8.4 one was the function return value trick.\n> \n> Right you are. And yeah, us moving on to gcc-14 as a minimum version\n> is not imminent.\n> \n> Still, while we can't force it, lots of distros are on gcc-15, so\n> while we'd have the _Generic() macro as a fallback for older versions,\n> at least most developers would hopefully get the nice clean modern\n> __typeof_unqual__ thing...\n\nAbsolutely. I'll try and make it happen if tglx doesn't.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176855487710311.mbox",
          "message_id": "<20260116082812.GH830755 () noisy ! programming ! kicks-ass ! net>",
          "author_name": "Peter Zijlstra",
          "author_email": "peterz () infradead ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-16 08:28:12+00:00",
          "date_str": "Fri, 16 Jan 2026 08:28:12 +0000",
          "body": "On Thu, Jan 15, 2026 at 03:03:52PM -0800, Linus Torvalds wrote:\n> On Thu, 15 Jan 2026 at 13:31, Peter Zijlstra <peterz@infradead.org> wrote:\n> >\n> > GCC-14 :-/ The GCC-8.4 one was the function return value trick.\n> \n> Right you are. And yeah, us moving on to gcc-14 as a minimum version\n> is not imminent.\n> \n> Still, while we can't force it, lots of distros are on gcc-15, so\n> while we'd have the _Generic() macro as a fallback for older versions,\n> at least most developers would hopefully get the nice clean modern\n> __typeof_unqual__ thing...\n\nAbsolutely. I'll try and make it happen if tglx doesn't.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176856586520842.mbox",
          "message_id": "<87jyxh3ike.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-16 11:25:53+00:00",
          "date_str": "Fri, 16 Jan 2026 11:25:53 +0000",
          "body": "On Fri, Jan 16 2026 at 00:01, Thomas Gleixner wrote:\n> This time I looked deeper and it seems that USE_TYPEOF_UNQUAL is not\n> set.\n>\n> If I force it to be set and use a proper compiler and top of tree\n> sparse, everything seems to be happy.\n>\n> Figuring that out is something for tomorrow...\n\nUSE_TYPEOF_UNQUAL is set _after_ the __unqual_scalar muck is\nprocessed...\n\nUpdated fix below.\n\nThanks,\n\n        tglx\n---\n include/linux/compiler.h       |   10 ----------\n include/linux/compiler_types.h |   11 +++++++++++\n 2 files changed, 11 insertions(+), 10 deletions(-)\n\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -231,16 +231,6 @@ void ftrace_likely_update(struct ftrace_\n \t\t\t\t\"must be non-C-string (not NUL-terminated)\")\n \n /*\n- * Use __typeof_unqual__() when available.\n- *\n- * XXX: Remove test for __CHECKER__ once\n- * sparse learns about __typeof_unqual__().\n- */\n-#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n-# define USE_TYPEOF_UNQUAL 1\n-#endif\n-\n-/*\n  * Define TYPEOF_UNQUAL() to use __typeof_unqual__() as typeof\n  * operator when available, to return an unqualified type of the exp.\n  */\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -562,6 +562,13 @@ struct ftrace_likely_data {\n #define asm_inline asm\n #endif\n \n+/*\n+ * Use __typeof_unqual__() when available.\n+ */\n+#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n+# define USE_TYPEOF_UNQUAL 1\n+#endif\n+\n /* Are two types/vars the same type (ignoring qualifiers)? */\n #define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n \n@@ -569,6 +576,7 @@ struct ftrace_likely_data {\n  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n  *\t\t\t       non-scalar types unchanged.\n  */\n+#ifndef USE_TYPEOF_UNQUAL\n /*\n  * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n  * is not type-compatible with 'signed char', and we define a separate case.\n@@ -586,6 +594,9 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n \t\t\t default: (x)))\n+#else\n+#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n+#endif\n \n /* Is this type a native word size -- useful for atomic operations */\n #define __native_word(t) \\\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176856552620505.mbox",
          "message_id": "<87jyxh3ike.ffs () tglx>",
          "author_name": "Thomas Gleixner",
          "author_email": "tglx () kernel ! org",
          "subject": "Re: [tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (dif",
          "date": "2026-01-16 11:25:53+00:00",
          "date_str": "Fri, 16 Jan 2026 11:25:53 +0000",
          "body": "On Fri, Jan 16 2026 at 00:01, Thomas Gleixner wrote:\n> This time I looked deeper and it seems that USE_TYPEOF_UNQUAL is not\n> set.\n>\n> If I force it to be set and use a proper compiler and top of tree\n> sparse, everything seems to be happy.\n>\n> Figuring that out is something for tomorrow...\n\nUSE_TYPEOF_UNQUAL is set _after_ the __unqual_scalar muck is\nprocessed...\n\nUpdated fix below.\n\nThanks,\n\n        tglx\n---\n include/linux/compiler.h       |   10 ----------\n include/linux/compiler_types.h |   11 +++++++++++\n 2 files changed, 11 insertions(+), 10 deletions(-)\n\n--- a/include/linux/compiler.h\n+++ b/include/linux/compiler.h\n@@ -231,16 +231,6 @@ void ftrace_likely_update(struct ftrace_\n \t\t\t\t\"must be non-C-string (not NUL-terminated)\")\n \n /*\n- * Use __typeof_unqual__() when available.\n- *\n- * XXX: Remove test for __CHECKER__ once\n- * sparse learns about __typeof_unqual__().\n- */\n-#if CC_HAS_TYPEOF_UNQUAL && !defined(__CHECKER__)\n-# define USE_TYPEOF_UNQUAL 1\n-#endif\n-\n-/*\n  * Define TYPEOF_UNQUAL() to use __typeof_unqual__() as typeof\n  * operator when available, to return an unqualified type of the exp.\n  */\n--- a/include/linux/compiler_types.h\n+++ b/include/linux/compiler_types.h\n@@ -562,6 +562,13 @@ struct ftrace_likely_data {\n #define asm_inline asm\n #endif\n \n+/*\n+ * Use __typeof_unqual__() when available.\n+ */\n+#if CC_HAS_TYPEOF_UNQUAL || defined(__CHECKER__)\n+# define USE_TYPEOF_UNQUAL 1\n+#endif\n+\n /* Are two types/vars the same type (ignoring qualifiers)? */\n #define __same_type(a, b) __builtin_types_compatible_p(typeof(a), typeof(b))\n \n@@ -569,6 +576,7 @@ struct ftrace_likely_data {\n  * __unqual_scalar_typeof(x) - Declare an unqualified scalar type, leaving\n  *\t\t\t       non-scalar types unchanged.\n  */\n+#ifndef USE_TYPEOF_UNQUAL\n /*\n  * Prefer C11 _Generic for better compile-times and simpler code. Note: 'char'\n  * is not type-compatible with 'signed char', and we define a separate case.\n@@ -586,6 +594,9 @@ struct ftrace_likely_data {\n \t\t\t __scalar_type_to_expr_cases(long),\t\t\\\n \t\t\t __scalar_type_to_expr_cases(long long),\t\\\n \t\t\t default: (x)))\n+#else\n+#define __unqual_scalar_typeof(x) __typeof_unqual__(x)\n+#endif\n \n /* Is this type a native word size -- useful for atomic operations */\n #define __native_word(t) \\\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "[tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (differe",
      "normalized_subject": "[tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (differe",
      "message_count": 2,
      "participants": [
        "kernel test robot"
      ],
      "categories": [
        "kernel_integration",
        "compiler_compat"
      ],
      "first_date": "2026-01-14T07:13:03+00:00",
      "last_date": "2026-01-14T16:36:01+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176837762303717.mbox",
          "message_id": "<202601141546.GCQHsj5y-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "[tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (differe",
          "date": "2026-01-14 07:13:03+00:00",
          "date_str": "Wed, 14 Jan 2026 07:13:03 +0000",
          "body": "tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git timers/vdso\nhead:   576d8a7a985dde4f51a4561dddc0d8734494d3de\ncommit: e04a494143bab7ea804fe1ebe286701ee8288e4a [12/14] vdso: Switch get/put_unaligned() from packed struct to memcpy()\nconfig: x86_64-randconfig-122-20260114 (https://download.01.org/0day-ci/archive/20260114/202601141546.GCQHsj5y-lkp@intel.com/config)\ncompiler: clang version 20.1.8 (https://github.com/llvm/llvm-project 87f0227cb60147a26a1eeb4fb06e3b505e9c7261)\nrustc: rustc 1.88.0 (6b00bc388 2025-06-23)\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20260114/202601141546.GCQHsj5y-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202601141546.GCQHsj5y-lkp@intel.com/\n\nsparse warnings: (new ones prefixed by >>)\n>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n   net/rds/ib_cm.c:96:35: sparse:     expected void *\n   net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n   net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n   net/rds/ib_cm.c:103:27: sparse:     expected void *\n   net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n\nvim +96 net/rds/ib_cm.c\n\nec16227e14141e4 Andy Grover                  2009-02-24   69  \nec16227e14141e4 Andy Grover                  2009-02-24   70  /*\nec16227e14141e4 Andy Grover                  2009-02-24   71   * Connection established.\nec16227e14141e4 Andy Grover                  2009-02-24   72   * We get here for both outgoing and incoming connection.\nec16227e14141e4 Andy Grover                  2009-02-24   73   */\nec16227e14141e4 Andy Grover                  2009-02-24   74  void rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *event)\nec16227e14141e4 Andy Grover                  2009-02-24   75  {\nec16227e14141e4 Andy Grover                  2009-02-24   76  \tstruct rds_ib_connection *ic = conn->c_transport_data;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   77  \tconst union rds_ib_conn_priv *dp = NULL;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   78  \t__be64 ack_seq = 0;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   79  \t__be32 credit = 0;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   80  \tu8 major = 0;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   81  \tu8 minor = 0;\nec16227e14141e4 Andy Grover                  2009-02-24   82  \tint err;\nec16227e14141e4 Andy Grover                  2009-02-24   83  \nec16227e14141e4 Andy Grover                  2009-02-24   84  \tdp = event->param.conn.private_data;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   85  \tif (conn->c_isv6) {\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   86  \t\tif (event->param.conn.private_data_len >=\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   87  \t\t    sizeof(struct rds6_ib_connect_private)) {\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   88  \t\t\tmajor = dp->ricp_v6.dp_protocol_major;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   89  \t\t\tminor = dp->ricp_v6.dp_protocol_minor;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   90  \t\t\tcredit = dp->ricp_v6.dp_credit;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   91  \t\t\t/* dp structure start is not guaranteed to be 8 bytes\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   92  \t\t\t * aligned.  Since dp_ack_seq is 64-bit extended load\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   93  \t\t\t * operations can be used so go through get_unaligned\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   94  \t\t\t * to avoid unaligned errors.\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   95  \t\t\t */\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23  @96  \t\t\tack_seq = get_unaligned(&dp->ricp_v6.dp_ack_seq);\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   97  \t\t}\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   98  \t} else if (event->param.conn.private_data_len >=\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23   99  \t\t   sizeof(struct rds_ib_connect_private)) {\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23  100  \t\tmajor = dp->ricp_v4.dp_protocol_major;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23  101  \t\tminor = dp->ricp_v4.dp_protocol_minor;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23  102  \t\tcredit = dp->ricp_v4.dp_credit;\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23  103  \t\tack_seq = get_unaligned(&dp->ricp_v4.dp_ack_seq);\neee2fa6ab322519 Ka-Cheong Poon               2018-07-23  104  \t}\nec16227e14141e4 Andy Grover          ",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176841139931448.mbox",
          "message_id": "<202601150001.sKSN644a-lkp () intel ! com>",
          "author_name": "kernel test robot",
          "author_email": "lkp () intel ! com",
          "subject": "[tip:timers/vdso 12/14] net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (differe",
          "date": "2026-01-14 16:36:01+00:00",
          "date_str": "Wed, 14 Jan 2026 16:36:01 +0000",
          "body": "tree:   https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git timers/vdso\nhead:   759a1f97373f25770cf438d9fb5f2bddf4d77a54\ncommit: e04a494143bab7ea804fe1ebe286701ee8288e4a [12/14] vdso: Switch get/put_unaligned() from packed struct to memcpy()\nconfig: x86_64-randconfig-122-20260114 (https://download.01.org/0day-ci/archive/20260115/202601150001.sKSN644a-lkp@intel.com/config)\ncompiler: clang version 20.1.8 (https://github.com/llvm/llvm-project 87f0227cb60147a26a1eeb4fb06e3b505e9c7261)\nrustc: rustc 1.88.0 (6b00bc388 2025-06-23)\nreproduce (this is a W=1 build): (https://download.01.org/0day-ci/archive/20260115/202601150001.sKSN644a-lkp@intel.com/reproduce)\n\nIf you fix the issue in a separate patch/commit (i.e. not just a new version of\nthe same patch/commit), kindly add following tags\n| Reported-by: kernel test robot <lkp@intel.com>\n| Closes: https://lore.kernel.org/oe-kbuild-all/202601150001.sKSN644a-lkp@intel.com/\n\nsparse warnings: (new ones prefixed by >>)\n>> net/rds/ib_cm.c:96:35: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n   net/rds/ib_cm.c:96:35: sparse:     expected void *\n   net/rds/ib_cm.c:96:35: sparse:     got restricted __be64 const *\n   net/rds/ib_cm.c:103:27: sparse: sparse: incorrect type in argument 1 (different modifiers) @@     expected void * @@     got restricted __be64 const * @@\n   net/rds/ib_cm.c:103:27: sparse:     expected void *\n   net/rds/ib_cm.c:103:27: sparse:     got restricted __be64 const *\n\nvim +96 net/rds/ib_cm.c\n\nec16227e14141e Andy Grover                  2009-02-24   69  \nec16227e14141e Andy Grover                  2009-02-24   70  /*\nec16227e14141e Andy Grover                  2009-02-24   71   * Connection established.\nec16227e14141e Andy Grover                  2009-02-24   72   * We get here for both outgoing and incoming connection.\nec16227e14141e Andy Grover                  2009-02-24   73   */\nec16227e14141e Andy Grover                  2009-02-24   74  void rds_ib_cm_connect_complete(struct rds_connection *conn, struct rdma_cm_event *event)\nec16227e14141e Andy Grover                  2009-02-24   75  {\nec16227e14141e Andy Grover                  2009-02-24   76  \tstruct rds_ib_connection *ic = conn->c_transport_data;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   77  \tconst union rds_ib_conn_priv *dp = NULL;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   78  \t__be64 ack_seq = 0;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   79  \t__be32 credit = 0;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   80  \tu8 major = 0;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   81  \tu8 minor = 0;\nec16227e14141e Andy Grover                  2009-02-24   82  \tint err;\nec16227e14141e Andy Grover                  2009-02-24   83  \nec16227e14141e Andy Grover                  2009-02-24   84  \tdp = event->param.conn.private_data;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   85  \tif (conn->c_isv6) {\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   86  \t\tif (event->param.conn.private_data_len >=\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   87  \t\t    sizeof(struct rds6_ib_connect_private)) {\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   88  \t\t\tmajor = dp->ricp_v6.dp_protocol_major;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   89  \t\t\tminor = dp->ricp_v6.dp_protocol_minor;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   90  \t\t\tcredit = dp->ricp_v6.dp_credit;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   91  \t\t\t/* dp structure start is not guaranteed to be 8 bytes\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   92  \t\t\t * aligned.  Since dp_ack_seq is 64-bit extended load\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   93  \t\t\t * operations can be used so go through get_unaligned\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   94  \t\t\t * to avoid unaligned errors.\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   95  \t\t\t */\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23  @96  \t\t\tack_seq = get_unaligned(&dp->ricp_v6.dp_ack_seq);\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   97  \t\t}\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   98  \t} else if (event->param.conn.private_data_len >=\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23   99  \t\t   sizeof(struct rds_ib_connect_private)) {\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23  100  \t\tmajor = dp->ricp_v4.dp_protocol_major;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23  101  \t\tminor = dp->ricp_v4.dp_protocol_minor;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23  102  \t\tcredit = dp->ricp_v4.dp_credit;\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23  103  \t\tack_seq = get_unaligned(&dp->ricp_v4.dp_ack_seq);\neee2fa6ab32251 Ka-Cheong Poon               2018-07-23  104  \t}\nec16227e14141e Andy Grover                  2009-02-24  105  \n02a6a2592e4",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 36/36] sched: Enable context analysis for core.c and fair.c",
      "normalized_subject": "sched: Enable context analysis for core.c and fair.c",
      "message_count": 1,
      "participants": [
        "Bart Van Assche"
      ],
      "categories": [
        "context_analysis"
      ],
      "first_date": "2026-01-12T22:04:59+00:00",
      "last_date": "2026-01-12T22:04:59+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176825831021305.mbox",
          "message_id": "<3de714fc-7a18-4bcc-9ab5-c3831efbdb84 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 36/36] sched: Enable context analysis for core.c and fair.c",
          "date": "2026-01-12 22:04:59+00:00",
          "date_str": "Mon, 12 Jan 2026 22:04:59 +0000",
          "body": "On 12/19/25 8:40 AM, Marco Elver wrote:\n> diff --git a/include/linux/sched/signal.h b/include/linux/sched/signal.h\n> index a63f65aa5bdd..a22248aebcf9 100644\n> --- a/include/linux/sched/signal.h\n> +++ b/include/linux/sched/signal.h\n> @@ -738,10 +738,12 @@ static inline int thread_group_empty(struct task_struct *p)\n>   \t\t(thread_group_leader(p) && !thread_group_empty(p))\n>   \n>   extern struct sighand_struct *lock_task_sighand(struct task_struct *task,\n> -\t\t\t\t\t\tunsigned long *flags);\n> +\t\t\t\t\t\tunsigned long *flags)\n> +\t__acquires(&task->sighand->siglock);\n\nI think the above annotation is wrong and should be changed into\n__cond_acquires(nonnull, &task->sighand->siglock). My understanding of\nthe code in kernel/signal.c is that lock_task_sighand() only returns\nwith sighand->siglock acquired if it returns a non-NULL pointer.\n\nBart.\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "context_analysis"
    },
    {
      "subject": "[PATCH] sparse/dissect: change do_symbol(sym) to use sym->definition",
      "normalized_subject": "sparse/dissect: change do_symbol(sym) to use sym->definition",
      "message_count": 1,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2026-01-11T17:28:26+00:00",
      "last_date": "2026-01-11T17:28:26+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176815530510428.mbox",
          "message_id": "<aWPduv1ewBCFVn5w () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/dissect: change do_symbol(sym) to use sym->definition",
          "date": "2026-01-11 17:28:26+00:00",
          "date_str": "Sun, 11 Jan 2026 17:28:26 +0000",
          "body": "Test-case:\n\n\t$ cat TEST.c\n\tstatic inline void i_func(void) { FUNC(); }\n\tstatic inline void i_func(void);\n\tvoid func(void) { i_func(); }\n\n\t$ ./test-dissect TEST.c\n\n\t   3:6                    def   f func                             void ( ... )\n\t   2:20                   def   f i_func                           void ( ... )\n\t   3:19  func             --r   f i_func                           void ( ... )\n\ndissect reports the wrong position for the definition of i_func()\nand doesn't inspect its body.\n\nThis is because the 2nd external_declaration() binds another SYM_NODE\nto the same ident and lookup_symbol() called during parsing returns\nthe most recent one, which is then used by do_symbol().\n\nWith this patch:\n\n\t$ ./test-dissect TEST.c\n\n\t   3:6                    def   f func                             void ( ... )\n\t   1:20                   def   f i_func                           void ( ... )\n\t   1:35  i_func           --r   f FUNC                             bad type\n\t   3:19  func             --r   f i_func                           void ( ... )\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n dissect.c | 7 ++++++-\n 1 file changed, 6 insertions(+), 1 deletion(-)\n\ndiff --git a/dissect.c b/dissect.c\nindex a0fda09c..f20522f0 100644\n--- a/dissect.c\n+++ b/dissect.c\n@@ -630,12 +630,17 @@ static inline bool is_typedef(struct symbol *sym)\n \treturn (sym->namespace == NS_TYPEDEF);\n }\n \n-static struct symbol *do_symbol(struct symbol *sym)\n+static struct symbol *do_symbol(struct symbol *__sym)\n {\n+\tstruct symbol *sym = __sym->definition ?: __sym;\n \tstruct symbol *type = base_type(sym);\n \tstruct symbol *dctx = dissect_ctx;\n \tstruct statement *stmt;\n \n+\tif (sym->inspected)\n+\t\treturn type;\n+\tsym->inspected = 1;\n+\n \treporter->r_symdef(sym);\n \n \tswitch (type->type) {\n-- \n2.52.0\n\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "[PATCH] sparse/semind: change r_member() to use r_symbol() when mem->kind == 'e'",
      "normalized_subject": "sparse/semind: change r_member() to use r_symbol() when mem->kind == 'e'",
      "message_count": 1,
      "participants": [
        "Oleg Nesterov"
      ],
      "categories": [
        "general"
      ],
      "first_date": "2026-01-11T17:28:14+00:00",
      "last_date": "2026-01-11T17:28:14+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176815528310373.mbox",
          "message_id": "<aWPdrkv4DTnGRHPf () redhat ! com>",
          "author_name": "Oleg Nesterov",
          "author_email": "oleg () redhat ! com",
          "subject": "[PATCH] sparse/semind: change r_member() to use r_symbol() when mem->kind == 'e'",
          "date": "2026-01-11 17:28:14+00:00",
          "date_str": "Sun, 11 Jan 2026 17:28:14 +0000",
          "body": "dissect() tries to provide as much info as possible, but from the\nsemind's perspective it doesn't make sense to store the enumerators\nas members; this just complicates the searching.\n\nSigned-off-by: Oleg Nesterov <oleg@redhat.com>\n---\n semind.c | 3 +++\n 1 file changed, 3 insertions(+)\n\ndiff --git a/semind.c b/semind.c\nindex e9708444..92b8f243 100644\n--- a/semind.c\n+++ b/semind.c\n@@ -746,6 +746,9 @@ static void r_member(unsigned mode, struct position *pos, struct symbol *sym, st\n \tstruct ident *ctx = &null;\n \tstruct index_record rec;\n \n+\tif (mem && mem->kind == 'e')\n+\t\treturn r_symbol(mode, pos, mem);\n+\n \tupdate_stream();\n \n \tif (semind_streams[pos->stream].id == -1)\n-- \n2.52.0\n\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "general"
    },
    {
      "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
      "normalized_subject": "locking/mutex: Support Clang's context analysis",
      "message_count": 31,
      "participants": [
        "Marco Elver",
        "Bart Van Assche",
        "Steven Rostedt",
        "Christoph Hellwig"
      ],
      "categories": [
        "context_analysis",
        "compiler_compat"
      ],
      "first_date": "2026-01-08T22:10:25+00:00",
      "last_date": "2026-01-10T03:23:16+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176791303920349.mbox",
          "message_id": "<57062131-e79e-42c2-aa0b-8f931cb8cac2 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 22:10:25+00:00",
          "date_str": "Thu, 08 Jan 2026 22:10:25 +0000",
          "body": "On 12/19/25 8:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> index bf535f0118bb..89977c215cbd 100644\n> --- a/include/linux/mutex.h\n> +++ b/include/linux/mutex.h\n> @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\t\\\n>   \t\t\t\t\t\t\t\t\t\\\n>   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n>   } while (0)\n\nThe above type of change probably will have to be reverted. If I enable\ncontext analysis for the entire kernel tree, drivers/base/devcoredump.c\ndoesn't build. The following error is reported:\n\ndrivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' \nthat is already held [-Werror,-Wthread-safety-analysis]\n   406 |         mutex_lock(&devcd->mutex);\n       |         ^\n\ndev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the \nsame function. The above type of change breaks compilation of all code\nthat initializes and locks a synchronization object from the same\nfunction. My understanding of dev_coredumpm_timeout() is that there is a\ngood reason for calling both mutex_init() and mutex_lock() from that\nfunction. Possible solutions are disabling context analysis for that\nfunction or removing __assume_ctx_lock() again from mutex_init(). Does\nanyone want to share their opinion about this?\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791303820346.mbox",
          "message_id": "<57062131-e79e-42c2-aa0b-8f931cb8cac2 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 22:10:25+00:00",
          "date_str": "Thu, 08 Jan 2026 22:10:25 +0000",
          "body": "On 12/19/25 8:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> index bf535f0118bb..89977c215cbd 100644\n> --- a/include/linux/mutex.h\n> +++ b/include/linux/mutex.h\n> @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\t\\\n>   \t\t\t\t\t\t\t\t\t\\\n>   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n>   } while (0)\n\nThe above type of change probably will have to be reverted. If I enable\ncontext analysis for the entire kernel tree, drivers/base/devcoredump.c\ndoesn't build. The following error is reported:\n\ndrivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' \nthat is already held [-Werror,-Wthread-safety-analysis]\n   406 |         mutex_lock(&devcd->mutex);\n       |         ^\n\ndev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the \nsame function. The above type of change breaks compilation of all code\nthat initializes and locks a synchronization object from the same\nfunction. My understanding of dev_coredumpm_timeout() is that there is a\ngood reason for calling both mutex_init() and mutex_lock() from that\nfunction. Possible solutions are disabling context analysis for that\nfunction or removing __assume_ctx_lock() again from mutex_init(). Does\nanyone want to share their opinion about this?\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791305820354.mbox",
          "message_id": "<57062131-e79e-42c2-aa0b-8f931cb8cac2 () acm ! org>",
          "author_name": "Bart Van Assche",
          "author_email": "bvanassche () acm ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 22:10:25+00:00",
          "date_str": "Thu, 08 Jan 2026 22:10:25 +0000",
          "body": "On 12/19/25 8:39 AM, Marco Elver wrote:\n> diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> index bf535f0118bb..89977c215cbd 100644\n> --- a/include/linux/mutex.h\n> +++ b/include/linux/mutex.h\n> @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n>   \tstatic struct lock_class_key __key;\t\t\t\t\\\n>   \t\t\t\t\t\t\t\t\t\\\n>   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n>   } while (0)\n\nThe above type of change probably will have to be reverted. If I enable\ncontext analysis for the entire kernel tree, drivers/base/devcoredump.c\ndoesn't build. The following error is reported:\n\ndrivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' \nthat is already held [-Werror,-Wthread-safety-analysis]\n   406 |         mutex_lock(&devcd->mutex);\n       |         ^\n\ndev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the \nsame function. The above type of change breaks compilation of all code\nthat initializes and locks a synchronization object from the same\nfunction. My understanding of dev_coredumpm_timeout() is that there is a\ngood reason for calling both mutex_init() and mutex_lock() from that\nfunction. Possible solutions are disabling context analysis for that\nfunction or removing __assume_ctx_lock() again from mutex_init(). Does\nanyone want to share their opinion about this?\n\nThanks,\n\nBart.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791762023521.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791760423505.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791760223498.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791761023512.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791761423518.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791760323501.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176791761323515.mbox",
          "message_id": "<aWA9P3_oI7JFTdkC () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-08 23:26:55+00:00",
          "date_str": "Thu, 08 Jan 2026 23:26:55 +0000",
          "body": "On Thu, Jan 08, 2026 at 02:10PM -0800, 'Bart Van Assche' via kasan-dev wrote:\n> On 12/19/25 8:39 AM, Marco Elver wrote:\n> > diff --git a/include/linux/mutex.h b/include/linux/mutex.h\n> > index bf535f0118bb..89977c215cbd 100644\n> > --- a/include/linux/mutex.h\n> > +++ b/include/linux/mutex.h\n> > @@ -62,6 +62,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n> >   \tstatic struct lock_class_key __key;\t\t\t\t\\\n> >   \t\t\t\t\t\t\t\t\t\\\n> >   \t__mutex_init((mutex), #mutex, &__key);\t\t\t\t\\\n> > +\t__assume_ctx_lock(mutex);\t\t\t\t\t\\\n> >   } while (0)\n> \n> The above type of change probably will have to be reverted. If I enable\n> context analysis for the entire kernel tree, drivers/base/devcoredump.c\n> doesn't build. The following error is reported:\n> \n> drivers/base/devcoredump.c:406:2: error: acquiring mutex '_res->mutex' that\n> is already held [-Werror,-Wthread-safety-analysis]\n>   406 |         mutex_lock(&devcd->mutex);\n>       |         ^\n> \n> dev_coredumpm_timeout() calls mutex_init() and mutex_lock() from the same\n> function. The above type of change breaks compilation of all code\n> that initializes and locks a synchronization object from the same\n> function. My understanding of dev_coredumpm_timeout() is that there is a\n> good reason for calling both mutex_init() and mutex_lock() from that\n> function. Possible solutions are disabling context analysis for that\n> function or removing __assume_ctx_lock() again from mutex_init(). Does\n> anyone want to share their opinion about this?\n\nProbably the most idiomatic option is to just factor out construction.\nClearly separating complex object construction from use also helps\nreadability regardless, esp. where concurrency is involved. We could\ndocument such advice somewhere.\n\nFor the above case, this seems cleanest and also clearer to me:\n\ndiff --git a/drivers/base/devcoredump.c b/drivers/base/devcoredump.c\nindex 55bdc7f5e59d..56ac8aa41608 100644\n--- a/drivers/base/devcoredump.c\n+++ b/drivers/base/devcoredump.c\n@@ -339,6 +339,40 @@ void dev_coredump_put(struct device *dev)\n }\n EXPORT_SYMBOL_GPL(dev_coredump_put);\n \n+static struct devcd_entry *\n+dev_coredumpm_init(struct device *dev, struct module *owner, void *data,\n+\t\t   size_t datalen, gfp_t gfp,\n+\t\t   ssize_t (*read)(char *buffer, loff_t offset, size_t count,\n+\t\t\t\t   void *data, size_t datalen),\n+\t\t   void (*free)(void *data))\n+{\n+\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n+\tstruct devcd_entry *devcd;\n+\n+\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tif (!devcd)\n+\t\treturn NULL;\n+\n+\tdevcd->owner = owner;\n+\tdevcd->data = data;\n+\tdevcd->datalen = datalen;\n+\tdevcd->read = read;\n+\tdevcd->free = free;\n+\tdevcd->failing_dev = get_device(dev);\n+\tdevcd->deleted = false;\n+\n+\tmutex_init(&devcd->mutex);\n+\tdevice_initialize(&devcd->devcd_dev);\n+\n+\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n+\t\t     atomic_inc_return(&devcd_count));\n+\tdevcd->devcd_dev.class = &devcd_class;\n+\n+\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n+\n+\treturn devcd;\n+}\n+\n /**\n  * dev_coredumpm_timeout - create device coredump with read/free methods with a\n  * custom timeout.\n@@ -364,7 +398,6 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \t\t\t   void (*free)(void *data),\n \t\t\t   unsigned long timeout)\n {\n-\tstatic atomic_t devcd_count = ATOMIC_INIT(0);\n \tstruct devcd_entry *devcd;\n \tstruct device *existing;\n \n@@ -381,27 +414,10 @@ void dev_coredumpm_timeout(struct device *dev, struct module *owner,\n \tif (!try_module_get(owner))\n \t\tgoto free;\n \n-\tdevcd = kzalloc(sizeof(*devcd), gfp);\n+\tdevcd = dev_coredumpm_init(dev, owner, data, datalen, gfp, read, free);\n \tif (!devcd)\n \t\tgoto put_module;\n \n-\tdevcd->owner = owner;\n-\tdevcd->data = data;\n-\tdevcd->datalen = datalen;\n-\tdevcd->read = read;\n-\tdevcd->free = free;\n-\tdevcd->failing_dev = get_device(dev);\n-\tdevcd->deleted = false;\n-\n-\tmutex_init(&devcd->mutex);\n-\tdevice_initialize(&devcd->devcd_dev);\n-\n-\tdev_set_name(&devcd->devcd_dev, \"devcd%d\",\n-\t\t     atomic_inc_return(&devcd_count));\n-\tdevcd->devcd_dev.class = &devcd_class;\n-\n-\tdev_set_uevent_suppress(&devcd->devcd_dev, true);\n-\n \t/* devcd->mutex prevents devcd_del() completing until init finishes */\n \tmutex_lock(&devcd->mutex);\n \tdevcd->init_completed = false;\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794143105689.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794143505693.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794140505653.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794141905683.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794135205563.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794141105674.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176794140605656.mbox",
          "message_id": "<20260109060249.GA5259 () lst ! de>",
          "author_name": "Christoph Hellwig",
          "author_email": "hch () lst ! de",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 06:02:49+00:00",
          "date_str": "Fri, 09 Jan 2026 06:02:49 +0000",
          "body": "On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> Probably the most idiomatic option is to just factor out construction.\n> Clearly separating complex object construction from use also helps\n> readability regardless, esp. where concurrency is involved. We could\n> document such advice somewhere.\n\nInitializing and locking a mutex (or spinlock, or other primitive) is a\nnot too unusual pattern, often used when inserting an object into a\nhash table or other lookup data structure.  So supporting it without\ncreating pointless wrapper functions would be really useful.  One thing\nthat would be nice to have and probably help here is to have lock\ninitializers that create the lock in a held state.\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796681526998.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796679926983.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796680226986.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796804728088.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796750927580.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796804628085.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176796750827579.mbox",
          "message_id": "<20260109080715.0a390f6b () gandalf ! local ! home>",
          "author_name": "Steven Rostedt",
          "author_email": "rostedt () goodmis ! org",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-09 13:07:15+00:00",
          "date_str": "Fri, 09 Jan 2026 13:07:15 +0000",
          "body": "On Fri, 9 Jan 2026 07:02:49 +0100\nChristoph Hellwig <hch@lst.de> wrote:\n\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.  \n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nRight. If tooling can't handle a simple pattern of initializing a lock than\ntaking it, that's a hard show stopper of adding that tooling.\n\n-- Steve\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801818301665.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801820901701.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801818501673.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801818401668.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801819201679.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801818901676.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176801820501698.mbox",
          "message_id": "<aWHGJA8imMgELQrA () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 10/36] locking/mutex: Support Clang's context analysis",
          "date": "2026-01-10 03:23:16+00:00",
          "date_str": "Sat, 10 Jan 2026 03:23:16 +0000",
          "body": "On Fri, Jan 09, 2026 at 07:02AM +0100, Christoph Hellwig wrote:\n> On Fri, Jan 09, 2026 at 12:26:55AM +0100, Marco Elver wrote:\n> > Probably the most idiomatic option is to just factor out construction.\n> > Clearly separating complex object construction from use also helps\n> > readability regardless, esp. where concurrency is involved. We could\n> > document such advice somewhere.\n> \n> Initializing and locking a mutex (or spinlock, or other primitive) is a\n> not too unusual pattern, often used when inserting an object into a\n> hash table or other lookup data structure.  So supporting it without\n> creating pointless wrapper functions would be really useful.  One thing\n> that would be nice to have and probably help here is to have lock\n> initializers that create the lock in a held state.\n\nFair point. Without new APIs, we can fix it with the below patch;\nessentially \"promoting\" the context lock to \"reentrant\" during\ninitialization scope. It's not exactly well documented on the Clang\nside, but is a side-effect of how reentrancy works in the analysis:\nhttps://github.com/llvm/llvm-project/pull/175267\n\n------ >8 ------\n\nFrom 9c9b521b286f241f849dcc4f9efbd9582dabd3cc Mon Sep 17 00:00:00 2001\nFrom: Marco Elver <elver@google.com>\nDate: Sat, 10 Jan 2026 00:47:35 +0100\nSubject: [PATCH] compiler-context-analysis: Support immediate acquisition\n after initialization\n\nWhen a lock is initialized (e.g. mutex_init()), we assume/assert that\nthe context lock is held to allow initialization of guarded members\nwithin the same scope.\n\nHowever, this previously prevented actually acquiring the lock within\nthat same scope, as the analyzer would report a double-lock warning:\n\n  mutex_init(&mtx);\n  ...\n  mutex_lock(&mtx); // acquiring mutex 'mtx' that is already held\n\nTo fix (without new init+lock APIs), we can tell the analysis to treat\nthe \"held\" context lock resulting from initialization as reentrant,\nallowing subsequent acquisitions to succeed.\n\nTo do so *only* within the initialization scope, we can cast the lock\npointer to any reentrant type for the init assume/assert. Introduce a\ngeneric reentrant context lock type `struct __ctx_lock_init` and add\n`__inits_ctx_lock()` that casts the lock pointer to this type before\nassuming/asserting it.\n\nThis ensures that the initial \"held\" state is reentrant, allowing\npatterns like:\n\n  mutex_init(&lock);\n  ...\n  mutex_lock(&lock);\n\nto compile without false positives, and avoids having to make all\ncontext lock types reentrant outside an initialization scope.\n\nThe caveat here is missing real double-lock bugs right after init scope.\nHowever, this is a classic trade-off of avoiding false positives against\n(unlikely) false negatives.\n\nLink: https://lore.kernel.org/all/57062131-e79e-42c2-aa0b-8f931cb8cac2@acm.org/\nReported-by: Bart Van Assche <bvanassche@acm.org>\nSigned-off-by: Marco Elver <elver@google.com>\n---\n include/linux/compiler-context-analysis.h | 12 ++++++++++++\n include/linux/local_lock_internal.h       |  6 +++---\n include/linux/mutex.h                     |  2 +-\n include/linux/rwlock.h                    |  4 ++--\n include/linux/rwlock_rt.h                 |  2 +-\n include/linux/rwsem.h                     |  4 ++--\n include/linux/seqlock.h                   |  2 +-\n include/linux/spinlock.h                  |  8 ++++----\n include/linux/spinlock_rt.h               |  2 +-\n include/linux/ww_mutex.h                  |  2 +-\n lib/test_context-analysis.c               |  3 +++\n 11 files changed, 31 insertions(+), 16 deletions(-)\n\ndiff --git a/include/linux/compiler-context-analysis.h b/include/linux/compiler-context-analysis.h\nindex db7e0d48d8f2..e056cd6e8aaa 100644\n--- a/include/linux/compiler-context-analysis.h\n+++ b/include/linux/compiler-context-analysis.h\n@@ -43,6 +43,14 @@\n # define __assumes_ctx_lock(...)\t\t__attribute__((assert_capability(__VA_ARGS__)))\n # define __assumes_shared_ctx_lock(...)\t__attribute__((assert_shared_capability(__VA_ARGS__)))\n \n+/*\n+ * Generic reentrant context lock type that we cast to when initializing context\n+ * locks with __assumes_ctx_lock(), so that we can support guarded member\n+ * initialization, but also immediate use after initialization.\n+ */\n+struct __ctx_lock_type(init_generic) __reentrant_ctx_lock __ctx_lock_init;\n+# define __inits_ctx_lock(var) __assumes_ctx_lock((const struct __ctx_lock_init *)(var))\n+\n /**\n  * __guarded_by - struct member and globals attribute, declares variable\n  *                only accessible within active context\n@@ -120,6 +128,8 @@\n \t\t__attribute__((overloadable)) __assumes_ctx_lock(var) { }\t\t\t\t\\\n \tstatic __always_inline void __assume_shared_ctx_lock(const struct name *var)\t\t\t\\\n \t\t__attribute__((overloadable)) __assumes_shared_ctx_lock(var) { }\t\t\t\\\n+\tstatic __always_inline void __init_ctx_lock(const struct name *var)\t\t\t\t\\\n+\t\t__attribute__((overloadable)) __inits_ctx_lock(var) { }\t\t\t\t\t\\\n \tstruct name\n \n /**\n@@ -162,6 +172,7 @@\n # define __releases_shared_ctx_lock(...)\n # define __assumes_ctx_lock(...)\n # define __assumes_sha",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "issue with _Static_assert and __builtin()s",
      "normalized_subject": "issue with _Static_assert and __builtin()s",
      "message_count": 3,
      "participants": [
        "Ben Dooks",
        "Dan Carpenter"
      ],
      "categories": [
        "kernel_integration",
        "rfc_proposals",
        "compiler_compat",
        "sparse_internals"
      ],
      "first_date": "2026-01-07T19:41:45+00:00",
      "last_date": "2026-01-08T09:38:25+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176781828803527.mbox",
          "message_id": "<2943a1fd-1168-4043-bede-8f39cad4444b () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "issue with _Static_assert and __builtin()s",
          "date": "2026-01-07 19:41:45+00:00",
          "date_str": "Wed, 07 Jan 2026 19:41:45 +0000",
          "body": "This is a multi-part message in MIME format.\n--------------g2cVKzvqn4i6DYTqoYhBm6vd\nContent-Type: text/plain; charset=UTF-8; format=flowed\nContent-Transfer-Encoding: 7bit\n\nSo I am looking at why the Linux kernel's check for nul characters\nin strings is causing errors out of sparse.\n\nEG:\ndrivers/md/dm.c:3813:1: error: bad constant expression\ndrivers/md/dm.c:3814:1: error: bad constant expression\ndrivers/md/dm.c:3816:1: error: bad constant expression\ndrivers/md/dm.c:3817:1: error: bad constant expression\n\nI've tracked it down to the sizeof(str) - 1 == __builtin_strlen(str)\nfailing to be a good constant expression...\n\nThis is an example of the assert which isn't working:\n\n_Static_assert(sizeof(\"moo\") - 1 == __builtin_strlen(\"moo\"), \"nul!\");\n\nThis does at least get past w/o warnings\n_Static_assert(__builtin_types_compatible_p(int, int), \"doh!\");\n\nI've had a go at updating builtin.c to deal with __builtin_strlen()\nfor a string constant (attached) but that's just changing the\noutput to \"error: bad integer constant expression\" so not sure\nwhat I've missed here.\n\n\n-- \nBen Dooks\t\t\t\thttp://www.codethink.co.uk/\nSenior Engineer\t\t\t\tCodethink - Providing Genius\n\nhttps://www.codethink.co.uk/privacy.html\n\n--------------g2cVKzvqn4i6DYTqoYhBm6vd\nContent-Type: text/x-patch; charset=UTF-8; name=\"initial-strlen.patch\"\nContent-Disposition: attachment; filename=\"initial-strlen.patch\"\nContent-Transfer-Encoding: base64\n\nZGlmZiAtLWdpdCBhL2J1aWx0aW4uYyBiL2J1aWx0aW4uYwppbmRleCBlNDc1MTQ0NS4uZDdl\nNTZiMzQgMTAwNjQ0Ci0tLSBhL2J1aWx0aW4uYworKysgYi9idWlsdGluLmMKQEAgLTU5Niw2\nICs1OTYsNDkgQEAgc3RhdGljIHN0cnVjdCBzeW1ib2xfb3Agb2JqZWN0X3NpemVfb3AgPSB7\nCiAJLmV4cGFuZCA9IGV4cGFuZF9vYmplY3Rfc2l6ZSwKIH07CiAKKyNpbmNsdWRlIDxzdHJp\nbmcuaD4KK3N0YXRpYyBpbnQgZXhwYW5kX3N0cmxlbihzdHJ1Y3QgZXhwcmVzc2lvbiAqZXhw\nciwgaW50IGNvc3QpCit7CisJc3RydWN0IGV4cHJlc3Npb24gKmluaXQsICphcmcgPSBmaXJz\ndF9leHByZXNzaW9uKGV4cHItPmFyZ3MpOworCXVuc2lnbmVkIGxvbmcgdmFsID0gMDsKKwor\nCWlmICghYXJnKQorCQlyZXR1cm4gVU5TQUZFOwkvLyA/IG9rCisKKwlzd2l0Y2ggKGFyZy0+\ndHlwZSkgeworCWNhc2UgRVhQUl9TVFJJTkc6CisJCS8vdG9kby8vCisJCWJyZWFrOworCWNh\nc2UgRVhQUl9TWU1CT0w6CisJCWlmIChhcmctPnN5bWJvbC0+aWRlbnQpCisJCQlnb3RvIG5v\ndF9saXRlcmFsOworCisJCWluaXQgPSBhcmctPnN5bWJvbC0+aW5pdGlhbGl6ZXI7CisJCWlm\nICghaW5pdCB8fCBpbml0LT50eXBlICE9IEVYUFJfU1RSSU5HKQorCQkJZ290byBub3RfbGl0\nZXJhbDsKKworCQl2YWwgPSBzdHJsZW4oaW5pdC0+c3RyaW5nLT5kYXRhKTsKKwkJYnJlYWs7\nCisJZGVmYXVsdDoKKwkJZ290byBub3RfbGl0ZXJhbDsKKwkJYnJlYWs7CisJfQorCisJZXhw\nci0+dHlwZSA9IEVYUFJfVkFMVUU7CisJZXhwci0+ZmxhZ3MgfD0gQ0VGX1NFVF9JQ0U7CisJ\nZXhwci0+dmFsdWUgPSB2YWw7CisJZXhwci0+dGFpbnQgPSAwOworCXJldHVybiAwOworCitu\nb3RfbGl0ZXJhbDoKKwlyZXR1cm4gVU5TQUZFOworfQorCisKK3N0YXRpYyBzdHJ1Y3Qgc3lt\nYm9sX29wIHN0cmxlbl9vcCA9IHsKKwkuZXhwYW5kID0gZXhwYW5kX3N0cmxlbiwKK307CisK\nIC8qCiAgKiBCdWlsdGluIGZ1bmN0aW9ucwogICovCkBAIC03NzUsNyArODE4LDcgQEAgc3Rh\ndGljIGNvbnN0IHN0cnVjdCBidWlsdGluX2ZuIGJ1aWx0aW5zX2NvbW1vbltdID0gewogCXsg\nIl9fYnVpbHRpbl9zdHJjcHkiLCAmc3RyaW5nX2N0eXBlLCAwLCB7ICZzdHJpbmdfY3R5cGUs\nICZjb25zdF9zdHJpbmdfY3R5cGUgfX0sCiAJeyAiX19idWlsdGluX3N0cmNzcG4iLCBzaXpl\nX3RfY3R5cGUsIDAsIHsgJmNvbnN0X3N0cmluZ19jdHlwZSwgJmNvbnN0X3N0cmluZ19jdHlw\nZSB9fSwKIAl7ICJfX2J1aWx0aW5fc3RyZHVwIiwgJnN0cmluZ19jdHlwZSwgMCwgeyAmY29u\nc3Rfc3RyaW5nX2N0eXBlIH19LAotCXsgIl9fYnVpbHRpbl9zdHJsZW4iLCBzaXplX3RfY3R5\ncGUsIDAsIHsgJmNvbnN0X3N0cmluZ19jdHlwZSB9fSwKKwl7ICJfX2J1aWx0aW5fc3RybGVu\nIiwgc2l6ZV90X2N0eXBlLCAxLCB7ICZzdHJpbmdfY3R5cGUgIH0sIC5vcCA9ICZzdHJsZW5f\nb3AgfSwKIAl7ICJfX2J1aWx0aW5fc3RybmNhc2VjbXAiLCAmaW50X2N0eXBlLCAwLCB7ICZj\nb25zdF9zdHJpbmdfY3R5cGUsICZjb25zdF9zdHJpbmdfY3R5cGUsIHNpemVfdF9jdHlwZSB9\nfSwKIAl7ICJfX2J1aWx0aW5fc3RybmNhdCIsICZzdHJpbmdfY3R5cGUsIDAsIHsgJnN0cmlu\nZ19jdHlwZSwgJmNvbnN0X3N0cmluZ19jdHlwZSwgc2l6ZV90X2N0eXBlIH19LAogCXsgIl9f\nYnVpbHRpbl9zdHJuY21wIiwgJmludF9jdHlwZSwgMCwgeyAmY29uc3Rfc3RyaW5nX2N0eXBl\nLCAmY29uc3Rfc3RyaW5nX2N0eXBlLCBzaXplX3RfY3R5cGUgfX0sCg==\n\n--------------g2cVKzvqn4i6DYTqoYhBm6vd--\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176785367327533.mbox",
          "message_id": "<aV9DhtIM7Z5ZmJRz () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: issue with _Static_assert and __builtin()s",
          "date": "2026-01-08 05:41:26+00:00",
          "date_str": "Thu, 08 Jan 2026 05:41:26 +0000",
          "body": "On Wed, Jan 07, 2026 at 07:41:45PM +0000, Ben Dooks wrote:\n> So I am looking at why the Linux kernel's check for nul characters\n> in strings is causing errors out of sparse.\n> \n> EG:\n> drivers/md/dm.c:3813:1: error: bad constant expression\n> drivers/md/dm.c:3814:1: error: bad constant expression\n> drivers/md/dm.c:3816:1: error: bad constant expression\n> drivers/md/dm.c:3817:1: error: bad constant expression\n> \n> I've tracked it down to the sizeof(str) - 1 == __builtin_strlen(str)\n> failing to be a good constant expression...\n> \n> This is an example of the assert which isn't working:\n> \n> _Static_assert(sizeof(\"moo\") - 1 == __builtin_strlen(\"moo\"), \"nul!\");\n> \n> This does at least get past w/o warnings\n> _Static_assert(__builtin_types_compatible_p(int, int), \"doh!\");\n> \n> I've had a go at updating builtin.c to deal with __builtin_strlen()\n> for a string constant (attached) but that's just changing the\n> output to \"error: bad integer constant expression\" so not sure\n> what I've missed here.\n> \n\nAl has a fix for that.\nhttps://git.kernel.org/pub/scm/linux/kernel/git/viro/sparse.git/commit/?id=2634e39bf02697a18fece057208150362c985992\n\nregards,\ndan carpenter\n\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176787216109614.mbox",
          "message_id": "<13cb6e5b-94f0-487d-a8fb-9e5ab8a3e45c () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "Re: issue with _Static_assert and __builtin()s",
          "date": "2026-01-08 09:38:25+00:00",
          "date_str": "Thu, 08 Jan 2026 09:38:25 +0000",
          "body": "On 08/01/2026 05:41, Dan Carpenter wrote:\n> On Wed, Jan 07, 2026 at 07:41:45PM +0000, Ben Dooks wrote:\n>> So I am looking at why the Linux kernel's check for nul characters\n>> in strings is causing errors out of sparse.\n>>\n>> EG:\n>> drivers/md/dm.c:3813:1: error: bad constant expression\n>> drivers/md/dm.c:3814:1: error: bad constant expression\n>> drivers/md/dm.c:3816:1: error: bad constant expression\n>> drivers/md/dm.c:3817:1: error: bad constant expression\n>>\n>> I've tracked it down to the sizeof(str) - 1 == __builtin_strlen(str)\n>> failing to be a good constant expression...\n>>\n>> This is an example of the assert which isn't working:\n>>\n>> _Static_assert(sizeof(\"moo\") - 1 == __builtin_strlen(\"moo\"), \"nul!\");\n>>\n>> This does at least get past w/o warnings\n>> _Static_assert(__builtin_types_compatible_p(int, int), \"doh!\");\n>>\n>> I've had a go at updating builtin.c to deal with __builtin_strlen()\n>> for a string constant (attached) but that's just changing the\n>> output to \"error: bad integer constant expression\" so not sure\n>> what I've missed here.\n>>\n> \n> Al has a fix for that.\n> https://git.kernel.org/pub/scm/linux/kernel/git/viro/sparse.git/commit/?id=2634e39bf02697a18fece057208150362c985992\n\nAh thanks, that'll save me a few hours of prodding my code to try\ngetting it working.\n\n-- \nBen Dooks\t\t\t\thttp://www.codethink.co.uk/\nSenior Engineer\t\t\t\tCodethink - Providing Genius\n\nhttps://www.codethink.co.uk/privacy.html\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "sparse_internals"
    },
    {
      "subject": "Re: req: option to show area warning is from",
      "normalized_subject": "req: option to show area warning is from",
      "message_count": 2,
      "participants": [
        "Ben Dooks",
        "Dan Carpenter"
      ],
      "categories": [
        "rfc_proposals",
        "compiler_compat",
        "type_system"
      ],
      "first_date": "2026-01-07T14:58:44+00:00",
      "last_date": "2026-01-07T19:40:32+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176781727802681.mbox",
          "message_id": "<944a3c73-f971-441c-8ba6-344f1ac099f3 () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "req: option to show area warning is from",
          "date": "2026-01-07 14:58:44+00:00",
          "date_str": "Wed, 07 Jan 2026 14:58:44 +0000",
          "body": "SSB0aGluayBpdCB3b3VsZCBiZSB1c2VmdWwgdG8gaGF2ZSBhbiBvcHRpb24gdG8gc2hvdyBh\nIG1vcmUgZGV0YWlsZWQNCnZpZXcgb2Ygd2hpY2ggcGFydCBvZiB0aGUgc291cmNlIGdlbmVy\nYXRlZCBhIHdhcm5pbmcuIFdvdWxkIHRoaXMgYmUNCnBvc3NpYmxlIGFuZCBpZiBzbyBpcyB0\naGVyZSBhbnlvbmUgaW50ZXJlc3RlZCBpbiBkb2luZyBpdD8NCg0KSSdtIGxvb2tpbmcgYXQg\ndGhlIGZvbGxvd2luZyB3YXJuaW5nOg0KLi9pbmNsdWRlL3RyYWNlL2V2ZW50cy94ZHAuaDoz\nMDQ6MTogd2FybmluZzogVXNpbmcgcGxhaW4gaW50ZWdlciBhcyBOVUxMIA0KcG9pbnRlcg0K\nDQpBbmQgdGhlIGtlcm5lbCBzb3VyY2UgZnJvbSB0aGUgcHJlLXByb2Nlc3NlZCBmaWxlIGxv\nb2tzIGxpa2UgdGhpczoNCg0KPiBzdGF0aWMgX19hdHRyaWJ1dGVfXygobm9faW5zdHJ1bWVu\ndF9mdW5jdGlvbikpIHZvaWQgZG9fcGVyZl90cmFjZV9tZW1fZGlzY29ubmVjdCh2b2lkICpf\nX2RhdGEsIGNvbnN0IHN0cnVjdCB4ZHBfbWVtX2FsbG9jYXRvciAqeGEpIHsgc3RydWN0IHRy\nYWNlX2V2ZW50X2NhbGwgKmV2ZW50X2NhbGwgPSBfX2RhdGE7IHN0cnVjdCB0cmFjZV9ldmVu\ndF9kYXRhX29mZnNldHNfbWVtX2Rpc2Nvbm5lY3QgX19hdHRyaWJ1dGVfXygoX191bnVzZWRf\nXykpIF9fZGF0YV9vZmZzZXRzOyBzdHJ1Y3QgdHJhY2VfZXZlbnRfcmF3X21lbV9kaXNjb25u\nZWN0ICplbnRyeTsgc3RydWN0IHB0X3JlZ3MgKl9fcmVnczsgdTY0IF9fY291bnQgPSAxOyBz\ndHJ1Y3QgdGFza19zdHJ1Y3QgKl9fdGFzayA9ICgodm9pZCAqKTApOyBzdHJ1Y3QgaGxpc3Rf\naGVhZCAqaGVhZDsgaW50IF9fZW50cnlfc2l6ZTsgaW50IF9fZGF0YV9zaXplOyBpbnQgcmN0\neDsgX19kYXRhX3NpemUgPSB0cmFjZV9ldmVudF9nZXRfb2Zmc2V0c19tZW1fZGlzY29ubmVj\ndCgmX19kYXRhX29mZnNldHMsIHhhKTsgaGVhZCA9ICh7IGRvIHsgY29uc3Qgdm9pZCBfX3Nl\nZ19ncyAqX192cHBfdmVyaWZ5ID0gKHR5cGVvZigoZXZlbnRfY2FsbC0+cGVyZl9ldmVudHMp\nICsgMCkpKCh2b2lkICopMCk7ICh2b2lkKV9fdnBwX3ZlcmlmeTsgfSB3aGlsZSAoMCk7ICh7\nIHVuc2lnbmVkIGxvbmcgdGNwX3B0cl9fID0gKHsgKiggdHlwZW9mKHRoaXNfY3B1X29mZikg\nKikoJih0aGlzX2NwdV9vZmYpKTsgfSk7IHRjcF9wdHJfXyArPSAoIHVuc2lnbmVkIGxvbmcp\nKGV2ZW50X2NhbGwtPnBlcmZfZXZlbnRzKTsgKF9fdHlwZW9mX3VucXVhbF9fKCooZXZlbnRf\nY2FsbC0+cGVyZl9ldmVudHMpKSAqKXRjcF9wdHJfXzsgfSk7IH0pOyBpZiAoIWJwZl9wcm9n\nX2FycmF5X3ZhbGlkKGV2ZW50X2NhbGwpICYmIF9fYnVpbHRpbl9jb25zdGFudF9wKCFfX3Rh\nc2spICYmICFfX3Rhc2sgJiYgaGxpc3RfZW1wdHkoaGVhZCkpIHJldHVybjsgX19lbnRyeV9z\naXplID0gKCgoKF9fZGF0YV9zaXplICsgc2l6ZW9mKCplbnRyeSkgKyBzaXplb2YodTMyKSkp\nICsgKChfX3R5cGVvZl9fKChfX2RhdGFfc2l6ZSArIHNpemVvZigqZW50cnkpICsgc2l6ZW9m\nKHUzMikpKSkoKHNpemVvZih1NjQpKSkgLSAxKSkgJiB+KChfX3R5cGVvZl9fKChfX2RhdGFf\nc2l6ZSArIHNpemVvZigqZW50cnkpICsgc2l6ZW9mKHUzMikpKSkoKHNpemVvZih1NjQpKSkg\nLSAxKSk7IF9fZW50cnlfc2l6ZSAtPSBzaXplb2YodTMyKTsgZW50cnkgPSBwZXJmX3RyYWNl\nX2J1Zl9hbGxvYyhfX2VudHJ5X3NpemUsICZfX3JlZ3MsICZyY3R4KTsgaWYgKCFlbnRyeSkg\ncmV0dXJuOyBwZXJmX2ZldGNoX2NhbGxlcl9yZWdzKF9fcmVncyk7IHsgZW50cnktPnhhID0g\neGE7IGVudHJ5LT5tZW1faWQgPSB4YS0+bWVtLmlkOyBlbnRyeS0+bWVtX3R5cGUgPSB4YS0+\nbWVtLnR5cGU7IGVudHJ5LT5hbGxvY2F0b3IgPSB4YS0+YWxsb2NhdG9yOzsgfSBwZXJmX3Ry\nYWNlX3J1bl9icGZfc3VibWl0KGVudHJ5LCBfX2VudHJ5X3NpemUsIHJjdHgsIGV2ZW50X2Nh\nbGwsIF9fY291bnQsIF9fcmVncywgaGVhZCwgX190YXNrKTsgfSBzdGF0aWMgX19hdHRyaWJ1\ndGVfXygobm9faW5zdHJ1bWVudF9mdW5jdGlvbikpIHZvaWQgcGVyZl90cmFjZV9tZW1fZGlz\nY29ubmVjdCh2b2lkICpfX2RhdGEsIGNvbnN0IHN0cnVjdCB4ZHBfbWVtX2FsbG9jYXRvciAq\neGEpIHsgdTY0IF9fY291bnQgX19hdHRyaWJ1dGVfXygodW51c2VkKSk7IHN0cnVjdCB0YXNr\nX3N0cnVjdCAqX190YXNrIF9fYXR0cmlidXRlX18oKHVudXNlZCkpOyBkb19wZXJmX3RyYWNl\nX21lbV9kaXNjb25uZWN0KF9fZGF0YSwgeGEpOyB9OyBzdGF0aWMgaW5saW5lIF9fYXR0cmli\ndXRlX18oKF9fZ251X2lubGluZV9fKSkgX19hdHRyaWJ1dGVfXygoX191bnVzZWRfXykpIF9f\nYXR0cmlidXRlX18oKG5vX2luc3RydW1lbnRfZnVuY3Rpb24pKSB2b2lkIHBlcmZfdGVzdF9w\ncm9iZV9tZW1fZGlzY29ubmVjdCh2b2lkKSB7IGNoZWNrX3RyYWNlX2NhbGxiYWNrX3R5cGVf\nbWVtX2Rpc2Nvbm5lY3QocGVyZl90cmFjZV9tZW1fZGlzY29ubmVjdCk7IH07DQoNCg0KVGhp\ncyBpcyBvYnZpb3VzbHkgYSBsb3QgdG8gZ28gdGhyb3VnaCBhbmQgdmVyeSBkaWZmaWN1bHQg\ndG8gcmVhZC4NCg0KSXQgd291bGQgYmUgZ3JlYXQgaWYgd2UgY291bGQgZ2V0IGEgZHVtcCBv\nZiB3aGF0IHdhcyBnb2luZyBvbi4NCg0KLS0gDQpCZW4gRG9va3MJCQkJaHR0cDovL3d3dy5j\nb2RldGhpbmsuY28udWsvDQpTZW5pb3IgRW5naW5lZXIJCQkJQ29kZXRoaW5rIC0gUHJvdmlk\naW5nIEdlbml1cw0KDQpodHRwczovL3d3dy5jb2RldGhpbmsuY28udWsvcHJpdmFjeS5odG1s\nDQoNCg==\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176781822903474.mbox",
          "message_id": "<aV62sDxNla12F1V4 () stanley ! mountain>",
          "author_name": "Dan Carpenter",
          "author_email": "dan.carpenter () linaro ! org",
          "subject": "Re: req: option to show area warning is from",
          "date": "2026-01-07 19:40:32+00:00",
          "date_str": "Wed, 07 Jan 2026 19:40:32 +0000",
          "body": "On Wed, Jan 07, 2026 at 02:58:44PM +0000, Ben Dooks wrote:\n> I think it would be useful to have an option to show a more detailed\n> view of which part of the source generated a warning. Would this be\n> possible and if so is there anyone interested in doing it?\n>=20\n> I'm looking at the following warning:\n> ./include/trace/events/xdp.h:304:1: warning: Using plain integer as NULL\n> pointer\n>=20\n> And the kernel source from the pre-processed file looks like this:\n>=20\n> > static __attribute__((no_instrument_function)) void do_perf_trace_mem_d=\nisconnect(void *__data, const struct xdp_mem_allocator *xa) { struct trace_=\nevent_call *event_call =3D __data; struct trace_event_data_offsets_mem_disc=\nonnect __attribute__((__unused__)) __data_offsets; struct trace_event_raw_m=\nem_disconnect *entry; struct pt_regs *__regs; u64 __count =3D 1; struct tas=\nk_struct *__task =3D ((void *)0); struct hlist_head *head; int __entry_size=\n; int __data_size; int rctx; __data_size =3D trace_event_get_offsets_mem_di=\nsconnect(&__data_offsets, xa); head =3D ({ do { const void __seg_gs *__vpp_=\nverify =3D (typeof((event_call->perf_events) + 0))((void *)0); (void)__vpp_=\nverify; } while (0); ({ unsigned long tcp_ptr__ =3D ({ *( typeof(this_cpu_o=\nff) *)(&(this_cpu_off)); }); tcp_ptr__ +=3D ( unsigned long)(event_call->pe=\nrf_events); (__typeof_unqual__(*(event_call->perf_events)) *)tcp_ptr__; });=\n }); if (!bpf_prog_array_valid(event_call) && __builtin_constant_p(!__task)=\n && !__task && hlist_empty(head)) return; __entry_size =3D ((((__data_size =\n+ sizeof(*entry) + sizeof(u32))) + ((__typeof__((__data_size + sizeof(*entr=\ny) + sizeof(u32))))((sizeof(u64))) - 1)) & ~((__typeof__((__data_size + siz=\neof(*entry) + sizeof(u32))))((sizeof(u64))) - 1)); __entry_size -=3D sizeof=\n(u32); entry =3D perf_trace_buf_alloc(__entry_size, &__regs, &rctx); if (!e=\nntry) return; perf_fetch_caller_regs(__regs); { entry->xa =3D xa; entry->me=\nm_id =3D xa->mem.id; entry->mem_type =3D xa->mem.type; entry->allocator =3D=\n xa->allocator;; } perf_trace_run_bpf_submit(entry, __entry_size, rctx, eve=\nnt_call, __count, __regs, head, __task); } static __attribute__((no_instrum=\nent_function)) void perf_trace_mem_disconnect(void *__data, const struct xd=\np_mem_allocator *xa) { u64 __count __attribute__((unused)); struct task_str=\nuct *__task __attribute__((unused)); do_perf_trace_mem_disconnect(__data, x=\na); }; static inline __attribute__((__gnu_inline__)) __attribute__((__unuse=\nd__)) __attribute__((no_instrument_function)) void perf_test_probe_mem_disc=\nonnect(void) { check_trace_callback_type_mem_disconnect(perf_trace_mem_disc=\nonnect); };\n>=20\n>=20\n> This is obviously a lot to go through and very difficult to read.\n>=20\n> It would be great if we could get a dump of what was going on.\n\nYeah, I spend a lot of time adding newlines to pre-processed code.  Is\nthere a good script to re-indent .i files?\n\nregards,\ndan carpenter\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "compiler_compat"
    },
    {
      "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
      "normalized_subject": "cleanup: Basic compatibility with context analysis",
      "message_count": 31,
      "participants": [
        "Marco Elver",
        "Tetsuo Handa",
        "Lorenzo Stoakes"
      ],
      "categories": [
        "context_analysis",
        "rfc_proposals"
      ],
      "first_date": "2026-01-06T13:21:38+00:00",
      "last_date": "2026-01-27T10:21:28+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176770872202747.mbox",
          "message_id": "<993d381a-c24e-41d2-a0be-c1b0b5d8cbe9 () I-love ! SAKURA ! ne ! jp>",
          "author_name": "Tetsuo Handa",
          "author_email": "penguin-kernel () I-love ! SAKURA ! ne ! jp",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 13:21:38+00:00",
          "date_str": "Tue, 06 Jan 2026 13:21:38 +0000",
          "body": "On 2025/12/20 0:39, Marco Elver wrote:\n> Introduce basic compatibility with cleanup.h infrastructure.\n\nCan Compiler-Based Context- and Locking-Analysis work with conditional guards\n(unlock only if lock succeeded) ?\n\nI consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\nfrequency of hung tasks under heavy load where many processes are preempted waiting\nfor the same mutex to become available (e.g.\nhttps://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n\nBut e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\nplain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\nreplacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n(Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176770871402735.mbox",
          "message_id": "<993d381a-c24e-41d2-a0be-c1b0b5d8cbe9 () I-love ! SAKURA ! ne ! jp>",
          "author_name": "Tetsuo Handa",
          "author_email": "penguin-kernel () I-love ! SAKURA ! ne ! jp",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 13:21:38+00:00",
          "date_str": "Tue, 06 Jan 2026 13:21:38 +0000",
          "body": "On 2025/12/20 0:39, Marco Elver wrote:\n> Introduce basic compatibility with cleanup.h infrastructure.\n\nCan Compiler-Based Context- and Locking-Analysis work with conditional guards\n(unlock only if lock succeeded) ?\n\nI consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\nfrequency of hung tasks under heavy load where many processes are preempted waiting\nfor the same mutex to become available (e.g.\nhttps://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n\nBut e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\nplain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\nreplacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n(Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176770870602718.mbox",
          "message_id": "<993d381a-c24e-41d2-a0be-c1b0b5d8cbe9 () I-love ! SAKURA ! ne ! jp>",
          "author_name": "Tetsuo Handa",
          "author_email": "penguin-kernel () I-love ! SAKURA ! ne ! jp",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 13:21:38+00:00",
          "date_str": "Tue, 06 Jan 2026 13:21:38 +0000",
          "body": "On 2025/12/20 0:39, Marco Elver wrote:\n> Introduce basic compatibility with cleanup.h infrastructure.\n\nCan Compiler-Based Context- and Locking-Analysis work with conditional guards\n(unlock only if lock succeeded) ?\n\nI consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\nfrequency of hung tasks under heavy load where many processes are preempted waiting\nfor the same mutex to become available (e.g.\nhttps://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n\nBut e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\nplain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\nreplacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n(Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772696719706.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772486517839.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772696219703.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772694819684.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772694719681.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772696119702.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176772366916822.mbox",
          "message_id": "<aV1HrwZm6xg8PnRU () elver ! google ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-06 17:34:39+00:00",
          "date_str": "Tue, 06 Jan 2026 17:34:39 +0000",
          "body": "On Tue, Jan 06, 2026 at 10:21PM +0900, Tetsuo Handa wrote:\n> On 2025/12/20 0:39, Marco Elver wrote:\n> > Introduce basic compatibility with cleanup.h infrastructure.\n> \n> Can Compiler-Based Context- and Locking-Analysis work with conditional guards\n> (unlock only if lock succeeded) ?\n> \n> I consider that replacing mutex_lock() with mutex_lock_killable() helps reducing\n> frequency of hung tasks under heavy load where many processes are preempted waiting\n> for the same mutex to become available (e.g.\n> https://syzkaller.appspot.com/bug?extid=8f41dccfb6c03cc36fd6 ).\n> \n> But e.g. commit f49573f2f53e (\"tty: use lock guard()s in tty_io\") already replaced\n> plain mutex_lock()/mutex_unlock() with plain guard(mutex). If I propose a patch for\n> replacing mutex_lock() with mutex_lock_killable(), can I use conditional guards?\n> (Would be yes if Compiler-Based Context- and Locking-Analysis can work, would be no\n>  if Compiler-Based Context- and Locking-Analysis cannot work) ?\n\nIt works for cond guards, so yes. But, only if support for\nmutex_lock_killable() is added. At the moment mutex.h only has:\n\n\t...\n\tDEFINE_LOCK_GUARD_1(mutex, struct mutex, mutex_lock(_T->lock), mutex_unlock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _try, mutex_trylock(_T->lock))\n\tDEFINE_LOCK_GUARD_1_COND(mutex, _intr, mutex_lock_interruptible(_T->lock), _RET == 0)\n\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_try,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_try_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_try, _T)\n\tDECLARE_LOCK_GUARD_1_ATTRS(mutex_intr,\t__acquires(_T), __releases(*(struct mutex **)_T))\n\t#define class_mutex_intr_constructor(_T) WITH_LOCK_GUARD_1_ATTRS(mutex_intr, _T)\n\t...\n\nAnd we also have a test in lib/test_context-analysis.c checking it\nactually works:\n\n\t...\n\tscoped_cond_guard(mutex_try, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\tscoped_cond_guard(mutex_intr, return, &d->mtx) {\n\t\td->counter++;\n\t}\n\t...\n\nWhat's missing is a variant for mutex_lock_killable(), but that should\nbe similar to the mutex_lock_interruptible() variant.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951204016849.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951170316588.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951167116557.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951212116900.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951170416592.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951212416906.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951212616913.mbox",
          "message_id": "<0c2d9b69-c052-4075-8a4b-023d277b8509 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:14:23+00:00",
          "date_str": "Tue, 27 Jan 2026 10:14:23 +0000",
          "body": "+cc Sid for awareness\n\nHi,\n\nThis patch breaks the radix tree and VMA userland tests. The next bots didn't\ncatch it but it seems now they're building the userland VMA tests\n(e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\nnot caught up to the issue this one caused (fails build in tools/testing/vma and\ntools/testing/radix-tree).\n\nAnyway it's a really easy fix, just need to stub out __no_context_analysis in\nthe tools/include copy of compiler_types.h, fix-patch provided below.\n\nTo avoid bisection hazard it'd be nice if it could be folded into this series\nbefore this patch, but if we're too late in the cycle for that I can submit a\nfix separately.\n\nThanks, Lorenzo\n\n----8<----\nFrom cc2390dbefed156757f001e8c3a500a6f8aa1244 Mon Sep 17 00:00:00 2001\nFrom: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\nDate: Tue, 27 Jan 2026 10:10:55 +0000\nSubject: [PATCH] fix\n\nSigned-off-by: Lorenzo Stoakes <lorenzo.stoakes@oracle.com>\n---\n tools/include/linux/compiler_types.h | 2 ++\n 1 file changed, 2 insertions(+)\n\ndiff --git a/tools/include/linux/compiler_types.h b/tools/include/linux/compiler_types.h\nindex 949b2cdd3412..ca60d491d4e8 100644\n--- a/tools/include/linux/compiler_types.h\n+++ b/tools/include/linux/compiler_types.h\n@@ -60,4 +60,6 @@\n \t\t\t__scalar_type_to_expr_cases(long long),\t\\\n \t\t\tdefault: (x)))\n\n+#define __no_context_analysis\n+\n #endif /* __LINUX_COMPILER_TYPES_H */\n--\n2.52.0\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951218216953.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951218916969.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951218116950.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951213716916.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951184016715.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951218616962.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951184716718.mbox",
          "message_id": "<CANpmjNNHmOzaCSc9hQJNuzNVHXA=LRgXB4Q69FNk6wBuuJGdAg () mail ! gmail ! com>",
          "author_name": "Marco Elver",
          "author_email": "elver () google ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:17:24+00:00",
          "date_str": "Tue, 27 Jan 2026 10:17:24 +0000",
          "body": "On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n<lorenzo.stoakes@oracle.com> wrote:\n>\n> +cc Sid for awareness\n>\n> Hi,\n>\n> This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> catch it but it seems now they're building the userland VMA tests\n> (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> not caught up to the issue this one caused (fails build in tools/testing/vma and\n> tools/testing/radix-tree).\n>\n> Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> the tools/include copy of compiler_types.h, fix-patch provided below.\n>\n> To avoid bisection hazard it'd be nice if it could be folded into this series\n> before this patch, but if we're too late in the cycle for that I can submit a\n> fix separately.\n\nThanks, I saw. I have a more complete fix I'm about to send.\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951238717115.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951208916868.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951238217107.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951240017118.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951237817103.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951238017106.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176951238317109.mbox",
          "message_id": "<599729a5-da4c-473a-bd07-4459639c95c7 () lucifer ! local>",
          "author_name": "Lorenzo Stoakes",
          "author_email": "lorenzo.stoakes () oracle ! com",
          "subject": "Re: [PATCH v5 06/36] cleanup: Basic compatibility with context analysis",
          "date": "2026-01-27 10:21:28+00:00",
          "date_str": "Tue, 27 Jan 2026 10:21:28 +0000",
          "body": "On Tue, Jan 27, 2026 at 11:17:24AM +0100, Marco Elver wrote:\n> On Tue, 27 Jan 2026 at 11:14, Lorenzo Stoakes\n> <lorenzo.stoakes@oracle.com> wrote:\n> >\n> > +cc Sid for awareness\n> >\n> > Hi,\n> >\n> > This patch breaks the radix tree and VMA userland tests. The next bots didn't\n> > catch it but it seems now they're building the userland VMA tests\n> > (e.g. https://lore.kernel.all/202601271308.b8d3fcb6-lkp@intel.com/) but maybe\n> > not caught up to the issue this one caused (fails build in tools/testing/vma and\n> > tools/testing/radix-tree).\n> >\n> > Anyway it's a really easy fix, just need to stub out __no_context_analysis in\n> > the tools/include copy of compiler_types.h, fix-patch provided below.\n> >\n> > To avoid bisection hazard it'd be nice if it could be folded into this series\n> > before this patch, but if we're too late in the cycle for that I can submit a\n> > fix separately.\n>\n> Thanks, I saw. I have a more complete fix I'm about to send.\n\nGreat, thanks!\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "rfc_proposals"
    },
    {
      "subject": "[PATCHv2 2/2] RISC-V: restart extension search on match",
      "normalized_subject": "RISC-V: restart extension search on match",
      "message_count": 3,
      "participants": [
        "Paul Walmsley",
        "Ben Dooks"
      ],
      "categories": [
        "kernel_integration"
      ],
      "first_date": "2026-01-02T11:44:49+00:00",
      "last_date": "2026-01-07T21:30:11+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176735869328148.mbox",
          "message_id": "<20260102114449.535597-3-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCH 2/2] RISC-V: restart extension search on match",
          "date": "2026-01-02 11:44:49+00:00",
          "date_str": "Fri, 02 Jan 2026 11:44:49 +0000",
          "body": "If we are passed multiple extensions in -march, don't assume these will\nbe in any sort of order. If we do match, then restart the loop by setting\nthe search back to 0, and retrying.\n\nThis sorts out issues with the current kernel build where there are now\nlots of extensions for the rv64i and even adding zacas doesn't silence the\nwarnings generated.\n\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\n target-riscv.c | 3 ++-\n 1 file changed, 2 insertions(+), 1 deletion(-)\n\ndiff --git a/target-riscv.c b/target-riscv.c\nindex 80c25285..ddf50e61 100644\n--- a/target-riscv.c\n+++ b/target-riscv.c\n@@ -56,7 +56,7 @@ static void parse_march_riscv(const char *arg)\n \n \t// Each -march=.. options entirely overrides previous ones\n \triscv_flags = 0;\n-\n+\t\n \tfor (i = 0; i < ARRAY_SIZE(basic_sets); i++) {\n \t\tconst char *pat = basic_sets[i].pattern;\n \t\tsize_t len = strlen(pat);\n@@ -80,6 +80,7 @@ ext:\n \t\tif (!strncmp(arg, pat, len)) {\n \t\t\triscv_flags |= extensions[i].flags;\n \t\t\targ += len;\n+\t\t\ti = 0;\n \t\t}\n \t}\n \tif (arg[0])\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176782138406372.mbox",
          "message_id": "<a273a46c-c90b-3895-c019-09a624ba43a4 () kernel ! org>",
          "author_name": "Paul Walmsley",
          "author_email": "pjw () kernel ! org",
          "subject": "Re: [PATCH 2/2] RISC-V: restart extension search on match",
          "date": "2026-01-07 20:42:24+00:00",
          "date_str": "Wed, 07 Jan 2026 20:42:24 +0000",
          "body": "On Fri, 2 Jan 2026, Ben Dooks wrote:\n\n> If we are passed multiple extensions in -march, don't assume these will\n> be in any sort of order. If we do match, then restart the loop by setting\n> the search back to 0, and retrying.\n> \n> This sorts out issues with the current kernel build where there are now\n> lots of extensions for the rv64i and even adding zacas doesn't silence the\n> warnings generated.\n> \n> Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n> ---\n>  target-riscv.c | 3 ++-\n>  1 file changed, 2 insertions(+), 1 deletion(-)\n> \n> diff --git a/target-riscv.c b/target-riscv.c\n> index 80c25285..ddf50e61 100644\n> --- a/target-riscv.c\n> +++ b/target-riscv.c\n> @@ -56,7 +56,7 @@ static void parse_march_riscv(const char *arg)\n>  \n>  \t// Each -march=.. options entirely overrides previous ones\n>  \triscv_flags = 0;\n> -\n> +\t\n\nLooks like some horizontal whitespace was inadvertently added here.\n\n>  \tfor (i = 0; i < ARRAY_SIZE(basic_sets); i++) {\n>  \t\tconst char *pat = basic_sets[i].pattern;\n>  \t\tsize_t len = strlen(pat);\n> @@ -80,6 +80,7 @@ ext:\n>  \t\tif (!strncmp(arg, pat, len)) {\n>  \t\t\triscv_flags |= extensions[i].flags;\n>  \t\t\targ += len;\n> +\t\t\ti = 0;\n>  \t\t}\n>  \t}\n>  \tif (arg[0])\n\n\nTested-by: Paul Walmsley <pjw@kernel.org>\n\n\n- Paul\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176782434508633.mbox",
          "message_id": "<20260107213011.204578-2-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCHv2 2/2] RISC-V: restart extension search on match",
          "date": "2026-01-07 21:30:11+00:00",
          "date_str": "Wed, 07 Jan 2026 21:30:11 +0000",
          "body": "If we are passed multiple extensions in -march, don't assume these will\nbe in any sort of order. If we do match, then restart the loop by setting\nthe search back to 0, and retrying.\n\nThis sorts out issues with the current kernel build where there are now\nlots of extensions for the rv64i and even adding zacas doesn't silence the\nwarnings generated.\n\nTested-by: Paul Walmsley <pjw@kernel.org>\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\nv2:\n  - fixed accidental whitespace change.\n---\n target-riscv.c | 1 +\n 1 file changed, 1 insertion(+)\n\ndiff --git a/target-riscv.c b/target-riscv.c\nindex 80c25285..cd6104b2 100644\n--- a/target-riscv.c\n+++ b/target-riscv.c\n@@ -80,6 +80,7 @@ ext:\n \t\tif (!strncmp(arg, pat, len)) {\n \t\t\triscv_flags |= extensions[i].flags;\n \t\t\targ += len;\n+\t\t\ti = 0;\n \t\t}\n \t}\n \tif (arg[0])\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "kernel_integration"
    },
    {
      "subject": "Re: [PATCH 1/2] RISC-V: Stop warning about Zabha and Zacas",
      "normalized_subject": "RISC-V: Stop warning about Zabha and Zacas",
      "message_count": 3,
      "participants": [
        "Paul Walmsley",
        "Ben Dooks"
      ],
      "categories": [
        "kernel_integration"
      ],
      "first_date": "2026-01-02T11:44:48+00:00",
      "last_date": "2026-01-07T21:30:10+00:00",
      "year": 2026,
      "messages": [
        {
          "filepath": "emails/2026/01/176735981029077.mbox",
          "message_id": "<20260102114449.535597-2-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCH 1/2] RISC-V: Stop warning about Zabha and Zacas",
          "date": "2026-01-02 11:44:48+00:00",
          "date_str": "Fri, 02 Jan 2026 11:44:48 +0000",
          "body": "The zabha (atomic byte and halfword) and zacas (atomic compare/swap)\nare now being used by the kernel, so parse these and stop the warnings\nwhen running make C=1 on current kernels.\n\nWARNING: invalid argument to '-march': '_zacas_zabha'\n\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\n target-riscv.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/target-riscv.c b/target-riscv.c\nindex d30be04b..80c25285 100644\n--- a/target-riscv.c\n+++ b/target-riscv.c\n@@ -22,6 +22,8 @@\n #define RISCV_ZICBOM\t(1 << 12)\n #define RISCV_ZIHINTPAUSE\t(1 << 13)\n #define RISCV_VECTOR\t(1 << 14)\n+#define RISCV_ATOMIC_CAS (1 << 15)\n+#define RISCV_ATOMIC_BH\t (1 << 16)\n \n static unsigned int riscv_flags;\n \n@@ -43,6 +45,8 @@ static void parse_march_riscv(const char *arg)\n \t\t{ \"d\",\t\tRISCV_DOUBLE|RISCV_FDIV|RISCV_ZICSR },\n \t\t{ \"c\",\t\tRISCV_COMP },\n \t\t{ \"v\",\t\tRISCV_VECTOR|RISCV_FPU|RISCV_ZICSR },\n+\t\t{ \"_zacas\",\tRISCV_ATOMIC_CAS },\n+\t\t{ \"_zabha\",\tRISCV_ATOMIC_BH },\n \t\t{ \"_zicsr\",\tRISCV_ZICSR },\n \t\t{ \"_zifencei\",\tRISCV_ZIFENCEI },\n \t\t{ \"_zicbom\",\tRISCV_ZICBOM },\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176782138306369.mbox",
          "message_id": "<c5021639-ca56-67cc-ccb5-e074e60bb19d () kernel ! org>",
          "author_name": "Paul Walmsley",
          "author_email": "pjw () kernel ! org",
          "subject": "Re: [PATCH 1/2] RISC-V: Stop warning about Zabha and Zacas",
          "date": "2026-01-07 20:41:18+00:00",
          "date_str": "Wed, 07 Jan 2026 20:41:18 +0000",
          "body": "On Fri, 2 Jan 2026, Ben Dooks wrote:\n\n> The zabha (atomic byte and halfword) and zacas (atomic compare/swap)\n> are now being used by the kernel, so parse these and stop the warnings\n> when running make C=1 on current kernels.\n> \n> WARNING: invalid argument to '-march': '_zacas_zabha'\n> \n> Signed-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n\nThanks Ben.  This saved me some time!\n\nTested-by: Paul Walmsley <pjw@kernel.org>\n\n\n- Paul\n",
          "year": "2026",
          "month": "01"
        },
        {
          "filepath": "emails/2026/01/176782434408632.mbox",
          "message_id": "<20260107213011.204578-1-ben.dooks () codethink ! co ! uk>",
          "author_name": "Ben Dooks",
          "author_email": "ben.dooks () codethink ! co ! uk",
          "subject": "[PATCHv2 1/2] RISC-V: Stop warning about Zabha and Zacas",
          "date": "2026-01-07 21:30:10+00:00",
          "date_str": "Wed, 07 Jan 2026 21:30:10 +0000",
          "body": "The zabha (atomic byte and halfword) and zacas (atomic compare/swap)\nare now being used by the kernel, so parse these and stop the warnings\nwhen running make C=1 on current kernels.\n\nWARNING: invalid argument to '-march': '_zacas_zabha'\n\nTested-by: Paul Walmsley <pjw@kernel.org>\nSigned-off-by: Ben Dooks <ben.dooks@codethink.co.uk>\n---\n target-riscv.c | 4 ++++\n 1 file changed, 4 insertions(+)\n\ndiff --git a/target-riscv.c b/target-riscv.c\nindex d30be04b..80c25285 100644\n--- a/target-riscv.c\n+++ b/target-riscv.c\n@@ -22,6 +22,8 @@\n #define RISCV_ZICBOM\t(1 << 12)\n #define RISCV_ZIHINTPAUSE\t(1 << 13)\n #define RISCV_VECTOR\t(1 << 14)\n+#define RISCV_ATOMIC_CAS (1 << 15)\n+#define RISCV_ATOMIC_BH\t (1 << 16)\n \n static unsigned int riscv_flags;\n \n@@ -43,6 +45,8 @@ static void parse_march_riscv(const char *arg)\n \t\t{ \"d\",\t\tRISCV_DOUBLE|RISCV_FDIV|RISCV_ZICSR },\n \t\t{ \"c\",\t\tRISCV_COMP },\n \t\t{ \"v\",\t\tRISCV_VECTOR|RISCV_FPU|RISCV_ZICSR },\n+\t\t{ \"_zacas\",\tRISCV_ATOMIC_CAS },\n+\t\t{ \"_zabha\",\tRISCV_ATOMIC_BH },\n \t\t{ \"_zicsr\",\tRISCV_ZICSR },\n \t\t{ \"_zifencei\",\tRISCV_ZIFENCEI },\n \t\t{ \"_zicbom\",\tRISCV_ZICBOM },\n-- \n2.37.2.352.g3c44437643\n\n",
          "year": "2026",
          "month": "01"
        }
      ],
      "primary_category": "kernel_integration"
    }
  ]
}